1
00:00:20,387 --> 00:00:24,091
WatchKit in Depth
第一部分


2
00:00:31,365 --> 00:00:32,232
诸位早上好！


3
00:00:32,299 --> 00:00:34,835
欢迎参加WatchKit in Depth
第一部分的讲座


4
00:00:34,902 --> 00:00:37,604
讲座分为两个环节
这是第一个环节


5
00:00:37,671 --> 00:00:40,007
进一步探讨WatchKit中的变化


6
00:00:40,374 --> 00:00:41,341
我叫安德鲁·普拉兹


7
00:00:41,408 --> 00:00:45,279
将与福里斯特·希尔
一道讲述今天的话题


8
00:00:45,579 --> 00:00:47,114
希望您会感兴趣


9
00:00:49,116 --> 00:00:50,784
我将讲述三个部分


10
00:00:51,051 --> 00:00:55,923
即架构 手表 app内部手表扩展的
基本布局工作原理


11
00:00:56,590 --> 00:00:58,492
我会讲述资源和数据的存放地点


12
00:00:58,559 --> 00:01:02,296
因为它是由两个部分构成的系统
所以开始时可能会有点难以理解


13
00:01:02,963 --> 00:01:05,331
对于那些已经从事过
Watch OS 1开发的朋友


14
00:01:05,498 --> 00:01:07,434
WatchOS 1是WatchKit的一个扩展
是一个手表app


15
00:01:07,501 --> 00:01:11,305
我将会讲到迁移
有哪些变化以及有哪些相同之处


16
00:01:11,772 --> 00:01:13,106
然后福里斯特将继续谈一下


17
00:01:13,173 --> 00:01:17,611
WatchKit中的一些新的API
以及新的类 


18
00:01:17,978 --> 00:01:19,580
因此您的手表 app包含三个部分


19
00:01:19,947 --> 00:01:21,582
它有一个iOS应用


20
00:01:22,082 --> 00:01:25,185
你将会在手机上安装它


21
00:01:25,485 --> 00:01:27,788
此外你还将提供一个
WatchKit扩展


22
00:01:27,855 --> 00:01:28,755
这是你自己写的代码


23
00:01:29,289 --> 00:01:31,325
然后是一个手表OS应用


24
00:01:31,391 --> 00:01:34,127
它包含资源和界面描述


25
00:01:36,597 --> 00:01:39,066
您有了手机
下载了您的app


26
00:01:40,200 --> 00:01:44,338
而我们已完成的工作就是
增加一批新的数据


27
00:01:44,404 --> 00:01:47,741
一批附带并与其一道安装的文件


28
00:01:47,808 --> 00:01:48,976
而那就是手表app


29
00:01:49,042 --> 00:01:52,246
它包含您对界面的描述
或许也有一些资源


30
00:01:52,479 --> 00:01:54,147
然后就是您的WatchKit扩展


31
00:01:54,214 --> 00:01:57,751
它包含代码和额外的资源


32
00:01:58,752 --> 00:02:00,153
因此当您把它与您的手表匹配时


33
00:02:00,821 --> 00:02:04,191
我们将所有的那些信息复制过去
它就会出现在主屏幕上


34
00:02:04,658 --> 00:02:05,759
作为一个完整的应用出现


35
00:02:08,895 --> 00:02:12,900
当然手机上仍然留有备份
以备以后重新安装的不时之需


36
00:02:14,334 --> 00:02:18,172
因此我会谈到两个你将要提供的部分


37
00:02:18,238 --> 00:02:21,842
一个是界面
另一个是实际代码以及扩展


38
00:02:22,910 --> 00:02:26,880
当您创建了一个
新的WatchKit App


39
00:02:27,281 --> 00:02:29,349
您可以看到实际上有两个独立的目标


40
00:02:29,750 --> 00:02:32,953
两个独立的组件
带有interface Storyboard的app


41
00:02:33,020 --> 00:02:35,122
和您的代码
这里的代码即Swift


42
00:02:35,189 --> 00:02:40,827
而你有多达四个不同的
可以向其添加代码的东西


43
00:02:42,629 --> 00:02:44,831
因此对于storyboard
这是它的界面部分


44
00:02:45,098 --> 00:02:48,101
您可以在IB内编辑它
正如编辑一个iOS应用一样


45
00:02:49,002 --> 00:02:55,042
而我们提供相当丰富的
一组界面元素 标签 图像等等


46
00:02:55,108 --> 00:02:59,112
这就是watchOS 1的全部内容
而且我们在watchOS 2里面


47
00:02:59,179 --> 00:03:02,816
添加了几个新特性如Picker视图
这将给您一个丰富的界面以及影片视图


48
00:03:04,685 --> 00:03:11,124
因此 例如这里有三个带有
你能够看到所有控制按钮的标准控件


49
00:03:11,191 --> 00:03:13,594
它们是在
interface builder内创建的


50
00:03:14,261 --> 00:03:16,663
我们也有针对特定功能的自定义界面


51
00:03:17,030 --> 00:03:19,967
一个是Glances
它有更为具体的布局


52
00:03:20,033 --> 00:03:22,402
另两个是用于通知的界面


53
00:03:22,469 --> 00:03:24,738
一个用于静态通知
另一个用于传送更为动态的


54
00:03:24,805 --> 00:03:27,474
您在运行时提供的信息


55
00:03:29,376 --> 00:03:32,379
因此正如我刚才所言
您的扩展有四个功能


56
00:03:33,413 --> 00:03:34,448
有个应用功能


57
00:03:34,515 --> 00:03:37,584
当您的应用从主屏幕启动的时候
我们调用您的扩展


58
00:03:37,851 --> 00:03:40,487
它也被用于从时钟出现的
单页glance


59
00:03:40,854 --> 00:03:44,091
以及在您接收到通知的时候进行显示


60
00:03:44,391 --> 00:03:46,393
而且现在
也用于complications


61
00:03:47,361 --> 00:03:50,531
对于其中的每一个都有个相关联的控件


62
00:03:50,597 --> 00:03:54,001
对于Glances以及常规应用
有WK Interface Controller


63
00:03:54,067 --> 00:03:55,369
有一个专门的次级类


64
00:03:55,435 --> 00:03:59,039
叫做
WK User Notification Interface Controller


65
00:03:59,106 --> 00:04:00,541
对于通知 您应该使用这个次级类


66
00:04:00,974 --> 00:04:02,943
还有一个新的数据源对象


67
00:04:03,377 --> 00:04:05,979
即WK Complication Data Source


68
00:04:06,046 --> 00:04:08,448
关于complications
我目前就讲这么多


69
00:04:08,515 --> 00:04:12,953
今天稍后还有一个讲座环节
对此进行更详细探讨


70
00:04:15,522 --> 00:04:20,459
因此您的WK Interface Controller
是与您的界面的主要连接工具


71
00:04:21,161 --> 00:04:25,399
它所做的主要是自动创建界面属性


72
00:04:25,465 --> 00:04:31,104
因此你会在界面设计中
对一个界面元素贴上标签


73
00:04:31,171 --> 00:04:32,873
并声称 类似这是我的标签


74
00:04:33,140 --> 00:04:37,811
然后我们在控件上创建一个关联的对象
并自动为您将其连接好


75
00:04:39,746 --> 00:04:44,451
控件也支持菜单处理
您可以自定义菜单或者使用静态菜单


76
00:04:44,985 --> 00:04:48,589
我们提供对控件的导航
推送等等或者调度


77
00:04:49,289 --> 00:04:51,091
和模态显示


78
00:04:51,892 --> 00:04:55,095
以及警告和action sheet


79
00:04:56,096 --> 00:05:00,000
另外一个我们提供的内容是
几个系统UI表单


80
00:05:00,067 --> 00:05:03,871
文本输入 视频回放 音频录制


81
00:05:07,074 --> 00:05:10,644
那么 比如说
这里有个非常简单的界面控件类


82
00:05:10,711 --> 00:05:14,448
它有一个插座变量app图标
而我们在IB中加载它


83
00:05:14,982 --> 00:05:19,653
当我们运行应用时 我们看到它提取了
图标并将其显示在屏幕上


84
00:05:21,655 --> 00:05:25,459
那么我想谈一下各种东西的位置


85
00:05:25,526 --> 00:05:28,161
你的资源存放在哪里
你从哪里提取数据


86
00:05:29,963 --> 00:05:33,834
因为这个手表app分为两个部分


87
00:05:33,901 --> 00:05:36,069
包括手表app本身
以及WatchKit扩展


88
00:05:36,470 --> 00:05:38,272
有两个地方存放数据


89
00:05:38,338 --> 00:05:41,208
即WatchApp bundle 
和WatchKit扩展bundle


90
00:05:41,275 --> 00:05:44,178
而你必须确保记住它存放的位置


91
00:05:44,478 --> 00:05:46,747
比如这里我创建了另一个对象


92
00:05:46,813 --> 00:05:48,649
和以前一样它也有一个
interface storyboard


93
00:05:48,715 --> 00:05:50,751
和一个名为
application image的图像文件


94
00:05:50,817 --> 00:05:53,053
以及本地化的字符串文件


95
00:05:53,420 --> 00:05:55,589
而扩展本身也包含同样的东西


96
00:05:55,656 --> 00:05:58,792
它有另一个png文件
和一个可本地化的字符串


97
00:06:00,794 --> 00:06:04,364
那现在如果我们进行个容易理解的操作
即创建两个插座变量


98
00:06:04,898 --> 00:06:08,936
并使用IB插座变量将其连接起来
表明这些是属性


99
00:06:09,603 --> 00:06:10,771
并调用组图标


100
00:06:10,838 --> 00:06:12,339
哦 我们没有扩展图标


101
00:06:13,373 --> 00:06:19,079
原因是当你调用的组图标
是在WK Interface Image上命名的时候


102
00:06:19,479 --> 00:06:21,448
它并不在应用bundle
内进行搜索


103
00:06:21,715 --> 00:06:24,284
但是扩展图标并不
存放在应用的bundle内


104
00:06:24,985 --> 00:06:30,057
因此你要做的是直接从正在那个特定的
bundle中运行的代码内提取它


105
00:06:30,123 --> 00:06:34,361
因此在扩展代码内
你调用UI图标的名称


106
00:06:34,728 --> 00:06:36,330
而这将在本地提取图标


107
00:06:36,396 --> 00:06:38,799
因为它知道如何在它自己的
bundle内部进行搜索


108
00:06:38,866 --> 00:06:40,234
然后你在系统内执行同样操作


109
00:06:40,300 --> 00:06:43,203
你调用组图标而不是已被命名的组图标


110
00:06:43,670 --> 00:06:47,207
那将传递图标并让两个图标
都出现在您的应用内


111
00:06:50,310 --> 00:06:51,712
那么现在你希望存储一些数据


112
00:06:51,778 --> 00:06:55,749
您不会只希望提取一些静态图片
你拥有一个极其动态的应用


113
00:06:56,316 --> 00:06:59,586
因此有两个你感兴趣的文件夹


114
00:07:00,087 --> 00:07:01,455
一个是文档文件夹


115
00:07:01,788 --> 00:07:04,424
这是你存储更为持久的信息的地方


116
00:07:05,158 --> 00:07:08,662
它是不可删除的
就是说它在重启之间是一直运行的


117
00:07:09,162 --> 00:07:11,865
但是需要注意的一点是
它是不可恢复的


118
00:07:11,932 --> 00:07:16,670
因此你必须检查手表是否被擦除
否则你就要安装新的手表


119
00:07:17,905 --> 00:07:19,173
还有一个缓存文件夹


120
00:07:19,573 --> 00:07:23,610
这个是可以删除的
因此如果系统认为需要更多空间


121
00:07:23,677 --> 00:07:26,480
存储音乐 图片或其他 app


122
00:07:26,547 --> 00:07:27,881
它将删除这些图片


123
00:07:27,948 --> 00:07:30,951
因此你可以认为那些图片可能随时消失


124
00:07:33,020 --> 00:07:36,089
这里有一个例子
我们快速地看一下在哪里找到它


125
00:07:37,224 --> 00:07:40,294
在这个例子中 主要调用的
是document directory类


126
00:07:40,360 --> 00:07:42,863
目录URL的文件管理器


127
00:07:42,930 --> 00:07:46,466
它将请求第一个
而那正是需要的 URL


128
00:07:46,800 --> 00:07:52,706
因此我们创建一个包含我们的文件名的
URL并向其写入一些数据


129
00:07:56,043 --> 00:07:58,478
现在媒体出现了另一个有趣的问题


130
00:07:59,179 --> 00:08:02,249
由于应用负责播放媒体


131
00:08:02,649 --> 00:08:06,220
它也负责将音频录制在某个地方


132
00:08:06,286 --> 00:08:11,391
因此当你的扩展请求播放一个影片
或播放音频 或录制音频的时候


133
00:08:11,758 --> 00:08:13,126
我们将其传送给应用


134
00:08:14,361 --> 00:08:16,997
另一方面扩展负责


135
00:08:17,064 --> 00:08:21,568
从互联网上下载或用其他操作生成媒体


136
00:08:21,635 --> 00:08:25,572
它也负责获取你可能已经设置好的
录制下来的音频文件


137
00:08:26,039 --> 00:08:28,742
并将它们传送到你的服务器上


138
00:08:30,277 --> 00:08:34,181
那么你需要做的就是
设置所谓的共享容器


139
00:08:34,914 --> 00:08:41,822
而那主要是为了让两个过程
即应用和扩展一个能够共同访问的地方


140
00:08:42,322 --> 00:08:43,590
因为出于安全因素


141
00:08:43,657 --> 00:08:49,329
通常你不能从一个过程
进入另一个存储区域


142
00:08:50,697 --> 00:08:52,032
而你启用了这种Xcode


143
00:08:52,299 --> 00:08:55,536
你使用了所谓的‘app群组’


144
00:08:55,602 --> 00:08:58,071
将其用于扩展和你
赋予了独特的识别符的应用


145
00:08:58,672 --> 00:09:00,541
而那就是你的应用群组


146
00:09:03,143 --> 00:09:07,548
那么这里你需要真正担心的唯一事情
仍然是有一个函数


147
00:09:08,015 --> 00:09:09,783
即文件管理器


148
00:09:09,850 --> 00:09:13,754
你可以为安全应用群组识别符
请求容器URL


149
00:09:13,820 --> 00:09:15,756
并将其通过你创建的群组
识别符进行传递


150
00:09:16,190 --> 00:09:19,193
而那将把你的URL
赋予到一共享的存储区域


151
00:09:19,993 --> 00:09:24,431
因此从那里你可以存储app


152
00:09:24,498 --> 00:09:28,535
能够从扩展读取或者提取的文件


153
00:09:28,602 --> 00:09:33,640
这里我们有一个例子是当前的音频录制
控件把URL从共享容器取出


154
00:09:33,707 --> 00:09:35,542
那么它将把音频录制到那个文件内


155
00:09:37,744 --> 00:09:41,014
因此现在我希望谈一下
如何从手表提取数据


156
00:09:42,182 --> 00:09:43,450
有两种方法可以实现


157
00:09:43,517 --> 00:09:46,787
一种是NSURL Session
它是在Foundation框架内的


158
00:09:46,854 --> 00:09:49,756
另一种是通过一个新的
Watch Connectivity框架


159
00:09:50,290 --> 00:09:54,695
因此NSURL Session是你
从互联网上获取资源的方法之一


160
00:09:54,761 --> 00:09:58,832
如果你有一个聊天app或类似的东西
你会希望与您的服务器对话


161
00:10:00,501 --> 00:10:03,904
它让你直接通过HTTP和HTTPS
访问互联网


162
00:10:04,204 --> 00:10:08,609
而有多种配置方式


163
00:10:09,643 --> 00:10:11,912
而且它支持以后台方式下载


164
00:10:11,979 --> 00:10:14,147
原因是您的扩展经常不处于运行状态


165
00:10:14,214 --> 00:10:17,284
您的手表屏幕是关闭的
您的扩展是睡眠状态的


166
00:10:17,551 --> 00:10:19,319
您的扩展甚至不运行的时候


167
00:10:19,386 --> 00:10:20,921
而这都是下载数据所需要的


168
00:10:21,922 --> 00:10:23,690
需要注意的一点是


169
00:10:23,757 --> 00:10:27,227
一旦我们告诉您数据已经在那里
一旦文件已被完全下载


170
00:10:27,294 --> 00:10:32,099
您需要立刻拿到它
因为否则的话它就会被从临时缓存删除


171
00:10:33,867 --> 00:10:35,836
因此这里有一些代码
一共有几页


172
00:10:35,903 --> 00:10:37,504
一个简单的downloader类


173
00:10:38,071 --> 00:10:40,073
我们首先要做的是释放NSURLSession 


174
00:10:40,140 --> 00:10:42,876
我们慢慢做这件事
以防我们永远不需要调用它


175
00:10:43,944 --> 00:10:45,812
而这里的调用主要是创建会话


176
00:10:46,180 --> 00:10:49,383
而且只有两行代码
一行是为了对后台进行配置


177
00:10:49,449 --> 00:10:52,619
那么你可以说这里是一个后台会话


178
00:10:52,686 --> 00:10:55,222
而我们希望传入一个ID
过一会儿我会谈到它


179
00:10:56,523 --> 00:10:58,959
而我们使用那种配置创建URL会话


180
00:10:59,026 --> 00:11:02,396
而且我们让downloader类本身
成为delegate之后的实例


181
00:11:02,462 --> 00:11:04,631
以便我们能够在文件进来时得到通知


182
00:11:05,599 --> 00:11:07,167
然后为了开始URL下载


183
00:11:07,668 --> 00:11:09,636
我们请求一个新的任务


184
00:11:10,237 --> 00:11:11,705
并让其运行


185
00:11:11,772 --> 00:11:15,943
而它将发出请求
并开始下载


186
00:11:17,611 --> 00:11:22,883
正如我刚才所言 通常你的扩展
是关闭的或不处于唤醒状态


187
00:11:23,217 --> 00:11:24,751
在它关闭的情况下


188
00:11:25,118 --> 00:11:29,489
你将需要重新连接到
已经设置好的所有下载任务


189
00:11:29,990 --> 00:11:36,830
因此你要设置的是个在您的WK扩展中
叫做restart的调用的函数


190
00:11:36,897 --> 00:11:38,165
福李斯特之后将谈到那一点


191
00:11:38,232 --> 00:11:41,702
启动调用函数并重新启动下载
以便你能够知道它们会到来


192
00:11:41,768 --> 00:11:45,105
实际上它们也会消失
但是你不会知道它们已经结束了


193
00:11:47,608 --> 00:11:49,610
而这里是实际的delegate方法


194
00:11:49,676 --> 00:11:53,180
这就是你与
NSURLSession连接的方法


195
00:11:53,480 --> 00:11:56,550
当文件完成下载之后就会调用此方法


196
00:11:56,617 --> 00:11:59,386
正如我刚才所言 
我们需要立刻将文件复制以防它消失


197
00:11:59,453 --> 00:12:00,921
以防系统将其删除


198
00:12:01,855 --> 00:12:03,624
这种情况下我们将获取缓存目录


199
00:12:03,690 --> 00:12:05,259
因为或许我们过一会可能会需要它


200
00:12:06,560 --> 00:12:08,695
我们将生成一个URL


201
00:12:08,762 --> 00:12:13,066
且我们用文件管理器复制
从被传递进来的原始URL


202
00:12:13,133 --> 00:12:16,370
即从位置URL到缓存目录的URL


203
00:12:16,970 --> 00:12:20,140
我们已经将其复制
并跟踪它以便以后使用


204
00:12:20,407 --> 00:12:22,910
因此我们可以读取你下载的任何数据


205
00:12:25,179 --> 00:12:27,781
此外还有
WatchKit connectivity框架


206
00:12:27,848 --> 00:12:29,283
它实际上存在于双方


207
00:12:29,650 --> 00:12:31,652
比如你在它们之间共享数据


208
00:12:31,718 --> 00:12:35,489
你可以在手表和iPhone之间
建立个共享的字典 


209
00:12:36,056 --> 00:12:38,425
它让你传输文件
也是后台运行


210
00:12:39,293 --> 00:12:43,864
它也让你从手表直接
向作为父应用的手机app


211
00:12:44,164 --> 00:12:46,066
向父设备iPhone上的父应用
发送请求


212
00:12:46,967 --> 00:12:50,771
明天将会有一个关于该话题的环节


213
00:12:51,138 --> 00:12:52,639
我建议大家要去听
因为它是新内容


214
00:12:52,706 --> 00:12:55,342
而且是手表和iPhone上都有的


215
00:12:58,912 --> 00:13:02,449
那么这里有几个迁移方面的幻灯片


216
00:13:02,516 --> 00:13:06,286
对于已经开始开发
watchOS 1 app的朋友


217
00:13:08,522 --> 00:13:10,123
您多半已经见到过这个内容


218
00:13:10,557 --> 00:13:14,027
watchOS 1的WatchKit扩展


219
00:13:14,094 --> 00:13:16,630
是你们已经创建的东西
或是你们的项目内一个目标


220
00:13:17,431 --> 00:13:20,934
但是它使用了SDK中的iOS平台


221
00:13:21,001 --> 00:13:24,404
因此它存在于iPhone内
而不是在手表内


222
00:13:27,241 --> 00:13:31,612
因此它让你在手机上共享一个框架


223
00:13:31,879 --> 00:13:34,848
那么你可能有一些代码
是两种扩展上通用的


224
00:13:34,915 --> 00:13:36,850
比如从网络上获取你的信息


225
00:13:37,217 --> 00:13:43,023
同样的代码在iPhone应用
和手表应用中4都能运行


226
00:13:44,091 --> 00:13:48,762
因为您无法直接读取手表存储器


227
00:13:49,196 --> 00:13:53,467
我们为您提供了一种缓存图像的方法
即一张图片和一个名称


228
00:13:53,534 --> 00:13:55,636
之后当我说“已对上述图像命名”时


229
00:13:56,570 --> 00:14:01,375
我们已把资源下载到了手表上
而且速度将会快得多


230
00:14:02,509 --> 00:14:05,512
因此我们为您提供了一种
直接与应用对话的方法


231
00:14:06,046 --> 00:14:10,050
显然是从手机到手机的过程
因此它是非常迅速的


232
00:14:11,518 --> 00:14:15,856
借助watchOS 2 
我们已经添加了一种新的SDK


233
00:14:16,456 --> 00:14:21,562
它是完全独立的
与iPhone和OS 10 SDK类似


234
00:14:22,496 --> 00:14:24,898
它确实为您提供了一套
可用的iOS次级框架


235
00:14:25,265 --> 00:14:27,835
虽然您不会获得
和手机上一样完整的功能性


236
00:14:28,135 --> 00:14:29,236
但是你也获得很多便利


237
00:14:32,039 --> 00:14:35,976
你可以在你的项目中加入一个框架


238
00:14:36,243 --> 00:14:39,213
正如你在iPhone watchOS 1 app
上所做的一样 


239
00:14:40,447 --> 00:14:45,686
但是这个框架是使用手表应用
和手表扩展下载的


240
00:14:45,752 --> 00:14:50,090
因此你不会在一个设备上共享代码


241
00:14:50,390 --> 00:14:55,195
但是它确实让你仍然把网络访问
代码分离到一个单独的


242
00:14:55,629 --> 00:14:56,763
手表可以使用的框架内


243
00:14:57,130 --> 00:14:59,800
现在当然 比如说手表
对于你提供的手表框架


244
00:15:00,501 --> 00:15:04,505
可能使用NSURLSession
读取信息


245
00:15:07,074 --> 00:15:10,544
因此如果您已经开发了
一个WatchOS 1应用


246
00:15:11,211 --> 00:15:13,881
您实际上已经做了很多准备
以便接触watchOS 2


247
00:15:15,082 --> 00:15:18,252
它们同样拥有有变化和添加的API 


248
00:15:18,986 --> 00:15:22,256
但是您应该能够
不做任何改动编译很大一部分


249
00:15:22,322 --> 00:15:24,124
并且可以将资源复制转移


250
00:15:24,191 --> 00:15:27,861
因此如果在您的 
WatchOS 1扩展内有图像


251
00:15:27,928 --> 00:15:32,566
您可将其添加到WatchOS2扩展
的目标并将其复制到手表上


252
00:15:33,300 --> 00:15:36,103
但是你必须确保它们的大小
被调整到适合于手表


253
00:15:37,104 --> 00:15:38,205
有几项新的改进


254
00:15:39,806 --> 00:15:43,410
当然主要的一点是
您的手表app运行于您的手表上


255
00:15:43,477 --> 00:15:45,445
扩展也是如此


256
00:15:45,512 --> 00:15:48,415
而那意味着UI的反应性好得多了


257
00:15:48,482 --> 00:15:52,519
您点击一个按钮它立刻做出反应


258
00:15:52,920 --> 00:15:56,990
当然现在你也可以独立操作
而不必担心手机就在附近


259
00:15:57,891 --> 00:16:00,761
你不必担心手机正在连接中或正在上网


260
00:16:01,862 --> 00:16:08,502
我们也增加了几个UI元素
以及一些新的系统UI表单


261
00:16:08,569 --> 00:16:12,005
我们将在本节讲座
或其他讲座上谈到它们


262
00:16:12,873 --> 00:16:14,141
我们增加了动画


263
00:16:14,641 --> 00:16:19,546
因此现在您可以让切换间的过渡
实现动画效果


264
00:16:19,613 --> 00:16:22,282
如图表或图形的大小


265
00:16:22,349 --> 00:16:24,651
或是类似的东西


266
00:16:24,718 --> 00:16:26,954
或字符串的不透明度
你可以使其具有动画效果


267
00:16:27,020 --> 00:16:28,755
就此内容明天会有一节专门讲座


268
00:16:29,189 --> 00:16:31,091
因此我建议您也看一下那节讲座


269
00:16:34,494 --> 00:16:38,799
那么对于控件
API大体上是相同的


270
00:16:39,132 --> 00:16:42,436
你有相同的界面控件
你会使用glance


271
00:16:42,503 --> 00:16:43,637
没有任何变化


272
00:16:43,704 --> 00:16:45,038
而且通知也是一样的


273
00:16:45,105 --> 00:16:46,607
你无须做出任何改动


274
00:16:46,874 --> 00:16:49,343
有几个API已经不存在了


275
00:16:49,409 --> 00:16:52,446
图像缓存和open parent已被


276
00:16:52,513 --> 00:16:56,316
替代为直接读取图像
和Watch Connectivity


277
00:16:57,618 --> 00:17:01,889
福李斯特将提到
两个新的元素是extension delegate 


278
00:17:02,789 --> 00:17:09,463
及在表盘上显示被用来为
complications提供图像和文本的数据源


279
00:17:11,298 --> 00:17:15,269
最后对于那些
目前有Xcode项目的朋友


280
00:17:15,736 --> 00:17:18,605
您需要做的是增加一个新的目标


281
00:17:18,672 --> 00:17:20,473
可以在使用WatchOS 1的同时


282
00:17:20,540 --> 00:17:26,613
请求增加WatchOS 2
并向其中添加文件


283
00:17:26,680 --> 00:17:29,116
将文件标记为同一个目标的一部分


284
00:17:29,183 --> 00:17:31,852
添加即将在手表上被编译并加载的框架


285
00:17:33,287 --> 00:17:34,154
如果您愿意


286
00:17:34,221 --> 00:17:38,926
您可以从Xcode开始
启动一个全新的项目


287
00:17:39,193 --> 00:17:42,296
而它将会自动创建iOS
和WatchOS 2 app


288
00:17:42,729 --> 00:17:44,264
因此您可以从那里启动填充内容


289
00:17:44,831 --> 00:17:47,701
昨天有一节讲座
我建议大家看一下视频


290
00:17:48,168 --> 00:17:52,105
它们对这一过程的描述要详细得多


291
00:17:53,040 --> 00:17:54,374
我就讲这么多


292
00:17:54,441 --> 00:17:58,145
现在让福里斯特接替我继续
更详细地讨论新课程


293
00:17:58,212 --> 00:17:59,680
以及现有API上发生的变化


294
00:18:03,483 --> 00:18:05,552
我叫福里斯特
是一名WatchKit工程师


295
00:18:05,619 --> 00:18:06,687
我将跟大家谈谈


296
00:18:06,753 --> 00:18:09,857
我们在面向WatchOS 2的
WatchKit中增加的新的API


297
00:18:11,758 --> 00:18:14,261
首先我谈一下
WK extension delegate


298
00:18:15,028 --> 00:18:20,267
在iOS上我们有
UI Application Delegate


299
00:18:20,868 --> 00:18:23,270
作为众多方法之一
它帮您跟踪您的app的生命周期


300
00:18:23,337 --> 00:18:26,206
这包括诸如你的启动
你变得活跃


301
00:18:26,273 --> 00:18:27,474
以及你将停止活跃


302
00:18:28,008 --> 00:18:30,644
我们已经添加了
WK extension delegate


303
00:18:30,711 --> 00:18:32,846
来跟踪您的应用的生命周期


304
00:18:34,882 --> 00:18:38,485
首先我将从
application Did Finish Launching开始


305
00:18:38,552 --> 00:18:44,591
当程序完成启动及扩展完全未运行时
它被调用一次


306
00:18:45,058 --> 00:18:48,996
这可能是您的应用需要的初始化步骤


307
00:18:49,062 --> 00:18:53,200
设置notification observer
并预热任何今后可能需要的服务的地方


308
00:18:53,267 --> 00:18:56,236
重要的一点是注意
此时您的应用尚未进入活跃状态


309
00:18:58,238 --> 00:19:00,107
接下来我们有
application Did Become Active


310
00:19:00,174 --> 00:19:04,511
每次你的应用被从后台转移到前台
或在第一次启动之后


311
00:19:05,012 --> 00:19:07,114
它都会被调用


312
00:19:08,448 --> 00:19:14,454
这是个启动任何仅需在您应用实际活
跃期间运行的代码的好时机


313
00:19:14,521 --> 00:19:16,356
或激活任何您可能需要的定时器


314
00:19:16,423 --> 00:19:22,095
尤其是更新在后台或根本未运行期间
已经发生变化的状态


315
00:19:24,431 --> 00:19:26,133
Application Will Resign Active


316
00:19:26,200 --> 00:19:30,304
是在您的app停止活跃状态
并被移动到后台之前调用的


317
00:19:30,370 --> 00:19:33,373
您希望准备进入不活跃状态


318
00:19:33,740 --> 00:19:35,475
如果您已经启动了任何定时器


319
00:19:36,076 --> 00:19:37,644
这是一个使它们暂停的好时点


320
00:19:37,711 --> 00:19:40,614
如果您选择在此时不将其暂停


321
00:19:40,681 --> 00:19:42,850
它们将不会在后台运行
你不会有后台运行时间


322
00:19:43,150 --> 00:19:46,153
但是你将会失去
对它们的精确运行周期的控制


323
00:19:46,720 --> 00:19:47,788
因此如果您想进行控制


324
00:19:47,855 --> 00:19:50,123
当你不活跃时
暂停它们是个不错的主意


325
00:19:50,390 --> 00:19:52,860
而当你真正变为活跃时再将其重启


326
00:19:53,327 --> 00:19:55,762
而你希望在此时
保存您的应用的状态


327
00:19:55,829 --> 00:19:58,565
因为在此时间点之后
系统中的另一进程需要那些内存


328
00:19:58,866 --> 00:20:01,001
您的扩展将被强制终止


329
00:20:04,571 --> 00:20:05,405
因此总的来说


330
00:20:05,472 --> 00:20:09,743
WK extension delegate
将跟踪您的应用的生命周期


331
00:20:09,810 --> 00:20:10,644
需要注意的是


332
00:20:10,711 --> 00:20:14,281
这与通知UI Glance UI
或complication数据


333
00:20:14,348 --> 00:20:15,516
毫无任何关系


334
00:20:15,582 --> 00:20:17,584
这仅与跟踪应用的生命周期有关


335
00:20:20,921 --> 00:20:23,524
接下来我讲一下
handle User Activity


336
00:20:23,590 --> 00:20:26,460
Handle User Activity是个
来自于WatchOS 1的现有调用方法


337
00:20:26,527 --> 00:20:29,396
在WatchOS 1中它被用于
应用启动的时候


338
00:20:29,696 --> 00:20:35,669
通过点击您的glance而导航
到您的应用内的适当位置


339
00:20:35,936 --> 00:20:37,471
那也从glance得到反映


340
00:20:37,938 --> 00:20:40,874
我们将在watchOS 2内
以两种方式构建它


341
00:20:41,375 --> 00:20:42,776
首先它会在应用启动时被调用


342
00:20:42,843 --> 00:20:45,646
通过点击您的
complication启动应用


343
00:20:45,946 --> 00:20:49,716
任何你在Complication中
反映的状态将需要导航


344
00:20:49,783 --> 00:20:52,519
到您的应用中该状态
对应的适当位置


345
00:20:53,420 --> 00:20:55,656
此外我们将把它移动到
 WK extension delegate


346
00:20:55,722 --> 00:20:58,725
而不是我们过去所做的
root Interface Controller


347
00:20:59,226 --> 00:21:04,298
这会给你提供更大的灵活性
让你处理想做的事情从而实现状态维护


348
00:21:11,038 --> 00:21:14,308
那么我们在一个名为WK extension
的新对象上进行新的调用


349
00:21:14,374 --> 00:21:15,976
新的调用是root Interface Controller


350
00:21:16,043 --> 00:21:19,213
我必须警告你它将来自于将来的种子
而不是在现有的种子内


351
00:21:19,279 --> 00:21:20,414
因此为了暂时进行估算


352
00:21:20,480 --> 00:21:23,417
您将不得不在您的界面控件的初建之时
在其上进行节省


353
00:21:24,351 --> 00:21:25,252
记住这一点后


354
00:21:25,319 --> 00:21:27,554
你可能会暂时在
WK extension delegate上


355
00:21:27,621 --> 00:21:29,890
执行handle User Activity


356
00:21:29,957 --> 00:21:32,893
我将通过新的调用取得新的根控件


357
00:21:32,960 --> 00:21:37,764
并将跳转回到根部然后我将请求根控件
继续运行并做出任何适当的操作


358
00:21:37,831 --> 00:21:38,732
以恢复您的状态


359
00:21:39,032 --> 00:21:40,934
注意 这里有很多你能做的其他事情


360
00:21:41,001 --> 00:21:44,204
你可以建立模态警告或进行其他操作


361
00:21:44,905 --> 00:21:46,874
以处理传递给你的用户活动


362
00:21:48,842 --> 00:21:52,646
接下来在IOS上
我们有UI application


363
00:21:53,213 --> 00:21:57,751
它是一个单独的对象
代表正在运行中的应用


364
00:21:58,452 --> 00:22:03,957
所以在watchOS 2上我们添加
类似WK extension的东西


365
00:22:06,059 --> 00:22:10,264
其中这个是主要的界面
用于打开标准的系统URL


366
00:22:10,831 --> 00:22:13,767
因此 您将能够打开
开放系统URL API 


367
00:22:13,834 --> 00:22:18,872
而执行诸如打电话 发送文本消息
或显示PassKit UI等操作


368
00:22:19,706 --> 00:22:21,909
那就是开放系统URL 
和WK extension


369
00:22:23,977 --> 00:22:25,779
现在我将讲一下关于通知的内容


370
00:22:28,916 --> 00:22:30,684
首先我要说的是远程通知


371
00:22:31,051 --> 00:22:33,253
远程通知来自于互联网


372
00:22:34,588 --> 00:22:36,390
而它们总是先到达你的手机


373
00:22:36,957 --> 00:22:39,927
那时候你的手机将决定是否
显示通知本身内容


374
00:22:40,894 --> 00:22:43,197
或将其继续转发直至它被显示在手表上


375
00:22:46,433 --> 00:22:50,971
现在手机使用了一套规则而做出决定


376
00:22:51,138 --> 00:22:52,773
而这些规则中的标准包括是否


377
00:22:52,840 --> 00:22:54,241
您的手机屏幕已被上锁


378
00:22:54,842 --> 00:22:57,077
或是否您的手表
被戴在您的手腕上并且已被解锁


379
00:23:01,148 --> 00:23:02,916
因此诸如watchOS 1


380
00:23:02,983 --> 00:23:08,355
您的WK用户通知界面控件在接收到
发给不活跃app的通知时便会运行


381
00:23:09,723 --> 00:23:11,158
当发生这种情况的时候


382
00:23:11,225 --> 00:23:13,727
其中的一个调用确实会收到远程通知
或者收到本地通知


383
00:23:13,794 --> 00:23:15,896
它将会在您的控件上被调用


384
00:23:16,864 --> 00:23:20,567
而您自行决定
是否及时调用completion handler


385
00:23:20,634 --> 00:23:24,938
如果您花费太长时间
您的默认界面将被显示


386
00:23:25,005 --> 00:23:27,140
它有点不太生动


387
00:23:27,207 --> 00:23:30,410
因此这由您决定是否
在合理的时间内进行这个操作


388
00:23:32,746 --> 00:23:34,748
接下来我将讲一下本地通知


389
00:23:35,282 --> 00:23:38,418
本地通知必须从手机上
由您的iPhone app发出


390
00:23:38,819 --> 00:23:41,388
但是你可以从WatchKit扩展
向您的iPhone app发出消息


391
00:23:41,455 --> 00:23:43,023
并请求它发出本地通知


392
00:23:44,391 --> 00:23:47,761
同样的逻辑也适用于远程通知


393
00:23:48,061 --> 00:23:51,598
对于远程通知手机将决定
是否显示通知本身


394
00:23:52,499 --> 00:23:54,501
或是否将其传回给手表
并将其显示在那里


395
00:23:57,938 --> 00:24:00,207
那么让我们来查看一个例子
看你如何进行该操作


396
00:24:02,109 --> 00:24:06,980
这里我将使用watch connectivity 
消息调用从手表向手机app发送消息


397
00:24:09,383 --> 00:24:12,219
当我的iPhone app收到那个消息时
它可以发出本地通知


398
00:24:12,286 --> 00:24:15,355
启动常规逻辑 确定在哪里显示该警告


399
00:24:16,323 --> 00:24:17,357
这是相对简单的代码


400
00:24:19,660 --> 00:24:21,495
那么现在我们可以
在您的手表上看到警告


401
00:24:21,929 --> 00:24:25,799
我要讲一下从您的通知UI
启动您的应用


402
00:24:26,633 --> 00:24:28,302
从这里可以用两种方式启动app


403
00:24:28,936 --> 00:24:33,240
要么你可以从通知动作按钮启动


404
00:24:33,307 --> 00:24:35,309
在这个例子里我已经
通过回复按钮进行了设置


405
00:24:35,642 --> 00:24:40,647
用户也可以通过
点击左上角的应用图标来启动应用


406
00:24:42,916 --> 00:24:44,484
当这些动作其中之一发生时


407
00:24:44,551 --> 00:24:46,453
或者当用户做了这些事情之一时


408
00:24:48,488 --> 00:24:53,160
在您的WK extension delegate上
会进行这些调用其中的一个


409
00:24:53,427 --> 00:24:58,265
两个handle action with identifier 
调用之一将被执行发出远程或本地通知


410
00:24:58,899 --> 00:25:01,702
您将会收到被启发的动作的识别符


411
00:25:01,768 --> 00:25:04,471
如果它们点击了应用图标
你将会收到一个 0


412
00:25:05,038 --> 00:25:08,842
而对于远程通知的情况
你将会收到一个含有通知负载的字典


413
00:25:09,376 --> 00:25:14,548
在本地通知的情况下 您将收到一开始
就创建的UI notification对象


414
00:25:14,615 --> 00:25:15,916
目的是为了发出你的通知


415
00:25:16,617 --> 00:25:18,352
那么 这就是如何从通知启动你的app


416
00:25:20,754 --> 00:25:23,624
接下来我将谈一下
内嵌通知的文本回复


417
00:25:24,491 --> 00:25:29,396
在iOS 9和watchOS 2中
为内嵌通知文本回复增加了第三方支持


418
00:25:31,899 --> 00:25:36,069
在此例中 回复动作已被指定为
发生文本输入行为


419
00:25:37,271 --> 00:25:39,439
当用户启发此动作


420
00:25:39,806 --> 00:25:41,308
而不是启动app时


421
00:25:41,375 --> 00:25:44,611
或向您的iPhone app
发回一个信号时


422
00:25:45,212 --> 00:25:47,114
用户将被呈现一个文本输入UI


423
00:25:47,581 --> 00:25:52,853
因此您在此UI中可以看到
用户能够启动麦克风口述回复


424
00:25:53,220 --> 00:25:56,590
他们可以点击表情符号图标


425
00:25:56,924 --> 00:26:02,196
以便从表情符号选择器内输入
或者从一个提示列表内进行选择


426
00:26:02,529 --> 00:26:05,065
而你作为app开发者
将可以提供这样的提示列表


427
00:26:05,799 --> 00:26:06,867
而你实现这个的方式


428
00:26:06,934 --> 00:26:07,868
就是通过执行这个


429
00:26:08,135 --> 00:26:11,772
对suggestions For Response
To Action With Identifier的调用


430
00:26:12,906 --> 00:26:15,609
它是在您的WK用户/通知
界面控件上的


431
00:26:18,745 --> 00:26:21,014
因此一旦用户选择了


432
00:26:21,081 --> 00:26:23,684
或提供了他们的文本输入内容
不管是通过您的选择之一


433
00:26:23,750 --> 00:26:25,152
或是其他某种方法


434
00:26:25,919 --> 00:26:27,888
您的应用将被启动


435
00:26:28,322 --> 00:26:30,791
而你将收到这个
handle Action With Identifier调用


436
00:26:30,858 --> 00:26:34,428
它出现在您的WK或
您的WK extension delegate上


437
00:26:37,965 --> 00:26:41,134
您将注意到这个变量有一个新的参数
即response Info


438
00:26:41,201 --> 00:26:43,036
而response Info将包含


439
00:26:43,103 --> 00:26:44,071
输入的文本


440
00:26:44,137 --> 00:26:48,308
用户在UI User Notification
Action Response Typed Text Key内


441
00:26:50,777 --> 00:26:54,348
那么我将要讲的另一个新特性是
运行中的语言选择


442
00:26:55,382 --> 00:26:57,251
这里您可以看到我们有标准的文本输入


443
00:26:57,718 --> 00:27:01,388
不管何时用户启动了文本输入UI


444
00:27:01,455 --> 00:27:04,825
他们都能选择通过力度触摸调出
语言选择器


445
00:27:05,425 --> 00:27:09,963
语言选择器将提供所有可用的语言


446
00:27:10,030 --> 00:27:14,001
这些语言根据您在iPhone上
提供的键盘而选择的


447
00:27:14,868 --> 00:27:17,437
那么我将提供英语和西班牙语


448
00:27:17,704 --> 00:27:19,239
那么我将继续进行切换到西班牙语


449
00:27:19,907 --> 00:27:22,075
这将把文本输入UI切换到西班牙语


450
00:27:22,409 --> 00:27:25,746
并可以填充一个西班牙语提示列表
而不是英语提示列表


451
00:27:26,446 --> 00:27:28,081
这就是运行中的语言选择


452
00:27:31,485 --> 00:27:34,087
接下来我会谈一下
如何通过另一种方式处理通知


453
00:27:34,354 --> 00:27:37,491
在watchOS 1中 
不管您的app活跃与否


454
00:27:37,558 --> 00:27:41,295
我们总会将您的
WK用户通知界面控件实例化


455
00:27:41,562 --> 00:27:45,399
而系统将在屏幕的上方显示出来
不管屏幕上是什么 包括您的app


456
00:27:46,099 --> 00:27:49,203
在watchOS 2中
如果您的app是活跃的 我们将不再那么做


457
00:27:49,269 --> 00:27:51,405
相反WK extension delegate


458
00:27:51,705 --> 00:27:54,508
将会收到
Did Receive Notification调用


459
00:27:55,275 --> 00:28:00,113
您的app将决定如何适当处理
和显示通知的内容


460
00:28:00,814 --> 00:28:03,383
比如说 如果你在编写一个聊天app


461
00:28:03,450 --> 00:28:06,954
您可能会把内容附加到聊天记录的末尾


462
00:28:08,288 --> 00:28:10,490
同样系统将不再为你显示警告


463
00:28:10,557 --> 00:28:12,826
因此如果您希望用户
了解出现了什么样的通知


464
00:28:12,893 --> 00:28:14,862
您需要将其
呈现在您的UI里面


465
00:28:16,230 --> 00:28:17,698
这个就是我要说的通知内容


466
00:28:18,232 --> 00:28:19,733
接下来我将讲一下模态警告


467
00:28:22,102 --> 00:28:24,638
在WatchOS 1中


468
00:28:25,072 --> 00:28:29,209
您可以取消
隐藏群组的隐藏状态而显示警告


469
00:28:30,110 --> 00:28:32,846
在watchOS 2中我们
允许使用present Alert Controller With Title 


470
00:28:32,913 --> 00:28:36,583
这会让对用户呈现模态警告的操作
变得容易得多


471
00:28:38,318 --> 00:28:42,089
在这个调用里面有三个变量
第一个是警告


472
00:28:42,456 --> 00:28:45,158
这是一个简单的调用
告诉用户发生了某些事情


473
00:28:47,294 --> 00:28:49,396
接下来我们有
Side By Side Buttons Alert


474
00:28:49,463 --> 00:28:54,568
这是当前在iOS中向用户
呈现二选一选择的非常流行的方式


475
00:28:54,635 --> 00:28:59,072
我们认为第三方开发者
也希望在他们的应用中使用它


476
00:29:00,841 --> 00:29:02,643
最后我们谈一下 action sheet


477
00:29:02,776 --> 00:29:06,413
action sheet最多有四种
动作外加一个可定制的取消动作


478
00:29:06,480 --> 00:29:08,282
您可以看到Nevermind动作


479
00:29:08,348 --> 00:29:10,884
我已经把Cancel动作定制为Nevermind


480
00:29:10,951 --> 00:29:13,487
各种动作可被选择标记为“毁灭性的”


481
00:29:13,554 --> 00:29:15,055
我是通过delete按钮实现的


482
00:29:15,122 --> 00:29:16,790
目前那意味着它们将以红色显示


483
00:29:18,025 --> 00:29:22,296
一旦用户从Cancel
或四个主要动作中做出选择


484
00:29:22,362 --> 00:29:25,065
您将会收到一个回调
表明哪个按钮被选中


485
00:29:28,101 --> 00:29:31,839
因此总的来说 我们在
watchOS 2中有一个新的架构


486
00:29:33,607 --> 00:29:35,375
我们增加了WK extension delegate


487
00:29:35,442 --> 00:29:37,311
帮您管理您的应用的生命周期


488
00:29:38,645 --> 00:29:40,247
我们有大量的新API


489
00:29:41,915 --> 00:29:43,250
而且当然还会有更多的到来


490
00:29:45,018 --> 00:29:48,255
如果您希望了解关于安德鲁和我
刚才在此所谈内容的更多信息


491
00:29:48,722 --> 00:29:51,558
请查阅
文稿和示例代码


492
00:29:51,859 --> 00:29:53,360
而如果你有具体的疑问


493
00:29:53,427 --> 00:29:57,197
请联系Jake Behrens
地址如下


494
00:29:57,564 --> 00:29:59,132
而且会有大量的相关讲座


495
00:29:59,766 --> 00:30:03,003
包括这里将进行的下一节讲座
也就是我们的讲座的第二部分


496
00:30:04,004 --> 00:30:05,405
那么非常感谢大家的莅临

