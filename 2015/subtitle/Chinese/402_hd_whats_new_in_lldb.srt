1
00:00:19,720 --> 00:00:22,990
《LLDB最新内容》
以自己的方式调试达至名利双收


2
00:00:23,056 --> 00:00:23,891
下午好


3
00:00:23,991 --> 00:00:26,026
欢迎参加
《LLDB最新内容》讲座


4
00:00:26,326 --> 00:00:27,361
我是凯特


5
00:00:34,001 --> 00:00:36,436
我负责管理Xcode
的运行时间分析工具


6
00:00:36,503 --> 00:00:37,771
也包括LLDB


7
00:00:38,071 --> 00:00:40,040
今天我来为大家介绍
但我还带来


8
00:00:40,107 --> 00:00:41,074
两位工程师


9
00:00:41,475 --> 00:00:42,509
西恩和恩里科


10
00:00:42,576 --> 00:00:44,611
他们会更深入
介绍部分内容


11
00:00:45,345 --> 00:00:47,814
但是开始之前
我想谈谈


12
00:00:47,881 --> 00:00:49,449
自上次WWDC以来  


13
00:00:49,516 --> 00:00:51,885
今年的亮点有些或大


14
00:00:52,152 --> 00:00:53,487
或小的改变


15
00:00:54,354 --> 00:00:55,189
最著名的是...


16
00:00:56,423 --> 00:00:58,559
我们推出首个Swift调试器


17
00:00:58,926 --> 00:01:01,461
显然这是向前迈出了一步
可以编写和开发


18
00:01:01,595 --> 00:01:04,298
Swift代码 大家一定会
逐渐熟悉并喜爱


19
00:01:05,666 --> 00:01:08,035
但更重要的是
不会就此为止


20
00:01:08,302 --> 00:01:10,137
我们会进一步
改善调试器


21
00:01:10,204 --> 00:01:12,206
希望大家继续反馈


22
00:01:12,272 --> 00:01:13,674
帮我们实现尽善尽美


23
00:01:14,208 --> 00:01:15,175
与此同时


24
00:01:15,409 --> 00:01:17,110
我们还
推出了Swift REPL


25
00:01:17,244 --> 00:01:21,281
它稍稍不同于标准请求回复
REPL环境


26
00:01:21,548 --> 00:01:24,985
实际上是伪装的LLDB


27
00:01:25,219 --> 00:01:28,856
大家不仅可以通过REPL 
在Swift中提出问题


28
00:01:28,922 --> 00:01:31,358
还可以通过它
来调试那些问题


29
00:01:31,425 --> 00:01:33,126
你实际上是在REPL中
设置断点


30
00:01:33,327 --> 00:01:34,394
实现想在调试环境下


31
00:01:34,494 --> 00:01:35,662
完成的任何事情


32
00:01:35,829 --> 00:01:37,531
因为它是LLDB


33
00:01:37,898 --> 00:01:39,199
如果还没有
这么深入研究


34
00:01:39,333 --> 00:01:41,902
我建议大家看看看
这一问题的相关博客


35
00:01:43,003 --> 00:01:44,605
但是 这不是...
最终结果


36
00:01:44,671 --> 00:01:47,140
之后 我们做了
无数的改进


37
00:01:47,207 --> 00:01:48,675
自从首次推出产品以来


38
00:01:48,742 --> 00:01:50,244
我们已经在Swift


39
00:01:50,310 --> 00:01:51,979
调试体验方面
进行了百余项改进


40
00:01:52,045 --> 00:01:55,816
而且我们还在继续提高
Objective-C的调试体验


41
00:01:56,116 --> 00:01:57,518
我们今天也会
提到部分内容


42
00:01:57,851 --> 00:02:00,988
不过只会介绍
自去年起做出的改进


43
00:02:02,322 --> 00:02:04,291
Swift类型
起初并未显示出


44
00:02:04,358 --> 00:02:05,993
继承了Objective-C域


45
00:02:06,159 --> 00:02:07,294
我们后来对此作了更正


46
00:02:07,995 --> 00:02:10,631
Help现在
包括了指令别名


47
00:02:10,697 --> 00:02:12,299
需要理解的是


48
00:02:12,366 --> 00:02:16,170
因为当LLDB看似语法
比较冗长


49
00:02:16,570 --> 00:02:17,971
我们可能会让你输入help


50
00:02:18,405 --> 00:02:20,140
实际上有许多快捷方式


51
00:02:20,207 --> 00:02:23,677
在这次讲座中
我们会使用下列符号来描述它们


52
00:02:24,311 --> 00:02:28,382
Help实际上可以
缩写为第一个独特序列


53
00:02:28,715 --> 00:02:31,084
在这种情况下
H就足以调出帮助


54
00:02:31,852 --> 00:02:34,354
更重要的是
对于更复杂的例子而言


55
00:02:34,421 --> 00:02:39,293
如表达式-O--
是指评价表达式


56
00:02:39,693 --> 00:02:41,962
告知结果
就像它是通过发送方法


57
00:02:42,062 --> 00:02:44,231
来描述自己的
一个对象


58
00:02:45,098 --> 00:02:46,667
随后在该表达之后


59
00:02:46,800 --> 00:02:48,268
并无其他选项


60
00:02:48,902 --> 00:02:50,170
但你可以输入PO


61
00:02:50,571 --> 00:02:52,739
PO是个方便的别名
可以对左边的


62
00:02:52,806 --> 00:02:54,274
所有内容进行速记


63
00:02:54,675 --> 00:02:56,643
那么如果你习惯于
用帮助


64
00:02:56,710 --> 00:02:58,212
应该学习使用这些别名


65
00:02:58,278 --> 00:02:59,947
因为它们可以最快捷地


66
00:03:00,013 --> 00:03:03,050
帮你获得LLDB中的
部分强大功能


67
00:03:04,184 --> 00:03:05,786
我们还改善了
数据格式


68
00:03:05,986 --> 00:03:08,488
因为告知你相关的数据情况


69
00:03:08,555 --> 00:03:10,257
对于调试体验而言
是非常重要的


70
00:03:10,724 --> 00:03:12,626
那么设置


71
00:03:12,826 --> 00:03:14,261
和NSNS Index Path


72
00:03:14,328 --> 00:03:15,729
目前就有了默认格式


73
00:03:15,796 --> 00:03:17,364
可以帮助理解数据


74
00:03:17,464 --> 00:03:18,966
而不是仅仅展示


75
00:03:19,032 --> 00:03:20,801
底层结构的回收机制


76
00:03:21,802 --> 00:03:23,670
表达式的Printf原型


77
00:03:24,171 --> 00:03:27,608
如果曾尝试以Printf对它
进行计算 可能会发现


78
00:03:27,941 --> 00:03:30,043
有一些稍微可疑的结果


79
00:03:30,544 --> 00:03:32,813
这是因为调试器对它


80
00:03:32,880 --> 00:03:34,414
不了解的表达式


81
00:03:34,481 --> 00:03:36,450
声明做了很多假设


82
00:03:36,650 --> 00:03:39,319
而之前它在很多情况下
也不了解printf


83
00:03:39,786 --> 00:03:42,022
因此之前不知道
它是个可变参数函数


84
00:03:42,089 --> 00:03:44,525
也就是可以采取
可变数量的特殊参数


85
00:03:44,825 --> 00:03:47,728
也不了解特别是在
64位设备上


86
00:03:47,794 --> 00:03:49,530
如何正确传递
这些特殊参数


87
00:03:49,897 --> 00:03:51,465
这些都已得到改正
这样所有的


88
00:03:51,532 --> 00:03:55,068
涉及C和Objective-C
的printf表达式


89
00:03:55,135 --> 00:03:56,970
都应该另行执行


90
00:03:57,538 --> 00:03:59,640
那么最后
这次是真的最后


91
00:03:59,873 --> 00:04:01,508
我们改善了分解格式


92
00:04:01,575 --> 00:04:03,310
使其更方便阅读


93
00:04:05,412 --> 00:04:07,981
来深入了解
部分更有趣的改进


94
00:04:08,715 --> 00:04:10,851
今年春天实现了
断点改进


95
00:04:10,918 --> 00:04:12,686
大家可能还没有意识到


96
00:04:12,819 --> 00:04:15,322
具体而言 大家现在
可以命名断点了


97
00:04:15,956 --> 00:04:18,024
命名的断点可能
会比其他断点


98
00:04:18,091 --> 00:04:20,360
更易于使用
这可能开始并不明显


99
00:04:20,427 --> 00:04:23,063
不过 这些命名不一定
具备独特性


100
00:04:23,163 --> 00:04:25,732
可以对单个断点
使用多个名称 这就很不简单


101
00:04:25,999 --> 00:04:28,168
可以把它们想象成标签


102
00:04:29,570 --> 00:04:32,506
所有的断点指令
都使用这些名称


103
00:04:32,606 --> 00:04:35,843
那么设置断点时
可以提供断点设置


104
00:04:36,210 --> 00:04:38,145
短线N 大写N


105
00:04:38,412 --> 00:04:39,613
加上名称


106
00:04:39,680 --> 00:04:41,715
还可以加上另一个短线大写N


107
00:04:41,782 --> 00:04:43,317
和额外的名称等等


108
00:04:44,151 --> 00:04:46,720
但更重要的是
一旦为断点


109
00:04:46,787 --> 00:04:48,789
或多个断点命名


110
00:04:48,856 --> 00:04:50,390
我就可以对它们


111
00:04:50,457 --> 00:04:51,825
通过所有其他的指令来操作


112
00:04:51,892 --> 00:04:55,028
断点可以命名
这会使得所有断点


113
00:04:55,262 --> 00:04:58,632
都是可以共享命名
或者就把它当作是标签


114
00:05:00,033 --> 00:05:02,469
这其实非常有趣
因为我们现在可以


115
00:05:02,536 --> 00:05:05,839
实现在LLDBinit中
设置断点


116
00:05:06,273 --> 00:05:08,008
如果你还不熟悉
LLDBinit


117
00:05:08,208 --> 00:05:09,276
这是一种文件...


118
00:05:09,676 --> 00:05:11,979
名前缀有个句号


119
00:05:12,045 --> 00:05:13,780
会进入主目录


120
00:05:13,847 --> 00:05:16,183
告知LLDB 这里有一束指令


121
00:05:16,250 --> 00:05:19,553
每次打开LLDB会话都需要执行


122
00:05:20,254 --> 00:05:22,823
如果这么使用
则会在LLDB启动时


123
00:05:22,890 --> 00:05:24,992
生成一组 默认断点


124
00:05:25,158 --> 00:05:28,762
所有设置的断点
在实际生成目标之前


125
00:05:29,129 --> 00:05:31,532
都会被
所生成的每个目标所继承


126
00:05:32,633 --> 00:05:33,901
那么结合两方面因素


127
00:05:34,201 --> 00:05:37,037
我可以在这些
代码行编写LLDBinit


128
00:05:37,571 --> 00:05:39,540
一组断点 -n
都命名为malloc


129
00:05:39,706 --> 00:05:41,441
一个断点 -n
都命名为free


130
00:05:41,642 --> 00:05:43,844
把所有断点命名为
memory


131
00:05:44,077 --> 00:05:45,245
然后再关闭


132
00:05:45,479 --> 00:05:48,015
这就可以很方便的
获得所有处理断点的内存


133
00:05:48,081 --> 00:05:49,650
只要在我之后用到的


134
00:05:49,716 --> 00:05:50,884
任何会话中输入


135
00:05:50,951 --> 00:05:54,988
"breakpoint
enablememory"即可


136
00:05:55,422 --> 00:05:58,225
这样就有了自己的
一组非常方便的断点


137
00:05:58,292 --> 00:05:59,793
我肯定大家会经常使用


138
00:06:00,027 --> 00:06:02,262
现在可以给它们
一些好记的名称


139
00:06:05,098 --> 00:06:07,601
但是 当然大家在这里
不仅是来学习


140
00:06:07,668 --> 00:06:09,102
我们已经完成
并推出的内容


141
00:06:09,369 --> 00:06:11,705
还有我们刚开始
预览的内容


142
00:06:11,772 --> 00:06:12,873
Xcode 7


143
00:06:13,273 --> 00:06:14,775
是个很重要的版本


144
00:06:15,108 --> 00:06:16,510
包括许多改进


145
00:06:16,643 --> 00:06:18,512
最重要的是表达式求值


146
00:06:18,612 --> 00:06:21,348
西恩会为大家
详细介绍这方面内容


147
00:06:21,682 --> 00:06:23,483
Swift 2支持...
当然...


148
00:06:23,550 --> 00:06:26,453
语言会不断发展
以及Objective-C 


149
00:06:26,520 --> 00:06:29,590
支持模块的高级处理


150
00:06:30,657 --> 00:06:32,292
这些内容
我们也会深入讲解


151
00:06:32,559 --> 00:06:34,728
但是部分内容
其实就在后台


152
00:06:34,795 --> 00:06:36,463
如果继续深入研究
你可能会注意到


153
00:06:36,530 --> 00:06:37,998
例如在Xcode 7中


154
00:06:38,398 --> 00:06:40,267
大家都知道模块


155
00:06:40,734 --> 00:06:44,238
我们实际上可以
在为模块构建调试信息一次后


156
00:06:44,371 --> 00:06:46,573
再不必在其他位置重复进行


157
00:06:46,840 --> 00:06:50,577
这可以大幅减少调试信息的


158
00:06:50,744 --> 00:06:54,181
数量 并提高汇编的
性能表现


159
00:06:54,681 --> 00:06:56,717
一旦进入
实际的.dSYM文件 


160
00:06:56,783 --> 00:06:58,452
这个.dSYM文件就会


161
00:06:58,519 --> 00:07:00,053
将你所需的
所有内容都包括在内


162
00:07:00,687 --> 00:07:03,023
但是其中还包括
部分其它优化


163
00:07:03,090 --> 00:07:06,126
例如 不为C++类型
复制信息


164
00:07:06,360 --> 00:07:07,895
这多亏了定义法则的规定


165
00:07:08,128 --> 00:07:10,464
否则我们会有多个副本


166
00:07:10,797 --> 00:07:13,033
实际上 我们看到
调试信息


167
00:07:13,233 --> 00:07:17,104
要比Xcode 6中
少了1/6


168
00:07:18,238 --> 00:07:20,107
特别是对C++项目更是如此


169
00:07:20,807 --> 00:07:23,577
我们还在多方面
改进了数据格式


170
00:07:23,710 --> 00:07:26,980
在Objective-C和
Swift中矢量类型有着


171
00:07:27,047 --> 00:07:28,482
独特的自动数据格式


172
00:07:29,049 --> 00:07:30,651
也许更重要的是


173
00:07:30,717 --> 00:07:32,819
如果有Swift自定义类型


174
00:07:33,120 --> 00:07:35,088
现在可以自定义它们的
表现方式


175
00:07:35,155 --> 00:07:37,057
只要编写Swift代码即可


176
00:07:37,291 --> 00:07:38,992
恩里科会介绍更多详情


177
00:07:40,260 --> 00:07:43,664
我们还在LLDB中整合了
地址消毒剂支持


178
00:07:43,730 --> 00:07:45,999
那么地址消毒剂
不只会在


179
00:07:46,066 --> 00:07:47,701
参考内存无效时会告知


180
00:07:47,801 --> 00:07:49,636
你还可以
针对内存提出问题


181
00:07:49,837 --> 00:07:52,639
比如可以问
例如 内存历史


182
00:07:52,706 --> 00:07:55,576
从LLDB控制台
了解它分配到哪里


183
00:07:55,776 --> 00:07:57,678
以及何时释放


184
00:07:57,911 --> 00:07:59,780
那么你可能想了解更多


185
00:07:59,980 --> 00:08:02,382
指令的内存系列
并想知道相关帮助


186
00:08:03,917 --> 00:08:06,620
我们还增加了
类型查找指令


187
00:08:06,820 --> 00:08:08,889
类型查找指令
可以获取


188
00:08:08,956 --> 00:08:10,991
系统的任何类型信息


189
00:08:11,425 --> 00:08:13,660
基本上 
这就是个类似头文件的表示


190
00:08:13,727 --> 00:08:15,495
可以在调试器中获得


191
00:08:15,629 --> 00:08:17,798
以便提醒你类型的内容


192
00:08:19,132 --> 00:08:20,734
因此 从LLDB提示中


193
00:08:21,101 --> 00:08:24,605
我只需要把类型变为
"type lookup"随后加上


194
00:08:24,838 --> 00:08:26,807
类型名称 然后我会
获得类型快速说明


195
00:08:26,974 --> 00:08:29,076
本例中 新的错误类型


196
00:08:29,142 --> 00:08:31,178
用于Swift错误处理机制


197
00:08:31,345 --> 00:08:33,046
我知道 在幕后


198
00:08:33,113 --> 00:08:34,615
通常会执行一对


199
00:08:34,748 --> 00:08:38,018
一般已执行了的属性
只要使用EDAM类型即可


200
00:08:38,217 --> 00:08:40,721
但是不管怎样 
都可以从控制台看到细节详情


201
00:08:41,221 --> 00:08:44,124
同理 如果我感兴趣
"Comparable"类型


202
00:08:44,191 --> 00:08:45,025
是个协议


203
00:08:45,225 --> 00:08:47,995
它会告诉这个协议
实际上是来自另外两个


204
00:08:48,295 --> 00:08:50,264
这样你会看到
我们从Equatable


205
00:08:50,330 --> 00:08:51,765
<br/> 
得到了等号运算符


206
00:08:52,065 --> 00:08:54,935
下划线Comparable 
可以提供小于比较


207
00:08:55,102 --> 00:08:58,438
而导出运算符是
Comparable协议的一部分


208
00:08:58,772 --> 00:09:01,341
这里还可获取许多
便捷信息


209
00:09:01,508 --> 00:09:02,843
和所有内容一样


210
00:09:03,644 --> 00:09:06,680
提醒你不必输入完整命令
"type lookup"


211
00:09:06,847 --> 00:09:10,217
TY空格L
便足以使用这个指令


212
00:09:11,251 --> 00:09:12,786
但是要想知道更多详情


213
00:09:12,886 --> 00:09:15,856
特别是谈到
怎样计算表达式


214
00:09:15,989 --> 00:09:18,258
我想有请
西恩•卡拉南[


215
00:09:19,426 --> 00:09:20,260
大家好


216
00:09:21,595 --> 00:09:24,631
我来讲讲
LLDB中的LLDB


217
00:09:25,666 --> 00:09:27,067
大家可能会觉得


218
00:09:27,267 --> 00:09:29,036
有那么多编译器会话


219
00:09:29,303 --> 00:09:30,804
为什么要在乎编译器？


220
00:09:31,572 --> 00:09:34,541
编译器是
LLDB的关键内容


221
00:09:35,309 --> 00:09:37,945
会使得LLDB功能强大


222
00:09:38,345 --> 00:09:40,647
会令LLDB简单易用


223
00:09:41,481 --> 00:09:42,916
它的强大是


224
00:09:43,116 --> 00:09:45,719
因为编译器对程序运行


225
00:09:46,019 --> 00:09:47,955
对配置数据的方法


226
00:09:48,388 --> 00:09:49,957
以及当你说想看看


227
00:09:51,692 --> 00:09:53,861
这个变量或调用函数时等 


228
00:09:53,927 --> 00:09:55,462
有着独特的理解


229
00:09:56,964 --> 00:10:00,067
编译器很重要
还有一个原因是


230
00:10:00,133 --> 00:10:03,070
它们可以与调试器
轻松配合使用


231
00:10:03,904 --> 00:10:05,372
如果想要打印


232
00:10:05,839 --> 00:10:07,774
只要使用你熟悉


233
00:10:07,841 --> 00:10:09,109
输入的代码


234
00:10:10,110 --> 00:10:11,778
交给表达式指令


235
00:10:12,646 --> 00:10:14,915
编译器就会从中拿到指令


236
00:10:17,784 --> 00:10:18,619
今天


237
00:10:18,719 --> 00:10:20,153
我来讲讲在编译器整合方面


238
00:10:20,220 --> 00:10:21,421
有两个重要


239
00:10:21,822 --> 00:10:23,490
相关领域


240
00:10:23,690 --> 00:10:25,259
获得了的改进


241
00:10:27,094 --> 00:10:27,961
首先


242
00:10:28,095 --> 00:10:29,396
有个好消息要告诉各位


243
00:10:29,463 --> 00:10:31,665
长期从事Objective-C 
的开发人员


244
00:10:32,499 --> 00:10:33,333
接下来


245
00:10:33,467 --> 00:10:34,301
我要告诉...


246
00:10:34,801 --> 00:10:36,336
Swift开发人员


247
00:10:36,670 --> 00:10:38,338
希望现在各位都是


248
00:10:39,439 --> 00:10:40,274
聊聊...


249
00:10:40,407 --> 00:10:42,042
我们所做的这些改进


250
00:10:43,777 --> 00:10:45,679
现在就开始
讲讲Objective-C


251
00:10:48,749 --> 00:10:49,716
LLDB


252
00:10:49,850 --> 00:10:50,684
包括...


253
00:10:50,784 --> 00:10:52,519
两个独立的编译器


254
00:10:54,288 --> 00:10:55,122
Clang


255
00:10:55,255 --> 00:10:57,057
强大的Objective-C
编译器


256
00:10:58,025 --> 00:10:59,626
当然 从去年起


257
00:10:59,993 --> 00:11:01,128
是Swift编译器


258
00:11:02,596 --> 00:11:04,698
我们的Objective-C
编译器支持


259
00:11:05,365 --> 00:11:06,900
多年来一直在改进


260
00:11:07,434 --> 00:11:09,570
我们加入了非常出色的新功能


261
00:11:10,771 --> 00:11:11,605
比如


262
00:11:11,939 --> 00:11:14,007
Objective-C
运行时间整合


263
00:11:14,842 --> 00:11:18,111
那么 如果Objective-C
运行时间有部分信息


264
00:11:18,312 --> 00:11:20,380
并未显示在
调试信息中


265
00:11:21,048 --> 00:11:23,317
我们知道该向编译器提供


266
00:11:23,383 --> 00:11:25,319
这样可以使用很多类


267
00:11:25,619 --> 00:11:27,221
而不必特别做些什么


268
00:11:28,755 --> 00:11:29,723
当然 去年


269
00:11:29,923 --> 00:11:31,892
我们在LLDB中


270
00:11:32,226 --> 00:11:33,427
引入了Swift编译器


271
00:11:34,294 --> 00:11:36,163
Swift编译器已经是


272
00:11:36,430 --> 00:11:37,831
是很强的工具


273
00:11:39,499 --> 00:11:41,101
我们把从Swift编译器中


274
00:11:41,368 --> 00:11:43,570
整合所学内容都用到其中


275
00:11:44,505 --> 00:11:46,273
我们对二者都做了改进


276
00:11:47,641 --> 00:11:48,509
我们来谈谈


277
00:11:48,575 --> 00:11:50,644
表达式剖析器与Swift


278
00:11:51,578 --> 00:11:52,412
怎么配合


279
00:11:52,846 --> 00:11:54,781
从Objective-C的角度


280
00:11:57,551 --> 00:11:59,953
我们现在来看
简单的打印指令


281
00:12:00,687 --> 00:12:03,557
这里说到打印 
因为我用了p快捷方式


282
00:12:04,491 --> 00:12:05,659
实际上是指


283
00:12:05,926 --> 00:12:07,327
表达式


284
00:12:08,228 --> 00:12:09,530
注意短线 


285
00:12:10,330 --> 00:12:11,164
这是指


286
00:12:11,231 --> 00:12:14,168
在p指令编码后的
所有内容


287
00:12:14,468 --> 00:12:17,838
不能这样把额外的选项
交给指令


288
00:12:18,405 --> 00:12:20,240
这里有其他方法
恩里科会给大家介绍


289
00:12:20,307 --> 00:12:21,608
而且凯特刚刚给大家看过


290
00:12:22,676 --> 00:12:25,712
这里是些循环运行的
简单代码


291
00:12:25,879 --> 00:12:27,481
并会每次打印出
循环计数


292
00:12:28,048 --> 00:12:29,483
的确 如果运行它


293
00:12:30,117 --> 00:12:32,019
你会得到自己预期的数字


294
00:12:33,287 --> 00:12:34,254
这个功能好在哪里？


295
00:12:36,523 --> 00:12:39,826
LLDB和程序
是单独的进程


296
00:12:40,761 --> 00:12:43,197
LLDB内部有
swift编译器


297
00:12:44,231 --> 00:12:45,999
程序已经在运行


298
00:12:46,633 --> 00:12:48,435
但是有了LLDB的帮助


299
00:12:48,869 --> 00:12:52,406
Swift编译器可以
把你刚输入程序运行的


300
00:12:52,606 --> 00:12:54,041
代码添加进来


301
00:12:55,709 --> 00:12:56,844
如果喜欢打印...


302
00:12:57,211 --> 00:12:58,846
循环计数器 这就相当棒


303
00:12:59,446 --> 00:13:01,315
但是还有
要调试的内容


304
00:13:03,517 --> 00:13:06,086
Swift可以和
变量配合


305
00:13:07,721 --> 00:13:09,056
输入一些代码


306
00:13:10,724 --> 00:13:13,293
数组的内容就打印出来


307
00:13:14,628 --> 00:13:15,963
现在 这里的数组


308
00:13:16,363 --> 00:13:18,432
正好有一些
在程序中的代码


309
00:13:19,433 --> 00:13:21,969
LLDB安排在编译器上...


310
00:13:22,436 --> 00:13:23,403
显示数据 


311
00:13:23,637 --> 00:13:25,939
这样可以生成
你所需的代码


312
00:13:28,242 --> 00:13:31,445
我还想简单...介绍一下


313
00:13:31,745 --> 00:13:34,348
就是Swift怎么和SDK配合


314
00:13:35,415 --> 00:13:39,353
当你输入
NSApplication.sharedApplication


315
00:13:40,621 --> 00:13:41,588
这样的表达式时 


316
00:13:42,556 --> 00:13:44,024
首先 你会看到


317
00:13:44,091 --> 00:13:46,460
NSApplication.sharedApplication


318
00:13:46,527 --> 00:13:47,394
是按照预期的方式


319
00:13:48,395 --> 00:13:50,130
但是LLDB要去


320
00:13:50,697 --> 00:13:54,168
发现包括它的SDK模块


321
00:13:55,369 --> 00:13:56,970
让编译器可以访问它


322
00:13:57,571 --> 00:14:00,007
然后编译器找到
NSApplication


323
00:14:00,240 --> 00:14:02,543
并想出如何使用
sharedApplication


324
00:14:04,244 --> 00:14:05,078
这非常好


325
00:14:05,345 --> 00:14:06,780
而且都是在Swift中...


326
00:14:06,914 --> 00:14:07,748
自动完成


327
00:14:08,682 --> 00:14:09,983
在Objective-C


328
00:14:10,851 --> 00:14:11,919
它并非总是工作


329
00:14:13,887 --> 00:14:16,957
让我们在Objective-C
尝试所有这些


330
00:14:17,658 --> 00:14:20,928
有些人此刻可能有些担心


331
00:14:21,595 --> 00:14:24,831
因为你知道 
NSLog有时并不像


332
00:14:24,898 --> 00:14:26,934
调试器中那么简单


333
00:14:30,103 --> 00:14:32,539
过去 当输入NSLog时


334
00:14:32,773 --> 00:14:34,274
会看到像这样的错误提示:


335
00:14:34,341 --> 00:14:36,310
NS日志存在未知返回类型


336
00:14:38,045 --> 00:14:40,013
这是因为
在SDK肯定会


337
00:14:40,080 --> 00:14:41,715
存在NSLog的定义


338
00:14:42,115 --> 00:14:43,617
但是LLDB发现


339
00:14:43,750 --> 00:14:46,186
符号中只有调试信息中的内容


340
00:14:46,486 --> 00:14:48,188
在本例中
它看到一个符号


341
00:14:48,822 --> 00:14:51,291
这个符号 我们不知道
它的返回类型是什么


342
00:14:51,391 --> 00:14:53,660
我们甚至不知道
它还用了格式字符串


343
00:14:55,362 --> 00:14:57,164
好消息是
问题已经得到解决


344
00:14:58,131 --> 00:14:59,833
NSLog是按照
预期的方式工作


345
00:15:06,773 --> 00:15:11,545
我们再做些
更隐秘的内容


346
00:15:11,612 --> 00:15:13,080
打印NSMakeRect


347
00:15:13,514 --> 00:15:14,348
稍等！


348
00:15:14,414 --> 00:15:15,649
为什么是隐秘的内容呢？


349
00:15:15,716 --> 00:15:17,251
就在这里框架中


350
00:15:19,319 --> 00:15:23,090
可惜的是
看似标识符并不存在


351
00:15:23,757 --> 00:15:26,693
现在大家就会了解
如果使用NSLog


352
00:15:26,760 --> 00:15:28,328
可以转换结果


353
00:15:28,395 --> 00:15:29,263
对 可以这么用


354
00:15:30,097 --> 00:15:32,566
但是NSMakeRect
不能这么用


355
00:15:33,667 --> 00:15:34,635
这是因为


356
00:15:34,801 --> 00:15:37,604
NSMakeRect
是确定的NS-Inline


357
00:15:37,971 --> 00:15:39,373
没有符号


358
00:15:39,806 --> 00:15:42,276
LLDB什么也看不到


359
00:15:44,044 --> 00:15:44,878
不错


360
00:15:45,345 --> 00:15:47,014
没问题了


361
00:15:53,954 --> 00:15:55,656
还剩一个问题


362
00:15:56,790 --> 00:15:57,958
我们现在来看


363
00:15:58,725 --> 00:16:00,961
原先NSApplicationsh
aredApplication


364
00:16:01,028 --> 00:16:01,862
的情况


365
00:16:01,929 --> 00:16:03,463
当然 若你是自己运行
这个表达式


366
00:16:03,530 --> 00:16:05,465
当然会在Objective-C
中运行


367
00:16:05,532 --> 00:16:08,035
我们已经在为
Objective-C运行时间整合


368
00:16:08,101 --> 00:16:08,936
做了很多工作


369
00:16:09,436 --> 00:16:12,272
但是如果想找出
undo.Manager 


370
00:16:12,439 --> 00:16:14,608
你很快会发现运行时间
并未告诉你所有内容


371
00:16:15,242 --> 00:16:17,744
特别是你发现的这个
关于undo.Manager的


372
00:16:17,811 --> 00:16:21,548
奇怪错误提示
在类型id对象中并未发现


373
00:16:22,549 --> 00:16:23,817
是什么情况？


374
00:16:24,117 --> 00:16:24,952
在SDK肯定


375
00:16:25,018 --> 00:16:27,154
sharedApplication
会返回一个


376
00:16:27,221 --> 00:16:28,722
NSApplication星级


377
00:16:28,789 --> 00:16:30,724
但如果来看
运行时间


378
00:16:31,024 --> 00:16:32,693
返回的是id


379
00:16:33,060 --> 00:16:33,894
是个一般的


380
00:16:34,895 --> 00:16:36,563
Objective-C对象


381
00:16:38,966 --> 00:16:39,800
好消息


382
00:16:40,200 --> 00:16:41,568
这不再是问题了


383
00:16:41,935 --> 00:16:46,607
实际上 我们会看到
只能从SDK得到的信息


384
00:16:46,773 --> 00:16:48,942
例如
指针为可空值


385
00:16:49,076 --> 00:16:51,879
这就是SDK支持Swift的
最新功能


386
00:16:52,079 --> 00:16:54,515
也会进入
Objective-C


387
00:16:57,684 --> 00:17:00,187dle
不过信息就在这里


388
00:16:57,684 --> 00:17:00,187
不过信息就在这里


389
00:17:00,454 --> 00:17:02,723
这就是我们
所应用的理念


390
00:17:03,524 --> 00:17:05,692
从SDK直接读出


391
00:17:06,193 --> 00:17:08,494
代码会一直
在LLDB中运行


392
00:17:08,694 --> 00:17:13,433
我们了解本地变量
函数 自己的类


393
00:17:15,002 --> 00:17:17,171
SDK函数
另一方面


394
00:17:17,671 --> 00:17:19,540
我们还有更多
问题 如大家所见


395
00:17:21,241 --> 00:17:24,278
SDK类就像NSView
和NSApplication


396
00:17:24,344 --> 00:17:25,746
我们看到了 但是如你所见


397
00:17:25,811 --> 00:17:27,414
因为运行时间整合


398
00:17:28,015 --> 00:17:29,716
这里有个小星号


399
00:17:31,185 --> 00:17:33,153
现在SDK包括
如果你试着在表达式用过


400
00:17:33,220 --> 00:17:35,522
NSASCIIStringEnc
oding


401
00:17:35,822 --> 00:17:37,958
就会了解这永远不行


402
00:17:39,126 --> 00:17:42,229
如果使用宏 如int-max


403
00:17:42,429 --> 00:17:43,764
那么 max


404
00:17:43,830 --> 00:17:46,200
利用两个数字中最大值


405
00:17:46,600 --> 00:17:48,368
这样也不会奏效


406
00:17:50,537 --> 00:17:53,140
所有这些在
最新的LLDB中都已解决


407
00:18:00,280 --> 00:18:02,349
我们也删掉了烦人的星号


408
00:18:05,886 --> 00:18:10,057
大家可能会说那么
每月要付多少个39.95才能用上


409
00:18:10,190 --> 00:18:11,358
这个功能呢？


410
00:18:11,425 --> 00:18:13,093
好消息 这完全免费


411
00:18:13,160 --> 00:18:15,996
你只需要
@import AppKit即可


412
00:18:17,130 --> 00:18:18,966
运行一个表达式


413
00:18:19,032 --> 00:18:21,768
表明输入
我关心的框架


414
00:18:22,536 --> 00:18:24,571
如果用到AppKit 
或是在诸位中间的


415
00:18:24,638 --> 00:18:25,806
两三位...


416
00:18:26,273 --> 00:18:28,175
iOS程编写人员


417
00:18:28,242 --> 00:18:29,710
输入UIKit...


418
00:18:30,878 --> 00:18:32,112
就可以了


419
00:18:34,715 --> 00:18:35,549
现在


420
00:18:36,917 --> 00:18:38,986
我们并未将
Swift放在那里不管


421
00:18:40,153 --> 00:18:44,491
Swift2.0可实现
强大的错误处理支持


422
00:18:44,658 --> 00:18:48,529
LLDB马上就可以
支持the bat


423
00:18:48,862 --> 00:18:50,197
正如大家所期待的那样


424
00:18:52,999 --> 00:18:55,068
我们可以处理Swift错误


425
00:18:56,236 --> 00:18:58,205
当调用可能在


426
00:18:58,272 --> 00:19:00,507
表达式引发错误的函数时


427
00:19:00,574 --> 00:19:02,543
你不必调用"try"


428
00:19:03,410 --> 00:19:04,311
因为...


429
00:19:04,578 --> 00:19:07,047
我们为大家抓取内容


430
00:19:08,515 --> 00:19:09,550
如果你输入


431
00:19:10,083 --> 00:19:11,685
这个函数"throws"


432
00:19:12,019 --> 00:19:13,387
并把它交给表达式


433
00:19:13,453 --> 00:19:15,522
注意这和p指令
完全一样


434
00:19:16,657 --> 00:19:17,591
你会获得


435
00:19:18,225 --> 00:19:19,660
为你生成的...


436
00:19:19,993 --> 00:19:21,128
错误变量 


437
00:19:21,261 --> 00:19:23,797
其中包括函数引发的错误


438
00:19:26,233 --> 00:19:28,735
也可以在
REPL中...完成这些


439
00:19:30,571 --> 00:19:32,940
如果从REPL提示中
你做了同样的事情


440
00:19:34,575 --> 00:19:36,710
则会得到...错误变量


441
00:19:39,780 --> 00:19:42,649
我们再来看看
LLDB支持的...


442
00:19:43,183 --> 00:19:44,218
更多内容


443
00:19:45,352 --> 00:19:47,554
也就是说 你不希望
总是看到


444
00:19:47,621 --> 00:19:49,423
最后出现的是错误


445
00:19:49,923 --> 00:19:53,160
你需要了解
产生错误的代码是什么


446
00:19:54,561 --> 00:19:56,063
不过 在Objective-C中


447
00:19:56,129 --> 00:19:57,564
你用到了断点来完成


448
00:19:58,699 --> 00:20:02,202
具体而言你在Objective-C
异常中设置了断点


449
00:20:03,170 --> 00:20:04,505
方法是...


450
00:20:04,671 --> 00:20:06,807
你用了断点来设置指令


451
00:20:08,575 --> 00:20:11,178
确定了希望为...


452
00:20:12,012 --> 00:20:14,314
异常Objective-C...


453
00:20:15,115 --> 00:20:15,949
设置断点


454
00:20:16,650 --> 00:20:18,852
我们来为你设置了断点


455
00:20:19,119 --> 00:20:21,121
那么一旦Objective-C代码


456
00:20:21,655 --> 00:20:22,956
要引发异常


457
00:20:23,290 --> 00:20:24,124
我们就会停下来


458
00:20:25,192 --> 00:20:27,494
在Swift错误中
你可以做同样的事情


459
00:20:28,195 --> 00:20:30,764
只要用Swift
替代Objective-C 


460
00:20:31,498 --> 00:20:33,734
我们就会停止
程序要...


461
00:20:33,934 --> 00:20:34,968
引发的...


462
00:20:35,335 --> 00:20:36,403
Swift错误


463
00:20:37,471 --> 00:20:38,605
但是还可以...


464
00:20:39,006 --> 00:20:40,974
做另一件很酷的事


465
00:20:42,309 --> 00:20:45,646
你可以停止
具体的错误类型


466
00:20:46,647 --> 00:20:48,549
这是我们支持
Swift的一个功能


467
00:20:49,149 --> 00:20:51,151
这么做的方法很简单


468
00:20:51,218 --> 00:20:54,955
和你在设置表达式断点
非常相似


469
00:20:56,490 --> 00:20:58,825
可以使用短线O参数


470
00:20:59,459 --> 00:21:01,628
来明确你希望捕捉的


471
00:21:01,929 --> 00:21:03,497
错误类型名称


472
00:21:04,831 --> 00:21:09,303
如果这么做
那么只有在出现


473
00:21:10,003 --> 00:21:12,573
你感兴趣的错误类型时


474
00:21:13,006 --> 00:21:13,907
才会停下来


475
00:21:15,876 --> 00:21:16,844
最后


476
00:21:18,312 --> 00:21:19,213
当然


477
00:21:20,314 --> 00:21:22,883
你可以按照
正常代码中...


478
00:21:23,217 --> 00:21:24,785
的方法捕捉错误


479
00:21:24,852 --> 00:21:26,420
毕竟 部分而言


480
00:21:26,653 --> 00:21:30,757
REPL是指了解和发现语言
运行的方法


481
00:21:32,025 --> 00:21:33,794
如果输入Foundation


482
00:21:34,127 --> 00:21:35,395
来获取NSError


483
00:21:36,330 --> 00:21:39,533
然后编写会产生
NSError的代码


484
00:21:40,334 --> 00:21:43,704
就可以捕捉
NSError...并打印出来


485
00:21:45,439 --> 00:21:46,440
如果这么做


486
00:21:46,707 --> 00:21:48,675
结果就和你在自己的程序中


487
00:21:48,742 --> 00:21:50,577
捕捉的效果完全相同


488
00:21:52,613 --> 00:21:54,081
我希望大家...


489
00:21:54,548 --> 00:21:55,983
记住两点


490
00:21:56,116 --> 00:21:57,117
首先


491
00:21:57,684 --> 00:21:58,685
添加输入...


492
00:21:58,886 --> 00:21:59,853
自己的模块


493
00:22:00,754 --> 00:22:01,922
第二


494
00:22:02,422 --> 00:22:05,359
试着用LLDB进行错误处理


495
00:22:05,425 --> 00:22:06,560
这是个不错的办法


496
00:22:07,694 --> 00:22:09,863
要想了解更多详情


497
00:22:09,930 --> 00:22:12,132
不是说告诉程序该做什么


498
00:22:12,766 --> 00:22:17,304
而是如何在程序
产生资料完成后打印信息


499
00:22:17,905 --> 00:22:19,740
有请恩里科·格拉纳塔


500
00:22:22,709 --> 00:22:23,544
大家好


501
00:22:24,378 --> 00:22:26,246
上午我还在实验室


502
00:22:26,313 --> 00:22:29,082
我们在想办法
解决一个问题


503
00:22:29,816 --> 00:22:33,487
问题是...为什么
我看不到这个变量？


504
00:22:33,787 --> 00:22:34,955
出什么事了？


505
00:22:35,556 --> 00:22:38,125
为了帮助大家找到问题


506
00:22:38,525 --> 00:22:39,860
我们试了几个指令


507
00:22:39,927 --> 00:22:42,896
试了表达式 还有
PO 我们还试了帧变量


508
00:22:43,564 --> 00:22:46,166
此刻 人们通常会问


509
00:22:46,466 --> 00:22:49,570
为什么有那么多指令来做几乎
相同的事情？


510
00:22:49,636 --> 00:22:52,072
来看我的数据
看看程序中在发生什么


511
00:22:53,373 --> 00:22:56,443
大家来这里
就是了解内部消息的


512
00:22:56,710 --> 00:22:59,847
我们来看一下
LLDB让你看数据的指令


513
00:23:00,614 --> 00:23:02,482
共有三个


514
00:23:02,850 --> 00:23:03,884
帧变量


515
00:23:04,151 --> 00:23:05,485
表达式指令


516
00:23:05,886 --> 00:23:07,187
是个p指令


517
00:23:07,721 --> 00:23:09,790
表达式 
短线大写O


518
00:23:09,857 --> 00:23:10,691
这个...


519
00:23:10,757 --> 00:23:12,092
刚才讲过


520
00:23:12,292 --> 00:23:15,195
是作为PO指令


521
00:23:15,896 --> 00:23:16,730
首先


522
00:23:16,864 --> 00:23:18,165
帧变量指令


523
00:23:18,699 --> 00:23:22,402
帧变量指令
可以缩写为frv


524
00:23:22,469 --> 00:23:26,106
输入时 
基本是Xcode变量视图


525
00:23:26,607 --> 00:23:29,743
它让你...看所有的
本地变量


526
00:23:30,410 --> 00:23:31,612
让你看...


527
00:23:32,012 --> 00:23:33,947
几个本地变量


528
00:23:34,748 --> 00:23:36,083
此外


529
00:23:36,250 --> 00:23:37,951
也可以应用...


530
00:23:38,118 --> 00:23:40,454
带有短线 短线格式旗标的格式


531
00:23:41,755 --> 00:23:43,156
要强调的一点是


532
00:23:43,490 --> 00:23:44,925
因为在看到首次输出时


533
00:23:45,926 --> 00:23:48,729
有Tuple的话
我会回到这里


534
00:23:48,996 --> 00:23:49,830
这是个...


535
00:23:49,963 --> 00:23:50,864
聚合


536
00:23:51,098 --> 00:23:53,800
是包括其他对象的对象


537
00:23:54,134 --> 00:23:56,737
聚合当中的内容


538
00:23:57,004 --> 00:23:58,005
我们称之为...


539
00:23:58,572 --> 00:23:59,406
子对象


540
00:24:01,241 --> 00:24:02,609
这个表达式指令


541
00:24:03,577 --> 00:24:05,379
在本次会话中你会多次看到


542
00:24:05,479 --> 00:24:06,580
我会简要介绍一下


543
00:24:06,980 --> 00:24:07,814
当然


544
00:24:08,215 --> 00:24:09,283
有了表达式指令


545
00:24:09,349 --> 00:24:11,919
可以简单算一下
正如你猜测的一样


546
00:24:12,519 --> 00:24:16,223
完全可能...使用之前的结果


547
00:24:16,657 --> 00:24:19,259
并用它们
完成更多内容


548
00:24:20,327 --> 00:24:22,462
当然 表达式指令
也知道如何


549
00:24:22,529 --> 00:24:24,698
自定义结果的格式


550
00:24:25,732 --> 00:24:27,968
需要再次强调的一点是


551
00:24:28,836 --> 00:24:29,803
子对象


552
00:24:30,771 --> 00:24:31,839
第三个指令


553
00:24:32,339 --> 00:24:33,507
po指令


554
00:24:34,141 --> 00:24:38,345
这个可能是...在座各位
Objective-C开发员的指令


555
00:24:38,545 --> 00:24:40,914
我猜测
在Objective-C代码之前


556
00:24:41,315 --> 00:24:43,383
大家都知道是PO指令


557
00:24:43,784 --> 00:24:46,887
你可以生成对象
把说明打印出来


558
00:24:47,788 --> 00:24:50,991
可以生成NSArray
或打印现有的NSArray


559
00:24:51,058 --> 00:24:52,492
你就会看到其中的内容


560
00:24:53,060 --> 00:24:54,461
要知道


561
00:24:54,528 --> 00:24:56,763
对于字符串而言非常简单


562
00:24:57,698 --> 00:24:58,532
那么


563
00:24:58,599 --> 00:24:59,533
三条指令


564
00:24:59,900 --> 00:25:02,135
它们并非是完全一样的功能


565
00:25:02,202 --> 00:25:04,004
大家估计此刻也猜到了


566
00:25:04,705 --> 00:25:05,539
实际上


567
00:25:06,540 --> 00:25:07,941
它们只是有些相似


568
00:25:08,008 --> 00:25:09,209
但不是完全相同


569
00:25:09,409 --> 00:25:10,244
例如


570
00:25:10,811 --> 00:25:12,880
表达式指令和po指令


571
00:25:13,213 --> 00:25:15,749
是...
"run my code"指令


572
00:25:16,083 --> 00:25:17,551
无论代码类型是什么


573
00:25:17,618 --> 00:25:19,386
这些指令都会运行


574
00:25:20,888 --> 00:25:22,990
但是 接下来的
帧变量指令


575
00:25:23,056 --> 00:25:25,359
和表达式指令
第二步则不相同


576
00:25:25,726 --> 00:25:27,728
当它们不得不显示结果时


577
00:25:27,861 --> 00:25:30,230
会用到LLDB格式器系统


578
00:25:31,331 --> 00:25:34,301
我们在以往的WWDC
讲座中


579
00:25:34,368 --> 00:25:36,603
介绍过LLDB格式器系统


580
00:25:37,004 --> 00:25:38,672
大家应该都去找来看看


581
00:25:39,072 --> 00:25:40,240
不过简单而言


582
00:25:40,641 --> 00:25:43,744
LLDB掌握部分嵌入系统类型


583
00:25:43,944 --> 00:25:45,479
并对其自动格式化


584
00:25:45,779 --> 00:25:48,582
NSArray NSDictionaries
加字符串


585
00:25:49,116 --> 00:25:53,654
还可以提供...在Python中
编写的自己的格式


586
00:25:54,688 --> 00:25:55,789
另一方面


587
00:25:55,989 --> 00:25:58,392
po指令并不使用
LLDB格式器


588
00:25:58,659 --> 00:26:02,930
po指令在...后面
在幕后


589
00:26:03,130 --> 00:26:04,031
运行更多的代码


590
00:26:04,398 --> 00:26:05,832
实际上会生成为


591
00:26:05,899 --> 00:26:07,301
为你显示的真实结果


592
00:26:08,202 --> 00:26:10,537
你可能已经在
一个Objective-C类中


593
00:26:10,604 --> 00:26:12,272
至少编写了一个
说明方法


594
00:26:12,506 --> 00:26:15,275
然后意识到
这就是po打印的内容


595
00:26:16,276 --> 00:26:17,110
现在


596
00:26:17,444 --> 00:26:18,946
我希望大家想一想


597
00:26:19,213 --> 00:26:20,047
这两个模型


598
00:26:20,113 --> 00:26:23,217
实际上在用你的对象
并为之生产数据


599
00:26:24,151 --> 00:26:26,019
LLDB格式器模型


600
00:26:26,220 --> 00:26:27,688
我们称之为


601
00:26:27,955 --> 00:26:29,857
"out of process"
格式模型


602
00:26:29,923 --> 00:26:30,757
为什么呢


603
00:26:30,824 --> 00:26:33,694
因为格式器位于进程之外


604
00:26:33,961 --> 00:26:36,430
它或者将
内容构建到调试器中


605
00:26:36,830 --> 00:26:39,933
或者你用部分Python
脚本表现对象


606
00:26:40,267 --> 00:26:42,069
这是不同的语言
不同的文件


607
00:26:42,135 --> 00:26:43,904
存在于不同的作用域中


608
00:26:44,638 --> 00:26:45,672
另一方面


609
00:26:46,306 --> 00:26:48,742
外部格式器位于调试器中


610
00:26:48,976 --> 00:26:50,978
这就很容易...


611
00:26:51,178 --> 00:26:54,448
让他访问调试器所具备
程序的所有内容


612
00:26:54,748 --> 00:26:57,384
就像是可以鸟瞰所有进程


613
00:26:58,519 --> 00:27:02,189
因此 这类格式器
也可以很容易...


614
00:27:02,523 --> 00:27:05,225
确定程序状态并未改变


615
00:27:05,659 --> 00:27:08,028
你若是看到
调试器中的数据后


616
00:27:08,095 --> 00:27:10,397
不想改变程序状态


617
00:27:10,764 --> 00:27:12,699
调试器相当于是阶段...


618
00:27:13,033 --> 00:27:13,867
检测器


619
00:27:13,934 --> 00:27:16,103
它来看内容
并试图不做改变


620
00:27:17,671 --> 00:27:18,839
在另外的模型中


621
00:27:19,206 --> 00:27:20,240
po模型


622
00:27:20,374 --> 00:27:22,743
writeadescription
method模型


623
00:27:23,010 --> 00:27:25,212
是个进程格式模型


624
00:27:25,612 --> 00:27:28,415
你同时编写数据和格式器


625
00:27:28,682 --> 00:27:30,617
再用相同的语言
编写一遍


626
00:27:31,118 --> 00:27:33,754
可能甚至都在相同的
文件中编写


627
00:27:34,621 --> 00:27:36,757
因为格式器是在应用中


628
00:27:36,823 --> 00:27:38,625
运行的代码


629
00:27:38,692 --> 00:27:40,661
可以轻松并完全


630
00:27:40,727 --> 00:27:42,829
访问应用的对象模型


631
00:27:44,031 --> 00:27:45,999
但是功能更强大


632
00:27:46,200 --> 00:27:47,901
责任也更大


633
00:27:48,535 --> 00:27:51,071
需要确保格式器


634
00:27:51,138 --> 00:27:53,040
并没有改变程序的状态


635
00:27:53,540 --> 00:27:56,710
要确保并未在
格式器中...


636
00:27:56,910 --> 00:27:59,680
对准备表现的对象
做了任何改变


637
00:28:00,981 --> 00:28:03,750
那好 Objective-C


638
00:28:03,817 --> 00:28:05,319
具备进程进程格式模型


639
00:28:05,452 --> 00:28:06,787
我可以编写说明方式


640
00:28:06,854 --> 00:28:08,222
调试器会用到


641
00:28:08,789 --> 00:28:10,123
那Swift会怎样？


642
00:28:11,358 --> 00:28:13,827
结果是 演讲厅里
在座的各位


643
00:28:13,894 --> 00:28:15,195
又一次知道了内部消息


644
00:28:15,462 --> 00:28:18,398
从一开始Swift已有了


645
00:28:18,632 --> 00:28:20,000
进程格式模型


646
00:28:20,701 --> 00:28:21,535
但是 在哪儿呢？


647
00:28:21,602 --> 00:28:22,736
怎么用呢？


648
00:28:23,537 --> 00:28:26,673
希望大家
都用过Swift开发环境


649
00:28:27,107 --> 00:28:29,142
如果用过Swift开发环境


650
00:28:29,510 --> 00:28:32,145
那就用过进程格式模型


651
00:28:32,479 --> 00:28:34,147
从一开始它就在这里


652
00:28:35,849 --> 00:28:36,817
那有什么新奇的呢？


653
00:28:37,784 --> 00:28:41,355
现在 在Xcode 7
我们会采取完全相同的模型


654
00:28:41,788 --> 00:28:44,024
把它作为公共API


655
00:28:44,791 --> 00:28:46,560
大家可以使用它


656
00:28:47,694 --> 00:28:50,230
它仍然支持...开发环境


657
00:28:50,664 --> 00:28:54,034
不过现在也支持
LLDB po指令


658
00:28:54,501 --> 00:28:56,603
现在 你有着正确的
Swift格式器


659
00:28:56,670 --> 00:28:58,071
针对Swift对象


660
00:28:58,705 --> 00:28:59,540
怎么弄？


661
00:28:59,806 --> 00:29:01,608
我们来详细讲一下


662
00:29:02,476 --> 00:29:04,144
这个模型基于...


663
00:29:04,411 --> 00:29:05,746
4个协议


664
00:29:06,980 --> 00:29:08,348
这些是各自的名称


665
00:29:09,283 --> 00:29:11,718
对 我说是四个协议


666
00:29:12,085 --> 00:29:13,954
它们的名称相当长


667
00:29:14,621 --> 00:29:16,823
但是...我不会
过分担心


668
00:29:16,957 --> 00:29:20,127
可能是这个模型的可选项


669
00:29:20,360 --> 00:29:21,595
4个协议


670
00:29:21,662 --> 00:29:23,630
并非是指必须符合所有要求


671
00:29:23,964 --> 00:29:27,000
可以选择子集
来获得所需要的结果


672
00:29:27,167 --> 00:29:29,203
符合使用的协议部分


673
00:29:29,436 --> 00:29:30,571
就可以了


674
00:29:31,471 --> 00:29:32,639
我们来看一下协议


675
00:29:33,774 --> 00:29:35,809
CustomStringConvertible


676
00:29:35,876 --> 00:29:37,611
是协议名称


677
00:29:37,911 --> 00:29:39,046
表示...


678
00:29:39,613 --> 00:29:42,482
怎样把对象作为
字符串打印？


679
00:29:43,584 --> 00:29:45,419
它并未告知LLDB


680
00:29:45,719 --> 00:29:47,354
它还告知了Swift


681
00:29:47,855 --> 00:29:48,689
怎么弄？


682
00:29:48,755 --> 00:29:50,457
Swift打印功函数


683
00:29:50,824 --> 00:29:53,594
以及Swift字符串
插值功能


684
00:29:53,760 --> 00:29:56,697
二者都用了CustomString
Convertible协议


685
00:29:57,297 --> 00:29:58,465
非常好用


686
00:29:58,599 --> 00:30:00,133
实现这些很难吗？


687
00:30:01,602 --> 00:30:02,436
非常简单


688
00:30:02,836 --> 00:30:05,906
我有个数据结构
代表啤酒歌的瓶子


689
00:30:05,973 --> 00:30:08,041
因为我自己正在
准备bash脚本


690
00:30:08,408 --> 00:30:10,210
我想把歌词打印出来


691
00:30:10,878 --> 00:30:12,713
就生成了一个实例


692
00:30:12,779 --> 00:30:14,781
并看墙上有多少啤酒瓶


693
00:30:15,449 --> 00:30:17,451
但是要等到
app的...


694
00:30:17,784 --> 00:30:19,086
所有内容都没问题的时候


695
00:30:19,152 --> 00:30:21,255
如果我做调试
也许我需要更多信息


696
00:30:21,788 --> 00:30:25,092
那就需要Custom Debug
String Convertible


697
00:30:25,392 --> 00:30:28,729
这是调试器对这个对象的
具体表示


698
00:30:29,429 --> 00:30:31,598
调试器具体表示是什么


699
00:30:32,032 --> 00:30:33,834
则要取决你的app


700
00:30:33,901 --> 00:30:35,769
完全取决于对象
模型的语义


701
00:30:36,503 --> 00:30:37,571
但是作为提示


702
00:30:37,638 --> 00:30:39,206
debugPrint函数


703
00:30:39,506 --> 00:30:41,642
将默认选择这个协议


704
00:30:42,242 --> 00:30:43,143
当然


705
00:30:43,510 --> 00:30:45,345
打印和debugPrint 


706
00:30:45,412 --> 00:30:47,814
不会满足其他一致性要求


707
00:30:48,015 --> 00:30:49,683
如果它们的兴趣点不在此


708
00:30:50,484 --> 00:30:51,518
怎么运行呢？


709
00:30:51,885 --> 00:30:53,153
很简单


710
00:30:53,954 --> 00:30:55,923
我们把啤酒瓶进行扩展


711
00:30:56,423 --> 00:30:58,425
因为我们在做调试


712
00:30:58,492 --> 00:31:00,360
希望了解墙上啤酒瓶的更多信息


713
00:31:00,594 --> 00:31:03,230
这样我们可以确定啤酒类型
是否正确


714
00:31:03,463 --> 00:31:05,766
这就会成为不错的bash脚本
因为它们都很出色


715
00:31:06,967 --> 00:31:08,268
第三个协议


716
00:31:08,535 --> 00:31:11,205
是CustomPlayground
Quick Lookable


717
00:31:11,772 --> 00:31:13,106
正如名称所示


718
00:31:13,373 --> 00:31:16,376
这个协议是主要
为环境而定


719
00:31:16,977 --> 00:31:20,747
是指为环境中的
对象提供


720
00:31:20,814 --> 00:31:22,916
丰富的图形表示


721
00:31:23,717 --> 00:31:24,651
想要看举例吗？


722
00:31:24,718 --> 00:31:26,019
当然有


723
00:31:26,787 --> 00:31:29,823
我可以编写代表一个人的
数据结构


724
00:31:30,157 --> 00:31:32,259
然后我可以获得
一个人的描述


725
00:31:32,326 --> 00:31:34,394
在环境的侧边工具栏显示


726
00:31:34,695 --> 00:31:36,930
以此作为生成这个类型
对象的结果


727
00:31:38,899 --> 00:31:41,068
不好意思
让你们失望了


728
00:31:41,134 --> 00:31:42,870
我的确想做成的


729
00:31:43,136 --> 00:31:45,706
但是 大会上不会销售


730
00:31:45,772 --> 00:31:48,008
带有人像的T恤衫


731
00:31:48,342 --> 00:31:49,376
不好意思


732
00:31:50,244 --> 00:31:52,379
不过 我有个弥补的办法


733
00:31:52,679 --> 00:31:54,181
其中最后的协议


734
00:31:54,481 --> 00:31:56,416
Custom
Reflectable协议


735
00:31:56,483 --> 00:31:58,619
它可以让我
生成完全自定义的


736
00:31:58,685 --> 00:31:59,786dle
子对象层次


737
00:32:00,087 --> 00:32:03,056
好 我说过 我会回到
"children"这里 说到做到


738
00:32:04,024 --> 00:32:07,227
当我说到完全自定义
子对象层次时


739
00:32:08,262 --> 00:32:09,730
我是说


740
00:32:10,364 --> 00:32:12,199
我可以
做个新的...


741
00:32:12,266 --> 00:32:14,801
我可以为对象
制作新的结构


742
00:32:15,135 --> 00:32:17,204
可以告知语言
可以告知调试器


743
00:32:17,271 --> 00:32:18,338
可以告知环境


744
00:32:18,639 --> 00:32:20,774
我的对象实际上是用什么来造的


745
00:32:20,874 --> 00:32:22,109
大家会看到


746
00:32:22,576 --> 00:32:24,044
你做此事的方法


747
00:32:24,311 --> 00:32:26,580
交易用的货币


748
00:32:26,880 --> 00:32:30,083
在想要对Swift描述
对象的结构时 


749
00:32:30,417 --> 00:32:31,251
被称为


750
00:32:31,451 --> 00:32:32,386
Mirror


751
00:32:32,486 --> 00:32:33,487
可反射的镜像


752
00:32:35,222 --> 00:32:37,925
我们来看个例子
不要费时费事


753
00:32:38,525 --> 00:32:40,727
我有个应用用来


754
00:32:40,827 --> 00:32:42,996
搜集温度样本


755
00:32:43,864 --> 00:32:45,199
它有两个数据结构


756
00:32:45,699 --> 00:32:46,934
一个用来描述


757
00:32:47,267 --> 00:32:48,435
此刻的时间


758
00:32:48,735 --> 00:32:51,205
它说在给定的时刻


759
00:32:51,538 --> 00:32:53,507
这就是我得到的温度信息


760
00:32:54,508 --> 00:32:56,543
接着当然我们
获得温度样本


761
00:32:57,244 --> 00:32:58,745
现在我来调试app


762
00:32:59,079 --> 00:33:00,781
我想看看是什么情况


763
00:33:00,848 --> 00:33:02,249
怎么来处理样本


764
00:33:02,683 --> 00:33:03,584
所以我提出


765
00:33:04,251 --> 00:33:05,485
po温度


766
00:33:06,587 --> 00:33:07,654
我得到的是这个


767
00:33:08,856 --> 00:33:11,792
实话讲 我看着它
觉得


768
00:33:12,025 --> 00:33:13,894
作为默认值还不错


769
00:33:14,394 --> 00:33:17,297
不过 我立刻发现
我想调整两个问题


770
00:33:17,931 --> 00:33:20,133
为什么在把时间堆在两行？


771
00:33:20,200 --> 00:33:22,469
我想把所有内容
都放在一行


772
00:33:22,836 --> 00:33:24,538
而且如果是用a.m.
p.m.格式


773
00:33:24,605 --> 00:33:25,939
表示上下午最好


774
00:33:26,573 --> 00:33:28,375
还有温度


775
00:33:28,809 --> 00:33:29,943
我看着它 觉得


776
00:33:30,043 --> 00:33:31,678
标度是什么呢？


777
00:33:31,745 --> 00:33:32,579
我不知道


778
00:33:32,679 --> 00:33:35,816
是开氏
列氏还是兰氏温标？


779
00:33:36,016 --> 00:33:39,486
我们在美国想用的是华氏温度


780
00:33:42,022 --> 00:33:45,192
好消息是
我们可以用两步骤


781
00:33:45,859 --> 00:33:47,628
解决所有这些问题


782
00:33:48,328 --> 00:33:49,162
开始


783
00:33:49,630 --> 00:33:52,633
第一步 我们把
时间按照一行打印


784
00:33:54,301 --> 00:33:56,870
我做了这些
来实现这一点


785
00:33:57,171 --> 00:33:59,206
用了NSDate格式器


786
00:34:00,741 --> 00:34:03,911
因为我要在...
自己的应用中运行


787
00:34:04,178 --> 00:34:07,114
因为我运行的对象格式代码


788
00:34:07,514 --> 00:34:09,783
实际就是
正常的Swift代码


789
00:34:09,983 --> 00:34:12,553
就是我通常编写app


790
00:34:12,853 --> 00:34:14,087
所用的代码不论是什么框架


791
00:34:14,288 --> 00:34:15,121
什么库


792
00:34:15,389 --> 00:34:18,859
还是我的app完成任务
通常所用的技术


793
00:34:19,359 --> 00:34:21,428
我在格式器中用就好了


794
00:34:21,862 --> 00:34:23,797
在本例中 是NSDate格式器


795
00:34:24,931 --> 00:34:25,866
第二步


796
00:34:26,400 --> 00:34:28,569
选用华氏温度


797
00:34:29,837 --> 00:34:31,038
怎么实现？


798
00:34:31,705 --> 00:34:33,172
我们生成镜像


799
00:34:33,639 --> 00:34:34,507
好了


800
00:34:34,875 --> 00:34:38,045
现在我们可以说
温度数据对象


801
00:34:38,110 --> 00:34:41,815
是作为包括三项内容
来构建


802
00:34:42,248 --> 00:34:44,251
时间 摄氏温度


803
00:34:44,318 --> 00:34:45,585
以及华氏温度


804
00:34:46,219 --> 00:34:48,722
时间是存储在
对象内部的


805
00:34:48,922 --> 00:34:51,757
真实时间数据的
字符串插值


806
00:34:52,659 --> 00:34:54,828
因为是用字符串插值


807
00:34:54,895 --> 00:34:57,931
因为我们提供了
自定义字符串可转换一致性


808
00:34:58,398 --> 00:35:00,567
这些可以自动提取


809
00:35:01,835 --> 00:35:03,837
这里还要
注意的一点是


810
00:35:04,304 --> 00:35:08,108
当我获得两种温标
用摄氏度


811
00:35:08,175 --> 00:35:10,677
和华氏度
来进行结果打印


812
00:35:11,278 --> 00:35:14,114
我不能改变
存储在对象内的数值


813
00:35:14,715 --> 00:35:16,016
当然 你会说 不要改


814
00:35:17,050 --> 00:35:19,520
实际上 
要注意的是


815
00:35:19,686 --> 00:35:21,522
不要用编写
进程格式器的


816
00:35:21,588 --> 00:35:23,557
方法改变程序的状态


817
00:35:24,892 --> 00:35:27,661
现在我们做了这么些工作
得到了这些东西


818
00:35:28,662 --> 00:35:30,697
会怎样从中受益呢？


819
00:35:31,732 --> 00:35:33,967
我们可以试着再做po


820
00:35:35,702 --> 00:35:36,970
来吧


821
00:35:37,337 --> 00:35:38,705
现在我再来看


822
00:35:38,772 --> 00:35:39,673
我看到了对象


823
00:35:40,174 --> 00:35:42,109
可以看到现在是


824
00:35:42,176 --> 00:35:44,444
6:30 p.m.


825
00:35:44,711 --> 00:35:47,047
是93.2度


826
00:35:49,049 --> 00:35:50,951
大家可能会奇怪 的确


827
00:35:51,018 --> 00:35:52,753
昨天库柏蒂诺是很热


828
00:35:54,821 --> 00:35:58,125
现在我们完成了
但是这么做


829
00:35:58,192 --> 00:35:59,927
是因为我们很聪明
提前完成了工作


830
00:36:00,594 --> 00:36:03,497
有时 我会试着
调试一些内容


831
00:36:04,631 --> 00:36:07,167
把自己的程序调试到位


832
00:36:07,367 --> 00:36:09,803
结果有这样一个
很难复制的问题


833
00:36:10,003 --> 00:36:11,505
最后发生了


834
00:36:12,406 --> 00:36:15,008
不过现在真的
很难找到这数据


835
00:36:15,309 --> 00:36:17,211
数据非常令人头痛
非常很复杂


836
00:36:17,277 --> 00:36:20,414
真希望自己
之前做过这事儿


837
00:36:20,480 --> 00:36:23,217
这样我就可以更简单地
看待我的数据了


838
00:36:24,051 --> 00:36:25,352
不过 可惜没有


839
00:36:26,186 --> 00:36:27,588
所有的希望都落空


840
00:36:28,622 --> 00:36:30,424
不 没有


841
00:36:30,691 --> 00:36:33,427
还可以添加一致性
和运行时间


842
00:36:33,493 --> 00:36:36,663
通过表达式剖析器 
可以添加这些一致性


843
00:36:36,897 --> 00:36:38,866
并运转 同时调试你的app


844
00:36:39,867 --> 00:36:40,701
另一方面


845
00:36:41,401 --> 00:36:42,870
你还不能改变它们


846
00:36:43,237 --> 00:36:45,239
现有的一致性保留


847
00:36:47,207 --> 00:36:49,476
你在REPL做尝试


848
00:36:50,010 --> 00:36:51,945
你真希望自己能做po


849
00:36:52,179 --> 00:36:54,248
我希望自己能
添加一致性


850
00:36:55,315 --> 00:36:57,017
在REPL中也可以这么做


851
00:36:58,986 --> 00:37:02,089
当然 但是我确定
大家都期望这样


852
00:37:02,523 --> 00:37:03,357
为什么？


853
00:37:04,091 --> 00:37:05,759
在环境中 也是如此


854
00:37:07,160 --> 00:37:08,428
来看


855
00:37:11,298 --> 00:37:12,699
看似...


856
00:37:13,967 --> 00:37:15,836
我们在过去一年
在调试器方面


857
00:37:15,903 --> 00:37:17,371
所做了许多动作


858
00:37:17,604 --> 00:37:20,541
你们从凯特 西恩和我这里听到的


859
00:37:20,974 --> 00:37:26,713
这些都离不开要在调试的同时
确保能够轻松访问


860
00:37:26,780 --> 00:37:28,815
尽可能多的相关信息


861
00:37:30,284 --> 00:37:32,219
访问Objective-C
运行时间


862
00:37:32,352 --> 00:37:36,156
会让你在域无法获取之前
对之有更多了解


863
00:37:37,124 --> 00:37:38,659
SDK模块


864
00:37:39,026 --> 00:37:44,698
为应用所运行的操作环境


865
00:37:44,765 --> 00:37:47,201
更多类型 更多函数
甚至有宏观


866
00:37:47,367 --> 00:37:48,669
提供了
前所未有的访问程度


867
00:37:49,203 --> 00:37:51,471
还有进程格式


868
00:37:52,739 --> 00:37:55,175
进程格式是用来生成


869
00:37:55,242 --> 00:37:58,879
跨界应用类型的
编译表示的


870
00:37:59,112 --> 00:38:00,848e
极好方法


871
00:37:59,112 --> 00:38:00,848
极好方法


872
00:38:01,181 --> 00:38:03,750
它们可以应用在环境中
在REPL中


873
00:38:03,817 --> 00:38:05,352
也可以是在调试器中


874
00:38:06,620 --> 00:38:08,355
若要了解更多详情


875
00:38:08,755 --> 00:38:09,590
可以随时


876
00:38:09,656 --> 00:38:12,392
浏览我们的网站
Swift语言文件


877
00:38:12,492 --> 00:38:14,928
或开发人员论坛
当然还有实验室


878
00:38:14,995 --> 00:38:17,798
还可以给开发顾问
斯特凡发邮件


879
00:38:19,366 --> 00:38:22,402
非常感谢
希望大家喜欢WWDC

