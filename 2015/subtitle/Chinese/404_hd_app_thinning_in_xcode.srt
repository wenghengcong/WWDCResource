1
00:00:20,754 --> 00:00:23,524
Xcode的app切割


2
00:00:24,191 --> 00:00:26,460
早上好 我是安德斯


3
00:00:26,793 --> 00:00:30,531
欢迎你们来参加404会议
Xcode的app切割


4
00:00:32,533 --> 00:00:35,602
APP切割在这个舞台上已经多次提及


5
00:00:35,769 --> 00:00:40,107
但从你们昨天
提出的问题和问题数量看来


6
00:00:40,174 --> 00:00:41,842
很多人深感兴趣并且仍有疑问


7
00:00:42,509 --> 00:00:45,379
所以在这个会议上我们会讲的更详细些


8
00:00:45,946 --> 00:00:48,081
尤其是关于


9
00:00:48,148 --> 00:00:52,319
当今
APP切割如何影响APP传播途径


10
00:00:52,553 --> 00:00:54,788
我们会看看其工作原理以及改善


11
00:00:56,123 --> 00:00:57,090
我们会讨论


12
00:00:57,157 --> 00:01:01,161
如何进行高效的APP切割


13
00:01:01,628 --> 00:01:03,697
减少内存占用率


14
00:01:05,632 --> 00:01:06,667
然后我们要讨论


15
00:01:06,733 --> 00:01:08,135
这对你工作流程的意义


16
00:01:08,302 --> 00:01:11,772
当你在开发和测试应用以及
提交到App Store等过程中


17
00:01:13,941 --> 00:01:15,442
现在我们快速浏览一下


18
00:01:15,509 --> 00:01:17,044
当前的APP是如何传播的


19
00:01:17,744 --> 00:01:20,314
你会使用
Xcode开发iOS系统app


20
00:01:21,281 --> 00:01:23,951
然后测试并提交应用商店


21
00:01:25,252 --> 00:01:26,186
当你提交时 


22
00:01:26,253 --> 00:01:30,157
App会被标记上开发者证书


23
00:01:31,024 --> 00:01:35,229
在经过检验后
App Store会重新证书标记


24
00:01:35,562 --> 00:01:37,531
然后上架以供下载


25
00:01:40,234 --> 00:01:43,604
然后有一台设备下载了你的App


26
00:01:43,670 --> 00:01:47,541
这样设备就获得了你上传的的App


27
00:01:47,875 --> 00:01:49,409
现在我们来看看里面的内容


28
00:01:50,644 --> 00:01:52,579
首先 这是你的执行代码


29
00:01:53,180 --> 00:01:56,383
这里有很多资源
几乎所有的东西都罗列在内


30
00:01:58,218 --> 00:02:01,221
有些App代码很繁重 很多


31
00:02:01,288 --> 00:02:02,923
资源也比较少


32
00:02:03,423 --> 00:02:06,226
有些则正好相反 媒体文件较多


33
00:02:06,293 --> 00:02:08,529
大部分是资源


34
00:02:09,596 --> 00:02:11,598
我们举一个例子看一看


35
00:02:14,067 --> 00:02:19,373
现在代码基本上
有两种版本64位或32位


36
00:02:19,439 --> 00:02:21,508
实际上 还可能是RMV7


37
00:02:21,675 --> 00:02:24,478
也包括NRV64切片


38
00:02:24,745 --> 00:02:29,416
为了在
Apple硬件上运作良好RMV7


39
00:02:31,485 --> 00:02:34,021
当然 资源中如果有图像的话


40
00:02:34,087 --> 00:02:38,625
你会使用
1X 2X 3X或Retina


41
00:02:38,859 --> 00:02:41,361
以使图像在各类设备上运行良好


42
00:02:44,198 --> 00:02:46,300
你也许会想对图像进行一部分区分


43
00:02:46,466 --> 00:02:48,468
分为适用iPhone的 


44
00:02:48,669 --> 00:02:50,003
和适用iPad的


45
00:02:52,105 --> 00:02:56,543
如果是
游戏app或者是3D图像型APP 


46
00:02:56,910 --> 00:03:00,714
那么1X和2X在处理文本压缩和


47
00:03:00,781 --> 00:03:04,451
文字模块方面并无太大意义


48
00:03:06,286 --> 00:03:09,957
事实上 如果想利用
OpenGL AS和Metal语言


49
00:03:10,023 --> 00:03:12,759
那么可能需要不同类型的资源纹理


50
00:03:12,960 --> 00:03:14,695
而且还进行进一步的区分


51
00:03:14,761 --> 00:03:16,496
优质和劣质文件


52
00:03:16,630 --> 00:03:20,300
这样都能让设备在
不同内存大小上良好地运行


53
00:03:20,367 --> 00:03:24,438
在任何设备上运行
取决于内存大小的图像清晰度


54
00:03:25,506 --> 00:03:26,907
可能你还有声频资料


55
00:03:27,307 --> 00:03:29,710
所以你还可能需要根据比特率进行区分


56
00:03:31,411 --> 00:03:35,482
当然还有其他数据 像是游戏等级


57
00:03:35,782 --> 00:03:38,452
又或者你的app需要认证文件


58
00:03:38,519 --> 00:03:40,554
可能有些模板及其他一些信息


59
00:03:40,988 --> 00:03:45,259
无法让设备进行区分
所有设备上都可能发生这种事


60
00:03:47,027 --> 00:03:49,596
实际上
现在很多App都有所有类型的数据


61
00:03:49,930 --> 00:03:54,301
所以你可能要费力进行归类


62
00:03:54,368 --> 00:03:57,137
做好备注


63
00:03:57,304 --> 00:03:59,640
这样相应资料才能安装在相应的设备上


64
00:04:01,008 --> 00:04:04,311
这再好不过
这实际上就是APP切割的优势所在


65
00:04:05,145 --> 00:04:06,747
如果你有一个iPad Mini


66
00:04:07,714 --> 00:04:11,018
当它运行的时候 会运行RMV7切割


67
00:04:11,285 --> 00:04:13,654
iPad等设备也是如此


68
00:04:14,688 --> 00:04:17,457
另外APP切割所做的就是


69
00:04:17,524 --> 00:04:20,527
在运行时决定加载资料


70
00:04:20,928 --> 00:04:22,296
放到Store的资料


71
00:04:22,896 --> 00:04:25,666
设备上的内容就是保存到设备上


72
00:04:26,033 --> 00:04:30,470
始终保存在设备上
虽然不会在iPad1上下载


73
00:04:30,537 --> 00:04:34,942
所以RM 64切割
无法在ipad Mini上使用


74
00:04:35,542 --> 00:04:38,345
那么 
为什么要全部上传到Store中呢？


75
00:04:40,247 --> 00:04:41,982
在App Store上


76
00:04:42,416 --> 00:04:45,953
我们将为ipad
Mini预构建一个定制版本 


77
00:04:47,688 --> 00:04:50,657
iPhone 6+也是如此


78
00:04:50,724 --> 00:04:53,927
这时候 我们使用3X art
work RM 64等


79
00:04:54,428 --> 00:04:55,362
此类的工具


80
00:04:55,796 --> 00:04:57,264
值得注意的是


81
00:04:57,331 --> 00:05:02,903
你仍会上传包括各种原图变体


82
00:05:02,970 --> 00:05:05,439
和其他资源的通用APP  


83
00:05:05,772 --> 00:05:08,609
于是在App Store里


84
00:05:08,675 --> 00:05:09,977
切割就会发生


85
00:05:11,445 --> 00:05:14,147
实际上 App Store的作用是


86
00:05:14,214 --> 00:05:18,752
查看你的App能够支持的不同设备
即使不同设备特性


87
00:05:19,253 --> 00:05:21,788
然后再查看App中的实际内容


88
00:05:21,889 --> 00:05:25,692
以及你如何
使用1X 2X等工具进行标注


89
00:05:25,759 --> 00:05:30,163
然后Store
会预制并分离被下载的IPA


90
00:05:30,230 --> 00:05:33,267
我们来看一个已经看过的例子


91
00:05:33,500 --> 00:05:36,570
这是个演示箱 曾在美国展示过


92
00:05:37,938 --> 00:05:39,673
在这个例子中 我们有一个App


93
00:05:40,440 --> 00:05:42,309
74兆字节的通用APP


94
00:05:42,743 --> 00:05:46,513
适用于所有架构和设备


95
00:05:47,214 --> 00:05:50,717
通过切割 我们得到16至29兆字节


96
00:05:51,084 --> 00:05:55,789
平均在22兆字节的文件


97
00:05:56,156 --> 00:05:58,625
我们在这款App上运行切割


98
00:05:58,892 --> 00:06:00,861
实际上 其中产生了19种变量


99
00:06:00,928 --> 00:06:02,963
包括不同的特性组合


100
00:06:03,330 --> 00:06:07,634
这一些都在后台自动进行


101
00:06:07,701 --> 00:06:10,771
而你只需对app内容进行标注即可


102
00:06:12,573 --> 00:06:14,408
这是第一级保存 实在酷


103
00:06:14,675 --> 00:06:16,410
但是 有改善的空间吗？


104
00:06:16,476 --> 00:06:18,245
当然了 有


105
00:06:18,946 --> 00:06:23,517
设备上有些资料是我们一直使用到的


106
00:06:23,584 --> 00:06:24,952
首先 代码


107
00:06:25,352 --> 00:06:29,489
那里可能会有一些原图比如故事板
当你启动你的应用程序


108
00:06:30,090 --> 00:06:32,693
或者将原图添加到主菜单


109
00:06:32,759 --> 00:06:34,428
让我们假设
你需要不断使用这些原图


110
00:06:35,729 --> 00:06:38,198
然后还有其它这些东西  


111
00:06:38,265 --> 00:06:41,502
这个应用程序之后会需要用到
但现在不需要用到


112
00:06:41,568 --> 00:06:45,506
你之前听过的一个典型例子
比如游戏的第19级


113
00:06:46,106 --> 00:06:49,676
正在玩游戏第一级的用户
还不需要19级的资料


114
00:06:50,544 --> 00:06:51,945
同样地 还有其它例子


115
00:06:52,012 --> 00:06:53,747
如果App是文件类应用


116
00:06:53,814 --> 00:06:55,482
那么媒体模板就会比较丰富


117
00:06:55,816 --> 00:06:58,585
你可能会想把这些推向市场


118
00:06:58,785 --> 00:07:02,422
为了提供丰富的体验
你可能要有很多的模板


119
00:07:02,589 --> 00:07:05,826
但是它们可能会占用很多空间
你可能会根据需要进行下载


120
00:07:06,560 --> 00:07:09,496
对于音频工具也是这样的或者此类的


121
00:07:11,265 --> 00:07:13,467
很好的示范例子是


122
00:07:13,534 --> 00:07:16,069
许多用户看过一次就不再想让文件


123
00:07:16,136 --> 00:07:17,371
占用设备的空间


124
00:07:18,739 --> 00:07:22,009
如果我们看看我们以前讨论过的


125
00:07:22,342 --> 00:07:24,478
应用切割其实应用已经进行简化了


126
00:07:24,545 --> 00:07:26,246
因而只剩下一个结构


127
00:07:26,313 --> 00:07:31,785
以及一种资源类型的质量变体


128
00:07:33,820 --> 00:07:37,090
下一等级划分 我们可以做的只有


129
00:07:37,157 --> 00:07:41,728
在了解应用程序的特定区域后才能执行


130
00:07:41,862 --> 00:07:44,531
就是基于给定的时间所需要的资料


131
00:07:44,731 --> 00:07:46,700
因为这些是基于你的代码逻辑


132
00:07:47,434 --> 00:07:51,405
因此在这个例子中我们有图像


133
00:07:51,705 --> 00:07:53,607
Metal着色器诸如此类的


134
00:07:54,007 --> 00:07:56,043
我们可以把这些分为共享的


135
00:07:56,310 --> 00:07:59,446
以及归入到
应用程序本身时刻所必须的一类


136
00:07:59,880 --> 00:08:02,850
我们可以按需选择


137
00:08:03,951 --> 00:08:05,319
通过划分


138
00:08:06,386 --> 00:08:09,156
实际上你就可以减小


139
00:08:09,223 --> 00:08:12,259
应用程序占用的基础空间
这样就可以保存更多文件


140
00:08:13,427 --> 00:08:17,264
在这种特定的情况下
使用Xcode建立的


141
00:08:17,331 --> 00:08:20,634
标记资源包就会被清除


142
00:08:20,801 --> 00:08:23,904
保存到App Store中的IPA


143
00:08:24,972 --> 00:08:27,007
你可以根据需要进行下载


144
00:08:27,608 --> 00:08:29,409
你可以指定其中的一部分


145
00:08:29,476 --> 00:08:32,078
作为初始下载 当用户下载展示的


146
00:08:32,145 --> 00:08:34,347
应用程序并在进度条达到百分之百之后


147
00:08:34,982 --> 00:08:37,251
应用程序就准备就绪了


148
00:08:37,351 --> 00:08:39,152
App已经有了一些初始内容


149
00:08:40,453 --> 00:08:44,324
你可以根据需要下载更多的内容


150
00:08:44,558 --> 00:08:48,195
这已经不是存储在设备上应用程序包里


151
00:08:48,262 --> 00:08:51,698
也不会备份到iCloud存储空间里


152
00:08:51,765 --> 00:08:55,335
而是存储在系统内存中


153
00:08:55,936 --> 00:08:58,505
系统可以进行高速缓存资源


154
00:08:58,572 --> 00:09:00,908
并按需加载资源


155
00:09:02,242 --> 00:09:03,310
因此在这种情况下


156
00:09:03,377 --> 00:09:06,613
假如你在这个场景中
实际上我们会有更多的空间


157
00:09:06,680 --> 00:09:08,348
而不仅只有三个等级的空间


158
00:09:08,415 --> 00:09:10,617
我们可以有更多的等级空间


159
00:09:10,684 --> 00:09:12,419
假如你不使用按需加载资源的话


160
00:09:12,553 --> 00:09:16,156
当我们来到第四级系统会自动清理


161
00:09:16,223 --> 00:09:21,128
最近使用过的资源包包括你的第一级资
源


162
00:09:21,695 --> 00:09:22,696
对于第五级同样如此


163
00:09:24,164 --> 00:09:26,733
如果用户有段时间没使用你的应用程序


164
00:09:26,867 --> 00:09:29,670
以及其它需要下载需加载资源的App


165
00:09:30,037 --> 00:09:31,405
则可进行空间回收


166
00:09:31,471 --> 00:09:32,873
当应用程序再次被使用时


167
00:09:32,940 --> 00:09:34,141
则再次自动下载


168
00:09:36,076 --> 00:09:38,979
说说一些关于 按需加载资源的事


169
00:09:39,546 --> 00:09:43,116
你通过
在Xcode中标记资源建立资源包


170
00:09:43,183 --> 00:09:47,421
昨天你观看了一个简短演示


171
00:09:47,788 --> 00:09:51,425
今天晚一点的时候
将会有一整个环节说明按需加载资源


172
00:09:53,594 --> 00:09:56,897
资源包可以包含任何不可执行资源


173
00:09:57,664 --> 00:10:00,767
应用切割在在资源类型下


174
00:10:00,834 --> 00:10:02,236
资源目录起作用


175
00:10:02,302 --> 00:10:05,305
通过按需加载资源
你可以下载任何的松散文件并标记它们


176
00:10:05,372 --> 00:10:07,941
它们会成为资源包一部分
然后从App Store中下载


177
00:10:08,008 --> 00:10:09,676
它们存储在App Store中


178
00:10:10,043 --> 00:10:12,579
你把
它们一起提交到App Store


179
00:10:12,646 --> 00:10:16,416
作为IPA的一部分
但是App Store会把它们分开


180
00:10:17,217 --> 00:10:18,318
并单独存储


181
00:10:19,653 --> 00:10:22,856
它们会根据代码在需要时被下载


182
00:10:23,257 --> 00:10:24,992
它们作为必需品被回收


183
00:10:26,326 --> 00:10:29,229
它们就像其它内容一样被切割


184
00:10:29,763 --> 00:10:32,366
因此你可以把资源包放在这里


185
00:10:32,432 --> 00:10:36,436
实际上 如果你在资源包里标记资源


186
00:10:36,503 --> 00:10:39,907
Xcode会自动为你建立


187
00:10:41,208 --> 00:10:42,376
在资源目录里面


188
00:10:45,078 --> 00:10:47,247
我们来看下储存大小


189
00:10:47,314 --> 00:10:51,618
对了 今天下午4：30分


190
00:10:51,685 --> 00:10:53,320
在太平洋大厦会有一个会议


191
00:10:54,788 --> 00:10:58,192
让我们看看 我们得到什么种类的储存
程序片切割后


192
00:10:58,525 --> 00:11:02,663
我们得到的程序片平均为22兆字节


193
00:11:03,397 --> 00:11:04,531
在这种情况下 


194
00:11:04,598 --> 00:11:09,670
我们得根据核心app
下载5-11兆字节的内容


195
00:11:10,103 --> 00:11:13,173
而资源本身则是11-18兆字节


196
00:11:13,240 --> 00:11:16,476
关键是并非所有文件


197
00:11:16,543 --> 00:11:18,312
同时存在在设备中


198
00:11:19,046 --> 00:11:21,748
所以总量大约有8兆字节


199
00:11:21,815 --> 00:11:23,217
这是一个非常精简的app


200
00:11:23,283 --> 00:11:27,387
但你可以看到它是一个巨大的运用程序
尤其是它有大量媒体资源文件


201
00:11:27,888 --> 00:11:30,424
更精简app的就会很有帮助


202
00:11:32,593 --> 00:11:36,496
更小的APP更好的使用体验


203
00:11:36,930 --> 00:11:40,934
有些设备有8GB的空间


204
00:11:41,001 --> 00:11:45,405
我们会小心使用这些空间
没必要用的东西不会占用你的设备容量


205
00:11:46,940 --> 00:11:51,645
通过app简化设备就可支持更多应用


206
00:11:52,713 --> 00:11:57,417
更棒的是这同时也意味着
更短的下载用时 更少的电线传送


207
00:11:57,918 --> 00:12:01,822
更不容易超过100MB的限制


208
00:12:03,924 --> 00:12:04,892
这使你下载的应用


209
00:12:05,993 --> 00:12:08,128
这意味着你可以使用


210
00:12:08,428 --> 00:12:11,098
更多类型的设备而不受太多限制


211
00:12:11,164 --> 00:12:14,434
如果你一直很想使用那种


212
00:12:14,501 --> 00:12:17,337
不但可以在大功率设备上运行地很好


213
00:12:17,938 --> 00:12:20,707
而且也可以
在低能耗设备上使用的Metal 


214
00:12:20,774 --> 00:12:24,178
有更好的用户体验 那该怎么做呢 


215
00:12:24,244 --> 00:12:26,480
下面这个能使你克服其中一些限制


216
00:12:26,547 --> 00:12:28,015
你可以现在就提交 


217
00:12:28,081 --> 00:12:33,787
提交到Store
和用户下载的体积都变小


218
00:12:36,056 --> 00:12:38,692
这意味着你确实


219
00:12:38,759 --> 00:12:42,896
可以长期利用回收的空间


220
00:12:42,963 --> 00:12:45,332
处理之前因为容量问题


221
00:12:45,399 --> 00:12:46,733
而不能安装的应用


222
00:12:46,800 --> 00:12:48,869
这不是说你又得占据大量的容量 


223
00:12:48,936 --> 00:12:51,805
相反的 这意味着当你面临容量不够


224
00:12:51,872 --> 00:12:55,709
而又想放
更多的东西进app时可以更自由


225
00:12:57,878 --> 00:13:02,549
现在 我想请我的同事帕特里克·海宁


226
00:13:02,616 --> 00:13:04,484
来告诉你们具体如何做到这一点


227
00:13:07,721 --> 00:13:08,555
谢谢你 安德斯


228
00:13:11,758 --> 00:13:12,793
我是帕特里克·海宁


229
00:13:12,860 --> 00:13:15,095
我想谈论一些关于
资源切割的更多一些细节


230
00:13:16,697 --> 00:13:18,632
它的工作原理是什么呢


231
00:13:20,601 --> 00:13:22,202
好吧 非常高兴告诉大家


232
00:13:22,269 --> 00:13:24,505
资源切割和App简化已经无缝


233
00:13:24,571 --> 00:13:27,641
整合到Xcode的开发
 输出和工作流之中了


234
00:13:27,708 --> 00:13:29,142
也许你们已经很熟悉


235
00:13:29,209 --> 00:13:30,644
如何开发应用


236
00:13:32,079 --> 00:13:35,916
这一切的改善


237
00:13:35,983 --> 00:13:38,352
可以让你真正
实现资源切割和App简化的关键在于


238
00:13:38,418 --> 00:13:44,024
我们为产品开发和资源目录
设立工作流 


239
00:13:44,391 --> 00:13:49,296
并同时考虑了
各种不同设备和变量从而方便开发应用


240
00:13:51,231 --> 00:13:53,500
那么你需要做的是什么呢


241
00:13:54,701 --> 00:13:59,506
如果你已经习惯使用
iOS的app 亦或者


242
00:14:00,707 --> 00:14:04,945
习惯开发iOS应用


243
00:14:05,012 --> 00:14:07,214
那么你们
会使用1X 2X 3X原图 


244
00:14:07,281 --> 00:14:11,285
适应各类尺寸的屏幕 


245
00:14:11,818 --> 00:14:13,687
甚至可能早就在使用


246
00:14:13,754 --> 00:14:17,090
iOS 7的资源目录了


247
00:14:18,892 --> 00:14:20,327
这一些确实也是你必须要有的


248
00:14:20,894 --> 00:14:24,431
什么是资源目录 它们有什么作用呢


249
00:14:25,265 --> 00:14:26,967
资源目录就是根据


250
00:14:27,034 --> 00:14:29,169
资源的相关设备特征


251
00:14:29,236 --> 00:14:31,405
进行资源组织的功能


252
00:14:31,505 --> 00:14:33,507
因此非常重要且具有针对性


253
00:14:35,008 --> 00:14:36,577
这里需要重点强调一下


254
00:14:37,211 --> 00:14:39,146
为了能利用应用简化功能


255
00:14:39,379 --> 00:14:42,816
你的资源必须处于资源目录内才行


256
00:14:43,250 --> 00:14:45,185
我们无法处理松散资源


257
00:14:45,886 --> 00:14:50,257
这不能限制这项强大功能


258
00:14:50,324 --> 00:14:51,592
以后我们会进行改善


259
00:14:51,959 --> 00:14:53,026
需要重点说明


260
00:14:54,895 --> 00:14:56,597
所以我刚刚提到了设备特征


261
00:14:56,897 --> 00:15:00,767
因为在资源目录内


262
00:15:00,834 --> 00:15:03,837
资源可以用设备关键组特征进行优化


263
00:15:04,204 --> 00:15:06,306
这包括你很熟悉的


264
00:15:06,373 --> 00:15:11,111
屏幕分辨率
 2X 3X和其他系列设备


265
00:15:11,478 --> 00:15:15,816
不管它是ipad还是 iPhone


266
00:15:18,285 --> 00:15:23,457
更新
Xcode 7的iOS 9系统后 


267
00:15:23,790 --> 00:15:25,192
我们在设备硬件特征的基础上


268
00:15:25,259 --> 00:15:26,727
开发了一组设备特性


269
00:15:27,327 --> 00:15:30,998
尤其是图片处理能力和内存级别


270
00:15:31,765 --> 00:15:34,201
这确实引起了两个需求


271
00:15:34,268 --> 00:15:38,005
第一 我们可使用的一系列设备


272
00:15:38,071 --> 00:15:39,540
性能特点更多强大


273
00:15:39,606 --> 00:15:41,475
从最低终端到最高终端设备各有不同


274
00:15:41,542 --> 00:15:45,579
单一的资源并不适用于


275
00:15:45,779 --> 00:15:48,015
所有类别的设备


276
00:15:48,315 --> 00:15:52,686
对于最终的使用体验
会是怎样真的很难达成一致


277
00:15:53,153 --> 00:15:57,658
这对高端和低端的内存级别都是一样的


278
00:15:57,858 --> 00:16:02,763
新的设备特性使你能
给不同的功能制定相应的资源


279
00:16:04,831 --> 00:16:08,235
资源目录里又有哪些内容呢 


280
00:16:10,571 --> 00:16:13,373
好吧 目前为止 


281
00:16:13,440 --> 00:16:15,776
在我们所推出的资源目录中 
最热门的是image


282
00:16:16,977 --> 00:16:21,715
这主要是你应用里的原图资源


283
00:16:22,282 --> 00:16:26,353
特别是位图资源和载体类型


284
00:16:26,420 --> 00:16:30,490
你的图片可以是
png jpg或者pdf的格式


285
00:16:30,557 --> 00:16:33,794
这些会先压缩以节省空间


286
00:16:33,861 --> 00:16:36,964
编译成最佳的传送格式


287
00:16:37,030 --> 00:16:42,569
然后通过
UI工具包的API传送到你应用 


288
00:16:46,373 --> 00:16:50,477
iOS 9和Xcode7更新后有了


289
00:16:51,111 --> 00:16:53,080
新的的数据类别


290
00:16:53,614 --> 00:16:54,882
至少一个新的数据类别


291
00:16:55,549 --> 00:16:56,817
那就是Name数据


292
00:16:57,751 --> 00:16:58,785
这是用来做什么的呢


293
00:16:59,453 --> 00:17:03,390
Name数据让你可以
随心所欲的储存文件内容


294
00:17:04,625 --> 00:17:06,660
现在 可能你们会担心的事情是 


295
00:17:06,727 --> 00:17:08,362
我们只是根据内容


296
00:17:08,428 --> 00:17:10,830
对资源目录进行简化 


297
00:17:10,897 --> 00:17:14,601
你们会问
如果我尝试简化非Image类的资源


298
00:17:14,667 --> 00:17:16,203
这正是Name数据的作用所在


299
00:17:16,270 --> 00:17:20,440
Name数据让你可以
在资源目录中随意放入文件


300
00:17:20,507 --> 00:17:23,310
并根据硬件水平进行分类


301
00:17:23,377 --> 00:17:25,244
正如我之前提到的


302
00:17:27,247 --> 00:17:30,584
然后 在运行时 
可以使用OS X系统UI工具包


303
00:17:30,651 --> 00:17:35,722
新的NSDataAsset
类别在app内进行内容检索


304
00:17:37,224 --> 00:17:39,092
侧边栏在这里


305
00:17:39,393 --> 00:17:42,796
资源目录的特征 


306
00:17:42,863 --> 00:17:46,800
正如我描述的Name数据和其他特点


307
00:17:46,867 --> 00:17:48,368
在OS X系统中也有


308
00:17:48,435 --> 00:17:50,637
我们不会在OS X系统中


309
00:17:50,704 --> 00:17:53,807
进行应用简化
但是在目录里储存资源制品格式可以


310
00:17:53,874 --> 00:17:55,876
用于从所有目标上获取资源 


311
00:17:55,943 --> 00:17:58,345
包括OS X系统和Watch


312
00:17:58,412 --> 00:18:00,347
所有这些功能都能起作用


313
00:18:00,414 --> 00:18:01,615
API在所有平台均可使用


314
00:18:01,949 --> 00:18:04,084
简化只适用于iOS系统


315
00:18:04,651 --> 00:18:05,619
侧边栏结束


316
00:18:07,254 --> 00:18:10,791
在Xcode 7 和iSO 9
系统我们引入了另一种新的数据类型 


317
00:18:10,858 --> 00:18:14,761
就是Sprite地图集


318
00:18:15,429 --> 00:18:21,802
这意味资源目录
和SpriteKit已经实现整合


319
00:18:23,604 --> 00:18:26,373
让你们可以使用一般的方式
可以让你分组图像资源


320
00:18:26,440 --> 00:18:28,408
以一种普通的方式在资源目录内组织 


321
00:18:28,475 --> 00:18:30,444
并重命名为Sprite地图集 


322
00:18:30,511 --> 00:18:32,412
另外可以在创建时候


323
00:18:32,579 --> 00:18:36,884
自动创建纹理地图集


324
00:18:36,950 --> 00:18:42,256
从而在图像资源里
检索SK纹理地图集类型


325
00:18:42,890 --> 00:18:44,458
一项关键功能是 


326
00:18:44,758 --> 00:18:49,696
如果你已经在iPhone
iPad上完成常规组织 


327
00:18:50,063 --> 00:18:54,401
那么它将自动创建


328
00:18:54,535 --> 00:18:57,971
编译好的纹理地图集的简化版本 


329
00:18:58,105 --> 00:19:01,675
然后作为简化资源 


330
00:19:01,775 --> 00:19:05,979
与AppStore上和我稍后会谈到
的其他工作流简化的版本一致


331
00:19:07,948 --> 00:19:11,118
那么我们如何
从资源目录中进行app简化呢 


332
00:19:12,553 --> 00:19:14,922
好的 这实在很简单
也许大家已经猜到了 


333
00:19:15,222 --> 00:19:18,225
每个资源目录中的资源都有标记 


334
00:19:18,525 --> 00:19:23,263
用于描述资源相关特征
以及有用的特征


335
00:19:24,865 --> 00:19:28,268
在创建之时当我们建立流程后


336
00:19:28,702 --> 00:19:31,004
这些特征会在资源


337
00:19:31,071 --> 00:19:32,806
和相关简化app变体之间建立路径


338
00:19:34,107 --> 00:19:37,678
就是这么简单
我想要在这里重点说明一下


339
00:19:38,679 --> 00:19:41,081
资源目录已经存在好一会儿了


340
00:19:41,148 --> 00:19:43,417
它们可以让你能够在运行的时候


341
00:19:43,483 --> 00:19:45,986
选择适合请求该资源的


342
00:19:46,353 --> 00:19:48,088
设备的正确资源


343
00:19:48,155 --> 00:19:51,625
在简化app变体路径方面


344
00:19:51,725 --> 00:19:55,195
也是基于同样的算法
和一样的选择标准


345
00:19:55,529 --> 00:19:58,699
如果你的
app今天在不同设备上工作正常 


346
00:19:58,765 --> 00:20:01,435
那么app简化也同样工作正常 


347
00:20:01,735 --> 00:20:04,238
因为它们使用同一个原理


348
00:20:06,707 --> 00:20:11,478
好了我之前提到单词组织 


349
00:20:12,112 --> 00:20:13,780
我想要再强调一下


350
00:20:14,114 --> 00:20:18,252
有效对
资源目录进行归类绝对是关键所在


351
00:20:18,952 --> 00:20:19,820
为什么呢？ 


352
00:20:19,987 --> 00:20:23,056
因为对资源进行


353
00:20:23,323 --> 00:20:27,494
大规模标注意味着
程序片变体中的冗余数据就越少


354
00:20:28,128 --> 00:20:32,699
你不会
获取app变体产生的额外数据 


355
00:20:32,866 --> 00:20:35,802
而这些数据在目标设备上运行时


356
00:20:35,869 --> 00:20:38,105
是不会使用到的


357
00:20:39,373 --> 00:20:43,377
例如 即使应用之前可以正常工作 


358
00:20:43,443 --> 00:20:48,248
但是如果只是在一台设备上使用那么就
没有必要保留通用资源了 


359
00:20:48,315 --> 00:20:53,120
考虑一下比如你的iPad上的应用有
自己的UI弹出按钮


360
00:20:53,187 --> 00:20:54,755
是在iPhone上的应用


361
00:20:54,821 --> 00:20:59,393
却不会在你的iphone上显示出来


362
00:20:59,459 --> 00:21:02,863
通用资源的话可以使用可以显示正常


363
00:21:02,930 --> 00:21:07,034
但是
现在我们可以重新访问并进行归类 


364
00:21:07,100 --> 00:21:09,970
这样就无需
传送到iPhone版本的应用上 


365
00:21:10,470 --> 00:21:15,108
因为在那里没法显示
好的


366
00:21:16,143 --> 00:21:17,644
以上是基础的知识


367
00:21:17,711 --> 00:21:19,980
关于该系统工作的原理


368
00:21:20,047 --> 00:21:23,784
我们来举个例子 
说说具体的工作流程


369
00:21:23,884 --> 00:21:25,085
以及如何产生影响的


370
00:21:27,154 --> 00:21:28,622
首先说说创建


371
00:21:28,689 --> 00:21:30,257
你是如何创建资源目录的


372
00:21:30,891 --> 00:21:34,361
创建资源目录内容的首要方法是


373
00:21:34,428 --> 00:21:36,496
通过Xcode上的资源目录编辑器


374
00:21:38,131 --> 00:21:41,401
在IDE上使用用户界面很简单


375
00:21:41,468 --> 00:21:43,570
或许你对此很熟悉了


376
00:21:44,104 --> 00:21:48,408
创建一个新资源


377
00:21:48,475 --> 00:21:50,811
只需增加一个新项目


378
00:21:51,879 --> 00:21:53,647
你可以看到这里有个值域


379
00:21:53,714 --> 00:21:56,717
这里 你可以看到数据集 
图像集 Sprite地图集


380
00:21:56,783 --> 00:21:59,353
以及其他平台的其他数据类型


381
00:22:01,622 --> 00:22:03,490
当你将这增加到项目中时


382
00:22:03,557 --> 00:22:06,093
你可以看到在左边
有一个组织数组和范围


383
00:22:06,159 --> 00:22:08,695
显示的是设备特征
你可根据这些特征进行分类


384
00:22:08,762 --> 00:22:14,201
并显示你想要的资料丰富性


385
00:22:14,768 --> 00:22:18,238
将资源放到合适的源中


386
00:22:18,639 --> 00:22:20,974
然后离开 前往种类完成了


387
00:22:23,277 --> 00:22:25,212
好极了 用起来很简单


388
00:22:26,046 --> 00:22:30,284
倘若你的团队无法在资源
产品里使用Xcode将会怎么样


389
00:22:31,652 --> 00:22:33,754
倘若这是个游戏工作室


390
00:22:33,820 --> 00:22:36,990
在现有资源工具链和管道上投资巨大


391
00:22:37,057 --> 00:22:40,694
但对于创造出合适原图的


392
00:22:40,827 --> 00:22:43,397
内容工程师或设计者来说
现有的资源工具链和管道


393
00:22:43,463 --> 00:22:45,866
并不适合使用Xcode这将会怎样


394
00:22:46,800 --> 00:22:50,337
很高兴的告诉你们我们考虑到这种情况


395
00:22:50,671 --> 00:22:53,740
我们仔细地设计了资源目录特征


396
00:22:53,807 --> 00:22:56,610
与简化相配使之适用于这些情况


397
00:22:58,045 --> 00:23:00,314
我们特别地将它设计成


398
00:23:00,380 --> 00:23:04,151
很容易从现有资源管道


399
00:23:04,218 --> 00:23:05,786
导出图像集和数据集


400
00:23:06,787 --> 00:23:07,988
如何做到这点呢


401
00:23:09,723 --> 00:23:13,193
我们将通过
XC资源来源工件格式进行讲解


402
00:23:13,493 --> 00:23:17,698
我很高兴的告诉大家
我们将进行文件编制和发行


403
00:23:18,098 --> 00:23:21,034
使得外部工具链


404
00:23:21,101 --> 00:23:22,903
可以很容易的执行这个格式


405
00:23:24,638 --> 00:23:28,575
这算不上什么格式


406
00:23:28,642 --> 00:23:31,745
因为它只是JSON标记上一个简单的
文件夹结构而且很容易配合使用


407
00:23:32,246 --> 00:23:33,814
我想要强调的是


408
00:23:34,314 --> 00:23:39,853
这并不是下面提到的这种格式
先创建 然后导入Xcode中


409
00:23:39,920 --> 00:23:42,055
然后就变成了一个项目工件


410
00:23:42,456 --> 00:23:44,992
这是源工件格式


411
00:23:45,058 --> 00:23:47,194
在创建时 


412
00:23:47,594 --> 00:23:49,396
Xcode创建系统就开始用来


413
00:23:49,463 --> 00:23:51,532
处理和产生最后执行成品


414
00:23:53,500 --> 00:23:56,470
我们来看看它的细节信息


415
00:23:56,904 --> 00:24:02,009
来看看先前说过的
例子AirPlay图像原图


416
00:24:02,276 --> 00:24:03,944
在磁盘中看起来是这样的


417
00:24:04,011 --> 00:24:05,145
事实上 这就是格式


418
00:24:05,812 --> 00:24:06,780
非常简单


419
00:24:06,980 --> 00:24:09,550
它所包含的是一个文件夹命名约定


420
00:24:09,616 --> 00:24:10,984
包含资源的名字


421
00:24:11,051 --> 00:24:13,654
这是使用UI图像名称在代码中


422
00:24:13,720 --> 00:24:15,589
重新得到的名字


423
00:24:16,490 --> 00:24:19,159
随后文件夹里包含了单独原图源


424
00:24:19,593 --> 00:24:24,932
我想指出的是
尽管在这个特别例子中


425
00:24:24,998 --> 00:24:28,435
用了一个众所周知半标准文件命名约定


426
00:24:28,502 --> 00:24:30,771
来显示比例系数和设备习语


427
00:24:30,938 --> 00:24:32,739
但它并不需要


428
00:24:32,806 --> 00:24:34,675
任何特别的文件命名约定


429
00:24:34,741 --> 00:24:36,944
你可以使用任何工作流程


430
00:24:37,010 --> 00:24:38,679
或工具链或任何你所喜欢的方法


431
00:24:39,346 --> 00:24:40,347
为什么可以做到这样


432
00:24:40,547 --> 00:24:42,950
因为在这个设计中


433
00:24:43,016 --> 00:24:45,452
有重要的第三元素
即contents.JSON文件


434
00:24:46,920 --> 00:24:49,022
contents.JSON文件


435
00:24:49,256 --> 00:24:52,593
包含所有资源标记信息


436
00:24:52,659 --> 00:24:54,228
并将信息连接在一起


437
00:24:54,294 --> 00:24:55,796
并告诉系统


438
00:24:55,863 --> 00:24:59,533
与特别资源有关的特性


439
00:25:00,200 --> 00:25:02,369
来看看


440
00:25:02,903 --> 00:25:07,574
先前在Xcode编辑器上显示的
AirPlay图标


441
00:25:07,641 --> 00:25:09,309
现在看起来是这样子的


442
00:25:09,476 --> 00:25:11,378
你可以看到 它非常的简单明了


443
00:25:12,045 --> 00:25:16,416
这只是单独图像中的一个数组你可以看
到单独文件名称


444
00:25:16,483 --> 00:25:20,854
然后是设备习语和比例系数标记信息


445
00:25:21,355 --> 00:25:24,691
这些属性你看到的这些关键数值组


446
00:25:24,758 --> 00:25:26,693
就是将被记录在


447
00:25:26,760 --> 00:25:28,295
SES源工件格式中的东西


448
00:25:30,464 --> 00:25:34,968
举个高一级的例子 名字数据


449
00:25:35,102 --> 00:25:38,705
我们叫它数据集
不出所料 看起来很相似


450
00:25:38,772 --> 00:25:41,308
再一次 里面有单独源的文件名


451
00:25:41,375 --> 00:25:44,411
然后是通用型标识符


452
00:25:44,678 --> 00:25:47,614
和存储器的属性


453
00:25:47,781 --> 00:25:48,815
或显卡未来集类


454
00:25:50,284 --> 00:25:52,452
你可看到 它真的很好配合使用


455
00:25:52,519 --> 00:25:54,454
你可以看到它是如何操作的


456
00:25:54,521 --> 00:25:57,224
如何命名文件名和属性


457
00:25:57,291 --> 00:26:00,227
这也是为什么不管你在


458
00:26:00,294 --> 00:26:03,463
数据集和图像集加入什么名字没有关系


459
00:26:03,530 --> 00:26:05,999
重要的是
contents.JSON是正确的


460
00:26:08,836 --> 00:26:10,637
你可以用它来做什么呢


461
00:26:10,704 --> 00:26:12,439
这是用来做什么的呢


462
00:26:13,140 --> 00:26:16,043
我来举个例子


463
00:26:16,109 --> 00:26:18,679
假设有用Xcode创建的图像集


464
00:26:19,046 --> 00:26:20,514
我将展示的这个假设工作流程


465
00:26:20,581 --> 00:26:23,650
是在PhotoShop中
使用PhotoShop CC生成器


466
00:26:26,587 --> 00:26:29,556
假设你的设计者创建了漂亮的原图


467
00:26:29,623 --> 00:26:32,826
他们决定今天iPad是蓝色的


468
00:26:32,893 --> 00:26:33,961
iPhone是红色的


469
00:26:34,027 --> 00:26:35,362
这只是我们工作的方法


470
00:26:35,829 --> 00:26:36,964
设计者有时会这么做


471
00:26:39,366 --> 00:26:41,468
他们有漂亮的主文件


472
00:26:42,069 --> 00:26:44,471
并在这里陈列所有这些变体


473
00:26:44,538 --> 00:26:47,274
事实上 


474
00:26:47,341 --> 00:26:49,343
他们用生成器工作流程
创建了主文件


475
00:26:49,409 --> 00:26:51,245
打开图像资源生成


476
00:26:51,512 --> 00:26:53,981
由合适的命名约定


477
00:26:54,047 --> 00:26:57,684
构造他们的层级清单


478
00:26:57,951 --> 00:27:00,354
默认层级直接导出到一个图像集


479
00:27:00,988 --> 00:27:04,391
有一个生成器的特别版本


480
00:27:04,958 --> 00:27:08,428
他们小心地进行扩展


481
00:27:08,495 --> 00:27:12,699
这是产生
contents.JSON假想事例


482
00:27:12,966 --> 00:27:15,269
这就是将从
PhotoShop工作流程中输出的


483
00:27:15,569 --> 00:27:17,738
对于以前使用过生成器的人来说


484
00:27:17,871 --> 00:27:20,707
他们很熟悉照片布局了


485
00:27:20,774 --> 00:27:21,842
这是资源文件夹


486
00:27:22,009 --> 00:27:24,745
里面有生成的图像集 


487
00:27:24,811 --> 00:27:29,716
所有不同的原图实体
和contents.JSON


488
00:27:30,450 --> 00:27:33,921
我们要做的仅是拖出图像集


489
00:27:33,987 --> 00:27:35,989
并将图像集放到
XE资源文件夹下的文件夹中


490
00:27:36,056 --> 00:27:39,593
之后就可以进入竞态


491
00:27:43,330 --> 00:27:47,534
就这样简单说来就是
带Xcode项目的动态集成


492
00:27:49,469 --> 00:27:51,305
唯一的要求是


493
00:27:51,371 --> 00:27:55,676
从一个Xcode项目文件水平来说
你的项目必须有XE资源文件夹


494
00:27:55,742 --> 00:27:58,512
这是唯一的要求


495
00:28:00,047 --> 00:28:01,982
里面的所有内容


496
00:28:02,549 --> 00:28:06,019
都必须有一个任意层级 任意结构


497
00:28:06,520 --> 00:28:09,022
它必须符合图像集和数据集


498
00:28:09,089 --> 00:28:13,694
你可以按照任意深度进行嵌套


499
00:28:14,261 --> 00:28:16,864
你可以使用
受它支配的自己的文件系统组织


500
00:28:17,064 --> 00:28:19,166
假设你正确授权图像集和数据集


501
00:28:19,366 --> 00:28:23,103
在创建时Xcode将递归地下降层级


502
00:28:23,203 --> 00:28:28,408
发现所有图像集 数据集
和传播地图集并自动进行创建 


503
00:28:31,044 --> 00:28:34,581
现在你知道怎么创建资源目录了


504
00:28:35,115 --> 00:28:37,451
现在进入下一步 创建


505
00:28:39,253 --> 00:28:42,456
或许最普通最重要的创建工作流程是


506
00:28:42,789 --> 00:28:45,259
坐在座位上
在Tether设备的app上作


507
00:28:45,592 --> 00:28:49,630
或者你在模拟器上操作


508
00:28:49,696 --> 00:28:51,765
此种情况下如何简化应用呢


509
00:28:51,832 --> 00:28:53,534
很高兴的告诉你


510
00:28:53,600 --> 00:28:56,637
创建和运行工作流程


511
00:28:56,703 --> 00:29:00,541
可自动地为现有有效运作目标简化资源


512
00:29:01,074 --> 00:29:02,109
在Xcode中


513
00:29:02,910 --> 00:29:05,312
意思是说 每次进行创建


514
00:29:05,712 --> 00:29:07,681
事实上它仅会对


515
00:29:07,748 --> 00:29:10,617
你正在使用的目标设备分析


516
00:29:10,684 --> 00:29:15,989
产生并自动创建适当的执行资源目录


517
00:29:17,424 --> 00:29:21,461
所有的模拟器和设备均支持这功能


518
00:29:22,930 --> 00:29:25,566
这是利用应用简化


519
00:29:25,632 --> 00:29:28,335
绝佳的范例


520
00:29:29,736 --> 00:29:31,171
这个功能是


521
00:29:31,238 --> 00:29:33,674
由已经在目标编辑器资源目录显示的


522
00:29:33,740 --> 00:29:37,978
新创建设置激发或控制的


523
00:29:38,145 --> 00:29:40,447
仅在有效资源下启用创建


524
00:29:41,982 --> 00:29:43,650
这很方便


525
00:29:43,717 --> 00:29:46,386
倘若 你试着解决


526
00:29:46,453 --> 00:29:48,255
一个由应用简化引起的问题将会怎么样


527
00:29:48,322 --> 00:29:50,591
倘若简化全面影响了
特定的目标设备情况会怎么样


528
00:29:50,657 --> 00:29:54,862
为此 你可以不断拨动开关


529
00:29:57,631 --> 00:29:59,833
此创建工作流程的其他优势是


530
00:29:59,900 --> 00:30:03,070
极大的加快重复编译


531
00:30:03,136 --> 00:30:04,238
或增量编译


532
00:30:04,304 --> 00:30:06,673
在应用内容繁多的时候尤其适用


533
00:30:07,007 --> 00:30:12,346
它只处理并
只与当下适合目标的源进行匹配


534
00:30:12,412 --> 00:30:16,250
当它创建一个应用的
普通版本时


535
00:30:16,316 --> 00:30:19,520
并不需要像以前一样每一个都需做完


536
00:30:20,888 --> 00:30:22,256
另一个重要优势是


537
00:30:22,322 --> 00:30:25,626
对于一个特别设备或一组设备


538
00:30:25,692 --> 00:30:28,862
可以很容易测试


539
00:30:29,263 --> 00:30:30,697
若你想要理解


540
00:30:30,764 --> 00:30:34,334
目录变动对简化输出的影响


541
00:30:34,401 --> 00:30:37,004
整体创建应用的大小或
用户体验的其他方面的影响


542
00:30:37,237 --> 00:30:40,407
你可以迅速变动这些目录创建并运行 


543
00:30:40,641 --> 00:30:44,811
随后通过在其他设备
和Xcode中运行目标间进行转化


544
00:30:44,878 --> 00:30:49,550
来检查其他设备
可以极其快速简单地测试这些变动


545
00:30:53,220 --> 00:30:56,590
创建就讲到这里 接下来是什么呢


546
00:30:56,657 --> 00:30:58,325
传播


547
00:30:58,392 --> 00:31:03,297
这是简化应用的基本步骤


548
00:31:05,699 --> 00:31:08,468
现在 有很多方法


549
00:31:08,535 --> 00:31:10,337
可用来传播你的iOS应用


550
00:31:11,171 --> 00:31:13,307
使你能够传播你的iOS应用


551
00:31:13,373 --> 00:31:15,542
最大且最有效的一个 


552
00:31:15,609 --> 00:31:18,245
当然是你的终端用户 顾客


553
00:31:18,312 --> 00:31:21,114
通过AppStore
购买正在使用的用户这是最核心的 


554
00:31:21,181 --> 00:31:25,719
安德斯提到
这是你提供普通IPA的地方


555
00:31:26,320 --> 00:31:27,888
商店做了这个工作


556
00:31:27,955 --> 00:31:30,023
处理了所有简化变体


557
00:31:30,090 --> 00:31:32,226
当用户购买app时


558
00:31:32,292 --> 00:31:35,662
它将从商店里自动选择适合设备的变体


559
00:31:35,729 --> 00:31:38,065
下载并进行安装完成了 完全自动的


560
00:31:38,265 --> 00:31:39,233
不需要操心什么


561
00:31:39,733 --> 00:31:42,202
在发布应用前


562
00:31:42,536 --> 00:31:47,875
你或许也想为beta C
测试者创造完全相同的体验


563
00:31:48,242 --> 00:31:53,413
也可通过TestFlight支持测
试传播我们将通过简化传播


564
00:31:56,016 --> 00:31:58,652
然后 当然有ad hoc和企业传播


565
00:31:58,719 --> 00:32:01,788
这是个常用方法
可用来在你的组织中传播应用


566
00:32:01,855 --> 00:32:04,725
或在你的组中进行QA测试其他事情


567
00:32:05,692 --> 00:32:08,695
这是传播极其重要的一种方法


568
00:32:08,762 --> 00:32:12,499
我们也在其中创建了简化支持


569
00:32:12,566 --> 00:32:16,003
最后 还有已经更新的Xcode服务


570
00:32:16,637 --> 00:32:19,006
和Ecos服务器


571
00:32:19,072 --> 00:32:21,675
用来支持传播简化应用


572
00:32:22,042 --> 00:32:23,510
随后 我会讲到更多细节


573
00:32:24,545 --> 00:32:30,017
上述方法的自动化程度非常高


574
00:32:30,083 --> 00:32:31,885
你无需做太多事情


575
00:32:32,252 --> 00:32:35,589
等下要我要讲的是


576
00:32:35,656 --> 00:32:37,491
Ad hoc企业解决方案


577
00:32:37,558 --> 00:32:40,894
这里 你需要自己托管传播流程


578
00:32:40,961 --> 00:32:44,998
你可能需要理解
他们是如何放到一起如何运作的


579
00:32:45,432 --> 00:32:47,134
我们现在就来说这个它们是如何运作的


580
00:32:48,836 --> 00:32:52,039
Xcode中已增加的一个功能是


581
00:32:52,206 --> 00:32:54,875
现在 对于特别设备


582
00:32:54,942 --> 00:32:56,343
你可以从组织器中导出


583
00:32:56,610 --> 00:33:00,480
若你将测试一个创建或要将创建切换到


584
00:33:00,547 --> 00:33:02,149
制定设备 非常管用


585
00:33:02,216 --> 00:33:05,052
你可立即创建一个IPA


586
00:33:05,118 --> 00:33:07,521
用于直接指向到特定设备和为特定设备
提供的组织器


587
00:33:10,991 --> 00:33:15,162
未来 我们将为你提供一种方法


588
00:33:15,229 --> 00:33:19,166
可在所有的兼容设备上


589
00:33:19,233 --> 00:33:22,936
导出所有简化变体


590
00:33:23,003 --> 00:33:25,839
为应用的所有
可能支持设备提供完整的传播单元


591
00:33:25,906 --> 00:33:27,174
这很重要


592
00:33:27,241 --> 00:33:30,711
你或许不知道或能够为


593
00:33:30,777 --> 00:33:33,013
所有的设备生成所有的简化变体


594
00:33:33,080 --> 00:33:35,549
你想要获得全组信息


595
00:33:37,384 --> 00:33:40,854
事实上 它将做的是


596
00:33:40,921 --> 00:33:43,824
处理你所有的普通app创建存档


597
00:33:45,993 --> 00:33:49,596
生成适合所有不同兼容设备的


598
00:33:49,663 --> 00:33:52,099
所有简化变体
并将它们放入一组产品中


599
00:33:54,234 --> 00:33:57,271
现在 你有很多应用


600
00:33:58,038 --> 00:34:03,544
你或许会问自己 何才能为设备


601
00:34:03,610 --> 00:34:06,446
获取一个正确的应用 是个大问题


602
00:34:06,713 --> 00:34:09,716
将app发送到企业和adhoc设备


603
00:34:09,783 --> 00:34:11,185
最常用的方法是


604
00:34:11,251 --> 00:34:12,452
空中安装


605
00:34:14,321 --> 00:34:16,723
随后我会讲到这个
化配合使用并会讲到如何与简


606
00:34:16,790 --> 00:34:20,827
第一步保存为ad hoc或企业传播


607
00:34:20,893 --> 00:34:25,899
这很重要 包了传播显示选项


608
00:34:25,966 --> 00:34:28,768
左下角的复选框


609
00:34:29,837 --> 00:34:30,904
这是用来做什么


610
00:34:32,206 --> 00:34:34,007
它的作用是


611
00:34:34,074 --> 00:34:37,678
当Xcode在生成IPA的导出集时


612
00:34:37,744 --> 00:34:40,681
它将为它所生成的每个app变体


613
00:34:40,746 --> 00:34:42,783
生成一个含有URL的显示清单


614
00:34:42,850 --> 00:34:44,585
它将通过app变体的支持产品类型


615
00:34:45,351 --> 00:34:50,924
更重要的是 将编插入索引
由不同产品门类区分支持


616
00:34:51,592 --> 00:34:52,693
取决于那app的门类


617
00:34:53,927 --> 00:34:55,161
影响在于


618
00:34:55,395 --> 00:35:00,767
当设备试图安装app时


619
00:35:00,834 --> 00:35:03,036
使用空中显示PO清单


620
00:35:03,403 --> 00:35:06,139
它将会过一遍清单为设备 


621
00:35:06,373 --> 00:35:08,942
产品类型找到合适的URL


622
00:35:09,276 --> 00:35:12,045
并对其进行安装 


623
00:35:12,346 --> 00:35:13,180
这就是它的运作方式


624
00:35:13,247 --> 00:35:17,351
概念上与简化应用商店
实际所发生的相类似


625
00:35:17,718 --> 00:35:20,420
但所有的这些移动块


626
00:35:20,487 --> 00:35:25,125
都是由你通过Xcode进行生成并在
Web服务器上进行托管


627
00:35:26,793 --> 00:35:28,962
倘若更进一步将会怎么样


628
00:35:30,030 --> 00:35:33,367
这就是
Xcode服务器持续集成服务所做的


629
00:35:36,637 --> 00:35:38,939
Xcode服务器所做的是


630
00:35:39,006 --> 00:35:41,775
为创建代管和传播简化app


631
00:35:41,842 --> 00:35:43,577
包括代管按需资源包


632
00:35:43,644 --> 00:35:45,012
将我刚描述的原理


633
00:35:45,245 --> 00:35:48,582
变成完整解决方案


634
00:35:51,318 --> 00:35:52,853
非常简单


635
00:35:53,187 --> 00:35:55,923
Xcode服务器
你在Xcode中创建集成盒


636
00:35:55,989 --> 00:35:59,493
与Xcode服务器展开配合使用


637
00:36:00,360 --> 00:36:03,497
项目自动创建应用


638
00:36:03,564 --> 00:36:06,667
生成变体生成显示P清单


639
00:36:07,134 --> 00:36:09,636
甚至在你在Xcode服务网站上


640
00:36:09,803 --> 00:36:13,473
选定设备和选择特别创建的地方


641
00:36:13,674 --> 00:36:16,410
覆盖web服务你所需做的


642
00:36:16,610 --> 00:36:18,245
只是点击安装按钮


643
00:36:18,445 --> 00:36:20,614
以及我先前所描述的
对显示P清单进行定位


644
00:36:20,681 --> 00:36:22,482
牵引合适变量的所有原理


645
00:36:22,549 --> 00:36:25,719
它是自动进行的


646
00:36:26,453 --> 00:36:30,324
将设备指向Web服务并运行很简单


647
00:36:30,557 --> 00:36:33,126
我鼓励你来看一看这个 尤其是


648
00:36:33,193 --> 00:36:35,195
感受一下所有的一切是如何运作的


649
00:36:35,863 --> 00:36:39,166
我鼓励你看看


650
00:36:39,233 --> 00:36:43,337
这个模式和你在进行托管可能用来创建
你自己的企业传播工作流程


651
00:36:43,403 --> 00:36:48,242
或ad hoc
传播工作流程的模式是相同的


652
00:36:48,976 --> 00:36:51,044
所有的这些你都可以自己创建


653
00:36:53,447 --> 00:36:56,850
整合各功能的Xcode服务


654
00:36:56,917 --> 00:36:59,753
是使用空中显示的简化app变体的


655
00:36:59,820 --> 00:37:02,623
一种流线型的安装方法


656
00:37:03,490 --> 00:37:07,127
漂亮简单的解决方案  一站式


657
00:37:09,663 --> 00:37:12,099
好了 我们刚讲的是


658
00:37:12,165 --> 00:37:14,868
如何创建资源目录从而进行app划分


659
00:37:15,002 --> 00:37:16,703
我们讲了


660
00:37:17,204 --> 00:37:18,939
它如何与你的创建工作流程相结合


661
00:37:19,106 --> 00:37:21,375
我们也讲了传播的不同方法


662
00:37:21,441 --> 00:37:23,010
app简化如何与它们相互作用


663
00:37:23,911 --> 00:37:25,245
现场交给安德斯


664
00:37:25,312 --> 00:37:27,114
请安德斯为我们做总结


665
00:37:31,985 --> 00:37:32,819
谢谢你  帕特里克


666
00:37:35,322 --> 00:37:37,491
好了 在这部分 我们看了 


667
00:37:37,558 --> 00:37:40,460
app传播工作流程是如何运作的


668
00:37:41,862 --> 00:37:44,164
以及如何改进app简化


669
00:37:46,099 --> 00:37:49,269
你可以帮助它变得更加有效的方法


670
00:37:49,336 --> 00:37:55,409
当你恰地标记资源和传播特征


671
00:37:56,510 --> 00:38:01,048
对于你的工作流程来说
在测试及提交到App Store


672
00:38:01,815 --> 00:38:04,017
这意味着什么在这里需要进行一些操作


673
00:38:04,518 --> 00:38:05,352
你所应做的是


674
00:38:05,786 --> 00:38:08,522
不断开发资源的定制版本


675
00:38:08,589 --> 00:38:11,358
太好了 为你想开发出最好的app


676
00:38:11,425 --> 00:38:13,594
并在所有的设备上运作良好


677
00:38:13,894 --> 00:38:15,095
使用app简化


678
00:38:15,162 --> 00:38:17,898
现在稍微放宽了上传大小限制


679
00:38:18,565 --> 00:38:22,135
每个用户将只获得他们所需的


680
00:38:23,170 --> 00:38:25,506
不断开发资源的定制版本


681
00:38:26,240 --> 00:38:29,643
使用资源目录使你的资源系统化


682
00:38:29,710 --> 00:38:33,447
正如帕特里克提到的 你可以
在其中放置数据和Sprite地图集


683
00:38:33,514 --> 00:38:37,384
且这些可根据设备进行改变


684
00:38:39,386 --> 00:38:42,356
同样地
使用Xcode测试你简化app变体


685
00:38:42,789 --> 00:38:44,491
这个现在变得很重要


686
00:38:44,558 --> 00:38:45,993
因为我们是


687
00:38:46,059 --> 00:38:47,628
根据每个设备所需进行资源传播的


688
00:38:48,161 --> 00:38:51,231
正如帕特里克所提到的
你可通过使用Xcode目标做到这个


689
00:38:51,298 --> 00:38:56,737
使用Xcode
服务器创建多样的简化变体


690
00:38:56,803 --> 00:38:59,006
并在真实的设备上进行测试


691
00:39:01,675 --> 00:39:06,480
充分利用按需资源 资源进行标记


692
00:39:06,547 --> 00:39:08,849
使它们成为按需加载


693
00:39:08,916 --> 00:39:11,118
资源包的一部分


694
00:39:14,087 --> 00:39:18,692
我将检索数个地方以获取更多信息


695
00:39:18,992 --> 00:39:21,094
一是app简化指南


696
00:39:21,161 --> 00:39:23,630
app传播指南中的章节


697
00:39:24,364 --> 00:39:27,434
可在Apple的开发者网站上找到


698
00:39:27,601 --> 00:39:30,270
另一个是资源目录格式文件


699
00:39:30,337 --> 00:39:32,673
这个将
会放到Apple的开发者网站上


700
00:39:35,008 --> 00:39:36,543
我们有相关联的会议


701
00:39:36,610 --> 00:39:37,845
第一部分已经有了


702
00:39:37,911 --> 00:39:39,246
你可以通过录像进行了解


703
00:39:39,913 --> 00:39:42,716
另一点是
SpriteKit有什么新特性


704
00:39:42,783 --> 00:39:46,553
这个在20分钟后


705
00:39:47,187 --> 00:39:51,358
会详细讨论


706
00:39:51,592 --> 00:39:53,393
它侧重于按需资源部分
今天4:30在太平洋大厦进行


707
00:39:53,460 --> 00:39:55,028
我鼓励你们参加这会议


708
00:39:55,429 --> 00:40:00,067
明天1:30在Mission会议上


709
00:40:00,501 --> 00:40:02,836
将详细讨论DemoBots


710
00:40:03,704 --> 00:40:04,938
我们有许多实验室


711
00:40:05,005 --> 00:40:07,908
欢迎来我们的实验室学习更多信息


712
00:40:07,975 --> 00:40:09,776
继续观看WWDC的其他部分

