1
00:00:24,391 --> 00:00:25,292
杰森·比弗: 下午好


2
00:00:27,828 --> 00:00:29,429
欢迎来到Cocoa Touch讲座


3
00:00:29,530 --> 00:00:30,731
我是杰森·比弗


4
00:00:30,797 --> 00:00:33,033
是高级工程经理在iOS小组工作


5
00:00:35,202 --> 00:00:37,571
iOS 9的最新内容有很多


6
00:00:37,771 --> 00:00:42,242
不过 我首先希望来回
顾一下在过去几年所做的改进


7
00:00:44,178 --> 00:00:48,015
自从iOS 6起 我们开始
为怎样构建iOS应用等


8
00:00:48,081 --> 00:00:52,152
较大改进奠定基础我们开始在
所推出的每个主要版本中


9
00:00:52,352 --> 00:00:53,854
都体现了这样的改进


10
00:00:55,689 --> 00:00:57,791
在iOS 6中 我们增加了自动布局


11
00:00:58,325 --> 00:01:00,561
以便于轻松构建动态和多功能界面


12
00:01:00,627 --> 00:01:03,230
以便对适用尺寸和屏幕方向


13
00:01:03,664 --> 00:01:06,400
以及本地化等方面的改进


14
00:01:06,733 --> 00:01:07,801
做出反应


15
00:01:10,604 --> 00:01:12,639
在 iOS 7中 我们
推出了动态类型


16
00:01:13,473 --> 00:01:15,375
这可以帮助在用户可选的


17
00:01:15,442 --> 00:01:18,745
文字大小应用中实现漂亮的印刷样式


18
00:01:19,546 --> 00:01:20,914
与自动布局一道


19
00:01:21,748 --> 00:01:24,017
界面可以与用户所选文本
大小的改变自动适应


20
00:01:24,084 --> 00:01:25,619
通过采用动态类型系统


21
00:01:26,286 --> 00:01:31,458
可以在文本渲染应用中免费


22
00:01:31,525 --> 00:01:33,360
为文本的可读性实现改进


23
00:01:35,662 --> 00:01:38,999
在iOS 8 我们做出的改进
可能算得上是最大


24
00:01:39,099 --> 00:01:40,901
我们引入了适应性概念


25
00:01:42,603 --> 00:01:44,905
这是指应用应该


26
00:01:45,172 --> 00:01:46,807
在运行环境下适应改变


27
00:01:47,574 --> 00:01:50,410
这一概念的基础就是尺寸类别


28
00:01:52,246 --> 00:01:54,882
尺寸类别会根据


29
00:01:54,948 --> 00:01:58,385
空间是否会受到具体的尺寸束缚导致


30
00:01:58,452 --> 00:02:00,220
应用的用户界面发生结构改变


31
00:02:01,488 --> 00:02:05,058
在这里所显示的设置应用中
在iPad和iPhone


32
00:02:05,125 --> 00:02:08,328
运行的代码完全相同


33
00:02:08,395 --> 00:02:12,633
尺寸类别的不同
导致用户界面的结构变化


34
00:02:14,234 --> 00:02:17,337
尺寸类别iKit视图控制
器许多部件的适应性


35
00:02:17,404 --> 00:02:21,441
视图控制器的呈现搜索结果


36
00:02:22,276 --> 00:02:25,179
上拉菜单等等所有这些都


37
00:02:25,612 --> 00:02:30,684
与尺寸分类和必须配合使用的
可用空间相适应


38
00:02:32,886 --> 00:02:34,555
我们去年引入


39
00:02:34,621 --> 00:02:38,559
适应性概念的时候我们为何会往
这方面发展还不是很清晰


40
00:02:39,326 --> 00:02:42,663
在应用中我们通常是全屏


41
00:02:43,163 --> 00:02:46,934
在应用运行的时候一般
不需要改变用户界面结构


42
00:02:48,402 --> 00:02:50,170
随着多任务处理的引入


43
00:02:50,871 --> 00:02:52,739
做出上述改进的原因就很清晰了


44
00:02:53,273 --> 00:02:57,611
你无需针对具体硬件


45
00:02:57,878 --> 00:02:59,313
构建两种不同的体验


46
00:02:59,980 --> 00:03:02,783
针对用户运行的app你可以提供


47
00:03:03,250 --> 00:03:05,485
根据尺寸打造的体验连续性


48
00:03:06,687 --> 00:03:08,655
应用这些基础性基础不仅app


49
00:03:08,722 --> 00:03:12,793
可以用于我们所推出的所用硬件


50
00:03:13,760 --> 00:03:16,396
也可以支持这些多任务处理的新功能


51
00:03:17,097 --> 00:03:20,901
以及我们已有合作的
已采纳所有这些改变的开发人员


52
00:03:21,735 --> 00:03:25,506
在某种情况下真是只需要
几分钟时间就可以让他们的app


53
00:03:25,739 --> 00:03:28,208
与我们的app无缝对接


54
00:03:30,511 --> 00:03:33,113
需要特殊处理的是Picture
in Picture功能


55
00:03:33,480 --> 00:03:36,149
如果应用支持背景媒体播放
可以在iOS 9中


56
00:03:36,783 --> 00:03:39,853
使用新的API启动播放器


57
00:03:39,920 --> 00:03:41,922
支持 Picture in
Picture 功能


58
00:03:42,556 --> 00:03:44,658
要记住 Picture in
Picture 功能


59
00:03:44,725 --> 00:03:46,326
和所有多任务处理一样应用


60
00:03:47,094 --> 00:03:50,063
需要作为“良民”确保


61
00:03:50,130 --> 00:03:52,032
不会干扰整体用户体验


62
00:03:53,934 --> 00:03:56,970
本周 还有几场多任务处理的讲座


63
00:03:57,137 --> 00:03:59,206
《iPad多任务处理入门》


64
00:03:59,573 --> 00:04:02,142
《基于媒体的App多任务处理要点》


65
00:04:02,476 --> 00:04:04,745
以及《为多任务处理优化App》


66
00:04:06,713 --> 00:04:09,550
我们来继续介绍iOS 9的最新内容


67
00:04:11,218 --> 00:04:12,586
首先是自动布局


68
00:04:14,054 --> 00:04:17,423
我们先来讲讲最新的UI布局指南分类


69
00:04:18,257 --> 00:04:21,428
以免你在自动布局束缚中用到了


70
00:04:21,495 --> 00:04:25,165
额外的视图 现在可以使用布局指南


71
00:04:25,232 --> 00:04:27,100
以避免视图层次搞乱


72
00:04:29,069 --> 00:04:32,439
我们介绍的是默认的两个布局指南


73
00:04:33,440 --> 00:04:36,410
布局边界指南和可读内容指南


74
00:04:36,910 --> 00:04:39,012
可以在UIView使用这些属性


75
00:04:39,546 --> 00:04:41,248
在定义视图内容方面


76
00:04:41,715 --> 00:04:44,218
允许更多的表达性


77
00:04:45,919 --> 00:04:49,022
这些会替代我们在iOS 8中
所介绍的布局边界


78
00:04:49,089 --> 00:04:52,092
在编写新代码时 都应使用布局指南
在重新访问旧编码时


79
00:04:52,159 --> 00:04:55,696
也应该将边界替换为布局指南


80
00:04:57,764 --> 00:05:00,033
我准备花些时间
介绍一下第二种情况


81
00:05:00,100 --> 00:05:01,802
可读内容指南


82
00:05:05,472 --> 00:05:07,107
当文本主体很大时


83
00:05:07,708 --> 00:05:10,043
文本行长度与文本的可读性


84
00:05:10,110 --> 00:05:12,446
和易读性都有很大关系


85
00:05:13,847 --> 00:05:16,583
如果文本行太宽就像这样


86
00:05:17,084 --> 00:05:19,319
就很难看到文本行起始位置阅读时


87
00:05:19,686 --> 00:05:22,856
也就很难接上下一行


88
00:05:23,757 --> 00:05:25,659
相反 如果文本行太窄


89
00:05:26,193 --> 00:05:29,997
目光太过频繁地来回转移
则会打断阅读节奏


90
00:05:31,098 --> 00:05:33,967
文本行的理想长度取决于许多因素


91
00:05:34,034 --> 00:05:36,603
包括字体 大小 行距


92
00:05:38,038 --> 00:05:39,773
不过通过使用可读内容指南


93
00:05:40,440 --> 00:05:43,076
可以确保无论用户文本大小


94
00:05:43,143 --> 00:05:44,678
或应用渲染文本的可用空间


95
00:05:45,078 --> 00:05:48,682
如何文本的可读性都不会有问题


96
00:05:51,919 --> 00:05:54,221
我们来谈谈怎样使用布局指南


97
00:05:54,288 --> 00:05:56,757
减少应用中的视图数量


98
00:05:57,791 --> 00:06:00,494
比如说有个视图是要展示若干星球


99
00:06:00,561 --> 00:06:03,630
我们希望以父视图为中心来展示


100
00:06:04,064 --> 00:06:06,667
或是沿着x轴排开


101
00:06:07,201 --> 00:06:09,736
在使用自动布局束缚之前


102
00:06:09,803 --> 00:06:11,505
我们要先在视图层次中引入一系列


103
00:06:11,772 --> 00:06:13,073
额外视图来实现这一点


104
00:06:13,607 --> 00:06:16,443
现在先来定义布局指南


105
00:06:16,510 --> 00:06:20,514
这定义的是视图安排的空间


106
00:06:23,851 --> 00:06:25,886
比例我们也生成了另一组束缚


107
00:06:25,953 --> 00:06:27,588
是以这些视图为中心


108
00:06:29,389 --> 00:06:34,828
然后只需改变活动状态的束缚
就可以实现漂亮的动画是这个样子


109
00:06:35,529 --> 00:06:38,465
本例中 我们同时改变了所有的束缚


110
00:06:39,199 --> 00:06:41,301
但是如果我们是在不同的时间


111
00:06:41,368 --> 00:06:44,838
使用框架动画改变束缚


112
00:06:45,072 --> 00:06:47,241
就会实现诸多非常有趣的效果


113
00:06:51,311 --> 00:06:55,382
在iOS 9我们还将
StackView引入iOS


114
00:06:56,283 --> 00:06:59,820
以便于将子视图作为堆栈管理


115
00:06:59,887 --> 00:07:02,122
可以实现垂直或水平排布


116
00:07:02,389 --> 00:07:05,826
StackView在覆盖下
使用自动布局


117
00:07:05,893 --> 00:07:07,394
不过可以管理所有的束缚


118
00:07:08,862 --> 00:07:11,265
可以调整间隔对齐


119
00:07:11,532 --> 00:07:14,801
可以在可用空间允许均等


120
00:07:14,868 --> 00:07:18,138
或按比例调整视图分配方法


121
00:07:19,239 --> 00:07:21,842
StackViews还可以嵌套


122
00:07:24,011 --> 00:07:26,914
可以将StackView
作为另一个StackView的元素


123
00:07:26,980 --> 00:07:29,183
以便生成非常丰富的布局


124
00:07:30,918 --> 00:07:32,653
这些布局将自动调整


125
00:07:32,719 --> 00:07:35,923
内容显示方式并根据可用空间


126
00:07:36,190 --> 00:07:37,824
进行调整像这样


127
00:07:40,160 --> 00:07:42,629
我们还引入了快捷栏


128
00:07:43,163 --> 00:07:45,199
连上硬件键盘后在屏幕底边


129
00:07:45,666 --> 00:07:48,535
或软件键盘上有显示


130
00:07:49,536 --> 00:07:53,440
快捷栏包括字体控制 如黑体 斜体


131
00:07:53,507 --> 00:07:55,509
下划线 剪切 复制和粘贴


132
00:07:55,976 --> 00:07:58,212
还可以根据应用自定义


133
00:07:59,680 --> 00:08:02,716
符合UI文本输入协议的任何内容


134
00:08:03,317 --> 00:08:06,019
可以返回至使用该方法的辅助输入项


135
00:08:08,188 --> 00:08:11,558
UI文本辅助输入项
是iOS 9中的新分类


136
00:08:12,492 --> 00:08:15,796
有着两个属性用于确定


137
00:08:15,863 --> 00:08:17,531
引导和追踪栏-按钮组


138
00:08:17,598 --> 00:08:19,566
这样就可以轻松
在这里加入自己的元素


139
00:08:23,270 --> 00:08:26,840
现在正如在State of 
the Union专题会所见


140
00:08:26,974 --> 00:08:29,209
我们不再必须在单一的故事板上


141
00:08:29,276 --> 00:08:30,344
为应用准备整个界面


142
00:08:31,011 --> 00:08:33,447
可以将故事板彼此相连


143
00:08:34,648 --> 00:08:37,183
我们还提供了解开引线的方法


144
00:08:44,024 --> 00:08:48,095
我们现在可以在操作系统实现
完全的从右至左支持


145
00:08:49,062 --> 00:08:51,732
如果曾做过从右至左的语言本地化


146
00:08:52,165 --> 00:08:53,967
并在iOS 9上连接了app


147
00:08:54,034 --> 00:08:56,436
这一切也都将在app上自动实现


148
00:08:57,504 --> 00:09:00,240
所有的UI Kit控件都将自动反转


149
00:09:00,807 --> 00:09:02,676
注意导航也发生了反转


150
00:09:03,443 --> 00:09:05,179
所有的动画也都反转


151
00:09:05,546 --> 00:09:08,882
列表视图单元格布局
甚至滑块和开关


152
00:09:08,949 --> 00:09:10,384
也都发生反转


153
00:09:11,752 --> 00:09:14,454
集合视图也会自动反转布局


154
00:09:14,521 --> 00:09:16,190
流向改为从右至左


155
00:09:16,256 --> 00:09:18,892
这里我们看到起始标记的滑动
要求向右滑动


156
00:09:18,959 --> 00:09:22,362
未读标记要求是向左滑动


157
00:09:29,303 --> 00:09:32,906
视图控制器和视图上有两个属性


158
00:09:32,973 --> 00:09:34,908
名为语义内容属性


159
00:09:35,709 --> 00:09:39,246
可以确定内容如何排布


160
00:09:39,413 --> 00:09:42,249
默认状态下 所有内容都会自动反转


161
00:09:43,150 --> 00:09:45,786
不过可以按照应用中


162
00:09:45,853 --> 00:09:48,522
所需通过自定义覆盖这些属性


163
00:09:49,189 --> 00:09:51,558
还有一种方法


164
00:09:52,059 --> 00:09:54,428
可以为具体的内容属性获取布局方向


165
00:09:58,165 --> 00:10:02,135
语义内容属性有着5个值之一


166
00:10:02,269 --> 00:10:04,471
第一个未明确这是默认状态


167
00:10:05,105 --> 00:10:07,407
除非有理由改变
UI Kit做的事情


168
00:10:07,474 --> 00:10:09,176
这个值不用管它


169
00:10:10,811 --> 00:10:15,282
如果有一组控件代表播放


170
00:10:15,949 --> 00:10:17,417
快进和倒退等播放控件


171
00:10:17,918 --> 00:10:20,387
可以使用播放获取布局方向


172
00:10:21,488 --> 00:10:24,057
如果有一组控件代表或导致


173
00:10:25,125 --> 00:10:27,961
UI中出现部分方向改变


174
00:10:28,495 --> 00:10:32,699
例如 文本对齐控件
文本编辑器中的左中右


175
00:10:33,200 --> 00:10:35,269
可以使用获取布局方向


176
00:10:36,270 --> 00:10:38,272
最后 还有两个额外的值


177
00:10:38,605 --> 00:10:40,407
可以执行从左至右


178
00:10:40,474 --> 00:10:41,675
或从右至左的布局


179
00:10:46,380 --> 00:10:49,316
对于图像而言 UI Kit不清楚


180
00:10:49,383 --> 00:10:51,685
图像是否应该在任何情况下都默认反转


181
00:10:51,919 --> 00:10:53,754
比如照片这类用户内容


182
00:10:53,820 --> 00:10:56,490
就不应反转而在应用中的控件部分


183
00:10:56,557 --> 00:10:58,158
则应该进行反转


184
00:10:59,826 --> 00:11:02,663
因此在UI图像的
从左到右有属性或方法


185
00:11:02,763 --> 00:11:07,334
可以让你告诉我们
是否想反转图像


186
00:11:07,901 --> 00:11:10,637
另外还有一个属性可以
询问图像是否已经反转


187
00:11:11,538 --> 00:11:14,107
鼓励大家都到国际界面的


188
00:11:14,174 --> 00:11:16,243
最新UI Kit支持看看了解一下


189
00:11:16,310 --> 00:11:19,613
怎么让app支持从右至左的语言


190
00:11:23,450 --> 00:11:26,153
关于用户友好性现在可以使用


191
00:11:26,220 --> 00:11:28,655
更多的语音 比如
亚历克斯那样以及AV


192
00:11:28,722 --> 00:11:31,592
语音合成中的高质量语音


193
00:11:33,493 --> 00:11:36,396
我鼓励大家在关于 iOS
Accessibility 方面


194
00:11:36,463 --> 00:11:38,765
了解更多怎样让app
实现用户友好性的内容


195
00:11:42,102 --> 00:11:44,371
大家可以看到过我们在iOS 9中


196
00:11:44,838 --> 00:11:47,474
引入一系列最新文本编辑手势


197
00:11:48,242 --> 00:11:52,779
这些手势可以在屏幕底部的键盘上操作


198
00:11:52,980 --> 00:11:54,715
或也可以在文本区操作


199
00:11:55,382 --> 00:11:58,752
它们可以实现间接移动插入点


200
00:11:59,686 --> 00:12:02,389
可以轻松实现选择词语句子或段落


201
00:12:02,456 --> 00:12:05,559
只需多次点击即可


202
00:12:06,393 --> 00:12:09,196
还可以轻松扩展现有的选择


203
00:12:10,430 --> 00:12:12,599
连同我们介绍的快捷栏


204
00:12:13,066 --> 00:12:17,004
你可以轻松访问 复制和粘贴
而无需移动到文本


205
00:12:17,804 --> 00:12:20,641
文本互动操控可以相当轻松便捷


206
00:12:21,508 --> 00:12:24,645
现在在应用中什么都不用做


207
00:12:24,711 --> 00:12:26,780
来运用这些文本编辑手势


208
00:12:27,314 --> 00:12:30,317
不过如果在自己应用中的文本视图中


209
00:12:30,384 --> 00:12:31,451
自定义了这些手势


210
00:12:31,852 --> 00:12:33,320
应该确认不要与


211
00:12:33,387 --> 00:12:34,922
最新的系统文本手势发生冲突


212
00:12:37,925 --> 00:12:41,228
在iOS 7中 我们增加了


213
00:12:41,395 --> 00:12:43,864
发现键盘硬件键盘命令的应用支持


214
00:12:44,865 --> 00:12:46,200
App可以有自己的命令


215
00:12:46,266 --> 00:12:48,302
比如生成新文档的命令


216
00:12:49,369 --> 00:12:50,804
这对已经了解这些命令的用户


217
00:12:50,871 --> 00:12:53,006
很是方便但是无法发现


218
00:12:53,073 --> 00:12:54,708
这些命令是什么


219
00:12:55,642 --> 00:12:59,947
在 iOS 9中 我们引入了
最新键盘命令探索功能


220
00:13:00,647 --> 00:13:05,052
HUD 如果持续按下硬件键盘上的
命令键并且保持片刻


221
00:13:06,553 --> 00:13:09,656
HUD将会显现告知此刻


222
00:13:09,723 --> 00:13:11,992
可用的命令组是什么


223
00:13:12,259 --> 00:13:14,595
注意 这取决于上下文


224
00:13:15,462 --> 00:13:17,164
根据当时应用的状态不同


225
00:13:17,231 --> 00:13:19,233
你会获得不同的命令组


226
00:13:19,366 --> 00:13:22,870
因此 并不是看到整个命令组
部分启动 部分关闭


227
00:13:22,936 --> 00:13:25,672
而是只能看到
目前可以应用的部分


228
00:13:26,507 --> 00:13:29,009
在应用中运用 只需要为
为每个主要命令


229
00:13:29,176 --> 00:13:33,180
设置可探索功能标题


230
00:13:33,413 --> 00:13:35,749
UI Kit可以自动找出


231
00:13:36,049 --> 00:13:38,085
哪些命令在当时可以使用


232
00:13:42,322 --> 00:13:44,258
我们可以聊一聊触屏事件


233
00:13:45,392 --> 00:13:48,362
在屏幕上跟踪在手指和屏幕上


234
00:13:48,996 --> 00:13:53,433
产生的笔触之间会有一些固有延迟


235
00:13:54,401 --> 00:13:57,404
需要花些时间扫描硬件


236
00:13:58,105 --> 00:14:01,208
完成所有中间处理和绘图


237
00:14:01,275 --> 00:14:03,010
再将结果完全显示出来


238
00:14:03,744 --> 00:14:05,879
这就是所谓触屏显示延迟


239
00:14:06,313 --> 00:14:08,782
大部分用户在大多数情况


240
00:14:08,849 --> 00:14:10,584
不会注意到这个延迟


241
00:14:11,185 --> 00:14:13,587
当用户移动手指足够快时
延迟才会明显


242
00:14:14,621 --> 00:14:18,058
尽管iOS已经具备
业界领先的触屏显示延迟


243
00:14:18,125 --> 00:14:23,230
在iOS 9中我们将延迟水平
又做了大幅改进


244
00:14:25,299 --> 00:14:26,967
在屏幕上跟踪跟踪触控时


245
00:14:27,868 --> 00:14:30,404
UI Kit会
随着每次屏幕刷新


246
00:14:30,470 --> 00:14:33,273
通知应用这样应用就可以更新状态


247
00:14:34,441 --> 00:14:36,877
在部分更新款的硬件中


248
00:14:37,678 --> 00:14:40,881
触屏更新的频率要超过显示器


249
00:14:41,949 --> 00:14:45,018
因此在上一次显示器刷新后
现在有新方法


250
00:14:45,085 --> 00:14:47,221
可以访问任何中间触屏


251
00:14:48,522 --> 00:14:52,392
对于绘图应用而言这
可以更流畅更准确地绘图


252
00:14:54,728 --> 00:14:57,264
作为改善触屏显示延迟的第一步


253
00:14:57,331 --> 00:14:59,833
我们现在还可以实现触控预测


254
00:15:01,001 --> 00:15:03,804
这会用到高级算法考虑触控速度


255
00:15:03,871 --> 00:15:06,673
加速度以及曲率


256
00:15:06,974 --> 00:15:08,675
来预测触控的走向


257
00:15:09,610 --> 00:15:13,180
这就可以明显减少绘图时的延迟
因为可以预测出触控


258
00:15:13,247 --> 00:15:16,517
将发生的位置而不是后知后觉


259
00:15:25,626 --> 00:15:26,860
我们其实还不止于此


260
00:15:27,027 --> 00:15:28,829
除了提供触控预测


261
00:15:29,096 --> 00:15:32,065
我们在整个软件堆栈都做了调整


262
00:15:32,132 --> 00:15:36,537
以便进一步降低延迟
我说过60毫秒以上


263
00:15:36,603 --> 00:15:38,405
已经是业界领先水平


264
00:15:38,972 --> 00:15:40,774
我们降到了不足30毫秒


265
00:15:49,449 --> 00:15:52,886
我们还引入了
UI Kit动态的一系列改变


266
00:15:54,121 --> 00:15:57,824
首先是我们支持非矩形碰撞边界


267
00:16:04,932 --> 00:16:07,301
除了矩形我们现在还支持椭圆形


268
00:16:07,367 --> 00:16:08,669
和基于路径的碰撞


269
00:16:08,969 --> 00:16:12,406
这样就会更为接近真实的碰撞相互作用


270
00:16:14,007 --> 00:16:18,145
我们还支持大量的现场行为


271
00:16:19,213 --> 00:16:22,082
我们现在有线性和放射性引力就像这样


272
00:16:22,482 --> 00:16:27,688
弹力 阻力和速度或是噪音和湍流场


273
00:16:27,754 --> 00:16:31,992
就像这样 以及电场和磁场等


274
00:16:32,926 --> 00:16:37,431
我们还支持 定义
自己的场效的能力


275
00:16:40,701 --> 00:16:42,936
最后 我们添加


276
00:16:43,136 --> 00:16:45,239
一些新增额外附件类型


277
00:16:46,106 --> 00:16:48,942
在简单附上两个对象之前


278
00:16:49,009 --> 00:16:51,044
如果想以某种方式束缚它们的运动


279
00:16:51,111 --> 00:16:53,947
必须要设置若干外部束缚


280
00:16:54,414 --> 00:16:56,650
有了这些新增附件类型


281
00:16:56,917 --> 00:17:01,288
可以极大简化构建UI动态模型的过程


282
00:17:05,157 --> 00:17:08,996
我们也添加了模糊半径动画的能力


283
00:17:15,202 --> 00:17:17,938
为实现漂亮的效果就像这样


284
00:17:18,005 --> 00:17:20,073
聚光灯效果的进出


285
00:17:21,808 --> 00:17:25,179
我们还iOS 9中引入了
一系列EPI改进


286
00:17:25,945 --> 00:17:28,182
以优化在Swift中的应用


287
00:17:29,449 --> 00:17:32,953
这是利用Swift的更好表达能力


288
00:17:33,253 --> 00:17:37,858
并改善编译时间类型检查功能


289
00:17:41,094 --> 00:17:44,231
在可空性方面 可以明确属性行为


290
00:17:44,298 --> 00:17:46,400
以及返回值能否为零值


291
00:17:46,466 --> 00:17:49,837
我们已经介绍了整个API定义了


292
00:17:49,903 --> 00:17:52,673
零论证或返回零值


293
00:17:52,973 --> 00:17:54,575
是否担保不为零值


294
00:17:58,111 --> 00:17:59,746
我们还有轻量级泛型


295
00:17:59,880 --> 00:18:02,416
这是轻量级形式的类型参数化


296
00:18:02,816 --> 00:18:06,153
可以实现Cocoa和Cocoa
Touch API的更好表达


297
00:18:06,987 --> 00:18:10,657
例如 UI视图的子视图方式


298
00:18:10,891 --> 00:18:15,295
可以返回UI视图数组
而不仅仅是ID数组


299
00:18:17,231 --> 00:18:19,600
在《Swift最新内容》
讲座中有更多相关内容


300
00:18:23,937 --> 00:18:27,774
iOS 9新增了通知能力
可以实现针对用户的文本输入


301
00:18:27,841 --> 00:18:32,412
或是来自客户的文本输入
速度可以等同于回复文本消息


302
00:18:38,285 --> 00:18:41,889
UI用户通知动作分类
具备新的行为属性


303
00:18:41,955 --> 00:18:44,992
如果设置文本输入行为


304
00:18:46,660 --> 00:18:49,663
通知会有文本字段允许快速回复


305
00:18:55,969 --> 00:18:58,438
还有一个额外的动作参数字典


306
00:18:58,505 --> 00:19:01,275
可允许自定义Send按钮的名称


307
00:19:04,845 --> 00:19:07,514
我们还要介绍最新的
SF Safari视图控制器


308
00:19:08,415 --> 00:19:11,618
这可以实现
用原生语言app显示网络内容


309
00:19:12,419 --> 00:19:15,155
并用所有主要
Safari UI元素所包围


310
00:19:15,222 --> 00:19:17,291
用户对此已经非常熟悉


311
00:19:18,192 --> 00:19:19,760
甚至还可以支持高级功能


312
00:19:19,826 --> 00:19:21,161
比如Reader和自动填表


313
00:19:24,198 --> 00:19:26,700
在《Safari视图控制器介绍》
讲座中 会有更多内容


314
00:19:26,767 --> 00:19:28,869
在iOS 9中 我们引入了
一系列最新扩展点


315
00:19:28,936 --> 00:19:31,371
可实现在系统中扩展其他应用


316
00:19:33,006 --> 00:19:35,375
对于VPN 我们有三个新扩展点


317
00:19:36,009 --> 00:19:38,579
有包隧道提供者可以帮助你


318
00:19:38,645 --> 00:19:41,582
构建自己的
VPN隧道协议客户端


319
00:19:43,250 --> 00:19:46,887
还有app-代理提供者
可以帮助你执行


320
00:19:46,954 --> 00:19:50,524
自己的自定义透明网络代理协议客户端


321
00:19:52,059 --> 00:19:54,494
还有过滤器控制提供方
和过滤器数据提供方


322
00:19:54,595 --> 00:19:57,965
可允许实现动态装置上内容过滤


323
00:19:58,999 --> 00:20:01,068
对于Safari有两个新扩展点


324
00:20:02,336 --> 00:20:05,005
Shared Links可以让应用
明确可以在共享链接


325
00:20:05,072 --> 00:20:08,575
用户种子上显现的内容


326
00:20:10,811 --> 00:20:14,481
内容拦截扩展可允许定义


327
00:20:14,548 --> 00:20:17,818
内容或页面资源的子集


328
00:20:19,853 --> 00:20:23,590
并防止其显现


329
00:20:28,362 --> 00:20:32,399
对于Spotlight
还有一个扩展可以允许系统


330
00:20:34,201 --> 00:20:36,537
对应用数据进行索引
而且还可以在背景完成


331
00:20:37,738 --> 00:20:40,908
这样就无需启动应用来重新对


332
00:20:40,974 --> 00:20:43,110
app内容进行索引


333
00:20:44,745 --> 00:20:46,914
在《App搜索介绍》讲座中
有更多相关内容


334
00:20:50,417 --> 00:20:54,321
最后 音频单元或核心音频插件
可以作为乐器 音效


335
00:20:54,388 --> 00:20:57,457
或音频发生器来使用


336
00:20:58,892 --> 00:21:01,228
直至现在 iOS用户还在仅限于


337
00:21:01,295 --> 00:21:03,864
Apple提供的内置音频单元


338
00:21:05,232 --> 00:21:07,434
在iOS 9中 我们增加了新扩展点


339
00:21:07,501 --> 00:21:10,003
可以将自己的音频单元连入iOS


340
00:21:15,442 --> 00:21:17,811
大家在《音频单元扩展》讲座中
可以了解更多内容


341
00:21:20,047 --> 00:21:22,816
很多人都问到我我也很高兴地宣布


342
00:21:22,883 --> 00:21:26,153
我们已经发布全新Swift
和Objective-C API


343
00:21:26,220 --> 00:21:27,621
用于联系人互动


344
00:21:32,459 --> 00:21:33,126
谢谢


345
00:21:35,596 --> 00:21:38,365
大家在《iOS 10的iOS联系人
框架介绍》中


346
00:21:38,432 --> 00:21:39,566
可以了解更多内容


347
00:21:42,069 --> 00:21:46,373
对于Wallet和Passkit
在银行和商家应用中


348
00:21:46,440 --> 00:21:48,141
现在可以从零开始提供卡片


349
00:21:48,208 --> 00:21:49,610
如果有特殊授权


350
00:21:51,712 --> 00:21:54,748
还可以静默Apple Pay
如果出现了


351
00:21:54,948 --> 00:21:57,551
会影响应用的情况


352
00:21:57,818 --> 00:22:00,954
因此 比如在应用在某种条件下


353
00:22:01,255 --> 00:22:03,557
需要显示条码而且还连有NFC终端


354
00:22:03,891 --> 00:22:05,592
通常会使得Apple Pay显现


355
00:22:05,659 --> 00:22:08,095
可以静默这个功能这样才能扫描条码


356
00:22:08,829 --> 00:22:12,499
在核心位置app连接到iOS 9


357
00:22:12,566 --> 00:22:13,834
或是晚些时候


358
00:22:13,901 --> 00:22:16,203
背景位置跟踪会有些改变


359
00:22:17,604 --> 00:22:21,875
在CL Location 
Manager上还有新的API


360
00:22:22,743 --> 00:22:24,711
要求一次位置更新


361
00:22:24,778 --> 00:22:28,282
如果不需要持续更新位置


362
00:22:28,348 --> 00:22:29,783
这是更为有效方式


363
00:22:29,917 --> 00:22:31,151
来获得用户的当前位置


364
00:22:37,024 --> 00:22:40,227
对于MapKit 有若干新功能
具备地图视图


365
00:22:40,394 --> 00:22:42,963
第一是访问
3d Flyover View


366
00:22:47,968 --> 00:22:50,971
现在可以显示流量
以及量表和刻度尺


367
00:22:51,839 --> 00:22:54,341
已生成自己的自定义调出


368
00:23:00,047 --> 00:23:03,684
在HealthKit中 可以直接
实时访问 Watch OS 2


369
00:23:03,750 --> 00:23:05,252
传感器数据还有若干新数据类型


370
00:23:06,820 --> 00:23:08,822
跟踪用户水分的摄入量


371
00:23:09,423 --> 00:23:13,160
跟踪其在阳光下暴露的时间


372
00:23:13,393 --> 00:23:14,595
以及生殖健康


373
00:23:15,863 --> 00:23:18,632
新款API可实现
更好的HealthKit


374
00:23:18,699 --> 00:23:21,502
数据设备跟踪更好地支持删除数据


375
00:23:22,102 --> 00:23:25,172
以及跟踪锻炼的新款练习会话API


376
00:23:25,572 --> 00:23:28,876
几个月前 我们公布了
ResearchKit


377
00:23:28,976 --> 00:23:30,577
可以用于开发人员和研究人员


378
00:23:31,144 --> 00:23:32,913
创建医药研究app


379
00:23:34,248 --> 00:23:36,717
ResearchKit现在包括
iPad支持...


380
00:23:36,783 --> 00:23:38,952
PureTone
Audiometry


381
00:23:39,019 --> 00:23:41,388
的新活动任务可用于确定


382
00:23:41,455 --> 00:23:44,024
听力阈值水平


383
00:23:44,691 --> 00:23:47,094
以及简单反应时任务


384
00:23:47,160 --> 00:23:49,630
以便衡量用户
对事件的反应时间


385
00:23:50,464 --> 00:23:52,999
还有一种
图像捕捉步骤可供使用


386
00:23:53,901 --> 00:23:57,037
正如大家昨天所见
我们对HomeKit做了部分调整


387
00:23:58,939 --> 00:24:01,441
我们现在可以支持详细
变更通知


388
00:24:01,975 --> 00:24:03,243
灯亮起时


389
00:24:03,744 --> 00:24:07,681
就可以获得具体的委托信息


390
00:24:08,315 --> 00:24:12,152
明确特点和改动的配件


391
00:24:12,319 --> 00:24:15,689
因此现在可以让具体的灯亮起


392
00:24:15,756 --> 00:24:18,725
而不是泛泛地房间里有改动通知


393
00:24:21,261 --> 00:24:24,364
HomeKit有4个预定义动作组 


394
00:24:24,631 --> 00:24:28,268
早上醒来出门到家


395
00:24:28,335 --> 00:24:31,738
上床睡觉你可以完成
这些标准动作


396
00:24:31,805 --> 00:24:34,908
关灯 锁门这类事情


397
00:24:34,975 --> 00:24:36,410
确保车库门关好


398
00:24:36,510 --> 00:24:39,780
所有这类问题都无需用户另行配置


399
00:24:43,717 --> 00:24:46,854
在iOS 8可以生成定时触发器


400
00:24:46,920 --> 00:24:48,522
实现执行计划场景


401
00:24:49,556 --> 00:24:53,360
在iOS 9可以生成
更为复杂的触发器


402
00:24:53,994 --> 00:24:56,063
例如 要知道 当门锁打开时


403
00:24:56,230 --> 00:24:58,565
动作传感器检测到动作


404
00:24:58,665 --> 00:25:02,002
这是在日出后30分钟发生的事情


405
00:25:05,138 --> 00:25:07,608
当然 Watch上还有
HomeKit 可以用手表


406
00:25:07,674 --> 00:25:10,210
直接控制家中的设备


407
00:25:12,346 --> 00:25:15,516
有Wi-fi功能的附件
可以远程连接


408
00:25:15,749 --> 00:25:17,818
即便没有Apple TV也没关系


409
00:25:18,852 --> 00:25:20,988
还可以与它们通过iCloud


410
00:25:21,722 --> 00:25:22,823
直接沟通


411
00:25:22,990 --> 00:25:25,092
有蓝牙功能的配件


412
00:25:25,692 --> 00:25:27,661
可以自动连上Wi-Fi


413
00:25:28,795 --> 00:25:31,265
即便超出了配件的蓝牙有效范围


414
00:25:31,331 --> 00:25:32,633
也依然可以控制


415
00:25:34,134 --> 00:25:36,937
最后我们在家中的若干新项中


416
00:25:37,004 --> 00:25:38,472
加入标准定义


417
00:25:42,910 --> 00:25:46,146
对于CloudKit而言我们更新了


418
00:25:46,213 --> 00:25:48,081
公共数据库的限制和定价


419
00:25:48,415 --> 00:25:50,784
但是更令人兴奋的是
我们可以实现...


420
00:25:50,851 --> 00:25:52,886
CloudKit 
WebServices


421
00:25:53,120 --> 00:25:54,521
来整合网络应用


422
00:25:59,459 --> 00:26:01,562
本周还有两个讲座
是关于CloudKit 


423
00:26:02,296 --> 00:26:05,299
《CloudKit最新内容》
和《CloudKit诀窍和技巧》


424
00:26:08,535 --> 00:26:10,270
至此为止 UI文档


425
00:26:10,337 --> 00:26:12,105
和动作控制器
会将发送给其他app的


426
00:26:12,172 --> 00:26:14,074
每个文档都进行备份


427
00:26:15,475 --> 00:26:18,278
现在 只要打开到位
只要是在iCloud中储存 


428
00:26:18,345 --> 00:26:21,148
app可以要求直接打开文档


429
00:26:22,282 --> 00:26:25,419
可以在info.plist中


430
00:26:25,819 --> 00:26:26,820
添加秘钥


431
00:26:26,887 --> 00:26:28,655
声明适合执行新的代理方式


432
00:26:28,722 --> 00:26:29,923
来直接打开文件即可


433
00:26:32,326 --> 00:26:35,128
我们将在《构建基于文档的app》
讲座中详细讨论这个问题


434
00:26:39,466 --> 00:26:42,536
现在 许多应用包括的资源在用户首次


435
00:26:42,603 --> 00:26:44,638
开启应用时并不需要


436
00:26:45,873 --> 00:26:48,675
将app可能会用到的每个资源
都包括在内  会令app


437
00:26:48,742 --> 00:26:52,346
捆绑包太过庞大影响安装速度


438
00:26:52,412 --> 00:26:54,381
甚至会导致超出OTA限制


439
00:26:54,448 --> 00:26:55,949
这会影响销售


440
00:26:57,417 --> 00:27:00,888
为解决这个问题我们来介绍按需资源


441
00:27:01,822 --> 00:27:05,526
应用会上传单一的文件包
恰巧是满足当天


442
00:27:07,427 --> 00:27:09,396
所需 但是当应用有需求时


443
00:27:09,463 --> 00:27:10,797
内容可以动态下载


444
00:27:11,465 --> 00:27:14,868
这些资产都是运用基于输入信息


445
00:27:14,935 --> 00:27:17,571
以及用户行为的启发式逻辑
处于智能化缓存状态


446
00:27:21,408 --> 00:27:25,145
在Xcode中 资产都是
使用简单标签分组


447
00:27:25,212 --> 00:27:26,113
我们先来讲讲...


448
00:27:26,180 --> 00:27:29,049
NS BundleResource
Request 的新分类


449
00:27:29,516 --> 00:27:32,452
这可以实现用给定的标签要求所有资源


450
00:27:33,720 --> 00:27:37,357
一旦这些资源得以下载
你可以使用熟悉的API去访问


451
00:27:37,424 --> 00:27:39,826
　比如UI图像命名图像等


452
00:27:41,628 --> 00:27:44,431
还有办法在Xcode中进行检测


453
00:27:44,498 --> 00:27:47,534
模拟并未获得资源
而对服务器提出要求


454
00:27:47,601 --> 00:27:49,736
Xcode可以像服务器一般工作


455
00:27:49,870 --> 00:27:52,172
向应用发送相应资源


456
00:27:53,340 --> 00:27:55,375
现在 我们介绍另一种新技术


457
00:27:55,542 --> 00:27:58,312
来解决应用大小的问题就是app分割


458
00:28:00,881 --> 00:28:05,018
现在 应用常带有与用户安装的硬件


459
00:28:05,085 --> 00:28:06,486
不相关的资产和可执行内容


460
00:28:06,920 --> 00:28:11,058
这一分割技术可以提供用户设备


461
00:28:11,124 --> 00:28:14,728
所需的资源和可执行内容部分


462
00:28:16,296 --> 00:28:18,966
使用应用分割技术
处理App Store


463
00:28:19,066 --> 00:28:23,470
可以自动生成并为运行


464
00:28:24,738 --> 00:28:26,673
iOS 9的设备提供应用的定制变量


465
00:28:26,740 --> 00:28:28,876
这其中只包括设备相关的资源
和可执行内容部分


466
00:28:30,477 --> 00:28:31,678
在服务器运用这种技术


467
00:28:31,745 --> 00:28:34,214
不相关的内容甚至都不会下载


468
00:28:35,749 --> 00:28:37,184
这会节省安装时间


469
00:28:37,251 --> 00:28:39,286
并有希望将app处于OTA限制以下


470
00:28:41,688 --> 00:28:45,025
我们还要介绍最新的
NS数据资产分类


471
00:28:45,092 --> 00:28:48,095
和设备上的这可以轻松获取根据内存


472
00:28:48,161 --> 00:28:50,030
图像处理能力定制的内容


473
00:28:50,797 --> 00:28:54,401
现在来看Game Center 
我们加入了嘉宾玩家功能  


474
00:28:54,468 --> 00:28:57,104
在Game Center的多玩家
模式中 实现了新的配置


475
00:28:58,839 --> 00:29:01,909
我们还统一了Game Center
服务器环境


476
00:29:01,975 --> 00:29:03,977
以便于开发和测试的流线化


477
00:29:05,679 --> 00:29:07,714
最后 我们来介绍ReplayKit


478
00:29:07,881 --> 00:29:11,585
这可以提供
分享游戏体验的新方法


479
00:29:12,853 --> 00:29:15,756
可以实现app轻松录制视频和音频


480
00:29:15,822 --> 00:29:17,958
并与其他用户分享


481
00:29:20,160 --> 00:29:23,063
在iOS 9中 SpriteKit
支持Metal


482
00:29:23,130 --> 00:29:24,731
适用于相应的系统支持


483
00:29:25,365 --> 00:29:28,068
对于不支持Metal的系统
它是开放式GL


484
00:29:28,502 --> 00:29:30,804
这些都是自动完成无需人工干预


485
00:29:32,472 --> 00:29:34,441
还有一个全新的动作编辑器


486
00:29:36,176 --> 00:29:39,680
当然它与按需资源紧密整合


487
00:29:42,482 --> 00:29:44,885
在《SpriteKit最新内容》
讲座中有更多详情


488
00:29:47,554 --> 00:29:51,558
对于SceneKit在Xcode中
有全新的场景编辑器


489
00:29:51,625 --> 00:29:54,361
可以支持粒子 物理 


490
00:29:54,661 --> 00:29:56,029
动作等等 


491
00:29:56,930 --> 00:29:59,867
SceneKit还有相当多的新功能


492
00:30:01,235 --> 00:30:05,305
场景转换 音频节点 模型i/o 


493
00:30:05,973 --> 00:30:09,943
环境光遮蔽 光照图
以及许多其它功能


494
00:30:12,846 --> 00:30:15,916
SpriteKit和
SceneKit是构建游戏


495
00:30:15,983 --> 00:30:18,085
图形界面的强大框架


496
00:30:18,719 --> 00:30:21,455
对于游戏它的强大之处
不仅在于图像能力


497
00:30:23,590 --> 00:30:25,926
游戏有实体和组件部分


498
00:30:26,159 --> 00:30:31,131
还有代理在游戏中都有着目标和行为


499
00:30:32,666 --> 00:30:35,402
需要发现路径算法
允许代理在游戏附近导航


500
00:30:35,469 --> 00:30:39,206
还需要AI允许代理决定之后


501
00:30:39,606 --> 00:30:41,842
要采取怎样的行动


502
00:30:44,278 --> 00:30:45,379
参与游戏所需的所有


503
00:30:45,445 --> 00:30:48,615
这些元素现在都可在
GameplayKit中找到


504
00:30:48,682 --> 00:30:52,085
在《GameplayKit介绍》
讲座中还可以了解更多详情


505
00:30:52,719 --> 00:30:55,656
最后当然 我们要谈谈
WatchOS 2


506
00:30:56,123 --> 00:30:59,092
除了直接访问现有的框架


507
00:30:59,193 --> 00:31:01,828
还有新框架如Watch连结性


508
00:31:02,229 --> 00:31:07,301
将app与电话和WatchKit
连结 来搭建Watch表盘组件


509
00:31:09,837 --> 00:31:12,039
在《WatchOS 2 
WatchKit介绍》中


510
00:31:12,105 --> 00:31:13,240
可以了解更多详情


511
00:31:13,307 --> 00:31:15,509
本周所有讲座
的综述在《探讨WatchOS 2》


512
00:31:15,876 --> 00:31:17,377
中有介绍


513
00:31:19,580 --> 00:31:21,782
若要了解更多信息
当然有文件资料


514
00:31:22,549 --> 00:31:25,552
有在线论坛开发人员技术支持


515
00:31:26,753 --> 00:31:28,188
谢谢希望大家这周过得愉快

