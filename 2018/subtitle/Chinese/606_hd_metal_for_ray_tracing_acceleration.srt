1
00:00:17,084 --> 00:00:21,221 line:0
（Metal光线追踪加速技术
演讲606）


2
00:00:23,590 --> 00:00:24,625 line:-1
嗨 各位


3
00:00:25,092 --> 00:00:28,128 line:-2
我是Sean James
是GPU软件工程师


4
00:00:28,695 --> 00:00:30,964 line:-1
今天 我们将会讨论光线追踪技术


5
00:00:31,465 --> 00:00:33,333 line:-1
你们可能已经在“国情咨文”中


6
00:00:33,400 --> 00:00:36,036 line:-2
看过我们的光线追踪演示
而且想要了解更多


7
00:00:36,770 --> 00:00:39,473 line:-2
也许你们想要在自己的app中
使用光线追踪技术


8
00:00:40,007 --> 00:00:44,011 line:-2
今天 我将会介绍
如何在app中使用光线追踪


9
00:00:44,144 --> 00:00:47,514 line:-2
以及如何使用Metal
在GPU上进行加速


10
00:00:48,549 --> 00:00:51,285 line:-2
特别会介绍如何
使用Metal性能着色器


11
00:00:52,586 --> 00:00:56,323 line:-2
Metal性能着色器
是一个GPU计算基元


12
00:00:56,456 --> 00:00:59,760 line:-2
已经针对所有iOS
和macOS设备进行优化


13
00:01:00,961 --> 00:01:03,463 line:-1
MPS内置图像处理


14
00:01:03,664 --> 00:01:05,866 line:-1
线性代数和机器学习支持功能


15
00:01:06,800 --> 00:01:10,337 line:-2
在前面的演讲里
我们大量讨论了这些主题


16
00:01:11,305 --> 00:01:14,241 line:-1
今年 我们还增加了训练支持功能


17
00:01:14,908 --> 00:01:17,444 line:-1
关于这个主题 明天会有一个演讲


18
00:01:18,345 --> 00:01:19,213 line:-1
今天…


19
00:01:19,279 --> 00:01:22,916 line:-2
我将会介绍今年我们
为光线追踪添加的新支持功能


20
00:01:23,750 --> 00:01:25,953 line:-2
那么我们首先要问
什么是光线追踪？


21
00:01:27,788 --> 00:01:30,891 line:-2
光线追踪app的基本原理是
在光线与场景互动时


22
00:01:30,958 --> 00:01:33,594 line:-1
追踪光线的路径


23
00:01:34,561 --> 00:01:37,931 line:-2
光线可以建模光照、声音
和其他形式的能量


24
00:01:38,498 --> 00:01:42,503 line:-1
光线追踪在渲染、音频


25
00:01:42,569 --> 00:01:43,837 line:-1
和物理仿真方面均有应用


26
00:01:44,872 --> 00:01:47,875 line:-1
但是光线也可以表示更抽象的概念


27
00:01:47,941 --> 00:01:50,377 line:-2
比如是否可以从一个点
看到另一个点


28
00:01:51,278 --> 00:01:54,181 line:-1
因此光线追踪还可以应用于冲撞检测


29
00:01:54,248 --> 00:01:56,817 line:-1
人工智能和路径寻找


30
00:01:57,951 --> 00:02:00,654 line:-1
但是今天我将会以渲染为例


31
00:02:00,721 --> 00:02:03,190 line:-1
讲述如何在app中使用光线追踪


32
00:02:05,125 --> 00:02:07,694 line:-1
你们可以已经熟悉光栅化管道程序


33
00:02:08,328 --> 00:02:09,696 line:-1
光栅化工作原理是


34
00:02:09,763 --> 00:02:12,900 line:-1
一次将一个三角形投影到屏幕上


35
00:02:13,133 --> 00:02:15,035 line:-1
并且投射相应像素点的阴影


36
00:02:15,669 --> 00:02:18,639 line:-2
在GPU硬件中
可以很快地实现此效果


37
00:02:18,839 --> 00:02:20,274 line:-1
因此很多游戏和其他实时app


38
00:02:20,340 --> 00:02:22,643 line:-1
都选择使用此方法


39
00:02:24,244 --> 00:02:25,412 line:-1
但是光栅化模型


40
00:02:25,946 --> 00:02:29,049 line:-1
难以模拟光线的特定物理行为


41
00:02:30,784 --> 00:02:32,386 line:-1
其中一个例子是反射


42
00:02:33,053 --> 00:02:34,188 line:-1
在光栅化方法中


43
00:02:34,254 --> 00:02:37,124 line:-1
反射通常是使用近似方法实现的


44
00:02:37,191 --> 00:02:39,693 line:-2
例如立方体贴图
屏幕空间反射


45
00:02:40,627 --> 00:02:41,628 line:-1
但使用光线追踪器


46
00:02:41,695 --> 00:02:44,464 line:-2
我们可以直接计算
精确的反射效果


47
00:02:45,866 --> 00:02:47,401 line:-1
另一个例子是阴影


48
00:02:48,168 --> 00:02:49,269 line:-1
在光栅化方法中


49
00:02:49,336 --> 00:02:51,972 line:-2
通常使用阴影贴图
来实现阴影效果


50
00:02:52,472 --> 00:02:54,007 line:-1
但是在实施会遇到一些问题


51
00:02:54,074 --> 00:02:56,944 line:-1
比如偏差和分辨率问题


52
00:02:57,744 --> 00:02:58,612 line:-1
此外


53
00:02:58,779 --> 00:03:02,549 line:-2
软阴影贴图技术
会产生不均匀的软阴影


54
00:03:03,717 --> 00:03:04,818 line:-1
利用光线追踪技术


55
00:03:04,985 --> 00:03:08,388 line:-2
我们可以直接计算
确定点是否在阴影之中


56
00:03:08,822 --> 00:03:10,490 line:-1
因此可以生成清晰的阴影


57
00:03:10,757 --> 00:03:13,994 line:-1
包括在物体之间的距离增大时


58
00:03:14,061 --> 00:03:16,163 line:-1
生成从硬到软的真实阴影过渡效果


59
00:03:18,532 --> 00:03:20,834 line:-1
最后一个例子是球形淡出


60
00:03:22,202 --> 00:03:24,838 line:-2
它模拟光线在场景表面上的
淡出效果


61
00:03:25,706 --> 00:03:29,476 line:-2
使用光栅化方法
很难实现球形淡出效果


62
00:03:29,743 --> 00:03:32,613 line:-2
但是使用光线追踪器
却可以进行十分自然的建模


63
00:03:33,013 --> 00:03:35,516 line:-1
事实上 许多游戏和实时app


64
00:03:35,582 --> 00:03:37,718 line:-1
都包含球形淡出效果组件


65
00:03:37,985 --> 00:03:40,454 line:-2
这些组件使用光线追踪器
进行预计算


66
00:03:40,621 --> 00:03:42,422 line:-1
然后将结果存储到材质之中


67
00:03:42,556 --> 00:03:45,192 line:-1
在运行时映射到几何形状上


68
00:03:47,327 --> 00:03:50,797 line:-2
当然 我们还可以使用
光线追踪器模拟许多其他效果


69
00:03:50,864 --> 00:03:54,801 line:-2
例如环境光遮蔽
折射和面光源


70
00:03:55,169 --> 00:03:58,238 line:-2
以及摄像机效果
例如景深和运动模糊


71
00:03:59,573 --> 00:04:01,375 line:-1
因此 光线追踪技术被用于


72
00:04:01,441 --> 00:04:04,511 line:-1
许多高真实性离线渲染app


73
00:04:05,879 --> 00:04:07,381 line:-1
光线追踪技术的不足之处是


74
00:04:07,447 --> 00:04:09,583 line:-1
相比于光栅化方法


75
00:04:09,650 --> 00:04:10,751 line:-1
它需要明显更多的计算资源


76
00:04:10,984 --> 00:04:12,386 line:-1
因为需要进行更多的计算


77
00:04:12,452 --> 00:04:13,787 line:-1
来模拟这些效果


78
00:04:15,088 --> 00:04:16,356 line:-1
让我们来详细了解


79
00:04:16,423 --> 00:04:18,492 line:-1
光线追踪器的渲染原理


80
00:04:18,559 --> 00:04:21,060 line:-2
然后了解如何
使用Metal进行加速


81
00:04:23,597 --> 00:04:25,532 line:-1
我们使用名为路径追踪的算法


82
00:04:26,500 --> 00:04:29,403 line:-2
在现实世界中
光源发射光子


83
00:04:29,570 --> 00:04:32,873 line:-2
它们在周围反射
直到进入摄像机或你的眼睛


84
00:04:33,907 --> 00:04:37,077 line:-2
但是大多数光子
实际上并没有进入摄像机


85
00:04:37,377 --> 00:04:39,580 line:-1
因此模拟效率非常低


86
00:04:40,547 --> 00:04:41,515 line:-1
幸运的是…


87
00:04:41,782 --> 00:04:44,718 line:-2
根据光线的属性
我们可以进行反向推理


88
00:04:44,785 --> 00:04:46,153 line:-1
从摄像机开始


89
00:04:47,187 --> 00:04:51,892 line:-2
我们将光线从摄像机
投射到场景之中


90
00:04:53,460 --> 00:04:55,863 line:-1
然后计算交叉点的阴影


91
00:04:56,797 --> 00:04:58,198 line:-1
在生成阴影时 需要明白


92
00:04:58,265 --> 00:05:00,767 line:-1
多少光线到达阴影点


93
00:05:01,235 --> 00:05:04,705 line:-2
以及哪一部分的光线
反射到摄像机


94
00:05:05,572 --> 00:05:08,809 line:-2
实际上有两个光源
我们将会分别讨论


95
00:05:10,777 --> 00:05:12,679 line:-1
第一个光源是直射光线


96
00:05:13,213 --> 00:05:14,982 line:-1
此光线从光源


97
00:05:15,048 --> 00:05:17,017 line:-1
直接到达阴影点


98
00:05:18,218 --> 00:05:21,388 line:-2
我们可以轻松地计算出
多少光线会直接到达


99
00:05:21,455 --> 00:05:24,525 line:-2
以及哪一部分光线
会反射到摄像机


100
00:05:25,158 --> 00:05:26,159 line:-1
我们需要做的是


101
00:05:26,226 --> 00:05:29,096 line:-1
在将光线添加到图像之前


102
00:05:29,162 --> 00:05:31,164 line:-1
检查阴影点是否位于阴影之中


103
00:05:32,566 --> 00:05:35,569 line:-2
为此 我们可以从阴影点位置
朝向光源


104
00:05:35,636 --> 00:05:37,738 line:-1
投射更多阴影光线


105
00:05:39,006 --> 00:05:41,775 line:-1
如果阴影光线不能到达光源


106
00:05:41,842 --> 00:05:44,044 line:-2
那么原始阴影点
就位于阴影之中


107
00:05:44,278 --> 00:05:46,446 line:-1
我们不应该为图像添加光照效果


108
00:05:48,916 --> 00:05:51,218 line:-1
另一个光源是非直射光线


109
00:05:52,085 --> 00:05:54,288 line:-2
这是场景中
在到达阴影点之前


110
00:05:54,354 --> 00:05:56,857 line:-1
从其他表面反射的光线


111
00:05:57,991 --> 00:05:59,493 line:-1
为了收集非直射光线


112
00:05:59,560 --> 00:06:02,329 line:-2
我们可以从阴影点
朝向随机方向


113
00:06:02,396 --> 00:06:03,597 line:-1
投射二次光线


114
00:06:04,631 --> 00:06:08,402 line:-2
然后我们在第二个交叉点
重复阴影效果流程


115
00:06:09,903 --> 00:06:12,940 line:-1
首先计算多少光线


116
00:06:13,006 --> 00:06:14,708 line:-1
直接到达第二个交叉点


117
00:06:15,042 --> 00:06:17,477 line:-2
以及哪一部分光线
会被反射回来


118
00:06:17,544 --> 00:06:19,446 line:-1
朝向前一个交叉点


119
00:06:19,746 --> 00:06:21,849 line:-1
最终进入摄像机


120
00:06:22,916 --> 00:06:24,918 line:-1
我们需要从二次交叉点


121
00:06:24,985 --> 00:06:26,820 line:-1
投射另一束阴影光线


122
00:06:28,989 --> 00:06:31,658 line:-1
我们可以多次重复这个过程


123
00:06:31,892 --> 00:06:33,861 line:-1
以模拟场景中的光线反射


124
00:06:36,964 --> 00:06:39,099 line:-2
现在 为了获得
这些美观的软阴影


125
00:06:39,166 --> 00:06:40,601 line:-1
和反射光线效果…


126
00:06:41,134 --> 00:06:43,937 line:-1
对于路径上的每个点


127
00:06:44,004 --> 00:06:45,372 line:-2
我们都需要投射许多阴影光线
和二次光线


128
00:06:46,507 --> 00:06:49,576 line:-1
反射光线数量


129
00:06:49,643 --> 00:06:50,911 line:-1
将会呈指数增长


130
00:06:51,912 --> 00:06:53,647 line:-1
为了避免这种指数增长


131
00:06:54,414 --> 00:06:56,316 line:-1
我们只会选一条阴影光线


132
00:06:56,383 --> 00:06:58,919 line:-2
和每次反射时的
一个二次光线方向


133
00:07:00,087 --> 00:07:02,122 line:-1
这时图像中有很多噪讯


134
00:07:02,589 --> 00:07:05,526 line:-2
但是我们可以通过多帧叠加
使图像变得均匀


135
00:07:06,260 --> 00:07:09,129 line:-2
每个帧将会生成
自己的一次光线集合


136
00:07:09,196 --> 00:07:12,499 line:-1
因此我们能够实施摄像机效果


137
00:07:12,566 --> 00:07:14,401 line:-1
例如景深和运动模糊


138
00:07:16,570 --> 00:07:18,572 line:-2
让我们将这些过程
转换成为一个流程图


139
00:07:20,007 --> 00:07:21,909 line:-1
首先 我们生成一次光线


140
00:07:22,910 --> 00:07:24,811 line:-1
然后找到场景中的交叉点


141
00:07:26,313 --> 00:07:28,849 line:-1
计算交叉点位置的阴影


142
00:07:28,982 --> 00:07:31,218 line:-1
请记住 这是一个迭代过程


143
00:07:31,285 --> 00:07:34,188 line:-1
将会产生更多的阴影和二次光线


144
00:07:34,254 --> 00:07:36,290 line:-2
将会在场景中
再次产生交叉点


145
00:07:36,890 --> 00:07:38,525 line:-1
最后 将阴影颜色


146
00:07:38,592 --> 00:07:39,660 line:-1
写入图像


147
00:07:40,961 --> 00:07:43,297 line:-1
这是渲染app的流程


148
00:07:43,630 --> 00:07:45,399 line:-1
但是 大量的时间


149
00:07:45,465 --> 00:07:48,268 line:-2
实际上被花费在
光线三角形交叉测试上


150
00:07:49,403 --> 00:07:51,705 line:-1
这意味着 交叉区的渲染性能


151
00:07:51,772 --> 00:07:54,608 line:-1
对总体渲染性能有很大的影响


152
00:07:54,675 --> 00:07:57,411 line:-1
即使它与实际光照和阴影无关


153
00:07:58,478 --> 00:08:00,280 line:-1
这个核心交叉问题


154
00:08:00,347 --> 00:08:02,916 line:-2
是所有光线追踪app
都会面临的问题


155
00:08:04,785 --> 00:08:07,821 line:-2
因此我们决定
解决这个核心交叉问题


156
00:08:08,088 --> 00:08:10,924 line:-1
以实现高水平的交叉区性能


157
00:08:11,091 --> 00:08:13,193 line:-1
并且专注于app的细节


158
00:08:14,728 --> 00:08:15,562 line:-1
为此 今年


159
00:08:15,629 --> 00:08:18,398 line:-2
我们引入了
MPSRayIntersector API


160
00:08:19,633 --> 00:08:22,970 line:-2
这个API加速
所有macOS设备


161
00:08:23,136 --> 00:08:24,238 line:-1
和iOs设备的


162
00:08:24,571 --> 00:08:27,107 line:-1
GPU上的光线三角线交叉测试


163
00:08:28,542 --> 00:08:31,345 line:-2
我们希望这个API能够
很容易地集成到现有app之中


164
00:08:31,478 --> 00:08:33,746 line:-2
因此我们通过Metal缓冲区
简单地接收光线


165
00:08:34,648 --> 00:08:37,351 line:-2
MPS将会沿每条光线
寻找最近的交叉点


166
00:08:37,885 --> 00:08:39,953 line:-2
然后在另一个Metal缓冲区中
返回结果


167
00:08:40,754 --> 00:08:41,889 line:-1
你只需要


168
00:08:42,389 --> 00:08:45,392 line:-2
在app中提供
一个Metal指令缓冲区


169
00:08:45,459 --> 00:08:47,561 line:-2
在这个缓冲区中
执行交叉测试


170
00:08:47,928 --> 00:08:49,763 line:-1
我们会将所有交叉测试工作


171
00:08:49,830 --> 00:08:51,298 line:-1
编码到指令缓冲区中


172
00:08:52,766 --> 00:08:55,335 line:-2
让我们来更深入地分析
我们想要解决的问题


173
00:08:59,706 --> 00:09:00,541 line:-1
好的


174
00:09:01,742 --> 00:09:05,179 line:-2
3D模型通常表示为
三角形阵列


175
00:09:06,079 --> 00:09:08,949 line:-2
我们需要做的事情是
搜索这些三角形


176
00:09:09,149 --> 00:09:11,652 line:-2
找出哪些三角形
与每条光线交叉


177
00:09:12,920 --> 00:09:14,555 line:-1
此外 我们需要分析


178
00:09:14,688 --> 00:09:17,591 line:-2
哪些交叉点最接近
光线的起点


179
00:09:19,126 --> 00:09:20,761 line:-1
最简单的方法是


180
00:09:20,961 --> 00:09:22,896 line:-1
循环遍历所有三角形


181
00:09:22,963 --> 00:09:24,698 line:-1
检查光线的交叉点


182
00:09:25,332 --> 00:09:28,735 line:-2
但是 即使是最小的场景
这个过程也会非常慢


183
00:09:29,903 --> 00:09:33,740 line:-2
因此 我们创建了一个数据结构
名为“加速结构”


184
00:09:34,675 --> 00:09:35,742 line:-1
加速结构的工作原理


185
00:09:35,809 --> 00:09:39,146 line:-2
是递归地将场景划分为
多个三角形组


186
00:09:39,213 --> 00:09:41,148 line:-2
组中的三角形
在空间中相互邻近


187
00:09:42,482 --> 00:09:44,618 line:-1
当需要将一条光线与场景交叉时


188
00:09:45,118 --> 00:09:47,654 line:-1
将光线与树中的边界方框进行交叉


189
00:09:48,355 --> 00:09:51,992 line:-2
如果光线未与边界方框交叉
就可以跳过整个子树


190
00:09:53,093 --> 00:09:54,661 line:-1
最后 我们只需要


191
00:09:54,728 --> 00:09:56,396 line:-1
检查一小部分的三角形


192
00:09:56,463 --> 00:09:57,931 line:-1
以确定光线交叉


193
00:09:59,066 --> 00:10:00,100 line:-1
我们主要使用这方法


194
00:10:00,167 --> 00:10:02,035 line:-1
加速光线三角形交叉检查


195
00:10:03,303 --> 00:10:05,539 line:-1
当然 这是一个简单的例子


196
00:10:06,106 --> 00:10:07,107 line:-1
在实际场景中


197
00:10:07,174 --> 00:10:09,843 line:-1
加速结构可能会更加复杂


198
00:10:11,378 --> 00:10:14,581 line:-1
从这个图示中 我们可以看出


199
00:10:14,648 --> 00:10:16,984 line:-2
加速结构正在适应
复杂的几何形状


200
00:10:17,851 --> 00:10:19,786 line:-1
这意味着 我们的大多数时间


201
00:10:19,853 --> 00:10:23,824 line:-2
仅用于搜索高复杂性
几何区域中的交叉点


202
00:10:24,024 --> 00:10:25,025 line:-1
这正是我们想要的


203
00:10:26,460 --> 00:10:28,795 line:-2
我描述了加速结构是什么
以及它是如何工作


204
00:10:29,029 --> 00:10:31,965 line:-1
让你们有直观的感受


205
00:10:32,466 --> 00:10:34,668 line:-2
但实际上你们并不需要
过分关心这些内容


206
00:10:35,002 --> 00:10:37,070 line:-2
因为MPS将会为你们
处理所有的工作


207
00:10:39,039 --> 00:10:41,241 line:-2
请记住 我们使用三角形
建模我们的场景


208
00:10:41,808 --> 00:10:43,844 line:-2
这些三角形本身
可以使用顶点缓冲区中的


209
00:10:43,911 --> 00:10:45,779 line:-1
顶点进行表示


210
00:10:46,813 --> 00:10:50,784 line:-2
你只需要 调用MPS
顶点缓冲区中


211
00:10:50,851 --> 00:10:52,052 line:-1
创建一个加速结构


212
00:10:53,387 --> 00:10:55,122 line:-1
当准备搜索交叉时


213
00:10:55,289 --> 00:10:57,157 line:-1
只需要将这个加速结构


214
00:10:57,224 --> 00:10:58,525 line:-1
提供给交叉区域


215
00:10:59,693 --> 00:11:02,262 line:-2
让我们来看如何使用此方法
创建一个真实app


216
00:11:03,463 --> 00:11:05,465 line:-1
我们将这个app划分为三个阶段


217
00:11:05,899 --> 00:11:10,003 line:-2
首先 我们生成一次光线
找到光线与场景的交叉点


218
00:11:10,070 --> 00:11:11,338 line:-1
然后计算阴影


219
00:11:11,972 --> 00:11:13,574 line:-2
这类似于我们使用
光栅化方法


220
00:11:13,640 --> 00:11:14,775 line:-1
实现的效果


221
00:11:15,108 --> 00:11:16,910 line:-2
但在接下来的步骤中
我们会更进一步


222
00:11:18,245 --> 00:11:19,680 line:-1
接下来 我们将会添加阴影


223
00:11:20,013 --> 00:11:22,316 line:-1
MPS提供特殊的阴影光线支持


224
00:11:22,516 --> 00:11:24,518 line:-1
可以加快app速度


225
00:11:26,119 --> 00:11:26,987 line:-1
最后


226
00:11:27,054 --> 00:11:29,189 line:-1
我们使用二次光线


227
00:11:29,256 --> 00:11:30,624 line:-1
模拟场景中的光线反射


228
00:11:31,391 --> 00:11:33,694 line:-2
使用光栅化方法很难
实现这种效果


229
00:11:33,760 --> 00:11:35,729 line:-2
但是 我们看到
使用光线追踪技术


230
00:11:35,796 --> 00:11:36,930 line:-1
很容易做到这一点


231
00:11:38,665 --> 00:11:40,133 line:-1
让我们从一次光线开始


232
00:11:41,401 --> 00:11:43,537 line:-1
我们需要做五件事


233
00:11:44,404 --> 00:11:46,974 line:-2
首先 我们创建一个
光线三角形交叉检查器


234
00:11:48,542 --> 00:11:50,043 line:-1
然后 在我们的顶点缓冲区中


235
00:11:50,110 --> 00:11:51,345 line:-1
创建一个加速结构


236
00:11:53,480 --> 00:11:56,884 line:-2
接下来 我们生成一次光线
将它们写入光线缓冲区


237
00:11:58,719 --> 00:12:01,822 line:-2
然后 我们使用
Intersector


238
00:12:01,889 --> 00:12:03,257 line:-1
寻找光线与场景间的交叉区


239
00:12:04,024 --> 00:12:04,958 line:-1
最后


240
00:12:05,025 --> 00:12:07,694 line:-2
最后我们使用交叉区结果
计算阴影效果


241
00:12:09,263 --> 00:12:10,731 line:-1
我们先来看Intersector


242
00:12:12,566 --> 00:12:14,468 line:-1
MPSRayIntersector类


243
00:12:14,768 --> 00:12:17,304 line:-1
协调所有光线三角交叉区测试结果


244
00:12:18,305 --> 00:12:21,041 line:-2
我们只需要提供
想要用于交叉测试的


245
00:12:21,108 --> 00:12:23,043 line:-1
Metal设备


246
00:12:25,312 --> 00:12:27,314 line:-1
接下来 我们将创建加速结构


247
00:12:28,982 --> 00:12:29,917 line:-1
此加速结构用


248
00:12:29,983 --> 00:12:32,686 line:-2
MPSTriangle
AccelerationStructure类表示


249
00:12:33,120 --> 00:12:36,456 line:-2
同样地 要创建加速结构
我们只需要提供用于创建Intersector的


250
00:12:36,523 --> 00:12:38,158 line:-1
相同Metal设备


251
00:12:40,027 --> 00:12:43,230 line:-2
然后 加入我们的vertexBuffer
指定triangleCount


252
00:12:44,298 --> 00:12:46,967 line:-1
最后 我们创建加速结构


253
00:12:47,534 --> 00:12:48,869 line:0
只需要创建一次


254
00:12:48,936 --> 00:12:51,338 line:0
然后 就可以重复地


255
00:12:51,405 --> 00:12:52,739 line:0
多次使用这个加速结构


256
00:12:56,677 --> 00:12:59,947 line:-2
接下来 将生成一次光线
将它们写入光线缓冲区


257
00:13:01,148 --> 00:13:03,951 line:-2
为此 将启动
一个双线程计算内核


258
00:13:04,117 --> 00:13:05,652 line:-1
每个像素一个线程


259
00:13:06,486 --> 00:13:09,823 line:-2
每个线程将这个光线结构
写入光线缓冲区


260
00:13:11,458 --> 00:13:13,126 line:-1
可以设想 输出图像


261
00:13:13,193 --> 00:13:15,629 line:-1
在摄像机正方的平面上飘浮


262
00:13:17,397 --> 00:13:19,366 line:-1
一次光线从摄像机中发出


263
00:13:19,433 --> 00:13:21,768 line:-2
因此我以将原点
设置为摄像机位置


264
00:13:22,703 --> 00:13:24,004 line:-1
为了计算方向


265
00:13:24,471 --> 00:13:26,840 line:-1
将从摄像机位置寻找方向


266
00:13:27,007 --> 00:13:29,343 line:-1
穿过图像平面上的相应像素点


267
00:13:32,546 --> 00:13:34,047 line:-1
现在 已经生成一次光线


268
00:13:34,114 --> 00:13:36,583 line:-2
将用Intersector
寻找场景中的交叉区域


269
00:13:38,285 --> 00:13:40,087 line:-1
encodeIntersection调用


270
00:13:40,153 --> 00:13:42,456 line:-2
将我们创建的所有项目
关联在一起


271
00:13:43,457 --> 00:13:46,793 line:-2
首先请记住 我们将会编码到
一个Metal指令缓冲区之中


272
00:13:47,928 --> 00:13:49,162 line:-1
实际上 我们有多个选项


273
00:13:49,229 --> 00:13:51,498 line:-1
来选择进行哪种类型的交叉区搜索


274
00:13:51,999 --> 00:13:53,634 line:-1
本例中 我们使用最近的交叉区


275
00:13:53,700 --> 00:13:56,336 line:-1
将沿每条光线寻找最近的交叉区


276
00:13:58,172 --> 00:13:59,640 line:-1
然后 提供光线缓冲区


277
00:13:59,706 --> 00:14:02,776 line:-1
此缓冲区包含我们刚创建的一次光线


278
00:14:03,410 --> 00:14:04,778 line:-1
另外还提供交叉区缓冲区


279
00:14:04,845 --> 00:14:06,613 line:-1
此缓冲区包含交叉区结果


280
00:14:07,848 --> 00:14:09,583 line:-1
还需要提供rayCount


281
00:14:09,816 --> 00:14:11,485 line:-1
在本例中 它是图像宽度


282
00:14:11,552 --> 00:14:12,619 line:-1
乘以图像高度


283
00:14:13,787 --> 00:14:16,290 line:-1
最后 提供我们的加速结构


284
00:14:17,724 --> 00:14:20,494 line:-2
MPS将会沿每条光线
寻找最近的交叉区


285
00:14:20,561 --> 00:14:22,829 line:-1
并在交叉区缓冲中返回结果


286
00:14:23,230 --> 00:14:25,632 line:-2
最后剩下的工作是
使用交叉区数据


287
00:14:25,699 --> 00:14:26,700 line:-1
计算阴影


288
00:14:28,669 --> 00:14:30,771 line:-2
为此 我们启动
另外一个计算内核


289
00:14:31,705 --> 00:14:33,440 line:-1
可以像在片段着色器中那样


290
00:14:33,507 --> 00:14:35,742 line:-1
app光照和材质


291
00:14:36,043 --> 00:14:38,612 line:-1
在片段着色器中可以使用的


292
00:14:38,679 --> 00:14:40,547 line:-1
大多数标准材质和数学函数


293
00:14:40,714 --> 00:14:42,616 line:-1
都可以在计算内核中使用


294
00:14:43,784 --> 00:14:46,753 line:-2
但是一般来说
阴影取决于交叉点


295
00:14:46,820 --> 00:14:49,489 line:-2
和顶点属性
例如颜色和形态


296
00:14:50,023 --> 00:14:53,594 line:-2
在片段着色器中
GPU将为我们完成这些插值


297
00:14:53,927 --> 00:14:55,729 line:-1
但我们需要它们在交叉数据的基础上


298
00:14:55,796 --> 00:14:57,297 line:-1
自己进行插值


299
00:14:58,866 --> 00:15:01,368 line:-1
因此 让我们来看如何计算交叉点


300
00:15:03,237 --> 00:15:06,373 line:0
请记住
光线使用源点和方向进行定义


301
00:15:09,510 --> 00:15:12,779 line:0
这是Intersector
返回的交叉区结构


302
00:15:13,547 --> 00:15:15,249 line:0
距离字段告诉我们


303
00:15:15,315 --> 00:15:17,618 line:0
需要在光线方向行进多远的距离


304
00:15:17,951 --> 00:15:20,454 line:0
才能从光线起点到达交叉点


305
00:15:21,088 --> 00:15:24,324 line:0
如果光线不会与任何物体交叉
此距离将是负值


306
00:15:26,527 --> 00:15:29,296 line:0
primitiveIndex
告诉我们遇到哪个三角形


307
00:15:30,330 --> 00:15:33,767 line:0
我们使用最后一个字段
进行顶点属性插值


308
00:15:35,169 --> 00:15:37,771 line:-1
这个字段包含前两个质心坐标


309
00:15:37,838 --> 00:15:39,039 line:-1
即U和V


310
00:15:39,473 --> 00:15:42,242 line:-1
第三个坐标对应于交叉点相对于


311
00:15:42,309 --> 00:15:44,211 line:-1
三角形顶点的


312
00:15:45,579 --> 00:15:47,714 line:-1
实际上有三个质心坐标


313
00:15:47,781 --> 00:15:48,982 line:-1
组成一个坐标集合


314
00:15:49,216 --> 00:15:51,652 line:-1
因此我们可以用1减去前两个坐标


315
00:15:51,818 --> 00:15:53,954 line:-1
计算出第三个坐标W


316
00:15:55,589 --> 00:15:59,092 line:-2
如果仅定义三角形的
每个顶点的顶点属性


317
00:15:59,459 --> 00:16:01,395 line:-1
插入的顶点属性


318
00:16:02,329 --> 00:16:05,566 line:-1
仅仅是每个顶点的属性相加


319
00:16:05,632 --> 00:16:07,534 line:-1
并使用质心坐标加权


320
00:16:08,302 --> 00:16:11,205 line:-1
例如 如果设定每个顶点的颜色


321
00:16:11,271 --> 00:16:12,673 line:-1
那么插值颜色


322
00:16:12,739 --> 00:16:15,442 line:-1
就是每个顶点的颜色加权和


323
00:16:18,178 --> 00:16:20,480 line:-2
到此为止 我们创建了
一个光线Intersector


324
00:16:20,981 --> 00:16:22,583 line:-1
一个加速结构


325
00:16:23,584 --> 00:16:25,452 line:-1
然后生成一次光线


326
00:16:25,686 --> 00:16:27,521 line:-1
找到光线与场景的交叉区


327
00:16:28,288 --> 00:16:30,324 line:-1
在交叉点计算阴影


328
00:16:30,390 --> 00:16:32,793 line:-2
然后 我们将阴影颜色
写入图像


329
00:16:32,993 --> 00:16:34,361 line:-1
让我们来看图像


330
00:16:36,063 --> 00:16:39,199 line:-2
我们可以看到加速结构
表示的几何形状


331
00:16:39,399 --> 00:16:42,736 line:-2
以及插值顶点颜色
和计算出的光照效果


332
00:16:43,904 --> 00:16:45,372 line:-1
图像已经显示在屏幕上


333
00:16:45,439 --> 00:16:47,241 line:-1
我们添加一些其他效果


334
00:16:48,742 --> 00:16:51,011 line:0
首先 为图像增加阴影


335
00:16:53,447 --> 00:16:55,315 line:-1
为此 在添加阴影之前


336
00:16:55,883 --> 00:16:58,252 line:-1
需要检查


337
00:16:58,318 --> 00:16:59,953 line:-1
光线是否可以到达阴影点


338
00:17:00,888 --> 00:17:03,557 line:-2
为此 可以添加
更多的阴影光线


339
00:17:03,690 --> 00:17:06,026 line:-1
从交叉点投射到光源


340
00:17:07,594 --> 00:17:10,130 line:-1
如果阴影光线不能到达光源


341
00:17:10,196 --> 00:17:12,532 line:-1
那么初始阴影点就不是阴影


342
00:17:12,633 --> 00:17:14,667 line:-1
因此不应该添加其颜色到图像


343
00:17:17,704 --> 00:17:19,339 line:-1
我们将修改阴影内核


344
00:17:19,806 --> 00:17:22,910 line:-2
将附加阴影光线
写入另一个Metal缓冲区


345
00:17:24,444 --> 00:17:27,114 line:-2
然后 我们再次寻找
场景交叉区


346
00:17:28,115 --> 00:17:30,017 line:-1
然后启动最后一个内核


347
00:17:30,083 --> 00:17:33,220 line:-2
此内核根据阴影光线
是否与任何物体交叉


348
00:17:33,287 --> 00:17:35,889 line:-2
有条件地
将阴影颜色写入图像


349
00:17:36,990 --> 00:17:39,092 line:-1
因此 让我们开始修改阴影内核


350
00:17:40,894 --> 00:17:43,597 line:-2
现在 阴影光线略微
不同于一次光线


351
00:17:44,198 --> 00:17:45,032 line:-1
首先…


352
00:17:45,098 --> 00:17:47,768 line:-2
我们需要提供
一个最大交叉距离


353
00:17:47,901 --> 00:17:50,571 line:-2
这样 阴影光线
不会偏离光线


354
00:17:52,539 --> 00:17:54,908 line:-2
我们不需要知道
将会遇到哪个三角形


355
00:17:54,975 --> 00:17:56,910 line:-1
或质心坐标是多少


356
00:17:56,977 --> 00:17:58,912 line:-1
因此我们可以进行一些优化


357
00:18:00,314 --> 00:18:01,215 line:-1
最后…


358
00:18:01,281 --> 00:18:04,117 line:-2
记住 我们不能
将阴影颜色写入图像


359
00:18:04,184 --> 00:18:07,254 line:-2
除非我们知道原始阴影点
是否位于阴影之中


360
00:18:07,821 --> 00:18:11,058 line:-2
因此我们需要一种方法
通过Intersector将颜色


361
00:18:11,124 --> 00:18:14,127 line:-2
从阴影内核
传递到最终内核


362
00:18:14,194 --> 00:18:15,596 line:-1
这将会更新图像


363
00:18:16,296 --> 00:18:18,632 line:-2
为此 可以自定义
我们的光线结构


364
00:18:22,302 --> 00:18:23,904 line:-1
我们有多个选项


365
00:18:23,971 --> 00:18:26,507 line:-2
选择为Intersector
提供哪些数据


366
00:18:27,140 --> 00:18:28,742 line:-2
本例中
我们将使用一个数据类型


367
00:18:28,809 --> 00:18:31,445 line:-1
它包含最小和最大距离字段


368
00:18:32,379 --> 00:18:35,449 line:-2
MPS将会忽略
此范围之外的任何交叉


369
00:18:35,649 --> 00:18:38,552 line:-2
从而防止阴影射线
偏离光源


370
00:18:40,187 --> 00:18:41,054 line:-1
其次…


371
00:18:41,288 --> 00:18:44,758 line:-1
如果应用特定的光线相关数据


372
00:18:45,125 --> 00:18:47,261 line:-2
可以将这些数据追加到
光线结构的末尾


373
00:18:47,327 --> 00:18:48,996 line:-1
并且提供一个rayStride


374
00:18:49,730 --> 00:18:52,866 line:-2
MPS从你的光线缓冲区读取数据时
将会跳过此数据


375
00:18:53,867 --> 00:18:54,701 line:-1
在本例中


376
00:18:54,768 --> 00:18:57,004 line:-2
我们将阴影颜色添加到
光线结构的末尾


377
00:18:57,070 --> 00:18:59,339 line:-1
这样 可以将它从阴影内核


378
00:18:59,406 --> 00:19:00,607 line:-1
传递到最后内核


379
00:19:02,242 --> 00:19:04,611 line:-2
我们可以在光线Intersector上
配置这些选项


380
00:19:05,312 --> 00:19:06,146 line:0
首先…


381
00:19:06,346 --> 00:19:08,649 line:0
设置rayDataType
以匹配我们的结构类型


382
00:19:10,651 --> 00:19:11,885 line:0
然后 设置rayStride


383
00:19:11,952 --> 00:19:14,188 line:0
以跳过结构末尾的颜色


384
00:19:16,590 --> 00:19:18,859 line:-2
接下来 通过Intersector
运行阴影光线


385
00:19:20,894 --> 00:19:22,996 line:0
这是Intersector
首次调用


386
00:19:23,564 --> 00:19:26,200 line:0
记住 阴影光线仅检查


387
00:19:26,266 --> 00:19:28,836 line:0
原始阴影点与光源之间的可见性


388
00:19:28,902 --> 00:19:30,704 line:0
我们可以进行两项优化


389
00:19:31,538 --> 00:19:34,908 line:0
与自定义
rayDataType一样


390
00:19:34,975 --> 00:19:37,377 line:0
我们可以自定义
Intersection数据类型


391
00:19:37,711 --> 00:19:40,380 line:0
或Intersector的
返回数据类型


392
00:19:41,982 --> 00:19:45,152 line:0
在本例中只需要知道
距离是否为正值或负值


393
00:19:45,219 --> 00:19:46,820 line:0
表示是否存在交叉


394
00:19:47,454 --> 00:19:50,324 line:-2
因此可以将intersection数据类型
设置为distance


395
00:19:50,724 --> 00:19:52,326 line:-1
这会节省一些内存带宽


396
00:19:52,392 --> 00:19:55,162 line:-2
加快Intersection
缓冲区读写速度


397
00:19:57,497 --> 00:19:58,332 line:0
其次


398
00:19:58,398 --> 00:20:00,968 line:0
由于并不需要知道
将会遇到哪个三角形


399
00:20:01,034 --> 00:20:04,404 line:0
因此可以在遇到任意三角形时
结束交叉搜索


400
00:20:04,705 --> 00:20:05,672 line:0
通常情况下


401
00:20:05,739 --> 00:20:08,375 line:0
这比搜索最近交叉点的速度更快


402
00:20:09,142 --> 00:20:12,112 line:0
对此 MPS有一个专用模式
可以启用它


403
00:20:12,312 --> 00:20:15,349 line:0
方法是传递任意intersectionType
而不是传递nearest


404
00:20:18,385 --> 00:20:22,222 line:-2
最后 可以启动最后内核
将颜色添加到图像


405
00:20:24,191 --> 00:20:28,929 line:-2
每个线程将读入一阴影光线和相应的
intersection数据


406
00:20:30,297 --> 00:20:32,332 line:-1
如果交叉间距为正值


407
00:20:32,533 --> 00:20:34,902 line:-1
那么原始交叉点位于阴影之中


408
00:20:35,269 --> 00:20:36,703 line:-1
不需要做其他工作


409
00:20:37,504 --> 00:20:39,907 line:-1
否则 交叉点不在阴影之中


410
00:20:41,275 --> 00:20:44,745 line:-2
因此 应读入光线颜色
将它写入输出图像


411
00:20:45,979 --> 00:20:48,282 line:-2
这样就可以将阴影
添加到图像之中


412
00:20:50,817 --> 00:20:53,587 line:-2
我们可以看到
在添加光照到图像之前


413
00:20:53,654 --> 00:20:56,757 line:-2
每个阴影点检查
光源是否可见


414
00:20:57,591 --> 00:20:59,193 line:-1
由于我们使用光线追踪器


415
00:20:59,660 --> 00:21:02,429 line:-2
因此可以随机采样
光源的表面


416
00:21:02,496 --> 00:21:04,398 line:-1
为我们提供这些美观的软阴影


417
00:21:07,301 --> 00:21:09,403 line:-1
最后 让我们来看二次光源


418
00:21:11,205 --> 00:21:14,608 line:-2
记住 二次光线模拟
场景反射光线


419
00:21:15,709 --> 00:21:19,947 line:-2
为了添加二次光源
只需要把所有内核移入一个循环流程


420
00:21:20,480 --> 00:21:23,383 line:-2
在每次迭代中
将选择一个新随机方向


421
00:21:23,450 --> 00:21:24,918 line:-1
以沿续光线路径


422
00:21:29,790 --> 00:21:31,358 line:-1
然后 修改阴影内核


423
00:21:31,592 --> 00:21:34,194 line:-1
为下次迭代生成光线


424
00:21:35,162 --> 00:21:36,964 line:-1
完成图像更新之后


425
00:21:37,364 --> 00:21:40,200 line:-1
循环回到第一次交叉测试


426
00:21:40,734 --> 00:21:44,171 line:-2
可以根据需要的反射次数
重复这个循环流程


427
00:21:47,274 --> 00:21:49,409 line:-1
我们来看阴影内核修改


428
00:21:51,945 --> 00:21:53,080 line:-1
在每次迭代中


429
00:21:53,480 --> 00:21:55,816 line:-1
我们将光线起点移至交叉点


430
00:21:57,651 --> 00:22:00,087 line:-2
然后选择一个随机方向
以继续光线路径


431
00:22:01,388 --> 00:22:02,289 line:-1
最后


432
00:22:02,923 --> 00:22:05,893 line:-1
将光线颜色与插值顶点颜色相乘


433
00:22:06,894 --> 00:22:08,996 line:-1
这样光线就会使用


434
00:22:09,062 --> 00:22:11,031 line:-1
表面反射的颜色


435
00:22:11,832 --> 00:22:13,400 line:-1
在更高级的app中


436
00:22:13,467 --> 00:22:16,036 line:-1
计算将会更加复杂


437
00:22:16,436 --> 00:22:18,872 line:-1
但是 通过认真选择随机光线方向


438
00:22:18,939 --> 00:22:21,475 line:-1
可以取消其余的数学计算


439
00:22:22,543 --> 00:22:25,245 line:-2
即使从摄像机反向投射光线
也同样可行


440
00:22:25,479 --> 00:22:27,981 line:-2
只要在每个交叉点
使用光线颜色


441
00:22:28,048 --> 00:22:30,117 line:-1
严格地为直射光线着色


442
00:22:31,785 --> 00:22:33,687 line:-2
对于二次光线
这就是我们要做的事情


443
00:22:35,155 --> 00:22:38,125 line:-1
光线可以从墙面反射到


444
00:22:38,192 --> 00:22:40,594 line:-1
箱子侧面和天花板上


445
00:22:42,129 --> 00:22:43,564 line:-1
这是我们的示例app


446
00:22:44,865 --> 00:22:48,802 line:0
最初 屏幕上显示一幅图像
上面有一次光线和着色


447
00:22:49,670 --> 00:22:51,071 line:0
然后我们添加阴影


448
00:22:51,438 --> 00:22:52,306 line:0
最后


449
00:22:52,372 --> 00:22:55,309 line:0
使用二次光线模拟
场景中的光线反射


450
00:22:56,176 --> 00:22:59,847 line:0
让我们切换到演示
看看实时运行效果


451
00:23:03,951 --> 00:23:08,755 line:-2
这是我们编写的app运行在
12.9英寸iPad Pro上


452
00:23:09,656 --> 00:23:11,558 line:-1
我们可以扩展此app


453
00:23:11,892 --> 00:23:15,629 line:-2
以支持更高级的光照
阴影、材质和其他效果


454
00:23:16,096 --> 00:23:18,565 line:-1
让我们切换到更复杂的场景


455
00:23:18,732 --> 00:23:20,501 line:-1
这个场景使用了许多这样的特性


456
00:23:25,973 --> 00:23:28,108 line:-1
这是Amazon Lumberyard Bistro场景


457
00:23:28,175 --> 00:23:31,912 line:-2
在“国情咨文”中运行
使用四个GPU


458
00:23:32,713 --> 00:23:35,148 line:-1
这个场景有将近一百万个三角形


459
00:23:35,482 --> 00:23:37,985 line:-2
但是 使用这些先进的
光照和着色技术


460
00:23:38,051 --> 00:23:39,286 line:-1
我们仍能在iPad Pro上


461
00:23:39,353 --> 00:23:42,022 line:-2
实现将近两千万条光线/秒的
处理速度


462
00:23:42,456 --> 00:23:45,192 line:-2
这是一个综合指标
包括一次光线


463
00:23:45,259 --> 00:23:46,827 line:-1
阴影和二次光线


464
00:23:48,362 --> 00:23:51,498 line:-1
我们创建了便于使用的API


465
00:23:51,698 --> 00:23:54,835 line:-2
你们现在就可以使用它们
开始实施这些类型的app


466
00:23:56,069 --> 00:23:57,571 line:-1
这是我们的演示例子


467
00:23:59,239 --> 00:24:00,140 line:-1
谢谢


468
00:24:03,477 --> 00:24:05,312 line:-2
如果你们没有完全理解
也不用着急


469
00:24:05,479 --> 00:24:08,482 line:-2
这个app作为例子
将会提供下载


470
00:24:09,116 --> 00:24:12,085 line:-2
这个例子演示了
我今天讲述的所有内容


471
00:24:12,686 --> 00:24:15,389 line:-1
强烈建议你们下载这个示例


472
00:24:15,556 --> 00:24:18,792 line:-2
添加你们自己的几何
光照、阴影等等


473
00:24:19,560 --> 00:24:21,495 line:-1
关于API 还有很多的内容


474
00:24:21,562 --> 00:24:23,297 line:-1
今天没有时间逐一讲解


475
00:24:23,797 --> 00:24:25,165 line:-1
因此 建议你们查看


476
00:24:25,232 --> 00:24:27,000 line:-1
文件和头文件


477
00:24:27,868 --> 00:24:30,304 line:-1
接下来 把舞台交给同事Wayne


478
00:24:30,737 --> 00:24:33,373 line:-2
他将会介绍我们如何
将这项技术扩展到多GPU平台


479
00:24:35,542 --> 00:24:36,376 line:-1
谢谢


480
00:24:42,149 --> 00:24:42,983 line:-1
谢谢Sean


481
00:24:43,550 --> 00:24:44,384 line:-1
大家好


482
00:24:47,988 --> 00:24:49,590 line:-1
你们很多人使用Mac计算机


483
00:24:50,424 --> 00:24:52,226 line:-1
它有一个内置GPU


484
00:24:52,559 --> 00:24:56,363 line:-2
但是你们可能添加了
多个高性能eGPU


485
00:24:57,464 --> 00:25:01,301 line:-1
我们希望能够使用所有这些GPU


486
00:25:01,368 --> 00:25:04,104 line:-1
以尽量提高光线追踪速度


487
00:25:05,272 --> 00:25:06,473 line:-1
我们应该怎么做？


488
00:25:06,840 --> 00:25:07,708 line:-1
我们需要


489
00:25:07,774 --> 00:25:09,309 line:-1
考虑三件事情


490
00:25:10,277 --> 00:25:11,178 line:-1
首先


491
00:25:11,512 --> 00:25:14,281 line:-2
我们如何在GPU之间
分配处理工作量？


492
00:25:15,749 --> 00:25:16,583 line:-1
其次


493
00:25:17,284 --> 00:25:20,387 line:-2
有时候 GPU需要
一种方法来交换数据


494
00:25:20,721 --> 00:25:22,623 line:-1
我们如何处理这个问题？


495
00:25:23,824 --> 00:25:24,658 line:-1
最后


496
00:25:24,725 --> 00:25:26,760 line:-1
还需要一个同步方法


497
00:25:27,594 --> 00:25:30,163 line:-2
对此 我将介绍如何使用
新的Metal Events特性


498
00:25:30,230 --> 00:25:31,798 line:-1
本周我们进行了相关的介绍


499
00:25:32,666 --> 00:25:33,767 line:-1
让我们开始


500
00:25:35,335 --> 00:25:36,537 line:-1
对于如何划分处理工作量


501
00:25:36,603 --> 00:25:39,006 line:-2
我们将会使用名称为
Split Frame Rendering的方法


502
00:25:39,806 --> 00:25:42,976 line:-1
其原理是将帧分为多个区域


503
00:25:43,043 --> 00:25:46,346 line:-2
然后将这些区域
分配给不同的GPU


504
00:25:46,880 --> 00:25:48,448 line:-1
从而可以并行地进行渲染


505
00:25:49,883 --> 00:25:50,851 line:-1
现在 每个GPU


506
00:25:50,918 --> 00:25:53,820 line:-2
都将运行完整渲染管道
前面Sean已经讲过


507
00:25:54,121 --> 00:25:56,590 line:-2
这包括所有的处理
从初始光线生成


508
00:25:56,924 --> 00:25:59,026 line:-1
到阴影光线和着色


509
00:26:00,360 --> 00:26:02,196 line:-1
所有GPU完成处理之后


510
00:26:02,262 --> 00:26:04,965 line:-1
我们选择连接到显示的GPU


511
00:26:05,732 --> 00:26:07,968 line:-1
将会复制所有已经完成的区域


512
00:26:08,035 --> 00:26:08,902 line:-1
以进行合成


513
00:26:10,537 --> 00:26:11,471 line:-1
合成是将各个区域


514
00:26:11,538 --> 00:26:13,307 line:-1
拼接在一起


515
00:26:13,373 --> 00:26:15,309 line:-1
然后放入帧缓冲区


516
00:26:16,043 --> 00:26:19,179 line:-2
你可能想要将它们
与先前的渲染组合在一起


517
00:26:19,246 --> 00:26:21,448 line:-1
以增强图像质量和消除噪讯


518
00:26:23,550 --> 00:26:25,485 line:-1
在开始进行渲染之前


519
00:26:25,619 --> 00:26:28,822 line:-2
需要确保每个GPU
都有完整的场景副本


520
00:26:30,123 --> 00:26:33,227 line:-1
需要在所有GPU上复制资产


521
00:26:33,293 --> 00:26:35,462 line:-1
例如顶点缓冲区和材质


522
00:26:36,563 --> 00:26:38,432 line:-1
然后 创建Sean前面说过的


523
00:26:38,498 --> 00:26:39,867 line:-1
三角形加速结构


524
00:26:42,436 --> 00:26:44,705 line:-1
现在… 对于加速结构


525
00:26:44,771 --> 00:26:47,808 line:-1
不需要为每个GPU


526
00:26:47,875 --> 00:26:48,976 line:0
重头进行创建


527
00:26:49,510 --> 00:26:54,147 line:0
我们添加一个API
让你能够使用现有的加速结构


528
00:26:54,214 --> 00:26:56,850 line:0
为每个想要使用的GPU
生成一个副本


529
00:26:58,118 --> 00:27:00,587 line:0
这个副本是非递归性的


530
00:27:01,088 --> 00:27:04,091 line:0
因此 添加到加速结构的任何缓冲区


531
00:27:04,224 --> 00:27:06,693 line:0
例如顶点和索引缓冲区


532
00:27:07,628 --> 00:27:09,096 line:0
都需要单独复制它们


533
00:27:09,162 --> 00:27:11,431 line:0
然后 将它们添加到


534
00:27:11,498 --> 00:27:12,766 line:0
刚才创建的加速结构


535
00:27:16,203 --> 00:27:19,039 line:-2
现在 已经在所有GPU上
复制数据


536
00:27:19,106 --> 00:27:20,340 line:-1
准备开始渲染


537
00:27:21,975 --> 00:27:24,845 line:-2
从多GPU角度来的
一件有趣的事情是


538
00:27:24,912 --> 00:27:28,048 line:-2
这部分的管道
其实与Sean前面描述的渲染管道


539
00:27:28,115 --> 00:27:29,383 line:-1
没有什么差别


540
00:27:30,250 --> 00:27:32,619 line:-1
唯一的差别在于对于多GPU


541
00:27:32,819 --> 00:27:35,989 line:-1
需要设定各个GPU所负责的


542
00:27:36,056 --> 00:27:37,891 line:-1
屏幕区域的光线生成工作


543
00:27:38,458 --> 00:27:39,893 line:-1
其他部分都是相同的


544
00:27:40,894 --> 00:27:41,929 line:-1
因此


545
00:27:41,995 --> 00:27:46,099 line:-2
让我们直接来看
多GPU方案中最复杂的阶段


546
00:27:46,500 --> 00:27:48,769 line:-1
也就是合成阶段


547
00:27:51,371 --> 00:27:54,007 line:-1
为了在macOS上获得最佳性能


548
00:27:54,074 --> 00:27:57,077 line:-2
每个GPU都将渲染结果
放入自己的私有缓冲区


549
00:27:58,078 --> 00:28:01,081 line:-2
渲染完成后
我们将缓冲区复制到


550
00:28:01,148 --> 00:28:03,817 line:-1
用于进行合成的GPU


551
00:28:04,985 --> 00:28:07,187 line:-1
不能直接在缓冲区之间进行复制


552
00:28:07,254 --> 00:28:09,723 line:-1
因为Metal资源只能


553
00:28:09,790 --> 00:28:10,791 line:-1
在创建这些资源的设备上使用


554
00:28:11,425 --> 00:28:13,427 line:-2
因此 不能在一个GPU上
创建缓冲区


555
00:28:13,493 --> 00:28:16,230 line:-2
然后尝试将它添加到
不同GPU的Blit编码器


556
00:28:16,296 --> 00:28:17,598 line:-1
这样是不行的


557
00:28:18,832 --> 00:28:21,568 line:-2
这意味着 我们的副本
将需要经过系统内存


558
00:28:23,370 --> 00:28:25,472 line:-1
为了提高效率


559
00:28:25,539 --> 00:28:27,741 line:-1
我们使用缓冲区管理


560
00:28:29,343 --> 00:28:31,111 line:-1
我们创建两个Metal缓冲区


561
00:28:31,378 --> 00:28:34,882 line:-1
每台设备一个包装通用CPU分配


562
00:28:36,016 --> 00:28:38,652 line:-1
由于缓冲区包装相同的底层内存


563
00:28:39,052 --> 00:28:42,022 line:-2
在设备A上写入
Metal缓冲区的任何内容


564
00:28:42,489 --> 00:28:45,192 line:-2
对于设备B上的Metal缓冲区
来说都是可见的


565
00:28:46,927 --> 00:28:48,128 line:-1
如前所述


566
00:28:48,795 --> 00:28:50,731 line:-1
为了确保macOS上的处理性能


567
00:28:51,131 --> 00:28:54,368 line:-2
所有这些实际渲染工作
都使用私有缓冲区完成


568
00:28:55,169 --> 00:28:58,205 line:-1
然后 当需复制区域到不同GPU时


569
00:28:58,272 --> 00:29:00,307 line:-2
我们通过系统内存
Blit完成的区域


570
00:29:02,142 --> 00:29:03,944 line:-1
来看如何进行设置


571
00:29:05,012 --> 00:29:08,815 line:-2
首先 使用Metal共享存储模式
在设备A上创建缓冲区


572
00:29:09,783 --> 00:29:12,152 line:-1
这将会在内部分配系统内存


573
00:29:12,553 --> 00:29:15,522 line:-2
使用.contents方法
指向此内存区域


574
00:29:18,625 --> 00:29:20,460 line:-1
然后在设备B上创建缓冲区时


575
00:29:20,761 --> 00:29:25,032 line:-2
使用NoCopy API包装
刚才为缓冲区分配的内存


576
00:29:27,000 --> 00:29:29,136 line:-1
对于此API 需要知道的是


577
00:29:29,203 --> 00:29:32,406 line:-1
缓冲区必须是多页面大小


578
00:29:32,472 --> 00:29:35,442 line:-2
因此在创建原始缓冲区时
必须设置合适的内存大小


579
00:29:38,745 --> 00:29:41,381 line:-1
现在 我们可以在设备之间共享内存


580
00:29:41,448 --> 00:29:43,150 line:0
我们需要思考同步化问题


581
00:29:43,917 --> 00:29:46,420 line:0
为了描述这个问题
我们使用一个示例时间线


582
00:29:46,486 --> 00:29:48,989 line:0
来描述两个并行运行的GPU


583
00:29:49,489 --> 00:29:51,792 line:0
黑框表示指令缓冲区


584
00:29:51,859 --> 00:29:53,026 line:0
绿框表示我们编码进入


585
00:29:53,093 --> 00:29:55,996 line:0
这些指令缓冲区中的工作内容


586
00:29:56,296 --> 00:29:58,632 line:0
例如 使用计算指令编码器


587
00:30:00,033 --> 00:30:03,036 line:0
因此 上方GPU将进行渲染


588
00:30:03,470 --> 00:30:06,273 line:0
渲染完成之后
它将完成的区域


589
00:30:06,340 --> 00:30:08,408 line:0
Blit进入前面所述的共享缓冲区


590
00:30:09,910 --> 00:30:11,078 line:0
在此过程中


591
00:30:11,678 --> 00:30:13,714 line:0
GPU B也在进行渲染


592
00:30:15,082 --> 00:30:17,584 line:0
我们将使用这个GPU进行合成


593
00:30:18,118 --> 00:30:19,019 line:0
因此在某一时间点


594
00:30:19,086 --> 00:30:22,356 line:0
它将需要GPU A生成的缓冲区


595
00:30:23,357 --> 00:30:24,992 line:0
这里可看到 有一个问题


596
00:30:25,893 --> 00:30:28,228 line:0
这个区域没有同步化


597
00:30:28,996 --> 00:30:32,099 line:0
因此 在GPU完成写入缓冲区之前


598
00:30:32,165 --> 00:30:34,368 line:0
不能阻止GPU B读取缓冲区


599
00:30:35,669 --> 00:30:38,105 line:0
要处理该问题
可使用Metal Events


600
00:30:39,106 --> 00:30:41,008 line:0
利用Metal Events


601
00:30:41,074 --> 00:30:42,276 line:0
我们在指令缓冲区中
插入一个等待指令


602
00:30:43,043 --> 00:30:45,712 line:0
当GPU执行时
它会遇到等待指令


603
00:30:45,879 --> 00:30:47,447 line:0
然后就会停止


604
00:30:48,782 --> 00:30:51,818 line:0
它等待的是
其他GPU的信号


605
00:30:53,620 --> 00:30:55,022 line:0
收到信号之后


606
00:30:55,389 --> 00:30:58,058 line:0
我们就知道GPU A
已经完成缓冲区写入


607
00:30:58,125 --> 00:31:00,494 line:0
现在GPU B可以访问缓冲区


608
00:31:02,596 --> 00:31:05,699 line:-2
这种方法可以巧妙地
解决同步化问题


609
00:31:06,800 --> 00:31:08,802 line:-1
但是很显然 使性能强劲的GPU


610
00:31:08,869 --> 00:31:13,106 line:-1
保持等待状态并不是一个良策


611
00:31:13,841 --> 00:31:16,210 line:-1
因此需要尽快缩短等待


612
00:31:16,276 --> 00:31:19,279 line:-2
理想的情况下 我们希望GPU
保持工作 而不是等待


613
00:31:20,848 --> 00:31:23,183 line:-2
在这里 我们讨论的是
负载平衡问题


614
00:31:24,585 --> 00:31:26,587 line:-1
因此 我们在GPU之间


615
00:31:26,653 --> 00:31:27,988 line:-1
均等地分配屏幕区域


616
00:31:28,055 --> 00:31:29,723 line:-1
这有一个问题


617
00:31:30,357 --> 00:31:32,159 line:-1
首先 这没有考虑


618
00:31:32,226 --> 00:31:34,661 line:-1
所使用的GPU性能可能存在差异


619
00:31:35,662 --> 00:31:37,464 line:-1
如果一个GPU速度更快


620
00:31:37,531 --> 00:31:40,067 line:-1
那么它会首先完成任务


621
00:31:41,535 --> 00:31:44,538 line:-2
另一个问题是
一些屏幕区域的渲染


622
00:31:44,605 --> 00:31:46,139 line:-1
比其他区域更加复杂


623
00:31:46,206 --> 00:31:47,107 line:-1
它们需要更长的时间


624
00:31:47,541 --> 00:31:50,777 line:-2
它们可能有更复杂的几何形状
或更复杂的材质


625
00:31:52,246 --> 00:31:53,380 line:-1
为了解决这个问题


626
00:31:53,614 --> 00:31:56,049 line:-2
我们需要自适应地
调整区域大小


627
00:31:56,850 --> 00:31:59,152 line:-1
这时的目标是确保每个GPU


628
00:31:59,219 --> 00:32:02,656 line:-2
使用大约相等的时间
完成其场景区域渲染


629
00:32:04,291 --> 00:32:05,259 line:-1
为此 我们使用的方法是


630
00:32:05,325 --> 00:32:07,995 line:-1
从固定分区着手


631
00:32:08,362 --> 00:32:09,663 line:-1
然后我们渲染一个帧


632
00:32:10,597 --> 00:32:13,066 line:-2
测量每个GPU需要
多长时间完成渲染


633
00:32:13,500 --> 00:32:14,801 line:-1
然后我们根据此结果确定


634
00:32:14,868 --> 00:32:17,471 line:-1
为每个GPU分配多大的区域


635
00:32:19,940 --> 00:32:22,442 line:-2
将会在app运行时
完成这些工作


636
00:32:23,377 --> 00:32:25,846 line:-1
因此 它不断地适应


637
00:32:25,913 --> 00:32:26,847 line:-1
你的GPU的性能


638
00:32:27,181 --> 00:32:30,083 line:-2
无论使用哪个场景区域
来测量GPU的处理速度


639
00:32:32,953 --> 00:32:37,591 line:0
都会使用指令缓冲区完成处理程序
来获得结果


640
00:32:38,725 --> 00:32:41,662 line:0
完成处理程序是一个CPU代码块


641
00:32:41,728 --> 00:32:43,497 line:0
可在GPU完成执行
指令缓冲区之后


642
00:32:43,564 --> 00:32:45,432 line:0
运行此代码块


643
00:32:46,800 --> 00:32:48,535 line:0
现在iOS上


644
00:32:49,102 --> 00:32:50,904 line:0
指令缓冲区有多个有用的属性


645
00:32:50,971 --> 00:32:52,072 line:0
可以读取这些属性


646
00:32:52,139 --> 00:32:54,408 line:0
以发现在GPU上运行缓冲区的时间


647
00:32:55,609 --> 00:32:57,444 line:-1
但是它们在macOS上不可用


648
00:32:57,511 --> 00:32:59,446 line:-1
我们需要确保处理时间大致相当


649
00:33:00,747 --> 00:33:03,417 line:-2
我们使用的方法是
调用每个指令缓冲区完成处理程序时


650
00:33:03,483 --> 00:33:05,619 line:-1
存储主机时间


651
00:33:06,386 --> 00:33:08,188 line:-1
如果对每个指令缓冲区执行此操作


652
00:33:08,689 --> 00:33:10,591 line:-1
就可以根据这些时间差异


653
00:33:10,724 --> 00:33:12,593 line:-1
确定GPU运行时间


654
00:33:13,393 --> 00:33:14,294 line:-1
举例来说


655
00:33:15,195 --> 00:33:17,030 line:-1
为了估算这里显示的


656
00:33:17,097 --> 00:33:18,498 line:-1
三个指令缓冲区的执行时间


657
00:33:18,932 --> 00:33:21,301 line:-2
我们测量完成处理程序调用的
时间间隔


658
00:33:21,368 --> 00:33:24,004 line:-2
对于指令缓冲区3
和指令缓冲区0


659
00:33:26,640 --> 00:33:28,175 line:-1
这是理论性的


660
00:33:28,242 --> 00:33:29,743 line:-1
让我们来看实际运行情况


661
00:33:42,122 --> 00:33:44,591 line:-1
这是Sean前面展示过的


662
00:33:44,658 --> 00:33:46,760 line:-1
Amazon Lumberyard Bistro场景


663
00:33:47,561 --> 00:33:49,830 line:-2
这次它在MacBook Pro上
运行


664
00:33:50,797 --> 00:33:52,766 line:-1
在屏幕上方


665
00:33:52,833 --> 00:33:54,568 line:-1
有一个每秒光线数量指标


666
00:33:54,835 --> 00:33:56,870 line:-1
可以知道运行速度


667
00:33:57,471 --> 00:34:01,642 line:-2
这包括一次光线
二次光线和阴影光线


668
00:34:01,708 --> 00:34:03,310 line:-1
都包含在这个指标中


669
00:34:04,444 --> 00:34:07,381 line:-2
可以看到
每秒处理三千万条光线


670
00:34:07,447 --> 00:34:08,282 line:-1
而且


671
00:34:08,415 --> 00:34:10,350 line:-1
如果速度加快 效果会更好


672
00:34:10,484 --> 00:34:11,685 line:-1
我想要启用


673
00:34:11,752 --> 00:34:13,987 line:-1
我连接的一个eGPU


674
00:34:17,024 --> 00:34:18,358 line:-1
这里的文字显示


675
00:34:18,425 --> 00:34:22,094 line:-2
我们运行RX 580
和内置GPU


676
00:34:22,629 --> 00:34:25,899 line:-2
性能提高了一倍
达到大约六千万条光线/秒


677
00:34:26,900 --> 00:34:28,268 line:-1
可以看到这里的绿线


678
00:34:28,335 --> 00:34:31,705 line:-2
它更好地显示
如何在GPU之间分配负载


679
00:34:32,039 --> 00:34:35,074 line:-1
一个GPU渲染绿线上方的场景


680
00:34:35,141 --> 00:34:37,344 line:-1
一个GPU渲染绿线下方的场景


681
00:34:38,745 --> 00:34:41,281 line:-1
因此 通过使用eGPU


682
00:34:41,348 --> 00:34:42,349 line:-1
能够将速度提高两倍


683
00:34:43,150 --> 00:34:45,452 line:-1
但是我还有更高的期望


684
00:34:45,786 --> 00:34:49,623 line:-2
问题是 eGPU
处于等待状态


685
00:34:50,123 --> 00:34:52,192 line:-1
这是因为我们使用固定分区方法


686
00:34:52,926 --> 00:34:55,429 line:-1
如果我们切换为自适应负载均衡方法


687
00:34:56,196 --> 00:34:59,233 line:-2
可以看到RX 580
现在承担了大部分的工作


688
00:34:59,299 --> 00:35:01,702 line:-1
相比以前速度明显更快


689
00:35:04,638 --> 00:35:07,207 line:-1
这个场景大约有一百万个三角形


690
00:35:07,274 --> 00:35:09,877 line:-1
现在我们切换到室外场景


691
00:35:09,943 --> 00:35:13,213 line:-2
这也是Amazon Lumberyard场景
只不过是室外场景


692
00:35:13,313 --> 00:35:16,483 line:-1
这个场景大约有三百万个三角形


693
00:35:17,518 --> 00:35:20,921 line:-2
另外一个GPU处于等待状态
我们启用它


694
00:35:20,988 --> 00:35:21,822 line:-1
现在


695
00:35:22,656 --> 00:35:24,124 line:-1
这个GPU是Vega 64


696
00:35:24,858 --> 00:35:27,361 line:-2
可以看到Vega
承担了大部分的工作量


697
00:35:28,762 --> 00:35:30,831 line:-1
这个配置比较有趣


698
00:35:30,898 --> 00:35:33,634 line:-2
因为有三个不同的GPU
在共同工作


699
00:35:33,700 --> 00:35:35,235 line:-1
它们的架构不同


700
00:35:35,569 --> 00:35:37,037 line:-1
而且性能差异很大


701
00:35:37,104 --> 00:35:39,640 line:-2
但是它们协同工作
生成这幅高质量的图像


702
00:35:51,018 --> 00:35:53,954 line:-2
今天 我们介绍了
MPSRayIntersector


703
00:35:54,021 --> 00:35:55,389 line:-1
它是一个新的API


704
00:35:55,455 --> 00:35:58,325 line:-2
可用于在GPU上
加速光线三角形交叉


705
00:35:59,793 --> 00:36:01,028 line:-1
从前面的演示中可以看出


706
00:36:01,094 --> 00:36:04,364 line:-2
已经可以在所有的iOS
和macOS平台上使用此API


707
00:36:04,698 --> 00:36:08,001 line:-2
当你在macOS上添加GPU时
它具有良好的扩展性


708
00:36:09,770 --> 00:36:11,004 line:-1
我们希望看到


709
00:36:11,071 --> 00:36:13,540 line:-2
你们在app中
使用光线追踪技术


710
00:36:14,107 --> 00:36:16,977 line:-2
今天 我们在示例中
使用了路径追踪方法


711
00:36:17,311 --> 00:36:18,745 line:-1
以及混合渲染技术


712
00:36:18,812 --> 00:36:20,881 line:-1
你们可能希望使用光线追踪技术


713
00:36:20,948 --> 00:36:24,351 line:-2
生成美观的阴影
或环境光遮蔽 或反射


714
00:36:25,319 --> 00:36:27,254 line:-1
另外还有一些非渲染app


715
00:36:27,454 --> 00:36:31,225 line:-2
例如 自动模拟、物理
AI、冲撞检测


716
00:36:31,291 --> 00:36:32,926 line:-1
应用非常广泛


717
00:36:34,862 --> 00:36:35,963 line:-1
为了帮助你们上手


718
00:36:38,899 --> 00:36:41,535 line:-2
可以在developer.apple.com
查找示例代码


719
00:36:41,602 --> 00:36:43,003 line:-1
因此请务必查阅


720
00:36:43,470 --> 00:36:46,406 line:-1
另外还有头文件大量的文档


721
00:36:46,473 --> 00:36:48,742 line:-1
以及其他特性的相关信息


722
00:36:48,809 --> 00:36:50,344 line:-1
今天无法逐一讲解


723
00:36:51,411 --> 00:36:52,246 line:-1
最后


724
00:36:52,312 --> 00:36:54,014 line:-1
明天12:00还有实验室


725
00:36:54,515 --> 00:36:57,284 line:-2
Sean和我将会
更详细地讨论API


726
00:36:57,351 --> 00:37:00,120 line:-2
帮助你们在app中
使用光线追踪技术


727
00:37:00,187 --> 00:37:01,755 line:-1
希望你们能参加


728
00:37:02,623 --> 00:37:03,490 line:-1
最后


729
00:37:03,557 --> 00:37:04,858 line:-1
感谢你们参加本演讲


730
00:37:04,925 --> 00:37:07,027 line:-2
希望你们在剩下的WWDC中
度过美好时光

