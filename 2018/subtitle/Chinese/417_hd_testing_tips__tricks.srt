1
00:00:17,284 --> 00:00:21,421 line:0
（测试提示和技巧 演讲417）


2
00:00:32,432 --> 00:00:33,300 line:-1
大家好


3
00:00:33,367 --> 00:00:35,169 line:-1
欢迎来到“测试提示和技巧”


4
00:00:36,069 --> 00:00:37,571 line:-1
我叫Brian Croom


5
00:00:38,305 --> 00:00:39,806 line:-1
我的同事Stuart和我


6
00:00:39,873 --> 00:00:42,943 line:-2
真的很高兴与你们分享
一些很棒的测试技术


7
00:00:43,010 --> 00:00:44,578 line:-1
我们最近一直在学习这些技术


8
00:00:47,848 --> 00:00:50,717 line:-2
随着会议的临近
我们觉得如果我们能有一个app


9
00:00:50,784 --> 00:00:52,486 line:-1
用它能够在会议中心周围


10
00:00:52,553 --> 00:00:56,423 line:-2
找一些我们能够去看和做的东西
这会是一件很酷的事情


11
00:00:57,791 --> 00:00:59,026 line:-1
我们一直在创建这app


12
00:00:59,393 --> 00:01:03,497 line:-2
为它在圣何塞周围寻找
各种兴趣点提供视图


13
00:01:03,864 --> 00:01:05,699 line:-1
并列出了它们离你有多远


14
00:01:07,568 --> 00:01:09,503 line:-1
现在当然我们想要确保


15
00:01:09,570 --> 00:01:11,738 line:-1
我们有一个非常棒的测试套件


16
00:01:12,372 --> 00:01:16,143 line:-2
我们可以运行这个app
让我们相信我们的代码能够正常工作


17
00:01:16,443 --> 00:01:18,812 line:-2
并且随着开发的继续
可以保证代码继续工作


18
00:01:21,882 --> 00:01:25,419 line:-1
今天我们想与你们分享四套


19
00:01:25,485 --> 00:01:28,622 line:-2
我们在为app编写测试时
发现的非常有用的技术


20
00:01:30,290 --> 00:01:33,627 line:-1
一些在app中测试网络代码的策略


21
00:01:34,895 --> 00:01:38,732 line:-2
一些用于处理基础通知对象的
测试技巧


22
00:01:40,300 --> 00:01:44,671 line:-2
在测试中使用模拟对象时
利用协议的方法


23
00:01:45,639 --> 00:01:48,775 line:-2
以及一些使测试运行速度
非常快的技术


24
00:01:52,446 --> 00:01:54,248 line:-1
现在让我们开始讨论网络吧


25
00:01:55,883 --> 00:01:59,253 line:-2
为了允许动态内容更新
我们一直在开发app


26
00:01:59,319 --> 00:02:01,421 line:-1
以便从远程网络服务器加载数据


27
00:02:02,856 --> 00:02:04,491 line:-1
这里我们发现一些


28
00:02:04,558 --> 00:02:06,460 line:-1
网络代码编写测试时有用的东西


29
00:02:08,794 --> 00:02:11,565 line:-1
首先快速回顾一下去年的情况


30
00:02:12,332 --> 00:02:16,637 line:-2
在2017年WWDC
“可测试性工程”演讲中


31
00:02:17,070 --> 00:02:18,939 line:-1
我们讨论了金字塔模型


32
00:02:19,306 --> 00:02:21,508 line:-1
它是如何构造测试套件


33
00:02:21,909 --> 00:02:26,480 line:-2
平衡彻底性
可理解性和执行速度的指南


34
00:02:28,615 --> 00:02:31,818 line:-1
总之 理想的测试套件往往是


35
00:02:31,885 --> 00:02:34,488 line:-1
由大量集中的单元测试组成


36
00:02:34,555 --> 00:02:38,025 line:-2
能够在你的app中
执行单独的分类和方法


37
00:02:39,693 --> 00:02:42,262 line:-1
它们的特点是阅读简单


38
00:02:42,963 --> 00:02:46,099 line:-2
在检测到问题时
能产生明确的失败消息


39
00:02:47,000 --> 00:02:48,569 line:-1
并且运行速度非常快


40
00:02:48,802 --> 00:02:51,939 line:-1
通常是每分钟数百或数千次测试


41
00:02:54,741 --> 00:02:59,379 line:-2
这些测试由较小数量的
中型集成测试作为补充


42
00:03:00,214 --> 00:03:03,951 line:-2
这些测试以app中的
离散子系统或类集群为目标


43
00:03:04,918 --> 00:03:06,787 line:-1
检查它们是否一起正常工作


44
00:03:07,087 --> 00:03:09,089 line:-1
每个测试只需几秒钟即可运行


45
00:03:11,792 --> 00:03:15,095 line:-1
这个套件是一些端到端的系统测试


46
00:03:15,562 --> 00:03:17,898 line:-1
最常见的形式是UI测试


47
00:03:18,432 --> 00:03:20,734 line:-1
它非常类似于终端用户


48
00:03:20,801 --> 00:03:23,203 line:-1
在他们的设备上的操作方式


49
00:03:24,538 --> 00:03:26,807 line:-2
检查所有的部分
是否正确地连接在一起


50
00:03:27,107 --> 00:03:31,678 line:-2
以及检查与底层操作系统
和外部资源进行良好的交互


51
00:03:33,680 --> 00:03:35,782 line:-1
遵循该模型的测试套件


52
00:03:36,116 --> 00:03:39,520 line:-1
可以全面描述app代码的基本功能


53
00:03:43,790 --> 00:03:45,826 line:-1
为了测试这个app中的网络堆栈


54
00:03:46,193 --> 00:03:48,362 line:-2
我们真的很想
把这个金字塔模型放在心上


55
00:03:48,929 --> 00:03:51,565 line:-1
将它作为如何构建测试套件的指南


56
00:03:53,333 --> 00:03:55,202 line:-1
在这里我们看到了


57
00:03:55,269 --> 00:03:57,504 line:-1
在app中发出网络请求并将数据


58
00:03:57,804 --> 00:03:59,573 line:-1
输入UI所涉及的高级数据流


59
00:04:02,342 --> 00:04:03,911 line:-1
在这个app的早期原型中


60
00:04:04,444 --> 00:04:05,846 line:-1
我们在视图控制器中有个方法


61
00:04:05,913 --> 00:04:08,382 line:-1
它可以在一个地方完成所有这些工作


62
00:04:09,116 --> 00:04:10,284 line:-1
它看起来和这个很相似


63
00:04:12,486 --> 00:04:15,455 line:-1
该方法接受一个带有用户位置的参数


64
00:04:17,357 --> 00:04:20,928 line:-2
并使用该参数为我们的
服务器API端点构造URL


65
00:04:21,161 --> 00:04:23,230 line:-1
并将该位置作为查询参数


66
00:04:26,133 --> 00:04:29,069 line:-2
然后它使用Foundation的
URLSession API


67
00:04:29,336 --> 00:04:32,606 line:-2
为向那个URL得到一个请求
而创建一个数据任务


68
00:04:34,908 --> 00:04:37,978 line:-1
当服务器响应时它将打开数据


69
00:04:39,479 --> 00:04:42,349 line:-2
使用foundation的
JSONDecoder API对其解码


70
00:04:42,950 --> 00:04:45,519 line:-1
将其解码为一个有关值的数组


71
00:04:45,586 --> 00:04:47,521 line:-1
这是我在其他地方声明过的一个结构


72
00:04:47,855 --> 00:04:49,823 line:-1
并符合可解码协议


73
00:04:51,825 --> 00:04:53,360 line:-1
然后将其存储到属性中


74
00:04:53,427 --> 00:04:55,829 line:-1
以驱实现动表视图数据源


75
00:04:56,029 --> 00:04:57,264 line:-1
并将其放到屏幕上


76
00:05:00,567 --> 00:05:03,303 line:-2
现在非常值得注意的是
我能够


77
00:05:03,370 --> 00:05:05,305 line:-2
利用Swift
和Foundation的强大功能


78
00:05:05,739 --> 00:05:08,075 line:-2
能够在大约15行代码中
完成所有这一切


79
00:05:09,443 --> 00:05:11,778 line:-1
但是通过一个方法来做所有这些


80
00:05:12,179 --> 00:05:13,947 line:-1
那么我就损害了代码的可维护性


81
00:05:14,014 --> 00:05:16,383 line:-1
特别是代码的可测试性


82
00:05:20,921 --> 00:05:23,257 line:-1
来看看我们的测试金字塔的基础


83
00:05:23,457 --> 00:05:26,860 line:-1
我们真正想要做的是为每个流的


84
00:05:26,927 --> 00:05:28,662 line:-1
每个部分编写焦点单元测试


85
00:05:30,864 --> 00:05:34,935 line:-2
让我们首先考虑请求准备
和响应解析步骤


86
00:05:38,772 --> 00:05:41,141 line:-1
为了使这段代码更具可测试性


87
00:05:41,842 --> 00:05:44,111 line:-2
我们首先从视图控制器中取出它
并在这个专用的


88
00:05:45,546 --> 00:05:49,316 line:-2
PointsOfInterestRequest
类型上创建了两个方法


89
00:05:50,584 --> 00:05:53,287 line:-1
这给出了两个很好的解耦方法


90
00:05:53,353 --> 00:05:55,822 line:-1
每个都取一些值作为输入


91
00:05:56,223 --> 00:06:00,160 line:-2
并将它们转换为一些输出值
而不产生任何副作用


92
00:06:03,330 --> 00:06:05,232 line:-1
这使得我们很容易


93
00:06:05,599 --> 00:06:07,901 line:-1
为代码编写一个集中的单元测试


94
00:06:09,503 --> 00:06:11,371 line:-2
在这里我们测试
makeRequest方法


95
00:06:12,039 --> 00:06:14,208 line:-1
只要做一个样本并放置位置


96
00:06:14,274 --> 00:06:15,742 line:-1
将其传递到这个方法中


97
00:06:16,210 --> 00:06:18,846 line:-1
并对其返回值做出一些认定


98
00:06:22,082 --> 00:06:26,253 line:-2
类似地 我们可以通过传入
一些模拟JSON


99
00:06:26,386 --> 00:06:28,522 line:-2
并对解析的结果进行断言
来测试响应解析


100
00:06:31,491 --> 00:06:34,027 line:-1
关于这个测试的另一点需要注意的是


101
00:06:34,428 --> 00:06:36,864 line:-1
我正在使用XCTest支持


102
00:06:36,930 --> 00:06:38,999 line:-1
来用于标记为抛出的测试方法


103
00:06:39,399 --> 00:06:42,169 line:-1
这允许我在测试代码中使用try


104
00:06:42,336 --> 00:06:44,705 line:-2
而不需在测试代码周围使用
明确的do-catch块围绕它


105
00:06:49,042 --> 00:06:52,112 line:-2
现在让我们看看
与URL会话交互的代码


106
00:06:54,581 --> 00:06:56,884 line:-1
这里我们再次将其拉出视图控制器


107
00:06:57,985 --> 00:07:00,220 line:-1
并使用与我们刚才看到的


108
00:07:00,287 --> 00:07:02,055 line:-1
请求类型匹配方法签名的方法


109
00:07:02,122 --> 00:07:04,291 line:-1
创建了APIRequest协议


110
00:07:05,526 --> 00:07:08,362 line:-2
这是被请求类型初始化的
APIRequestLoader


111
00:07:09,530 --> 00:07:13,901 line:-2
和urlSession实例类
来使用的


112
00:07:17,504 --> 00:07:20,174 line:-2
这个类有一个
loadAPIRequest方法


113
00:07:20,674 --> 00:07:24,478 line:-2
它使用该apiRequest值
来生成一个URL请求


114
00:07:25,412 --> 00:07:27,314 line:-1
将其输入到urlSession中


115
00:07:28,415 --> 00:07:31,151 line:-2
然后再用apiRequest
在你的响应中进行解析


116
00:07:34,721 --> 00:07:37,491 line:-2
现在我们可以继续为这个方法
编写单元测试


117
00:07:37,925 --> 00:07:40,194 line:-2
但是现在我实际上想要向上
移动金字塔


118
00:07:40,527 --> 00:07:42,629 line:-1
并查看一个中级集成测试


119
00:07:42,696 --> 00:07:44,898 line:-1
它涵盖了这个数据流的几个部分


120
00:07:47,000 --> 00:07:49,903 line:-2
在套件的这一层我还能够进行的
另一个测试是


121
00:07:49,970 --> 00:07:53,106 line:-1
我与URLSession API


122
00:07:53,173 --> 00:07:55,375 line:-1
的交互是正确的


123
00:07:57,010 --> 00:07:59,847 line:-2
事实证明
foundation URL加载


124
00:07:59,913 --> 00:08:01,682 line:-1
系统为实现这点提供了很大的帮助


125
00:08:04,184 --> 00:08:07,588 line:-2
URLSession为用于
执行网络请求的app


126
00:08:07,654 --> 00:08:09,089 line:-1
提供了一个高级API


127
00:08:10,424 --> 00:08:12,459 line:-1
弯曲对象 如表示飞行请求的


128
00:08:12,526 --> 00:08:14,561 line:-1
URLSession数据任务


129
00:08:15,896 --> 00:08:17,264 line:-1
然而在幕后还有另一个较低级别的


130
00:08:17,497 --> 00:08:20,701 line:-1
API URLProtocol


131
00:08:21,368 --> 00:08:24,571 line:-1
它来执行打开网络连接 编写请求


132
00:08:24,738 --> 00:08:27,674 line:-1
和读取响应的底层工作


133
00:08:29,810 --> 00:08:32,145 line:-2
URLProtocol
被设计为子类


134
00:08:32,546 --> 00:08:35,849 line:-1
为URL加载系统提供了一个扩展点


135
00:08:39,253 --> 00:08:42,589 line:-2
Foundation为诸如
HTTPS这样的公共协议


136
00:08:42,789 --> 00:08:44,725 line:-1
提供内置协议子类


137
00:08:45,592 --> 00:08:49,229 line:-1
但是我们可以在测试中覆盖这些内容


138
00:08:50,063 --> 00:08:51,932 line:-1
方法是提供一个模拟协议


139
00:08:51,999 --> 00:08:55,636 line:-2
允许我们对即将发出的请求进行断言
并提供模拟响应


140
00:08:59,673 --> 00:09:02,509 line:-2
URLProtocol通过
URLProtocol客户端实例


141
00:09:02,676 --> 00:09:05,279 line:-1
将进程通信回系统


142
00:09:08,015 --> 00:09:09,850 line:-1
我们可以用这个方法


143
00:09:10,984 --> 00:09:13,987 line:-2
我们在测试包中创建一个
MockURLProtocol类


144
00:09:14,821 --> 00:09:18,458 line:-1
重写canInit请求


145
00:09:18,525 --> 00:09:21,295 line:-2
以向系统表明
我们对它提供的任何请求感兴趣


146
00:09:23,864 --> 00:09:26,099 line:-2
实现canonicalRequest
用于请求


147
00:09:26,567 --> 00:09:29,970 line:-2
但startLoading和StopLoading
方法用于大多数操作发生的地方


148
00:09:34,808 --> 00:09:37,611 line:-2
为了给我们的测试提供一种连接到
这个URLProtocol的方法


149
00:09:38,078 --> 00:09:41,949 line:-2
我们将提供一个闭包属性
requestHandler来设置测试


150
00:09:44,885 --> 00:09:47,120 line:-2
当一个URLSession
任务开始时


151
00:09:47,187 --> 00:09:50,224 line:-2
系统将实例化我们的
URLProtocol子类


152
00:09:50,591 --> 00:09:55,395 line:-2
为它提供URLRequest值和
URLProtocol客户端实例


153
00:09:57,264 --> 00:09:59,132 line:-2
然后它将调用
startLoading方法


154
00:09:59,733 --> 00:10:02,703 line:-2
在该方法中我们将使用测试设置的
requestHandler


155
00:10:03,437 --> 00:10:05,906 line:-2
并在参数处使用
URLRequest调用它


156
00:10:07,574 --> 00:10:10,344 line:-2
我们将获取它返回的内容
并将其作为URL响应


157
00:10:10,978 --> 00:10:13,547 line:-1
和数据传递回系统


158
00:10:14,748 --> 00:10:15,782 line:-1
或作为一个错误传递回系统


159
00:10:18,619 --> 00:10:20,787 line:-1
如果你想要取消测试请求


160
00:10:20,854 --> 00:10:24,591 line:-2
我们可以在停止加载方法实现中
执行类似的操作


161
00:10:28,862 --> 00:10:31,832 line:-1
有了存根协议我们就可以编写测试了


162
00:10:33,400 --> 00:10:36,336 line:-2
我们创建一个
APIRequestLoader实例


163
00:10:36,637 --> 00:10:40,340 line:-1
用一个请求类型和一个配置为使用


164
00:10:40,407 --> 00:10:42,776 line:-2
我们的URLProtocol的
URLSession来配置它


165
00:10:46,313 --> 00:10:50,851 line:-2
在测试体中我们在MockURLProtocol上
设置了一个requestHandler


166
00:10:51,752 --> 00:10:54,621 line:-1
对将要发出的请求作出断言


167
00:10:55,889 --> 00:10:57,524 line:-1
然后提供一个存根响应


168
00:10:59,826 --> 00:11:01,862 line:-2
然后我们可以调用
loadAPIRequest


169
00:11:03,030 --> 00:11:04,898 line:-1
等待调用完成块


170
00:11:06,166 --> 00:11:08,368 line:-1
并对解析响应作出断言


171
00:11:11,038 --> 00:11:14,575 line:-2
在这一层上的几个测试可以给
我们很大的信心


172
00:11:14,641 --> 00:11:16,410 line:-2
使我们相信我们的代码
能够很好地协同工作


173
00:11:16,476 --> 00:11:19,179 line:-1
而且我们正在与系统进行适当的集成


174
00:11:19,780 --> 00:11:23,083 line:-2
例如如果我忘记在我的数据任务中
调用简历的话


175
00:11:23,150 --> 00:11:25,953 line:-1
那么我们刚才看到的测试就会失败


176
00:11:26,553 --> 00:11:28,655 line:-1
我相信我不是唯一犯过这个错误的人


177
00:11:33,360 --> 00:11:35,529 line:-1
最后包含一些系统级的


178
00:11:35,596 --> 00:11:38,699 line:-1
端到端测试也是非常有价值的


179
00:11:39,766 --> 00:11:42,769 line:-2
实际上测试
UI测试是一个很好的工具


180
00:11:44,471 --> 00:11:46,173 line:-1
要了解更多关于UI测试的信息


181
00:11:46,240 --> 00:11:50,711 line:-2
请参考2015年WWDC的
“Xcode中的UI测试”演讲


182
00:11:53,981 --> 00:11:56,917 line:-2
现在当你开始编写真正的
端到端测试时


183
00:11:56,984 --> 00:11:59,620 line:-2
你遇到的一个重大挑战是
当发生问题时


184
00:12:00,120 --> 00:12:02,456 line:-1
当你遇到测试失败时


185
00:12:02,523 --> 00:12:04,925 line:-1
很难知道从哪里开始


186
00:12:04,992 --> 00:12:06,193 line:-1
寻找问题的根源


187
00:12:07,928 --> 00:12:10,731 line:-2
我们最近在测试中
帮助缓解这种情况的一件事是


188
00:12:11,298 --> 00:12:13,867 line:-1
设置一个模拟服务器的本地实例


189
00:12:14,301 --> 00:12:18,639 line:-2
中断我们的UI测试来对其发出请求
而不是对真正的服务器进行请求


190
00:12:19,706 --> 00:12:22,309 line:-1
这使得我们的UI测试更加可靠


191
00:12:22,376 --> 00:12:25,512 line:-2
因为我们可以控制
反馈到app中的数据


192
00:12:28,649 --> 00:12:31,785 line:-2
虽然在这个上下文中
使用模拟服务器是非常有用的


193
00:12:32,186 --> 00:12:35,989 line:-2
但是让一些测试针对真正的
服务器发出请求也是很好的


194
00:12:38,926 --> 00:12:40,561 line:-1
其一种很酷的技术就是


195
00:12:40,627 --> 00:12:43,230 line:-1
可以在单元测试包中进行一些测试


196
00:12:43,497 --> 00:12:46,233 line:-2
直接调用
在Stack中工作的app


197
00:12:47,000 --> 00:12:49,770 line:-2
并使用这些测试
将请求指向真正的服务器


198
00:12:51,071 --> 00:12:54,908 line:-2
这提供了一种验证服务器
接受请求的方式


199
00:12:54,975 --> 00:12:56,643 line:-1
是否与app的方式相同的方法


200
00:12:57,544 --> 00:12:59,847 line:-1
并且你可以解析服务器的响应


201
00:13:00,347 --> 00:13:02,516 line:-1
而不必同时处理


202
00:13:02,583 --> 00:13:04,618 line:-1
测试UI的复杂问题


203
00:13:10,357 --> 00:13:13,327 line:-1
因此最后我们看到了一个


204
00:13:13,393 --> 00:13:16,230 line:-1
将代码分解成更小独立的部分


205
00:13:16,296 --> 00:13:17,831 line:-1
以便单元测试的例子


206
00:13:19,566 --> 00:13:24,571 line:-2
我们已看到了如何使用URLProtocol
作为模拟网络请求的工具


207
00:13:26,340 --> 00:13:29,209 line:-2
我们还讨论了如何使用
金字塔的强大功能


208
00:13:29,276 --> 00:13:31,745 line:-2
来帮助我们构建
一个平衡良好的测试套件


209
00:13:31,812 --> 00:13:33,714 line:-1
这将使我们对我们的代码充满信心


210
00:13:35,449 --> 00:13:39,253 line:-2
现在我想把Stuart叫到台上
来谈谈更多的技术


211
00:13:43,190 --> 00:13:44,124 line:-1
谢谢


212
00:13:46,560 --> 00:13:47,494 line:-1
谢谢 Brian


213
00:13:48,195 --> 00:13:50,430 line:-1
那么我想要讨论的第一个领域是


214
00:13:50,497 --> 00:13:53,000 line:-1
测试通知的一些最佳实践方法


215
00:13:54,735 --> 00:13:57,471 line:-1
澄清一下 这里的通知


216
00:13:57,538 --> 00:14:00,107 line:-2
我说的是基础级别的通知
即NSNotification


217
00:14:00,174 --> 00:14:02,576 line:-1
和Objective-C


218
00:14:03,377 --> 00:14:07,114 line:-2
是的 有时我们需要测试
一个主题是否观察到一个通知


219
00:14:07,281 --> 00:14:10,617 line:-2
而另一些时候我们需要测试
一个主题是否发布了一个通知


220
00:14:11,451 --> 00:14:14,588 line:-1
通知是一种一对多的通信机制


221
00:14:14,788 --> 00:14:17,824 line:-1
这意味着在发布单个通知时


222
00:14:17,891 --> 00:14:20,694 line:-2
它可能会通过
你的app发送给多个收件人


223
00:14:20,928 --> 00:14:24,131 line:-2
甚至是你的app进程运行的
框架代码中


224
00:14:24,198 --> 00:14:28,001 line:-1
因此正因为这一点 我们必须始终


225
00:14:28,068 --> 00:14:33,540 line:-2
以独立的方式测试通知
以避免意外的副作用


226
00:14:33,607 --> 00:14:37,044 line:-1
因为这可能导致不稳定不可靠的测试


227
00:14:37,578 --> 00:14:40,280 line:-2
让我们看一个
有这个问题的代码的例子


228
00:14:41,348 --> 00:14:43,750 line:-2
在这里有 Brian和我
正在构建的app


229
00:14:43,817 --> 00:14:45,552 line:-2
的PointsOfInterest
TableViewController


230
00:14:46,119 --> 00:14:49,590 line:-1
表视图中显示了附近有趣地点的列表


231
00:14:49,723 --> 00:14:52,526 line:-1
每当app的位置授权发生变化时


232
00:14:52,593 --> 00:14:54,228 line:-1
它可能需要重新加载数据


233
00:14:54,695 --> 00:14:57,464 line:-2
因此它从app的
CurrentLocationProvider类中


234
00:14:57,531 --> 00:15:00,167 line:-2
观察到一个名为
AuthChanged的通知


235
00:15:00,767 --> 00:15:04,338 line:-1
当它观察到这个通知时


236
00:15:04,404 --> 00:15:07,608 line:-2
它会在必要时重新加载它的数据
为了这个例子 它设置一个标志


237
00:15:08,275 --> 00:15:11,478 line:-1
这样我们的测试代码就可以检查标志


238
00:15:11,545 --> 00:15:13,614 line:-1
看看是否实际收到了通知


239
00:15:14,548 --> 00:15:17,451 line:-1
这里我们可以看到它正在使用


240
00:15:17,518 --> 00:15:18,752 line:-1
默认的通知中心来添加观察者


241
00:15:19,853 --> 00:15:22,623 line:-2
让我们来看看
这个代码的单元测试可能是什么样子


242
00:15:23,857 --> 00:15:25,759 line:-1
在这个类的测试中


243
00:15:25,826 --> 00:15:29,229 line:-2
我们发布了AuthChanged
方法通知来模拟它


244
00:15:29,296 --> 00:15:31,532 line:-2
并将它发布到默认的
NotificationCenter


245
00:15:31,598 --> 00:15:33,367 line:-1
与我们的视图控制器使用相同


246
00:15:34,034 --> 00:15:37,437 line:-1
现在这个测试起作用了


247
00:15:37,504 --> 00:15:38,906 line:-2
但它可能在app代码的
其他地方有未知的副作用


248
00:15:39,439 --> 00:15:41,608 line:-2
一些系统通知很常见
比如UI app


249
00:15:41,675 --> 00:15:45,345 line:-2
appDidFinish
Launchingnotification


250
00:15:45,412 --> 00:15:48,549 line:-1
被许多层观察到并且有未知的副作用


251
00:15:48,849 --> 00:15:51,218 line:-1
或者它只会减慢我们的测试速度


252
00:15:51,585 --> 00:15:54,788 line:-2
因此我们想
更好地隔离这些代码来测试它


253
00:15:56,790 --> 00:15:59,760 line:-2
我们可以使用一种技术
来更好地隔离这些测试


254
00:16:00,294 --> 00:16:01,962 line:-1
要使用它我们首先必须认识到


255
00:16:02,029 --> 00:16:04,831 line:-2
NotificationCenter
可以有多个实例


256
00:16:05,465 --> 00:16:10,137 line:-2
你可能会注意到
它有一个作为类属性的默认实例


257
00:16:10,204 --> 00:16:13,340 line:-1
但它支持在必要时创建其他实例


258
00:16:13,407 --> 00:16:15,709 line:-1
这将是隔离我们测试的关键


259
00:16:16,443 --> 00:16:20,647 line:-2
因此要应用这种技术我们首先
必须创建一个新的NotificationCenter


260
00:16:20,848 --> 00:16:24,618 line:-2
将它传递给我们的主题并使用它
而不是使用默认的实例


261
00:16:25,519 --> 00:16:27,754 line:-1
这通常被称为依赖注入


262
00:16:28,488 --> 00:16:30,824 line:-2
我们来看看
如何在视图控制器中使用它


263
00:16:31,892 --> 00:16:35,662 line:-2
在这里我有使用默认
NotificationCenter的原始代码


264
00:16:35,863 --> 00:16:38,198 line:-1
我将它修改为使用一个单独的实例


265
00:16:39,433 --> 00:16:41,768 line:-2
我添加了一个新的
NotificationCenter属性


266
00:16:41,969 --> 00:16:44,104 line:-2
并在设置它的初始化器中
添加了一个参数


267
00:16:44,738 --> 00:16:47,708 line:-1
它使用这个新属性


268
00:16:48,108 --> 00:16:49,643 line:-1
而不是向默认中心添加一个观察者


269
00:16:51,879 --> 00:16:56,183 line:-2
我还将向初始化器添加默认的
默认参数值


270
00:16:56,250 --> 00:16:59,253 line:-2
这样可以避免在我的app中
破坏任何现有代码


271
00:16:59,319 --> 00:17:02,189 line:-2
因为现有的客户端不需要通过
新的参数


272
00:17:02,256 --> 00:17:03,757 line:-1
只有我们的单元测试会需要


273
00:17:05,925 --> 00:17:07,828 line:-1
现在让我们回去并更新我们的测试


274
00:17:08,862 --> 00:17:10,396 line:-1
这是最初的测试代码


275
00:17:11,031 --> 00:17:14,434 line:-2
我已修改它以使用单独的
NotificationCenter


276
00:17:18,105 --> 00:17:21,608 line:-2
这显示了如何测试
我们的主题是否观察到了通知


277
00:17:21,675 --> 00:17:24,578 line:-2
但是如何测试
我们的主题是否发布了通知呢？


278
00:17:25,479 --> 00:17:29,116 line:-2
我们将再次使用相同的
单独NotificationCenter技巧


279
00:17:29,183 --> 00:17:32,252 line:-2
但我还将展示如何使用
内置的预期API


280
00:17:32,319 --> 00:17:34,087 line:-1
来添加通知观察者


281
00:17:35,489 --> 00:17:37,691 line:-1
这是我们app的另一部分代码


282
00:17:37,958 --> 00:17:39,893 line:-1
CurrentLocationProvider类


283
00:17:40,527 --> 00:17:44,431 line:-2
稍后我将详细讨论这个类
但是请注意


284
00:17:44,498 --> 00:17:46,700 line:-2
它有向我app中其他类
发送消息的方法


285
00:17:46,767 --> 00:17:50,771 line:-2
即该app的位置授权
已经通过发布通知进行更改


286
00:17:51,939 --> 00:17:53,273 line:-1
和我们的视图控制器一样


287
00:17:53,340 --> 00:17:56,276 line:-2
它目前正硬编码默认的
NotificationCenter


288
00:17:58,545 --> 00:18:00,881 line:-1
这是我为这个类写的单元测试


289
00:18:01,014 --> 00:18:03,050 line:-1
它用来验证


290
00:18:03,116 --> 00:18:05,652 line:-2
在调用NotifyAuthChanged
方法时是否发布通知


291
00:18:06,887 --> 00:18:10,824 line:-2
我们可以在这里的中间部分看到
这个测试使用addObserver方法


292
00:18:10,891 --> 00:18:12,726 line:-1
创建一个基于块的观察者


293
00:18:12,926 --> 00:18:15,095 line:-1
然后它移除块内的观察者


294
00:18:16,063 --> 00:18:18,031 line:-1
现在我可以对这个测试做一个改进


295
00:18:18,098 --> 00:18:19,399 line:-1
就是使用内置的


296
00:18:19,466 --> 00:18:22,402 line:-2
XCTNSNotificationExpectation
API


297
00:18:22,469 --> 00:18:26,373 line:-2
来为我们创建这个
NotificationCenter观察者


298
00:18:27,574 --> 00:18:28,876 line:-1
这是一个很好的改进


299
00:18:29,142 --> 00:18:31,612 line:-1
它允许我们删除几行代码


300
00:18:32,713 --> 00:18:34,515 line:-1
但它仍然有我们之前看到的问题


301
00:18:34,581 --> 00:18:37,417 line:-2
即隐式使用默认
NotificationCenter


302
00:18:37,484 --> 00:18:38,652 line:-1
我们来解决这个问题


303
00:18:40,120 --> 00:18:41,388 line:-1
这是我们的原始代码


304
00:18:42,556 --> 00:18:44,525 line:-1
我将应用前面看到的相同的技术


305
00:18:44,591 --> 00:18:47,728 line:-2
在初始化器中使用一个单独的
NotificationCenter


306
00:18:47,928 --> 00:18:50,664 line:-1
存储它并使用它而不是默认值


307
00:18:53,734 --> 00:18:55,369 line:-2
现在回到我们的测试代码
我将修改它


308
00:18:56,203 --> 00:18:59,339 line:-2
将一个新的NotificationCenter
传递给我们的主题


309
00:19:00,240 --> 00:19:02,342 line:-1
但是现在我们来看一下期望


310
00:19:03,310 --> 00:19:07,381 line:-2
当我们的测试期望接收到
一个特定中心的通知时


311
00:19:07,614 --> 00:19:10,083 line:-2
我们可以将
NotificationCenter参数


312
00:19:10,150 --> 00:19:11,852 line:-1
传递给预期的初始化器


313
00:19:13,720 --> 00:19:18,759 line:-1
我还想指出这个期望的超时值是0


314
00:19:18,926 --> 00:19:21,628 line:-1
这是因为我们实际上期望


315
00:19:21,695 --> 00:19:22,996 line:-1
它在我们等待它时已实现


316
00:19:23,830 --> 00:19:26,466 line:-2
这是因为在
NotifyAuthChanged方法返回时


317
00:19:26,533 --> 00:19:29,369 line:-1
方法返回时通知应该已经发布了


318
00:19:30,571 --> 00:19:33,740 line:-1
因此使用这对技术来测试通知


319
00:19:34,107 --> 00:19:36,443 line:-2
我们可以确保我们的测试
保持完全隔离


320
00:19:36,977 --> 00:19:40,814 line:-2
并且我们在不需要修改app中的
现有代码的情况下进行了更改


321
00:19:40,948 --> 00:19:43,383 line:-1
因为我们指定了默认的参数值


322
00:19:47,921 --> 00:19:50,190 line:-1
接下来我想谈谈在编写单元


323
00:19:50,257 --> 00:19:53,827 line:-2
测试时经常遇到的一个挑战
即与外部类交互


324
00:19:55,896 --> 00:19:59,166 line:-2
在开发app时
你可能会遇到这样的情况


325
00:19:59,233 --> 00:20:01,869 line:-1
你的类正在与其他类对话


326
00:20:01,935 --> 00:20:05,239 line:-2
无论是在app的其他地方
或者还是由SDK提供的


327
00:20:05,639 --> 00:20:07,941 line:-1
你发现编写测试很困难


328
00:20:08,008 --> 00:20:12,179 line:-1
因为创建外部类很难甚至是不可能的


329
00:20:12,846 --> 00:20:15,249 line:-1
这种情况经常发生 特别是


330
00:20:15,315 --> 00:20:17,417 line:-1
对于那些没有被直接创建的API中


331
00:20:17,751 --> 00:20:21,822 line:-2
而且当这些API具有需要测试的
委托方法时就更加困难了


332
00:20:22,890 --> 00:20:25,826 line:-1
我想展示如何通过模拟


333
00:20:25,959 --> 00:20:28,762 line:-2
与外部类的交互来使用协议
进而解决这个问题


334
00:20:28,929 --> 00:20:31,899 line:-1
而且这样做并不会降低测试的可靠性


335
00:20:34,134 --> 00:20:37,437 line:-2
在我们的app中
我们有一个使用CoreLocation的


336
00:20:37,504 --> 00:20:38,939 line:-1
CurrentLocationProvider类


337
00:20:39,806 --> 00:20:41,708 line:-2
它创建一个
CLLocationManager


338
00:20:41,842 --> 00:20:43,610 line:-1
并在它的初始化器中配置它


339
00:20:43,944 --> 00:20:47,614 line:-2
设置它想要的精度属性
并将自己设置为委托


340
00:20:50,017 --> 00:20:51,351 line:-1
这是这门类的重点


341
00:20:51,518 --> 00:20:53,654 line:-2
它是一个名为
checkCurrentLocation的方法


342
00:20:54,154 --> 00:20:56,857 line:-1
它请求当前位置并获取一个完成块


343
00:20:56,924 --> 00:20:59,693 line:-1
该块返回该位置是否为感兴趣的点


344
00:21:00,894 --> 00:21:03,197 line:-1
请注意我们在这里调用


345
00:21:03,263 --> 00:21:05,032 line:-2
CLLocationManager
上的请求位置方法


346
00:21:05,899 --> 00:21:09,069 line:-2
当我们调用它时
它将尝试获取当前位置


347
00:21:09,303 --> 00:21:11,738 line:-1
并最终调用类上的委托方法


348
00:21:12,172 --> 00:21:13,841 line:-1
那么 让我们来看看委托方法


349
00:21:15,309 --> 00:21:19,680 line:-2
我们使用一个扩展来遵循这里的
CLLocationManagerDelegate协议


350
00:21:19,813 --> 00:21:21,682 line:-1
我们并且调用一个存储完成块


351
00:21:22,449 --> 00:21:25,285 line:-2
好的
让我们为这个类写一个单元测试


352
00:21:26,753 --> 00:21:29,289 line:-2
这里是我尝试编写的一个
如果我们阅读它


353
00:21:29,489 --> 00:21:33,093 line:-2
我们可以看到它首先创建一个
CurrentLocationProvider


354
00:21:33,594 --> 00:21:37,197 line:-2
然后检查所需的精度
以及委托是否设置好


355
00:21:37,497 --> 00:21:38,532 line:-1
到现在为止还好


356
00:21:39,166 --> 00:21:40,734 line:-1
但事情就变得棘手了


357
00:21:41,301 --> 00:21:43,871 line:-2
我们想测试
checkCurrentLocation方法


358
00:21:44,137 --> 00:21:47,674 line:-2
因为这是我们的主要逻辑所在
但是我们有一个问题


359
00:21:48,175 --> 00:21:51,745 line:-1
我们无法知道何时调用请求位置方法


360
00:21:52,012 --> 00:21:55,983 line:-2
因为这是CLLocationManager上的
一个方法而非代码的一部分


361
00:21:57,551 --> 00:22:00,053 line:-2
我们在这个测试中
可能会遇到的另一个问题是


362
00:22:00,287 --> 00:22:03,190 line:-2
CoreLocation
需要用户授权


363
00:22:03,724 --> 00:22:05,893 line:-1
如果之前没有授权


364
00:22:05,959 --> 00:22:07,494 line:-1
它会在设备上显示权限对话框


365
00:22:08,362 --> 00:22:10,931 line:-1
这导致我们的测试依赖于设备状态


366
00:22:10,998 --> 00:22:14,368 line:-2
并且使它们更难维护
最终更有可能失败


367
00:22:16,336 --> 00:22:18,572 line:-1
因此如果你在过去遇到过这个问题


368
00:22:18,639 --> 00:22:21,575 line:-1
你可能会考虑对外部类进行子类化


369
00:22:21,642 --> 00:22:24,444 line:-1
并重写你调用它的任何方法


370
00:22:24,845 --> 00:22:29,016 line:-2
例如我们可以在这里尝试子类
CLLocationManager


371
00:22:29,082 --> 00:22:31,385 line:-1
并重写RequestLocation方法


372
00:22:31,952 --> 00:22:34,688 line:-1
这在一开始可能行得通 但有风险


373
00:22:35,622 --> 00:22:38,525 line:-2
SDK中的一些类
不是被设计成子类的


374
00:22:38,592 --> 00:22:39,826 line:-1
它们的行为可能不同


375
00:22:40,694 --> 00:22:43,797 line:-2
另外我们仍然需要调用
超类的初始化程序


376
00:22:43,864 --> 00:22:45,465 line:-1
这不是我们可以重写的代码


377
00:22:46,266 --> 00:22:47,701 line:-1
但是主要的问题是


378
00:22:47,768 --> 00:22:51,905 line:-2
如果我修改代码来调用
CLLocationManager上的另一个方法


379
00:22:52,139 --> 00:22:54,174 line:-1
我也要必须记住


380
00:22:54,241 --> 00:22:56,243 line:-1
在我的测试子类上重写该方法


381
00:22:57,044 --> 00:23:00,013 line:-1
如果我依赖子类 编译器不会通知我


382
00:23:00,080 --> 00:23:02,482 line:-1
我已经开始调用另一个方法


383
00:23:02,549 --> 00:23:04,685 line:-1
这很容易忘记和破坏我的测试


384
00:23:05,552 --> 00:23:07,321 line:-1
因此我不推荐这种方法


385
00:23:07,387 --> 00:23:11,225 line:-1
而我推荐使用协议模拟外部类型


386
00:23:11,291 --> 00:23:12,960 line:-1
我们来看看怎么做


387
00:23:14,494 --> 00:23:16,129 line:-1
这是原始代码


388
00:23:16,330 --> 00:23:19,032 line:-1
第一步是定义一个新协议


389
00:23:20,300 --> 00:23:22,703 line:-2
我已经命名了新协议
LocationFetcher


390
00:23:22,936 --> 00:23:25,405 line:-2
它包含了我的代码
从CLLocationManager中


391
00:23:25,472 --> 00:23:28,075 line:-1
使用的方法和属性的确切集合


392
00:23:28,976 --> 00:23:32,012 line:-1
成员名称和类型完全匹配


393
00:23:32,079 --> 00:23:35,883 line:-2
这允许我在
CLLocationManager上


394
00:23:35,949 --> 00:23:37,384 line:-1
创建一个符合协议的空扩展


395
00:23:37,451 --> 00:23:39,286 line:-1
因为它已经满足了所有要求


396
00:23:41,321 --> 00:23:44,858 line:-2
然后我将LocationManager属性
重命名为LocationFetcher


397
00:23:45,092 --> 00:23:47,794 line:-2
并将其类型更改为
LocationFetcher协议


398
00:23:49,663 --> 00:23:52,599 line:-2
我还将向初始化器添加一个
默认参数值


399
00:23:52,666 --> 00:23:56,170 line:-2
就像我之前所做的那样
以避免破坏任何现有的app代码


400
00:23:58,438 --> 00:24:01,708 line:-2
我需要对checkCurrentLocation
方法做一个小的更改


401
00:24:02,009 --> 00:24:03,544 line:-1
以使用重命名的属性


402
00:24:05,445 --> 00:24:07,548 line:-1
最后让我们看一下委托方法


403
00:24:08,182 --> 00:24:09,850 line:-1
这个部分处理起来有点棘手


404
00:24:09,917 --> 00:24:12,786 line:-1
因为委托期望Manager参数


405
00:24:12,853 --> 00:24:16,623 line:-2
是真正的CLLocationManager
而不是我的新协议


406
00:24:17,558 --> 00:24:20,627 line:-2
因此当委托参与时
事情会变得有点复杂


407
00:24:20,694 --> 00:24:22,930 line:-1
但是我们仍然可以在这里应用协议


408
00:24:23,130 --> 00:24:24,431 line:-1
让我们来看看


409
00:24:26,400 --> 00:24:29,770 line:-2
我将回到前面定义的
LocationFetcher协议


410
00:24:30,337 --> 00:24:34,141 line:-2
并将该委托属性重命名为
LocationFetcherDelegate


411
00:24:34,641 --> 00:24:36,677 line:-1
我将其类型更改为一个新协议


412
00:24:36,743 --> 00:24:40,514 line:-2
该协议的接口与
CLLocationManagerDelegate几乎相同


413
00:24:40,848 --> 00:24:42,516 line:-1
但是我调整了方法名


414
00:24:42,583 --> 00:24:45,719 line:-2
我将第一个参数的类型改为
LocationFetcher


415
00:24:49,356 --> 00:24:52,125 line:-1
现在我需要在扩展中实现


416
00:24:52,192 --> 00:24:56,063 line:-2
LocationFetcherDelegate属性
因为它不再满足这个要求


417
00:24:56,997 --> 00:24:59,867 line:-2
我将实现getter
和setter来使用强制转换


418
00:24:59,933 --> 00:25:03,070 line:-2
来回转换到
CLLocationManagerDelegate


419
00:25:03,570 --> 00:25:06,240 line:-2
稍后我会解释为什么
我在这里使用强制转换


420
00:25:08,242 --> 00:25:09,810 line:-1
然后在我的类的初始化器中


421
00:25:09,877 --> 00:25:12,913 line:-2
我需要用locationFetcher
Delegate替换委托属性


422
00:25:14,915 --> 00:25:17,818 line:-1
最后一步是修改原来的扩展


423
00:25:17,885 --> 00:25:21,655 line:-2
以符合新的模拟委托协议
这部分很容易


424
00:25:21,722 --> 00:25:25,726 line:-1
我需要做的就是替换协议和方法签名


425
00:25:26,560 --> 00:25:28,629 line:-1
但是 我实际上仍然需要遵守旧的


426
00:25:28,695 --> 00:25:31,965 line:-2
CLLocationManagerDelegate
协议


427
00:25:32,499 --> 00:25:34,601 line:-2
这是因为真正的
CLLocationManager


428
00:25:34,668 --> 00:25:37,004 line:-1
不知道我的模拟委托协议


429
00:25:38,272 --> 00:25:40,841 line:-2
因此这里的诀窍是
将符合实际委托协议的


430
00:25:40,908 --> 00:25:43,076 line:-1
扩展添加回来


431
00:25:43,143 --> 00:25:46,580 line:-2
但让它调用上面等效的
locationFetcher委托方法


432
00:25:47,981 --> 00:25:50,284 line:-1
前面我提到我在委托


433
00:25:50,350 --> 00:25:51,885 line:-2
getter和setter中
使用了强制转换


434
00:25:52,419 --> 00:25:55,455 line:-1
这是为了确保我的类符合这两种协议


435
00:25:55,522 --> 00:25:57,824 line:-1
我没有忘记其中的一种或另一种


436
00:26:01,562 --> 00:26:03,130 line:-1
因此在我的单元测试中


437
00:26:03,197 --> 00:26:06,733 line:-2
我将为模拟定义一个嵌套在
我的测试类中的struct


438
00:26:06,800 --> 00:26:08,969 line:-2
它符合
locationFetcher协议


439
00:26:09,036 --> 00:26:10,537 line:-1
并满足其要求


440
00:26:11,505 --> 00:26:13,407 line:-1
注意在它的requestLocation方法中


441
00:26:13,473 --> 00:26:17,611 line:-2
它调用一个块来获取一个假的位置
我可以在测试中自定义它


442
00:26:18,245 --> 00:26:21,682 line:-2
然它后调用委托方法
将那个假位置传递给它


443
00:26:24,585 --> 00:26:27,254 line:-2
现在我有了我所需要的一切
我可以写我的测试


444
00:26:27,988 --> 00:26:30,057 line:-2
我创建一个
MockLocationFetcher结构


445
00:26:30,123 --> 00:26:32,593 line:-2
并配置它的
handleRequestLocation块


446
00:26:32,659 --> 00:26:34,161 line:-1
以提供假位置


447
00:26:35,262 --> 00:26:39,600 line:-2
然后我创建CurrentLocationProvider
并将MockLocationFetcher传递给它


448
00:26:40,167 --> 00:26:43,637 line:-2
最后我用一个完成块调用
checkCurrentLocation


449
00:26:44,238 --> 00:26:45,606 line:-1
在完成块中有一个断言


450
00:26:45,672 --> 00:26:47,441 line:-1
用于检查位置


451
00:26:47,508 --> 00:26:49,076 line:-1
是一个感兴趣的点


452
00:26:51,178 --> 00:26:52,012 line:-1
所以它很管用


453
00:26:52,079 --> 00:26:54,948 line:-2
我现在可以模拟我的类使用
CLLocationManager


454
00:26:55,015 --> 00:26:56,850 line:-2
而不需要创建一个真正的
CLLocationManager


455
00:26:58,185 --> 00:27:00,120 line:-1
因此在这里我展示了如何使用


456
00:27:00,187 --> 00:27:03,690 line:-1
协议来模拟与外部类及其委托的交互


457
00:27:04,224 --> 00:27:06,760 line:-2
这是很多步骤
让我们回顾一下我们所做的


458
00:27:08,862 --> 00:27:10,764 line:-1
首先我们定义了一个新的协议


459
00:27:10,831 --> 00:27:13,600 line:-1
表示外部类的接口


460
00:27:14,301 --> 00:27:17,171 line:-2
该协议需要包含
我们在外部类上使用的


461
00:27:17,237 --> 00:27:19,339 line:-1
所有方法和属性


462
00:27:19,540 --> 00:27:22,409 line:-1
并且通常它们的声明可以完全匹配


463
00:27:23,777 --> 00:27:27,147 line:-2
接下来我们在原始的
外部类上创建了一个扩展


464
00:27:27,214 --> 00:27:29,082 line:-1
它声明符合协议


465
00:27:30,450 --> 00:27:32,953 line:-1
然后我们用我们的新协议替换了


466
00:27:33,020 --> 00:27:34,321 line:-1
外部类的所有用法


467
00:27:34,755 --> 00:27:36,523 line:-1
并添加了一个初始化器参数


468
00:27:36,590 --> 00:27:38,959 line:-1
以便在测试中设置该类型


469
00:27:41,028 --> 00:27:43,830 line:-1
我们还讨论了如何模拟委托协议


470
00:27:43,897 --> 00:27:45,933 line:-1
这是SDK中常见的模式


471
00:27:46,934 --> 00:27:48,669 line:-1
这里还有一些步骤


472
00:27:48,735 --> 00:27:49,837 line:-1
但这里是我们所做的


473
00:27:51,004 --> 00:27:55,008 line:-1
首先我们定义了一个模拟委托协议


474
00:27:55,075 --> 00:27:56,643 line:-2
其方法签名
与我们正模拟的协议相似


475
00:27:57,077 --> 00:28:00,747 line:-2
但是我们用模拟协议类型
代替了真正的类型


476
00:28:02,015 --> 00:28:05,719 line:-2
然后在我们最初的模拟协议中
我们重新命名了委托属性


477
00:28:05,953 --> 00:28:08,488 line:-1
并在扩展中实现了该重命名属性


478
00:28:09,857 --> 00:28:12,960 line:-2
因此虽然这种方法
可能需要更多的代码


479
00:28:13,026 --> 00:28:15,062 line:-1
而不是子类之类的替代方法


480
00:28:15,596 --> 00:28:17,731 line:-1
,它会更可靠 更不可能打破


481
00:28:17,798 --> 00:28:19,600 line:-1
我扩大我的代码


482
00:28:20,200 --> 00:28:22,069 line:-2
因为这样编译器将强制执行
我为代码调用的任何新方法


483
00:28:22,135 --> 00:28:27,207 line:-1
必须包括在这些新协议中


484
00:28:31,778 --> 00:28:35,716 line:-1
最后我想谈谈测试执行速度


485
00:28:38,118 --> 00:28:40,120 line:-1
当你的测试需要很长时间运行时


486
00:28:40,387 --> 00:28:42,422 line:-1
你就不太可能在开发期间运行它们


487
00:28:42,689 --> 00:28:45,292 line:-2
或者你可能会尝试跳过
运行时间最长的测试


488
00:28:46,159 --> 00:28:48,595 line:-2
我们的测试套件
会帮助我们及早发现问题


489
00:28:48,662 --> 00:28:50,497 line:-1
而修复回归是最容易的


490
00:28:50,731 --> 00:28:53,767 line:-2
因此我们希望确保我们的测试
总是尽可能快地运行


491
00:28:54,935 --> 00:28:56,770 line:-1
现在你可能在过去遇到过一些


492
00:28:56,837 --> 00:28:59,806 line:-1
需要在测试中人工等待或休眠的情况


493
00:28:59,873 --> 00:29:03,443 line:-2
因为你的测试是异步的
或者使用了计时器


494
00:29:04,378 --> 00:29:05,812 line:-1
延迟操作是很棘手的


495
00:29:05,879 --> 00:29:07,948 line:-2
我们希望确保
在我们的测试中包含它们


496
00:29:08,182 --> 00:29:11,118 line:-2
但是如果我们不小心的话
它们也会使事情变慢很多


497
00:29:11,818 --> 00:29:13,220 line:-1
因此我想谈谈一些


498
00:29:13,287 --> 00:29:15,722 line:-2
我们可以避免
在我们的测试中人为延迟的方法


499
00:29:15,789 --> 00:29:17,357 line:-1
因为它们永远都是不必要的


500
00:29:19,059 --> 00:29:20,194 line:-1
下面是一个例子


501
00:29:20,594 --> 00:29:22,930 line:-2
在Brian和我正在构建的
兴趣点app上


502
00:29:23,297 --> 00:29:25,432 line:-1
在主UI上 我们在底部有一个条带


503
00:29:25,499 --> 00:29:27,134 line:-1
它显示了特色的地方


504
00:29:27,534 --> 00:29:29,903 line:-1
它基本上是绕着附近的顶部旋转


505
00:29:30,237 --> 00:29:32,873 line:-1
每隔十秒钟就会显示一个新的位置


506
00:29:33,507 --> 00:29:36,343 line:-1
现在有几种方法可以实现这个功能


507
00:29:36,410 --> 00:29:38,812 line:-2
但是这里我使用的是
foundation中的timer API


508
00:29:40,948 --> 00:29:43,317 line:-2
让我们看一下我可能
为这个类编写的单元测试


509
00:29:44,051 --> 00:29:46,119 line:-2
它创建一个
FeaturedPlaceManager


510
00:29:46,520 --> 00:29:50,858 line:-2
并在调用scheduleNextPlace方法之前
存储它的当前位置


511
00:29:51,491 --> 00:29:54,127 line:-1
然后运行循环11秒


512
00:29:54,361 --> 00:29:56,496 line:-1
我加了一秒钟作为宽限期


513
00:29:57,397 --> 00:30:00,234 line:-2
最后它检查当前位置
在最后发生了变化


514
00:30:01,001 --> 00:30:04,137 line:-2
现在这不是很好
它需要很长时间才能运行


515
00:30:04,972 --> 00:30:08,208 line:-2
为了缓解这一问题
我们可以在代码中公开一个属性


516
00:30:08,275 --> 00:30:12,246 line:-2
以允许我们将超时定制为更短的时间
比如一秒


517
00:30:12,946 --> 00:30:16,216 line:-1
这就是代码改变的样子


518
00:30:20,754 --> 00:30:24,691 line:-2
现在使用这种方法
我们可以将测试延迟减少到1秒


519
00:30:25,359 --> 00:30:27,794 line:-1
这个方法比以前的好


520
00:30:27,861 --> 00:30:31,932 line:-2
我们的测试肯定会运行得更快
但仍然不理想


521
00:30:32,366 --> 00:30:35,002 line:-1
我们的代码还有延迟只是时间更短


522
00:30:35,669 --> 00:30:39,506 line:-2
真正的问题是
我们正在测试的代码仍然依赖于时间


523
00:30:39,773 --> 00:30:43,110 line:-2
这意味着
当我们使预期的延迟越来越短


524
00:30:43,177 --> 00:30:45,212 line:-1
我们的测试可能变得不那么可靠


525
00:30:45,345 --> 00:30:48,582 line:-2
因为它们将更依赖于CPU
来预测事情的进度


526
00:30:48,715 --> 00:30:51,919 line:-2
这并不总是正确的
尤其是对于异步代码


527
00:30:52,786 --> 00:30:54,755 line:-1
那么让我们来看看一个更好的方法


528
00:30:56,557 --> 00:30:59,793 line:-1
我建议首先确定延迟机制


529
00:31:00,127 --> 00:31:01,962 line:-1
在我的示例中它是一个定时器


530
00:31:02,029 --> 00:31:05,832 line:-2
但你也可以使用DispatchQueue
的asyncAfter API


531
00:31:06,867 --> 00:31:09,136 line:-1
我们想要模拟这个机制


532
00:31:09,203 --> 00:31:12,806 line:-2
以便我们能够
立即调用延迟的操作并绕过延迟


533
00:31:16,043 --> 00:31:17,544 line:-1
这里是我们的原始代码


534
00:31:17,845 --> 00:31:21,481 line:-2
让我们从这个scheduledTimer方法的
实际功能开始


535
00:31:22,516 --> 00:31:25,786 line:-2
ScheduledTimer
方法实际上为我们做了两件事


536
00:31:26,253 --> 00:31:30,224 line:-2
它创建一个计时器 然后将
该计时器添加到当前运行循环中


537
00:31:31,158 --> 00:31:34,394 line:-2
现在这个API
可以非常方便地创建计时器


538
00:31:34,628 --> 00:31:36,530 line:-1
但是如果我将这两个步骤分开


539
00:31:36,597 --> 00:31:38,699 line:-1
它将帮助我们使代码更可测试


540
00:31:40,601 --> 00:31:44,137 line:-1
在这里 我将前面的代码从使用


541
00:31:44,238 --> 00:31:48,442 line:-2
scheduledTimer转换为先创建计时器
后将其添加到当前的runLoop秒中


542
00:31:48,509 --> 00:31:50,210 line:-1
我已经将其存储在一个新属性中


543
00:31:51,545 --> 00:31:54,014 line:-1
现在这段代码相当于我们以前的代码


544
00:31:54,214 --> 00:31:56,183 line:-1
但是一旦我们将这两个步骤分开


545
00:31:56,650 --> 00:31:59,520 line:-1
我们就可以看到runLoop


546
00:31:59,586 --> 00:32:00,854 line:-1
只是这个类与之交互的另一个外部类


547
00:32:01,355 --> 00:32:02,589 line:-1
因此我们可以应用


548
00:32:02,656 --> 00:32:05,292 line:-2
我们前面讨论过的
带有协议的模拟技术


549
00:32:06,126 --> 00:32:10,464 line:-2
为此我们将创建一个小协议
其中包含这个addTimer方法


550
00:32:12,099 --> 00:32:14,401 line:-2
我调用了该新协议
TimerScheduler


551
00:32:14,601 --> 00:32:17,104 line:-1
它只有一个addTimer方法


552
00:32:17,271 --> 00:32:20,040 line:-2
它与runLoop API
的签名相匹配


553
00:32:22,242 --> 00:32:25,012 line:-1
现在回到我的代码中


554
00:32:25,078 --> 00:32:27,014 line:-2
我需用刚刚创建的协议
替换runLoop


555
00:32:29,683 --> 00:32:33,520 line:-2
在我的测试中我不想使用真正的
runLoop作为我的TimerScheduler


556
00:32:33,820 --> 00:32:38,125 line:-2
相反我想创建一个模拟调度器
它将计时器传递给我的测试


557
00:32:39,660 --> 00:32:43,096 line:-1
为此 我将创建一个嵌套在


558
00:32:43,163 --> 00:32:46,967 line:-2
我的单元测试类MockTimerScheduler中的新结构
它符合TimerScheduler协议


559
00:32:47,935 --> 00:32:51,471 line:-2
它存储一个块 每当被告知要
添加计时器时 该块就会被调用


560
00:32:53,907 --> 00:32:56,977 line:-2
有了所有的片段
我就可以写我的最后单元测试了


561
00:32:57,811 --> 00:33:02,683 line:-2
首先我创建一个MockTimerScheduler
并配置它的handleAddTimer块


562
00:33:03,450 --> 00:33:04,785 line:-1
这个块接收计时器


563
00:33:04,852 --> 00:33:08,589 line:-2
一旦它被添加到调度程序中
它将记录计时器的延迟


564
00:33:08,789 --> 00:33:13,627 line:-2
然后通过触发计时器来绕过延迟
来调用块


565
00:33:14,995 --> 00:33:18,832 line:-2
然后我们创建一个FeaturedPlaceManager
并为它提供MockTimerScheduler


566
00:33:19,933 --> 00:33:22,936 line:-2
最后 我们调用scheduleNextPlace
开始测试


567
00:33:23,837 --> 00:33:26,540 line:-1
好啊 我们的测试不再有任何延迟


568
00:33:27,040 --> 00:33:29,810 line:-1
它们执行得非常快而且不依赖于时间


569
00:33:29,877 --> 00:33:31,345 line:-1
所以它会更可靠


570
00:33:32,179 --> 00:33:36,016 line:-2
作为奖励
我现在可以使用底部的这个断言


571
00:33:36,083 --> 00:33:37,751 line:-1
来验证计时器延迟的数量


572
00:33:38,051 --> 00:33:40,587 line:-1
这不是我在之前的测试中所能做


573
00:33:42,890 --> 00:33:47,194 line:-2
所以就像我说的
我们代码的延迟已经完全消除了


574
00:33:48,028 --> 00:33:51,331 line:-2
我们认为这是测试涉及
延迟操作代码的一种很好的方法


575
00:33:51,765 --> 00:33:54,735 line:-1
但是对于测试中最快的总体执行速度


576
00:33:54,935 --> 00:33:57,571 line:-1
最好是直接构建大部分测试


577
00:33:57,638 --> 00:34:00,741 line:-1
而根本不需要模拟延迟操作


578
00:34:01,975 --> 00:34:03,510 line:-1
例如 在我们的app中


579
00:34:03,677 --> 00:34:07,347 line:-2
被延迟的动作
正在更改到下一个功能位置


580
00:34:07,781 --> 00:34:12,886 line:-2
我可能只需要一两次测试
就可以证明计时器延迟正常工作


581
00:34:13,219 --> 00:34:14,388 line:-1
对于其余的类


582
00:34:14,454 --> 00:34:17,056 line:-2
我可以直接调用
ShowNextPlace方法


583
00:34:17,123 --> 00:34:19,560 line:-1
根本不需要模拟一个计时器调度程序


584
00:34:22,563 --> 00:34:24,864 line:-1
在我们讨论测试执行速度这一主题时


585
00:34:24,931 --> 00:34:26,632 line:-1
我们还有一些其他的技巧要分享


586
00:34:27,701 --> 00:34:31,271 line:-2
我们已经看到的一个领域是
NSPredicateExpections的使用


587
00:34:31,839 --> 00:34:34,341 line:-1
我们指出的是这些类


588
00:34:34,408 --> 00:34:36,143 line:-1
几乎不像其他预期类那样具有性能


589
00:34:36,342 --> 00:34:39,880 line:-2
因为它们依赖于轮询机制
而不是更直接的回调机制


590
00:34:40,547 --> 00:34:42,449 line:-1
它们主要用于UI测试


591
00:34:42,516 --> 00:34:46,053 line:-1
其中评估的条件发生在另一个进程中


592
00:34:46,386 --> 00:34:49,556 line:-2
因此在单元测试中
我们建议使用更直接的机制


593
00:34:49,623 --> 00:34:55,495 line:-2
例如常规的XCTestExec
NSNotification或KVOExec


594
00:34:58,031 --> 00:34:59,600 line:-1
另一个测试速度提示是


595
00:34:59,666 --> 00:35:02,469 line:-1
确保你的app尽快启动


596
00:35:03,337 --> 00:35:06,540 line:-2
现在大多数app都必须
在启动时做一些设置工作


597
00:35:06,840 --> 00:35:09,877 line:-2
尽管这种工作
对于常规app的启动是必要的


598
00:35:10,310 --> 00:35:12,913 line:-2
但当你的app作为
测试运行程序启动时


599
00:35:12,980 --> 00:35:14,648 line:-1
很多工作可能是不必要的


600
00:35:15,249 --> 00:35:19,152 line:-1
例如加载视图控制器 启动网络请求


601
00:35:19,219 --> 00:35:21,588 line:-1
或配置分析包


602
00:35:21,655 --> 00:35:24,091 line:-1
这些都是单元测试场景中


603
00:35:24,157 --> 00:35:25,692 line:-1
通常不必要的东西


604
00:35:27,094 --> 00:35:30,898 line:-1
XCTest在开始运行测试之前


605
00:35:30,964 --> 00:35:32,699 line:-1
等待app委托完成启动方法返回


606
00:35:33,133 --> 00:35:35,302 line:-2
因此若你分析并注意到
app启动在测试中


607
00:35:35,369 --> 00:35:37,371 line:-1
花费了很长时间


608
00:35:38,071 --> 00:35:41,008 line:-2
一个技巧就是检测你的app
何时作为测试运行程序启动


609
00:35:41,074 --> 00:35:42,176 line:-1
并避免这项工作


610
00:35:44,111 --> 00:35:49,016 line:-2
一种方法是指定自定义环境变量
或启动参数


611
00:35:49,850 --> 00:35:53,353 line:-2
打开方案编辑器
转到左侧的测试操作


612
00:35:53,620 --> 00:35:55,155 line:-1
然后到参数选项卡


613
00:35:55,355 --> 00:35:58,559 line:-2
然后添加一个环境变量
或一个启动参数


614
00:35:59,259 --> 00:36:01,862 line:-2
在这个屏幕截图中
我添加了一个环境变量


615
00:36:01,929 --> 00:36:04,264 line:-2
名为IS-UNIT-TESTING
设置为1


616
00:36:06,400 --> 00:36:09,770 line:-2
然后 修改app委托的
appDidFinishLaunching代码


617
00:36:09,837 --> 00:36:12,639 line:-1
使用类似于此的代码检查此条件


618
00:36:13,540 --> 00:36:16,343 line:-1
现在 如果你这样做


619
00:36:16,410 --> 00:36:19,213 line:-2
请确保你跳过的代码
对于单元测试的功能来说并不重要


620
00:36:22,916 --> 00:36:28,989 line:-2
最后总结一下Brian开始时候
提醒我们测试金字塔


621
00:36:29,423 --> 00:36:31,792 line:-2
以及如何在app中
有一个均衡的测试策略


622
00:36:32,292 --> 00:36:35,896 line:-1
展示几种测试网络操作的实用技术


623
00:36:36,897 --> 00:36:40,167 line:-1
然后我讨论了隔离基础通知


624
00:36:40,734 --> 00:36:42,269 line:-1
并使用依赖项注入


625
00:36:43,437 --> 00:36:46,039 line:-1
我们为编写测试时最常见的挑战之一


626
00:36:46,106 --> 00:36:49,343 line:-2
即与外部类交互
提供了一个解决方案


627
00:36:49,877 --> 00:36:51,245 line:-1
即使它们有一个委托


628
00:36:52,312 --> 00:36:54,982 line:-1
我们还分享了一些保持测试快速运行


629
00:36:55,048 --> 00:36:56,850 line:-1
和避免人为延迟的技巧


630
00:36:57,784 --> 00:36:59,486 line:-1
我们真的希望你觉得这些测试有用


631
00:36:59,553 --> 00:37:02,089 line:-2
并在下次编写测试时
寻找应用它们的方法


632
00:37:04,625 --> 00:37:07,628 line:-2
要了解更多信息
请查看这个链接上的演讲网页


633
00:37:07,895 --> 00:37:08,962 line:-1
如果你错过了


634
00:37:09,029 --> 00:37:12,733 line:-2
我们希望你能看看
周三“视频测试新特性”演讲


635
00:37:13,700 --> 00:37:16,003 line:-2
非常感谢
希望你们度过一个很棒的WWDC

