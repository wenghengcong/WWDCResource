1
00:00:16,917 --> 00:00:21,922 line:0
（订阅工程实现最佳实践）


2
00:00:21,989 --> 00:00:22,990 line:0
（演讲705）


3
00:00:23,056 --> 00:00:24,191 line:0
大家下午好


4
00:00:30,364 --> 00:00:32,332 line:-2
我叫Pete Hare
我是Apple App Store团队的


5
00:00:32,399 --> 00:00:34,168 line:-1
一名工程经理


6
00:00:34,234 --> 00:00:36,870 line:-1
我们在这里讨论构建你的app


7
00:00:36,937 --> 00:00:39,806 line:-2
和服务器基础设施的最佳方式
从而支持订阅服务


8
00:00:40,541 --> 00:00:42,509 line:-1
今天我将在这里讨论几个主题


9
00:00:42,709 --> 00:00:44,111 line:-1
首先 我们将讨论构建


10
00:00:44,178 --> 00:00:46,180 line:-2
你的app和服务器体系结构
的最佳方法


11
00:00:47,080 --> 00:00:49,249 line:-1
我们还会介绍一些有助于提升


12
00:00:49,316 --> 00:00:51,118 line:-1
用户app内体验的窍门和技巧


13
00:00:52,152 --> 00:00:53,854 line:-1
我的同事Michael会谈下


14
00:00:53,921 --> 00:00:55,923 line:-1
如何减少订户流失


15
00:00:56,590 --> 00:00:58,492 line:-1
最后我们将会宣布一些


16
00:00:58,559 --> 00:01:01,094 line:-1
你可以使用的分析和报告工具


17
00:01:02,162 --> 00:01:03,530 line:-1
但首先让我们谈一谈


18
00:01:03,597 --> 00:01:05,732 line:-2
如何构建你的app
和服务器基础架构


19
00:01:05,799 --> 00:01:07,000 line:-1
（设备和服务器架构）


20
00:01:07,334 --> 00:01:09,503 line:-1
我们从一个简单的问题开始


21
00:01:10,270 --> 00:01:11,505 line:-1
什么是订阅？


22
00:01:12,639 --> 00:01:15,175 line:-1
订阅就是让用户


23
00:01:15,242 --> 00:01:18,512 line:-2
通过周期性的向你付费
来访问你的内容或服务


24
00:01:19,146 --> 00:01:20,914 line:-1
当你从工程层面看它时


25
00:01:20,981 --> 00:01:23,951 line:-1
订阅实际上只是一组重复交易


26
00:01:24,284 --> 00:01:27,254 line:-1
其中每个将解锁某个订阅周期


27
00:01:28,555 --> 00:01:30,324 line:-1
若想在你的app中使用订阅功能


28
00:01:30,624 --> 00:01:32,492 line:-2
作为一名开发人员
你需要做一些事情


29
00:01:32,559 --> 00:01:34,962 line:-1
来处理这些交易


30
00:01:35,395 --> 00:01:36,496 line:-1
我们看看其中每一步


31
00:01:36,563 --> 00:01:40,734 line:-2
首先 它始于你的app
收到一笔交易


32
00:01:42,002 --> 00:01:44,037 line:-1
你的app收到交易后 你需要继续


33
00:01:44,104 --> 00:01:46,440 line:-1
验证它是一笔真实的交易


34
00:01:46,507 --> 00:01:48,308 line:-1
即资金已经转移了


35
00:01:49,443 --> 00:01:53,614 line:-2
然后你就可以更新和维护
该用户的订阅状态


36
00:01:53,680 --> 00:01:55,782 line:-1
以便他们能够持续访问你的服务


37
00:01:56,683 --> 00:01:58,585 line:-1
让我们更详细地介绍其中每一个步骤


38
00:01:58,652 --> 00:02:02,256 line:-2
首先 我们谈谈在你的app中
接收该交易


39
00:02:04,024 --> 00:02:06,426 line:0
现在无论是首次购买订阅


40
00:02:06,493 --> 00:02:08,862 line:0
还是续订交易


41
00:02:09,395 --> 00:02:11,932 line:0
你的app均已被设为
使用StoreKit框架


42
00:02:11,999 --> 00:02:14,101 line:0
来处理订阅和交易


43
00:02:14,735 --> 00:02:17,237 line:0
当你用StoreKit处理交易时


44
00:02:17,304 --> 00:02:21,208 line:0
App Store将在后台
对用户的信用卡收取这些费用


45
00:02:21,642 --> 00:02:25,345 line:0
无论何时只要有交易发生
它都会通过一个名为


46
00:02:25,412 --> 00:02:27,214 line:0
SKPaymentTransactionsObserver
的东西


47
00:02:27,281 --> 00:02:28,515 line:0
来通知你的app


48
00:02:30,083 --> 00:02:33,720 line:0
这个交易观察者对象
实际上是你的app中


49
00:02:33,921 --> 00:02:35,689 line:0
app内购买的核心部分


50
00:02:35,756 --> 00:02:38,392 line:-2
它只是StoreKit中
一个协议 看起来像这样


51
00:02:38,458 --> 00:02:39,860 line:-1
你可将其设置在任何对象上


52
00:02:40,260 --> 00:02:42,963 line:-2
这例子中 我们将它
设置在AppDelegate上


53
00:02:43,797 --> 00:02:46,433 line:-2
但最重要的是你需要
在app生命周期中


54
00:02:46,500 --> 00:02:50,404 line:-2
尽可能早的添加一个交易观察者
到默认支付队列


55
00:02:51,471 --> 00:02:54,875 line:-2
一旦你在默认支付队列中
注册了交易观察者


56
00:02:54,942 --> 00:02:56,743 line:-1
你就准备好开始接收


57
00:02:56,810 --> 00:02:58,245 line:-1
后台所发生的交易了


58
00:02:59,880 --> 00:03:01,682 line:-1
你在交易观察者中的


59
00:03:01,748 --> 00:03:04,551 line:-2
一个名为updatedTransactions的
回调函数中接收交易


60
00:03:04,952 --> 00:03:07,487 line:-1
StoreKit会通知你的app


61
00:03:07,554 --> 00:03:09,690 line:-1
你要处理的一组交易


62
00:03:09,957 --> 00:03:11,558 line:-1
它们可以各种不同的状态出现


63
00:03:11,625 --> 00:03:13,794 line:-2
我们不打算在这次演讲中
深入讨论这些状态


64
00:03:13,861 --> 00:03:16,563 line:-1
但请注意已购买状态的交易


65
00:03:17,231 --> 00:03:19,733 line:-2
这是StoreKit
正在告诉你的app


66
00:03:19,800 --> 00:03:22,035 line:-1
这笔交易已准备好进行验证和解锁


67
00:03:24,638 --> 00:03:26,206 line:-1
一旦你有一笔处于已购买状态的交易


68
00:03:26,273 --> 00:03:28,442 line:-1
你已准备好进行下一步


69
00:03:28,509 --> 00:03:30,310 line:-1
即验证它是一个真实的交易


70
00:03:32,412 --> 00:03:34,248 line:-1
所以当涉及到检查真实性的时候


71
00:03:34,314 --> 00:03:36,783 line:-1
你怎么知道钱真的已经转手了呢？


72
00:03:37,985 --> 00:03:39,686 line:-2
你可用一种称为
App Store收据的东西


73
00:03:40,487 --> 00:03:43,323 line:-2
App Store收据
如你在百货公司得到的收据一样


74
00:03:43,390 --> 00:03:45,759 line:-1
它是用户说他们购买了某东西的


75
00:03:45,826 --> 00:03:47,094 line:-1
购买证明


76
00:03:47,728 --> 00:03:50,497 line:-1
在这种情况下 它是app首次下载


77
00:03:50,564 --> 00:03:53,133 line:-2
以及该app中发生的
任何app内购买的可信记录


78
00:03:54,568 --> 00:03:57,137 line:-2
这是一个数字文件
它存储在用户的设备上


79
00:03:57,204 --> 00:03:58,906 line:-1
我们为你提供一个API来访问它


80
00:03:59,439 --> 00:04:01,141 line:-1
并且它由App Store生成


81
00:04:02,342 --> 00:04:04,845 line:-2
我们还使用数字证书
对此文档进行签名


82
00:04:04,912 --> 00:04:07,581 line:-1
以便你可以检查以确保它


83
00:04:07,648 --> 00:04:09,349 line:-1
是由Apple发布的真实文档


84
00:04:10,551 --> 00:04:13,954 line:-2
最后 该文档仅适用于
你的设备上的该app


85
00:04:14,188 --> 00:04:16,156 line:-1
如果你之前使用过订阅服务


86
00:04:16,223 --> 00:04:18,959 line:-1
你会注意到拥有多台设备的用户


87
00:04:19,493 --> 00:04:22,095 line:-2
他们的收据在每台设备上
看起来略有不同


88
00:04:23,964 --> 00:04:26,033 line:-1
当涉及到验证你的app


89
00:04:26,099 --> 00:04:27,467 line:-1
所获悉的交易时


90
00:04:27,534 --> 00:04:29,269 line:-1
你需要做的第一步是验证该文档


91
00:04:29,336 --> 00:04:32,339 line:-2
也就是App Store收据
是真实的


92
00:04:32,406 --> 00:04:33,407 line:-1
你怎么做到呢？


93
00:04:35,142 --> 00:04:36,143 line:-1
通过两种方式完成此操作


94
00:04:36,210 --> 00:04:38,345 line:-1
首先 你可以使用设备上验证


95
00:04:38,412 --> 00:04:40,681 line:-1
它直接发生在用户的设备上


96
00:04:40,747 --> 00:04:43,483 line:-2
你可以通过一系列检查
来校验用来签发该app的证书


97
00:04:43,550 --> 00:04:45,752 line:-1
并验证其是否可信


98
00:04:46,220 --> 00:04:49,056 line:-2
或你可使用被称为
“服务器到服务器验证”的技术


99
00:04:49,690 --> 00:04:52,960 line:-2
第二种技术是将
二进制编码的收据数据


100
00:04:53,427 --> 00:04:54,761 line:-1
发送到你自己的服务器


101
00:04:55,095 --> 00:04:57,831 line:-2
再从你的服务器发送到
App Store进行处理


102
00:04:58,031 --> 00:05:00,367 line:-2
App Store
将为你做这些检查


103
00:05:00,834 --> 00:05:02,302 line:-2
（收据验证
别让你的app上当受骗）


104
00:05:02,369 --> 00:05:04,938 line:-2
你可以使用这其中任何一种技术
但无论你选择哪种


105
00:05:05,005 --> 00:05:06,773 line:-1
最重要的是不要在用户的设备上


106
00:05:06,840 --> 00:05:09,543 line:-2
使用在线验证
这不是一种安全的方式


107
00:05:09,610 --> 00:05:12,412 line:-1
来验证此文件是真实的


108
00:05:13,080 --> 00:05:14,715 line:-1
但让我们在细节上


109
00:05:14,781 --> 00:05:17,451 line:-2
比较一下这两种方法
尤其是订阅管理


110
00:05:17,518 --> 00:05:19,286 line:-1
和可更新订单订阅


111
00:05:20,287 --> 00:05:22,523 line:-1
这两种技术都可以用来


112
00:05:22,589 --> 00:05:24,358 line:-1
验证文件的真实性


113
00:05:25,592 --> 00:05:27,461 line:-1
它们还可以让你访问收据的内容


114
00:05:27,528 --> 00:05:30,430 line:-1
比如该特定用户发生的任何交易


115
00:05:31,398 --> 00:05:33,133 line:-1
但当涉及到可更新订单订阅时


116
00:05:33,200 --> 00:05:36,203 line:-2
服务器到服务器收据验证
有几个关键优势


117
00:05:36,270 --> 00:05:38,839 line:-1
要优于使用设备上收据验证


118
00:05:39,506 --> 00:05:42,075 line:-1
首先 我们在验证的响应中


119
00:05:42,142 --> 00:05:44,945 line:-1
会包含一些额外的订阅信息


120
00:05:45,279 --> 00:05:47,848 line:-2
你可使用这些信息
Michael稍后继续讨论这点


121
00:05:47,915 --> 00:05:49,216 line:-1
（比较验证方法）


122
00:05:49,283 --> 00:05:50,918 line:-1
你的服务器始终处于开启状态


123
00:05:50,984 --> 00:05:53,020 line:-1
以便于在后台处理这些续订交易


124
00:05:53,086 --> 00:05:56,690 line:-2
如果你拥有多个平台的服务
这点就非常重要


125
00:05:58,458 --> 00:06:01,061 line:0
你的服务器不易受
设备时钟更改的影响


126
00:06:01,728 --> 00:06:03,764 line:0
如果你使用设备上收据验证


127
00:06:03,830 --> 00:06:05,699 line:0
来在用户设备上进行订阅管理


128
00:06:05,766 --> 00:06:08,435 line:0
实际上没有任何东西能够
阻止用户调整他们的时钟


129
00:06:08,502 --> 00:06:10,904 line:0
以使自己仍处于有效的订阅期


130
00:06:10,971 --> 00:06:14,408 line:0
比如他们已经失效的免费试用期


131
00:06:15,776 --> 00:06:17,778 line:0
最后 它更简单


132
00:06:18,579 --> 00:06:21,348 line:0
在服务器到服务器验证中
你只需与JSON API打交道


133
00:06:21,415 --> 00:06:24,952 line:0
不必使用OpenSSL
或ASN.1解码


134
00:06:25,018 --> 00:06:27,254 line:0
考虑到所有这些因素
我们真的很鼓励


135
00:06:27,321 --> 00:06:30,023 line:-2
越来越多的人
在涉及到维护自动更新订阅状态时


136
00:06:30,090 --> 00:06:33,260 line:-1
采用服务器到服务器验证


137
00:06:34,461 --> 00:06:37,931 line:-2
如果你有一个简单的不需联网的
实用app


138
00:06:37,998 --> 00:06:41,301 line:-2
你仍然可以使用设备上验证
进行订阅管理


139
00:06:41,635 --> 00:06:43,136 line:-1
若你有兴趣了解更多相关信息


140
00:06:43,203 --> 00:06:44,404 line:-1
我想邀请你观看


141
00:06:44,471 --> 00:06:46,440 line:-2
去年StoreKit进阶
的演讲视频


142
00:06:46,507 --> 00:06:49,543 line:-2
我们在该视频中更详细地介绍了
设备上收据验证


143
00:06:50,110 --> 00:06:52,579 line:-2
但这次演讲的目的是
我们主要关注


144
00:06:52,646 --> 00:06:55,249 line:-1
这里列出的服务器到服务器技术


145
00:06:56,183 --> 00:06:57,317 line:-1
让我们回到刚才的例子


146
00:06:57,384 --> 00:06:59,386 line:-2
并了解我们如何使用
服务器到服务器验证


147
00:06:59,453 --> 00:07:01,154 line:-1
来处理当前这笔交易


148
00:07:01,722 --> 00:07:03,490 line:-1
回到我们的交易观察者


149
00:07:03,824 --> 00:07:05,726 line:-2
你可以使用主包中的
appStoreReceiptURL API


150
00:07:05,792 --> 00:07:09,062 line:-1
来访问该二进制收据数据


151
00:07:09,897 --> 00:07:13,100 line:-2
一旦你获取该URL
你就可以提取出文件系统中该处的


152
00:07:13,166 --> 00:07:16,737 line:-2
二进制数据 接着你可以使用
base64Encode


153
00:07:16,803 --> 00:07:19,339 line:-2
取出那个receiptData
会返回一字符串


154
00:07:19,406 --> 00:07:21,675 line:-2
你可以将其发送到
你自己的服务器进行处理


155
00:07:21,742 --> 00:07:24,311 line:-2
你可能会调用
currentUser上的


156
00:07:24,378 --> 00:07:25,579 line:-1
一些app内的网络API


157
00:07:27,114 --> 00:07:29,383 line:-1
当你将数据发送到服务器进行处理时


158
00:07:29,449 --> 00:07:31,552 line:-1
显然你首先需要安全地做到这一点


159
00:07:31,618 --> 00:07:33,854 line:-1
你可以将它发送到你的服务器上的


160
00:07:33,921 --> 00:07:34,922 line:-1
/processTransaction端点


161
00:07:35,422 --> 00:07:37,758 line:-2
在此端点中
你可能包含一个参数userID


162
00:07:37,824 --> 00:07:40,794 line:-1
其与系统中当前用户的账户相关联


163
00:07:41,795 --> 00:07:43,764 line:-2
你可以将此收据数据
发送至你的服务器


164
00:07:43,830 --> 00:07:47,134 line:0
然后一旦你的服务器收到它
你就可以建立一个安全连接


165
00:07:47,201 --> 00:07:49,570 line:0
到App Store的
/verifyReceipt端点


166
00:07:50,070 --> 00:07:53,006 line:0
然后你就可以将收据数据
发送到App Store了


167
00:07:53,707 --> 00:07:55,676 line:0
在这里你可以包含一个密码字段


168
00:07:55,742 --> 00:07:58,879 line:0
这是你的app
和App Store间的共享密钥


169
00:07:58,946 --> 00:08:01,815 line:0
你可在App Store Connect中
对其进行设置并将其存储在你的服务器上


170
00:08:01,882 --> 00:08:03,050 line:0
（验证一笔交易）


171
00:08:03,116 --> 00:08:06,053 line:0
当你将此收据数据发送到
/verifyReceipt端点时


172
00:08:06,119 --> 00:08:07,654 line:0
/verifyReceipt端点
将返回


173
00:08:07,721 --> 00:08:09,990 line:0
一个类似这样的JSON载荷


174
00:08:11,792 --> 00:08:13,994 line:0
当你验证交易的真实性时


175
00:08:14,061 --> 00:08:16,864 line:0
首先检查的是这个status字段


176
00:08:17,164 --> 00:08:18,665 line:0
它能够表明Apple


177
00:08:18,732 --> 00:08:21,201 line:0
的确签发了这个文档


178
00:08:21,635 --> 00:08:24,171 line:0
一旦你确认了
这个status字段为0


179
00:08:24,238 --> 00:08:27,708 line:0
你就可以检查此载荷的
receipt部分的内容


180
00:08:27,941 --> 00:08:29,943 line:0
这是你发送给
/verifyReceipt端点的


181
00:08:30,010 --> 00:08:32,346 line:0
二进制数据的解码版本


182
00:08:32,412 --> 00:08:35,582 line:0
因此你可在此做些事
如验证此收据中bundle_id


183
00:08:35,649 --> 00:08:38,251 line:0
是否与你的app的包ID相匹配


184
00:08:39,019 --> 00:08:41,522 line:0
然后你可以检查in_app数组


185
00:08:41,722 --> 00:08:45,092 line:0
它包含此app中该用户的交易列表


186
00:08:45,726 --> 00:08:48,495 line:0
你还可以验证该收据的
product_id


187
00:08:48,996 --> 00:08:51,632 line:0
是否与你app中的该字段相匹配


188
00:08:52,499 --> 00:08:54,067 line:0
假设这些都匹配


189
00:08:54,434 --> 00:08:56,670 line:0
你就可以决定此收据能够


190
00:08:56,737 --> 00:08:59,072 line:0
赋予这个特定的用户
使用你的订阅产品的权利


191
00:08:59,139 --> 00:09:01,375 line:0
现在你已准备好继续进行第三步


192
00:09:01,842 --> 00:09:03,777 line:-1
更新用户的订阅状态


193
00:09:07,481 --> 00:09:09,950 line:-1
与每个订阅周期始于某笔交易类似


194
00:09:10,017 --> 00:09:13,253 line:-1
它也会以到期日期结束


195
00:09:14,454 --> 00:09:16,757 line:-2
/verifyReceipt的
响应会告诉我们


196
00:09:16,823 --> 00:09:19,459 line:-1
每个交易的到期日期


197
00:09:19,526 --> 00:09:22,296 line:-2
回头看一下
/verifyReceipt响应


198
00:09:22,596 --> 00:09:24,865 line:-1
你会注意到交易中的


199
00:09:24,932 --> 00:09:26,433 line:-1
这个expires_date字段


200
00:09:26,500 --> 00:09:27,634 line:-1
（更新订阅状态）


201
00:09:27,701 --> 00:09:29,136 line:-1
现在让我们看看用户表


202
00:09:29,203 --> 00:09:31,438 line:-2
你可能会将这些数据
保存在你的服务器上


203
00:09:33,006 --> 00:09:35,375 line:-1
你可以从此交易中获取此过期日期


204
00:09:35,442 --> 00:09:37,911 line:-2
并将其填充到你的服务器上的
一个字段中


205
00:09:37,978 --> 00:09:40,814 line:-2
比如该用户的
latestExpiresDate字段


206
00:09:40,881 --> 00:09:44,117 line:-1
这个字段将作为你的服务器


207
00:09:44,184 --> 00:09:47,154 line:-1
判断该用户是否为订阅用户的依据


208
00:09:48,355 --> 00:09:50,791 line:-2
你也应该记录这个字段
original_transaction_id


209
00:09:50,858 --> 00:09:53,460 line:-1
你可以将其


210
00:09:53,527 --> 00:09:55,262 line:-1
保存到该用户的


211
00:09:55,329 --> 00:09:56,930 line:-1
originalTransactionId字段中


212
00:09:56,997 --> 00:09:58,465 line:-1
我们稍后还会谈到


213
00:09:58,532 --> 00:09:59,867 line:-1
为什么这很重要


214
00:10:01,468 --> 00:10:03,403 line:-1
一旦你在服务器上保存了


215
00:10:03,470 --> 00:10:05,339 line:-1
该用户的这两样信息


216
00:10:05,405 --> 00:10:07,007 line:-1
你就可以进行最后一步


217
00:10:07,074 --> 00:10:09,877 line:-1
也就是通知设备该交易通过了


218
00:10:09,943 --> 00:10:11,278 line:-1
你的验证


219
00:10:11,945 --> 00:10:14,047 line:-1
然后当你的设备得到这个回调


220
00:10:14,114 --> 00:10:17,551 line:-2
它就会在你的交易观察者中
调用finishTransaction函数


221
00:10:18,252 --> 00:10:20,554 line:-2
这是一个非常重要的步骤
因为完成交易


222
00:10:20,621 --> 00:10:22,756 line:-1
实际上会将其清除出你的支付队列


223
00:10:22,823 --> 00:10:26,126 line:-2
如果你不调用finishTransaction
它可能会在下次app启动时


224
00:10:26,193 --> 00:10:27,861 line:-1
再次出现以进行处理


225
00:10:27,928 --> 00:10:30,898 line:-2
因此请确保你完成每个
在StoreKit中开始的交易


226
00:10:32,833 --> 00:10:34,701 line:-1
当你完成交易后


227
00:10:34,768 --> 00:10:36,637 line:-1
你的服务器中将有更新后的订阅状态


228
00:10:36,703 --> 00:10:40,073 line:-2
用户现在可以在订阅期内
自由享受该服务


229
00:10:43,143 --> 00:10:45,279 line:-1
现在让我们再看看我提到的那个


230
00:10:45,345 --> 00:10:46,947 line:-1
保存在你的服务器上的用户表


231
00:10:47,781 --> 00:10:50,284 line:-1
使用此设置购买订阅的每个用户


232
00:10:50,350 --> 00:10:52,986 line:-2
都将被分配一个唯一的
originalTransactionId


233
00:10:53,053 --> 00:10:56,089 line:-1
即你从交易响应中保存的字段


234
00:10:56,924 --> 00:11:00,093 line:-2
这个标识符实质上
就是该用户的订阅ID


235
00:11:01,261 --> 00:11:04,798 line:-2
它很重要 因为它将显示在
所有后续续订交易中


236
00:11:05,098 --> 00:11:06,800 line:-1
让我们来看看这是如何工作的


237
00:11:07,167 --> 00:11:09,570 line:-1
假设你正在验证一笔续订交易


238
00:11:09,636 --> 00:11:11,038 line:-1
这与你在你的服务器上使用


239
00:11:11,104 --> 00:11:13,707 line:-2
/processTransaction端点
的方式完全相同


240
00:11:14,708 --> 00:11:17,578 line:-2
当你验证这笔交易时
假设它是一个有效的交易


241
00:11:18,111 --> 00:11:21,849 line:-2
你到了更新该用户的
订阅状态这个阶段


242
00:11:22,583 --> 00:11:24,751 line:-1
你会发现这里现在有多笔交易


243
00:11:24,818 --> 00:11:26,620 line:-1
因为这是一笔续订交易


244
00:11:26,687 --> 00:11:27,888 line:-1
（更新订阅状态）


245
00:11:27,955 --> 00:11:30,591 line:-1
现在根据你现有的服务器端逻辑


246
00:11:31,091 --> 00:11:33,260 line:-1
这个最新的到期日期已经过了


247
00:11:33,327 --> 00:11:36,330 line:-2
所以此用户目前不是订阅用户
你需要根据收据中的数据弄清楚


248
00:11:36,396 --> 00:11:39,199 line:-1
他们是否还是订阅用户


249
00:11:40,100 --> 00:11:43,770 line:-2
那么你如何使用此收据数据
来进行判断呢？


250
00:11:43,837 --> 00:11:47,608 line:-1
为了判断用户是否处于订阅有效期


251
00:11:47,674 --> 00:11:50,244 line:-2
你可以找出与
originalTransactionId对应的


252
00:11:50,310 --> 00:11:52,079 line:-1
那笔交易


253
00:11:52,145 --> 00:11:53,247 line:-1
（用户是否处于订阅有效期？）


254
00:11:53,313 --> 00:11:56,617 line:-2
然后你可以找到具有最新
expires_date的交易


255
00:11:57,184 --> 00:11:59,853 line:-1
如果你发现该日期是过去的某天


256
00:12:00,087 --> 00:12:02,122 line:-2
则表明该用户
不再处于订阅有效期内了


257
00:12:02,189 --> 00:12:04,091 line:-1
但是如果该日期是将来某天


258
00:12:04,291 --> 00:12:07,761 line:-1
则表示此用户仍处于有效订阅期


259
00:12:08,328 --> 00:12:11,398 line:-2
我们通过刚才这个例子
来看看这是如何工作的


260
00:12:13,333 --> 00:12:16,103 line:-2
获取与该用户关联的
originalTransactionId


261
00:12:16,837 --> 00:12:20,307 line:-1
并提取与此订阅相关的所有交易


262
00:12:20,741 --> 00:12:23,377 line:-2
然后使用其expires_date字段
对这些交易进行排序


263
00:12:23,777 --> 00:12:26,046 line:-1
并找到具有最新过期日期的那个


264
00:12:26,113 --> 00:12:30,217 line:-2
现在你可以使用该expires_date
来更新该用户的


265
00:12:30,284 --> 00:12:31,485 line:-1
latestExpiresDate字段


266
00:12:32,519 --> 00:12:34,221 line:-1
当你这样做时 你正在有效地


267
00:12:34,288 --> 00:12:37,191 line:-1
将该用户的订阅期延长一段时间


268
00:12:37,357 --> 00:12:38,792 line:-1
你的服务器端逻辑现在知道


269
00:12:38,859 --> 00:12:40,894 line:-1
该用户位于有效的订阅时间窗口中


270
00:12:41,828 --> 00:12:44,198 line:-2
当然 当你正在处理通过
StoreKit发送的续订交易时


271
00:12:44,264 --> 00:12:46,967 line:-1
你仍然需要告知设备


272
00:12:47,034 --> 00:12:48,869 line:-1
它通过了这些验证检查


273
00:12:49,403 --> 00:12:51,371 line:-1
并让你的app


274
00:12:51,438 --> 00:12:53,407 line:-1
再次调用finishTransaction函数


275
00:12:53,473 --> 00:12:55,542 line:-1
（在设备上完成所有交易）


276
00:12:57,411 --> 00:12:59,847 line:-1
假设你已经设置并能正常工作


277
00:13:00,547 --> 00:13:02,115 line:-2
App Store正在后台
向用户的信用卡收费


278
00:13:02,182 --> 00:13:05,519 line:-1
并且你正使用StoreKit处理


279
00:13:05,586 --> 00:13:07,387 line:-1
这些来自你的app的交易


280
00:13:07,721 --> 00:13:09,857 line:-1
然后你的服务器将更新和维护


281
00:13:09,923 --> 00:13:12,359 line:-1
这个latestExpiresDate字段


282
00:13:12,426 --> 00:13:14,528 line:-1
现在你已经能够通过服务端逻辑推断


283
00:13:14,595 --> 00:13:16,530 line:-1
用户是否为合法订阅用户了


284
00:13:16,597 --> 00:13:17,631 line:-1
（续订交易）


285
00:13:17,698 --> 00:13:20,300 line:-2
现在让我们来介绍一个
稍微复杂一些的例子


286
00:13:20,367 --> 00:13:23,704 line:-1
也许你通过网站提供服务


287
00:13:24,238 --> 00:13:25,472 line:-1
现在当用户访问一个网站


288
00:13:25,772 --> 00:13:28,709 line:-2
来使用你的订阅服务
你根据latestExpiresDate


289
00:13:28,775 --> 00:13:31,211 line:-1
知道该用户是一个合法订阅用户


290
00:13:31,278 --> 00:13:32,513 line:-1
（多平台）


291
00:13:32,579 --> 00:13:35,916 line:-2
但尽管我们希望
人们一直在使用我们的app


292
00:13:36,517 --> 00:13:39,386 line:-2
假设用户有几天没有使用过
你的app了


293
00:13:39,453 --> 00:13:42,189 line:-2
在这段时间内
App Store在后台


294
00:13:42,256 --> 00:13:44,191 line:-1
成功更新了该用户的订阅


295
00:13:45,192 --> 00:13:47,995 line:-2
当用户尝试通过你的网站
访问服务器时


296
00:13:48,595 --> 00:13:50,297 line:-2
latestExpiresDate
现在已过期了


297
00:13:50,364 --> 00:13:52,733 line:-1
因为你的服务器尚未知晓该笔新交易


298
00:13:52,799 --> 00:13:55,802 line:-1
那么你的服务器怎么知道


299
00:13:55,869 --> 00:13:57,504 line:-2
发生在App Store上的
这笔交易呢？


300
00:13:59,206 --> 00:14:00,040 line:-1
（状态轮询）


301
00:14:00,107 --> 00:14:02,242 line:-1
你可以使用这种称为状态轮询的技术


302
00:14:02,309 --> 00:14:04,378 line:-1
这可以让你在你的服务器中


303
00:14:04,444 --> 00:14:05,679 line:-1
直接发现这些交易


304
00:14:06,446 --> 00:14:09,416 line:-2
为了设置为能够从你的服务器
进行状态轮询


305
00:14:09,716 --> 00:14:12,920 line:-1
你只需保存编码收据数据的最新版本


306
00:14:12,986 --> 00:14:15,489 line:-2
即你发送的
与每个用户相关联的那个数据


307
00:14:16,190 --> 00:14:19,826 line:-1
你可以将该编码数据视为一个令牌


308
00:14:20,594 --> 00:14:23,764 line:-2
你能够像对待令牌一样对待它
是因为每次你将该编码收据数据


309
00:14:23,830 --> 00:14:26,934 line:-1
发给/verifyReceipt端点时


310
00:14:27,167 --> 00:14:29,369 line:-2
/verifyReceipt端点
不仅会返回


311
00:14:29,436 --> 00:14:32,139 line:-1
该收据数据的解码版本


312
00:14:32,206 --> 00:14:34,942 line:-1
它还包含与该用户订阅相关的


313
00:14:35,309 --> 00:14:37,477 line:-1
所有发生过的新交易


314
00:14:37,544 --> 00:14:40,514 line:-1
它位于那个JSON响应中称为


315
00:14:40,781 --> 00:14:41,915 line:-1
latestReceiptInfo的字段中


316
00:14:42,850 --> 00:14:45,786 line:-2
你可以使用该信息为用户
解锁这些新的订阅期


317
00:14:46,019 --> 00:14:49,189 line:-1
而无需启动该app


318
00:14:50,023 --> 00:14:52,759 line:-2
让我们看看它是如何工作的
当你验证交易时


319
00:14:52,826 --> 00:14:55,395 line:-2
就像我们之前看到的
你实际上在上传这个收据数据


320
00:14:55,462 --> 00:14:56,563 line:-1
（验证续订交易）


321
00:14:56,630 --> 00:14:59,700 line:-1
现在 一旦你确定这个交易


322
00:14:59,766 --> 00:15:02,102 line:-1
通过了与你以前一样的检查过程后


323
00:15:02,402 --> 00:15:04,905 line:-2
你就可以将
receiptData的值存储到


324
00:15:04,972 --> 00:15:08,141 line:-1
该用户的latestReceiptData字段中


325
00:15:09,510 --> 00:15:11,879 line:-2
你现已存储了用户的
latestReceiptData


326
00:15:12,246 --> 00:15:14,781 line:-2
这是一个
base64Encode字符串


327
00:15:15,282 --> 00:15:17,284 line:-1
当需要回答以下这个问题时


328
00:15:17,351 --> 00:15:18,852 line:-1
即我的用户是否处于订阅有效期


329
00:15:18,919 --> 00:15:22,055 line:-2
你可以直接从服务器获取
latestReceiptData


330
00:15:22,122 --> 00:15:24,358 line:-2
并将其发送到
/verifyReceipt端点


331
00:15:25,225 --> 00:15:29,329 line:-2
你还可包含一可选标志
即exclude-old-transactions


332
00:15:29,796 --> 00:15:31,932 line:-2
这会告诉/verifyReceipt
你甚至不想知道


333
00:15:31,999 --> 00:15:33,600 line:-1
收据的解码版本


334
00:15:33,667 --> 00:15:36,069 line:-1
你只想了解是否有任何新的交易


335
00:15:36,136 --> 00:15:37,271 line:-1
（状态轮询）


336
00:15:37,337 --> 00:15:41,175 line:-2
/verifyReceipt
将返回这个特定的对象


337
00:15:41,241 --> 00:15:42,676 line:-1
即latest_receipt_info对象


338
00:15:42,910 --> 00:15:45,445 line:-2
这个对象中包含那些
在生成此收据数据之前


339
00:15:45,512 --> 00:15:48,815 line:-1
发生的新的交易


340
00:15:48,882 --> 00:15:52,119 line:-2
你可以直接从响应中的
latest_receipt_info对象中


341
00:15:52,753 --> 00:15:54,254 line:-1
获取expires_date


342
00:15:55,222 --> 00:15:57,090 line:-1
并针对当前用户进行更新


343
00:15:57,391 --> 00:16:00,360 line:-2
从而再次延长他们的访问有效期
到下一个订阅窗口


344
00:16:00,761 --> 00:16:04,064 line:-1
因此 试图访问你的网站内容的用户


345
00:16:04,131 --> 00:16:06,366 line:-1
现在可以进入到下一个订阅期


346
00:16:06,433 --> 00:16:09,636 line:-1
而无需使用新的交易来启动app


347
00:16:11,305 --> 00:16:13,240 line:-1
如果你使用状态轮询技术


348
00:16:13,307 --> 00:16:14,508 line:-1
你必须要记住一件事


349
00:16:14,575 --> 00:16:17,144 line:-1
那就是当你的app再次联网时


350
00:16:17,211 --> 00:16:19,880 line:-1
交易仍会通过StoreKit


351
00:16:19,947 --> 00:16:21,715 line:-1
在更新后的交易回调中出现


352
00:16:21,782 --> 00:16:24,985 line:-2
你仍然应该处理这些交易
将其发送到


353
00:16:25,052 --> 00:16:27,521 line:-2
你的服务器以进行验证
并在用户的设备上


354
00:16:27,588 --> 00:16:28,822 line:-1
再次关闭它们


355
00:16:28,989 --> 00:16:30,991 line:-1
即使你的服务器已经通过状态轮询


356
00:16:31,058 --> 00:16:32,092 line:-1
知道它们的存在


357
00:16:33,560 --> 00:16:35,963 line:-2
我们鼓励你将其作为
发送最新收据数据


358
00:16:36,029 --> 00:16:39,933 line:-1
并将其存储到服务器上的机会


359
00:16:44,271 --> 00:16:45,639 line:-1
状态轮询在用户的信用卡


360
00:16:46,006 --> 00:16:48,408 line:-1
可以收费时工作很好


361
00:16:48,642 --> 00:16:52,312 line:-2
但是如果在某个订阅期内
用户的信用卡出现了一些问题


362
00:16:52,379 --> 00:16:55,649 line:-2
以至App Store无法
对其下一个订阅周期收费


363
00:16:55,716 --> 00:16:57,451 line:-1
这时该怎么办


364
00:16:57,985 --> 00:17:00,821 line:-2
这个用户是否注定会
非自愿地取消订阅


365
00:17:01,455 --> 00:17:02,289 line:-1
并不会


366
00:17:03,156 --> 00:17:06,393 line:-2
当遇到这样的结算问题时
你可以执行三个简单的步骤


367
00:17:06,460 --> 00:17:10,063 line:-2
首先 你观察到这个用户
没有续订交易


368
00:17:10,130 --> 00:17:13,133 line:-1
他们的订阅现在已经失效


369
00:17:13,733 --> 00:17:16,537 line:-1
其次 你可以引导该用户


370
00:17:16,603 --> 00:17:18,571 line:-1
更新他的账单信息


371
00:17:19,806 --> 00:17:23,577 line:-1
然后是第三步 当发生续订交易时


372
00:17:23,810 --> 00:17:26,680 line:-1
立即解除对该用户的屏蔽


373
00:17:27,146 --> 00:17:29,449 line:-1
第一步和第二步非常简单


374
00:17:29,516 --> 00:17:31,552 line:-2
如果使用了我们刚刚谈到的
状态轮询技术


375
00:17:31,618 --> 00:17:33,820 line:-1
但这里的第三步使用了一个


376
00:17:33,887 --> 00:17:37,357 line:-2
我们去年推出的特性
服务器到服务器通知


377
00:17:38,392 --> 00:17:39,426 line:-1
我们来看看这个例子


378
00:17:39,493 --> 00:17:42,629 line:-2
假设在一个订阅期内
App Store在尝试向


379
00:17:42,696 --> 00:17:44,731 line:-1
此用户的信用卡收费时发生错误


380
00:17:44,798 --> 00:17:46,233 line:-1
（服务器到服务器通知）


381
00:17:46,300 --> 00:17:49,570 line:-1
然后你会通过状态轮训发现这个用户


382
00:17:49,636 --> 00:17:51,371 line:-1
没有新的续订交易


383
00:17:52,072 --> 00:17:54,708 line:-1
你的服务器通过正确的计算


384
00:17:54,775 --> 00:17:56,476 line:-1
确定该用户不再是合法订阅用户


385
00:17:56,543 --> 00:17:59,680 line:-1
所以当用户通过网站访问你的服务时


386
00:17:59,746 --> 00:18:01,548 line:-1
你给他们一些适当的错误信息


387
00:18:01,615 --> 00:18:04,284 line:-1
告诉他们其订阅服务无法续订


388
00:18:04,685 --> 00:18:07,454 line:-2
你可以引导该用户
在App Store中


389
00:18:07,521 --> 00:18:08,555 line:-1
更新他们的账单信息


390
00:18:09,423 --> 00:18:11,258 line:-1
现在当用户更新他们的账单信息时


391
00:18:11,325 --> 00:18:13,727 line:-2
也许他们只需更新过期日期
或其它什么内容


392
00:18:14,261 --> 00:18:15,262 line:-1
这时发生了两件事


393
00:18:15,896 --> 00:18:18,432 line:-1
首先 App Store


394
00:18:18,632 --> 00:18:21,368 line:-2
会立即向用户的信用卡收费
并进行一次成功的交易


395
00:18:21,768 --> 00:18:23,403 line:-1
当App Store这样做了


396
00:18:23,570 --> 00:18:25,839 line:-2
它所做的第二步是
直接向你的服务器


397
00:18:25,906 --> 00:18:29,843 line:-2
发出一个关于该续订交易的
HTTP POST请求


398
00:18:30,043 --> 00:18:34,715 line:-1
该POST请求的载荷中


399
00:18:34,781 --> 00:18:36,617 line:-1
包括刚发生的交易的新信息


400
00:18:36,984 --> 00:18:38,952 line:-2
你可以使用载荷中的
original_transaction_id字段


401
00:18:39,019 --> 00:18:42,489 line:-1
来确定这个通知是针对哪个用户的


402
00:18:43,290 --> 00:18:45,292 line:-1
一旦你找出该用户


403
00:18:45,359 --> 00:18:47,528 line:-2
你可以使用最新的
expires_date


404
00:18:47,728 --> 00:18:50,998 line:-2
来为此用户进行更新
以便他们获得


405
00:18:51,064 --> 00:18:52,766 line:-1
下一个订阅期的访问权限


406
00:18:53,166 --> 00:18:55,002 line:-1
接着这位可能还在盯着你的网页


407
00:18:55,068 --> 00:18:57,538 line:-1
试图访问其中内容的用户


408
00:18:58,505 --> 00:19:00,574 line:-1
将能够立即被解锁


409
00:19:00,807 --> 00:19:04,111 line:-2
因为你的服务器直接从
App Store收到该推送


410
00:19:05,846 --> 00:19:08,815 line:-2
当这种事情发生时
快速解锁用户非常重要


411
00:19:08,882 --> 00:19:11,151 line:-1
尤其是当他们付出巨大努力


412
00:19:11,218 --> 00:19:13,487 line:-1
去手动更新他们的信用卡信息


413
00:19:13,554 --> 00:19:15,289 line:-1
并等待访问服务器时


414
00:19:15,589 --> 00:19:18,559 line:-2
但是这里有一点需要注意
那就是只有当订阅确实


415
00:19:18,625 --> 00:19:21,161 line:-2
如我们刚刚看到的那样失效时
这个通知才会被发送


416
00:19:22,029 --> 00:19:24,198 line:-1
为了发现成功的续订交易


417
00:19:24,364 --> 00:19:26,300 line:-2
你仍然需要依赖
我们刚刚介绍的


418
00:19:26,366 --> 00:19:27,668 line:-1
状态轮询技术


419
00:19:28,569 --> 00:19:31,772 line:-2
但设置并使用
服务器到服务器通知非常简单


420
00:19:31,839 --> 00:19:34,608 line:-2
你所要做的只是在
App Store Connect中输入一个网址


421
00:19:35,275 --> 00:19:37,311 line:-1
这只是你自己服务器上的一个端点


422
00:19:37,377 --> 00:19:39,179 line:-2
如果你将其输入到
App Store Connect


423
00:19:39,513 --> 00:19:42,349 line:-2
App Store将开始向
服务器发送有关这些状态变更事件的


424
00:19:42,583 --> 00:19:44,117 line:-1
HTTPS POST请求


425
00:19:44,384 --> 00:19:47,754 line:-2
正如我们在POST请求中
看到的那样 请求中包含了


426
00:19:48,021 --> 00:19:49,957 line:-2
触发该请求的交易的
latest_transaction_info字段


427
00:19:50,624 --> 00:19:53,894 line:-2
你需要确保你的服务器
符合ATS要求以便接收这些信息


428
00:19:54,061 --> 00:19:56,196 line:-1
但这是一个非常简单的步骤


429
00:19:56,263 --> 00:19:58,131 line:-1
它却可以给很多用户带来更好的体验


430
00:20:02,402 --> 00:20:04,705 line:-2
以上是一些关于
如何构建你的app


431
00:20:04,771 --> 00:20:06,907 line:-1
和服务器体系结构的技巧和窍门


432
00:20:06,974 --> 00:20:10,310 line:-2
让我们来谈谈你可以
在app内体验中使用的三个窍门


433
00:20:10,377 --> 00:20:12,513 line:-1
来大幅提升用户体验


434
00:20:13,480 --> 00:20:16,783 line:-1
首先 我们假设用户已登录到


435
00:20:16,850 --> 00:20:18,585 line:-1
你提供的服务的账户中


436
00:20:19,720 --> 00:20:22,356 line:-1
为了跟踪每个订阅ID


437
00:20:22,422 --> 00:20:25,225 line:-2
你需要使用位于服务器上的
这个用户表


438
00:20:25,692 --> 00:20:27,661 line:-1
现在我们谈到实际创建账户


439
00:20:27,728 --> 00:20:29,763 line:-2
我们认为
最好在进行创建帐户步骤之前


440
00:20:29,830 --> 00:20:31,598 line:-1
就可以进行app内购买


441
00:20:31,665 --> 00:20:32,566 line:-1
（创建用户帐户）


442
00:20:32,633 --> 00:20:35,135 line:-2
为什么呢？
对用户来说这是一种更好的经验


443
00:20:35,202 --> 00:20:36,904 line:-1
你第一次打开某app


444
00:20:36,970 --> 00:20:38,172 line:-1
就可以购买订阅


445
00:20:38,238 --> 00:20:40,574 line:-1
并立即访问你想要的内容


446
00:20:40,641 --> 00:20:43,177 line:-2
对你而言 这样更好
因为你可以获得更高的转化率


447
00:20:43,243 --> 00:20:45,479 line:-1
用户不必输入邮件地址


448
00:20:45,546 --> 00:20:48,081 line:-1
和密码就能够向你支付


449
00:20:49,216 --> 00:20:51,585 line:-2
现在你可以通过在这些实例中
使用匿名帐户


450
00:20:51,652 --> 00:20:54,254 line:-1
来使用我们刚刚谈到的技术


451
00:20:55,622 --> 00:20:58,992 line:0
你可以使用
original_transaction_id


452
00:20:59,059 --> 00:21:01,195 line:0
来关联多个设备


453
00:21:02,396 --> 00:21:04,464 line:0
如果你使用这样的匿名账户


454
00:21:04,531 --> 00:21:07,768 line:0
当用户需要真正创建一个账户时


455
00:21:07,835 --> 00:21:10,437 line:0
你可以简单地通过一个去匿名过程


456
00:21:10,504 --> 00:21:13,640 line:0
即更新邮件地址字段


457
00:21:13,707 --> 00:21:15,943 line:0
和其他个人信息相关的字段
来达到目的


458
00:21:17,945 --> 00:21:19,213 line:0
这是第一个窍门


459
00:21:19,279 --> 00:21:21,949 line:0
第二个窍门是关于
如何销售你的app内购买项目


460
00:21:22,216 --> 00:21:23,917 line:-1
在销售你的订阅时


461
00:21:23,984 --> 00:21:27,221 line:-2
你可以使用我们去年推出的功能
即推介定价


462
00:21:27,821 --> 00:21:30,224 line:-1
推介定价有一个重要的步骤


463
00:21:30,424 --> 00:21:34,127 line:-1
即你在运行时需要知道用户是否真的


464
00:21:34,361 --> 00:21:35,629 line:-1
具有推介定价资格


465
00:21:35,696 --> 00:21:37,764 line:-2
你需要知道它的原因是
你必须知道


466
00:21:37,831 --> 00:21:39,700 line:-1
你要呈现给用户的价格


467
00:21:40,033 --> 00:21:41,902 line:-2
无论是显示正常的
StoreKit价格


468
00:21:41,969 --> 00:21:44,271 line:-1
还是你想给用户提供的推介价格


469
00:21:44,338 --> 00:21:45,339 line:-1
来让他们进门


470
00:21:46,340 --> 00:21:48,742 line:-1
现在你可以通过监视


471
00:21:48,809 --> 00:21:51,211 line:-1
后台正在发生的交易


472
00:21:51,278 --> 00:21:52,846 line:-1
来提前知道这一点


473
00:21:53,480 --> 00:21:56,416 line:-2
让我们看看它是如何工作的
在验证交易时


474
00:21:56,483 --> 00:21:59,186 line:-2
就像我们刚才看到的一样
你需要留意这两个字段


475
00:21:59,686 --> 00:22:04,057 line:-2
is_trial_period字段
和is_in_intro_offer_period字段


476
00:22:04,525 --> 00:22:06,226 line:-1
如果这些字段中的任何一个为真


477
00:22:06,560 --> 00:22:08,829 line:-1
这就表明这笔交易


478
00:22:09,096 --> 00:22:11,732 line:-1
是一个推介价位或免费试用的交易


479
00:22:12,533 --> 00:22:16,103 line:0
如果是这样
你应该记录它的


480
00:22:16,403 --> 00:22:17,504 line:0
针对当前用户的
product_id


481
00:22:17,571 --> 00:22:20,541 line:0
你可以将它们存储在名为
consumedProductDiscounts的字段中


482
00:22:21,642 --> 00:22:24,278 line:0
现在 如果你正在跟踪


483
00:22:24,578 --> 00:22:27,781 line:0
哪些产品被用来提供推介优惠
当你需要向用户显示一些


484
00:22:27,848 --> 00:22:31,151 line:0
新的订阅产品的价格时


485
00:22:31,852 --> 00:22:33,020 line:-1
你可以这样做


486
00:22:33,086 --> 00:22:35,155 line:-2
你可以获取
currentUser的


487
00:22:35,222 --> 00:22:36,823 line:-1
consumedProductDiscounts


488
00:22:37,357 --> 00:22:39,393 line:-2
在它们上面执行
SKProductsRequest函数


489
00:22:39,927 --> 00:22:43,730 line:0
现在iOS 12中
SKProductRequest的response


490
00:22:43,964 --> 00:22:46,099 line:0
包含subscriptionGroupIdentifier
属性的原因是


491
00:22:46,366 --> 00:22:49,403 line:0
以便于你知道这个特定产品
来自哪个订阅组


492
00:22:49,937 --> 00:22:52,472 line:0
现在有了这个
subscriptionGroupIdentifier


493
00:22:52,539 --> 00:22:56,577 line:0
你就可以在该用户的一组
consumedGroupDiscounts中


494
00:22:56,643 --> 00:22:57,678 line:0
跟踪该消息


495
00:22:57,744 --> 00:23:01,348 line:0
你知道这个用户使用过哪个订阅组


496
00:23:02,850 --> 00:23:05,786 line:-2
现在 当你要呈现
比如说产品A的价格字符串时


497
00:23:06,086 --> 00:23:07,487 line:-1
它只需进行一个简单的检查


498
00:23:07,554 --> 00:23:11,592 line:-2
你可以检查此用户的
consumedGroupDiscounts列表是否包含


499
00:23:11,859 --> 00:23:15,262 line:-2
你想要卖给他们的产品的组标识符
在这种情况下是产品A


500
00:23:15,329 --> 00:23:18,866 line:-2
如果确实如此
则表示该用户已实际使用过


501
00:23:18,932 --> 00:23:20,300 line:-1
之前的推介报价


502
00:23:20,367 --> 00:23:23,704 line:-2
因此你可以将正常价格字符串
呈现给该用户


503
00:23:24,238 --> 00:23:27,274 line:-2
但如果不是
他们仍然有资格获得该推介优惠


504
00:23:27,341 --> 00:23:31,111 line:-2
因此你可以使用位于
SKProductObject上的推介价格


505
00:23:32,479 --> 00:23:35,549 line:-2
在呈现价格字符串时
这部分没有什么变化


506
00:23:35,616 --> 00:23:39,286 line:-2
它与你用于呈现
任何app内购买的技术相同


507
00:23:39,353 --> 00:23:41,455 line:0
我不打算在这里深入讨论


508
00:23:41,522 --> 00:23:44,191 line:0
但我建议你观看上一个演讲的视频


509
00:23:44,258 --> 00:23:46,360 line:0
其中讨论了如何更加动态的


510
00:23:46,426 --> 00:23:47,661 line:0
呈现这些价格字符串


511
00:23:48,095 --> 00:23:50,330 line:-1
有关设置推介优惠的更多信息


512
00:23:50,397 --> 00:23:53,166 line:-2
我也建议你看看
周三下午5点在三号厅举办的


513
00:23:53,233 --> 00:23:55,102 line:-1
“App Store Connect新特性”演讲


514
00:23:57,104 --> 00:23:59,072 line:-1
所以这是关于推介定价的第二个窍门


515
00:23:59,139 --> 00:24:01,909 line:-1
这里的第三个窍门是关于订阅管理的


516
00:24:03,010 --> 00:24:05,112 line:-2
你可以直接在你的app的
用户界面中


517
00:24:05,179 --> 00:24:07,881 line:-2
让用户可以在不同订阅层级之间
升级和降级


518
00:24:08,448 --> 00:24:09,349 line:-1
为了做到这一点


519
00:24:09,416 --> 00:24:12,052 line:-2
你实际上可以像
出售首次订阅一样处理它


520
00:24:13,320 --> 00:24:15,489 line:-1
现在如果你正在销售给用户的订阅


521
00:24:15,556 --> 00:24:17,224 line:-1
是同一个订阅组的一部分


522
00:24:17,291 --> 00:24:20,394 line:-1
它将与用户已订阅的层不同


523
00:24:20,761 --> 00:24:23,163 line:-1
你可以创建一个SKPayment


524
00:24:23,230 --> 00:24:24,831 line:-1
就像你向用户出售


525
00:24:24,898 --> 00:24:25,966 line:-1
首次订阅服务一样


526
00:24:26,033 --> 00:24:28,268 line:-2
当你这样做时
StoreKit实际上会处理


527
00:24:28,335 --> 00:24:30,304 line:-1
这是一次升级或降级的事实


528
00:24:30,637 --> 00:24:33,540 line:-1
所以你不必担心该用户会订阅两次


529
00:24:34,308 --> 00:24:36,276 line:-1
如果你不想在app中提供你自己的


530
00:24:36,343 --> 00:24:38,345 line:-1
升级和降级用户界面


531
00:24:38,412 --> 00:24:39,913 line:-1
你也可以只提供一个


532
00:24:39,980 --> 00:24:42,149 line:-2
到App Store
订阅管理界面的链接


533
00:24:42,216 --> 00:24:44,318 line:-2
我们为你提供一个链接
以便你能够直接


534
00:24:44,384 --> 00:24:45,886 line:-1
从你的app访问此界面


535
00:24:45,953 --> 00:24:49,289 line:-2
在这里用户可以升级
降级甚至取消订阅


536
00:24:50,190 --> 00:24:52,593 line:-2
你的app通常是
用户进行订阅管理的


537
00:24:52,659 --> 00:24:53,727 line:-1
首选地方


538
00:24:53,794 --> 00:24:55,162 line:-1
以便升级、降级或取消订阅


539
00:24:55,229 --> 00:24:57,664 line:-2
因此提供某种让用户
可以做到这点的链接


540
00:24:57,731 --> 00:25:00,801 line:-2
是一个非常好的主意
它可能在你的app的设置中


541
00:25:01,435 --> 00:25:02,336 line:-1
为了进入这个页面


542
00:25:02,402 --> 00:25:05,305 line:-2
在我们的app内购买项目指南中
有一个可用的链接


543
00:25:05,706 --> 00:25:07,975 line:-1
链接在这里 如果你想要记一下的话


544
00:25:09,009 --> 00:25:11,945 line:-2
以上是一些可以在app中
实现的简单窍门


545
00:25:12,012 --> 00:25:14,648 line:0
从而为用户提供
使用订阅服务的愉快体验


546
00:25:14,715 --> 00:25:16,483 line:0
接下来
我把话筒交给同事Michael


547
00:25:16,550 --> 00:25:19,152 line:-1
他会谈一些能够防止订户流失的


548
00:25:19,219 --> 00:25:20,287 line:-1
实用技术


549
00:25:20,354 --> 00:25:21,188 line:-1
谢谢大家


550
00:25:29,263 --> 00:25:31,865 line:-2
下午好
我叫Michael Gargas


551
00:25:31,932 --> 00:25:35,068 line:-2
我是App Store运营团队的
技术支持


552
00:25:35,469 --> 00:25:39,706 line:0
今天我想谈谈如何通过
使用Pete刚刚谈到的


553
00:25:39,773 --> 00:25:41,575 line:0
一些策略和方法


554
00:25:41,642 --> 00:25:43,076 line:0
来减少app内的订户流失


555
00:25:44,811 --> 00:25:47,814 line:-2
今天我们将覆盖
非自愿流失和自愿流失


556
00:25:47,881 --> 00:25:50,817 line:-2
这是两种在订阅app中
常见的流失类型


557
00:25:51,285 --> 00:25:53,720 line:-1
以及一些方法来赢回这些


558
00:25:53,787 --> 00:25:56,156 line:-1
你可能已经失去或即将失去的用户


559
00:25:57,724 --> 00:26:00,327 line:-1
首先我们来谈谈非自愿流失


560
00:26:01,461 --> 00:26:03,997 line:-1
非自愿流失是


561
00:26:04,064 --> 00:26:06,967 line:-2
由于平台上付款或结算失败
而损失的订户


562
00:26:08,502 --> 00:26:10,204 line:-1
去年的WWDC中


563
00:26:10,404 --> 00:26:12,206 line:-1
我们向你介绍了我们做的一些工作


564
00:26:12,272 --> 00:26:15,576 line:-2
来最小化app内的
非自愿流失的情况


565
00:26:16,276 --> 00:26:18,545 line:-2
我们宣布了我们升级后的
结算重试服务


566
00:26:18,879 --> 00:26:22,983 line:-2
其中我们将重试时间
从24小时扩展到60天


567
00:26:24,051 --> 00:26:26,320 line:-1
我们还实施了新的重试策略


568
00:26:26,553 --> 00:26:30,591 line:-2
并随时调整它们
以赢回越来越多的订阅


569
00:26:32,025 --> 00:26:35,596 line:-2
2017年7月13日是
值得记住的一个日期


570
00:26:35,996 --> 00:26:38,098 line:-1
因为这一天Apple


571
00:26:38,165 --> 00:26:41,034 line:-1
积极开始为你恢复订阅


572
00:26:43,704 --> 00:26:47,040 line:-2
如果我们查看自启动以来的
结算重试效果


573
00:26:47,107 --> 00:26:49,877 line:-2
我们可以看到
我们的恢复率已经翻了一倍还多


574
00:26:51,178 --> 00:26:53,113 line:-1
而对于非自愿流失


575
00:26:53,347 --> 00:26:55,949 line:-2
我们已经在平台范围内
削减其2%以上


576
00:27:02,856 --> 00:27:06,693 line:-2
现在 如果看看我们的调整
如何影响订阅的恢复


577
00:27:06,760 --> 00:27:09,096 line:-2
我们可以看到
一个季度随着一个季度


578
00:27:09,263 --> 00:27:13,133 line:-2
我们已经能够持续恢复
你越来越多的订阅


579
00:27:15,469 --> 00:27:20,807 line:-2
现在最终的结果是
自启动结算重试功能后


580
00:27:20,874 --> 00:27:22,609 line:-1
我们已经恢复了1200万次订阅


581
00:27:27,014 --> 00:27:30,317 line:-2
这就是Apple为尽量减少
你的非自愿流失所做的一切


582
00:27:30,751 --> 00:27:33,687 line:-1
作为开发人员你也可以采取一些策略


583
00:27:33,754 --> 00:27:37,191 line:-2
来最大程度地减少
你的订阅app内的自愿流失


584
00:27:38,325 --> 00:27:41,562 line:-1
你可以利用到Pete在前面提到的


585
00:27:41,628 --> 00:27:43,096 line:-1
一些订阅相关的收据字段


586
00:27:43,397 --> 00:27:45,032 line:-1
你还可以使用宽限期


587
00:27:45,465 --> 00:27:49,803 line:-2
在此期间 你可以部署一些
有效的客户消息


588
00:27:51,104 --> 00:27:53,473 line:0
我们来看一个示例订阅


589
00:27:54,341 --> 00:27:58,579 line:0
在这里我们可以看到
我们的订户将于4月26日到期续订


590
00:27:58,745 --> 00:28:01,281 line:0
然而他们遇到了一个结算问题


591
00:28:02,516 --> 00:28:06,687 line:0
所以为了让你知道
Apple正在通过结算重试服务


592
00:28:06,753 --> 00:28:09,289 line:0
积极尝试向该用户收费


593
00:28:09,656 --> 00:28:12,459 line:0
我们将在JSON响应中显示一个
合理命名的字段


594
00:28:12,526 --> 00:28:15,462 line:-1
is_in_billing_retry_period


595
00:28:15,963 --> 00:28:18,031 line:-1
其值为1代表


596
00:28:18,098 --> 00:28:21,001 line:-1
我们正尝试向该订户收取资金


597
00:28:23,437 --> 00:28:25,172 line:-1
如果我们回到刚才的订阅示例


598
00:28:25,239 --> 00:28:27,975 line:-2
你可以看到
这已被添加到JSON响应中


599
00:28:28,575 --> 00:28:31,478 line:-1
当你看到它与过期日期同时出现


600
00:28:31,645 --> 00:28:35,816 line:-2
这就是你作为开发人员
实施我们所谓的宽限期的标志


601
00:28:37,317 --> 00:28:39,453 line:-1
你可能会问自己什么是宽限期


602
00:28:42,689 --> 00:28:47,227 line:-2
宽限期是在结算重试状态下的
免费订阅访问


603
00:28:47,294 --> 00:28:49,563 line:-1
然而 这发生在你失去该用户之前


604
00:28:49,630 --> 00:28:51,398 line:-1
在他们彻底流失之前


605
00:28:52,065 --> 00:28:54,835 line:-1
宽限期的目标是改善订阅恢复


606
00:28:55,669 --> 00:28:57,437 line:-1
我们来看看如何利用收据响应中的


607
00:28:57,504 --> 00:28:59,840 line:-1
部分信息做到这一点


608
00:29:00,874 --> 00:29:03,043 line:-1
我们回到刚才的示例订阅


609
00:29:03,277 --> 00:29:05,879 line:-2
你可以看到我们的订户处于
结算重试状态


610
00:29:05,946 --> 00:29:08,015 line:-1
并将于4月26日到期续订


611
00:29:09,249 --> 00:29:13,153 line:-2
我们想添加一些服务器端逻辑以使用
expires_date字段


612
00:29:13,554 --> 00:29:17,524 line:-2
和is_in_billing_retry_period字段
来添加一段时间


613
00:29:17,691 --> 00:29:19,459 line:-1
在这个例子中为三天


614
00:29:19,893 --> 00:29:22,796 line:-1
用户在这期间将能够继续访问该服务


615
00:29:22,863 --> 00:29:24,498 line:-1
并在技术上仍然保持订阅状态


616
00:29:27,034 --> 00:29:28,368 line:-1
你为什么要这样做呢？


617
00:29:28,435 --> 00:29:32,773 line:-1
因为这是部署有效客户消息的好时机


618
00:29:33,173 --> 00:29:35,642 line:-1
来在该情景下与你的订阅者进行沟通


619
00:29:35,809 --> 00:29:39,246 line:-1
让他们知道他们的订阅可能存在问题


620
00:29:39,847 --> 00:29:43,383 line:-2
你可能想要执行某些操作
例如要求他们更新付款方式


621
00:29:43,617 --> 00:29:47,154 line:-1
或让他们重申所订阅产品的


622
00:29:47,221 --> 00:29:48,622 line:-1
价值定位


623
00:29:49,323 --> 00:29:52,593 line:-1
在此期间 你也可以提供受限服务


624
00:29:52,659 --> 00:29:55,963 line:-2
比如在娱乐app中可以浏览
但不能观看体验


625
00:29:58,232 --> 00:30:01,368 line:-2
这里我们可以看到Peak
一个App Store上的订阅app


626
00:30:02,503 --> 00:30:05,105 line:-1
Peak正在利用结算重试状态字段


627
00:30:05,372 --> 00:30:08,442 line:-1
来向其订阅者呈现一条情景消息


628
00:30:08,775 --> 00:30:12,179 line:-1
让他们知道他们的订阅存在问题


629
00:30:12,479 --> 00:30:15,582 line:-2
当用户与其交互时
用户会看到另一个界面


630
00:30:15,749 --> 00:30:19,186 line:-2
其中明确指出问题所在
以及解决问题的方法


631
00:30:21,388 --> 00:30:24,091 line:-1
如果能将用户从这个界面


632
00:30:24,157 --> 00:30:27,661 line:-2
直接引导到我们的系统中
使其能够更新付款信息


633
00:30:27,728 --> 00:30:29,363 line:-1
这将非常有效


634
00:30:30,597 --> 00:30:33,433 line:-2
因此今天我很兴奋地宣布
在今年的WWDC后不久


635
00:30:33,500 --> 00:30:35,669 line:-1
我们将有两个新的URL


636
00:30:36,203 --> 00:30:39,439 line:-2
一个用来直接驱动用户
更新他们的账单信息


637
00:30:39,506 --> 00:30:41,909 line:-1
另一个用来让用户管理自己的订阅


638
00:30:41,975 --> 00:30:45,379 line:-2
比如Pete早些时候提到的
升级、降级和跨级操作


639
00:30:51,051 --> 00:30:53,453 line:-1
这时很多开发者会问


640
00:30:53,520 --> 00:30:55,822 line:-1
我们何时能看到我们的用户被恢复


641
00:30:56,890 --> 00:30:59,793 line:-2
平均而言
我们看到大部分用户的恢复发生在


642
00:30:59,860 --> 00:31:03,764 line:-2
在平台上进入结算重试状态的
前7天内


643
00:31:06,166 --> 00:31:08,902 line:-2
这应该是提供
完整访问宽限期的合适时间


644
00:31:09,203 --> 00:31:12,406 line:-2
因为我们看到很多用户
在此期间自行恢复


645
00:31:13,941 --> 00:31:15,008 line:-1
你最好在该期间末尾


646
00:31:15,075 --> 00:31:17,444 line:-1
部署客户消息


647
00:31:17,511 --> 00:31:20,514 line:-2
来引导一些可能需要更长时间
才再次打开


648
00:31:20,581 --> 00:31:21,815 line:-1
你的app的订阅者


649
00:31:24,418 --> 00:31:26,920 line:-1
让我们回到刚才的示例订阅


650
00:31:27,321 --> 00:31:31,091 line:-2
如果我们成功恢复了这些用户的订阅
会发生什么呢？


651
00:31:33,060 --> 00:31:37,431 line:-2
当重试尝试成功时
重试或恢复的那个日期


652
00:31:37,497 --> 00:31:40,434 line:-1
将成为新的订阅周期的起始日期


653
00:31:40,767 --> 00:31:42,936 line:-1
这将在交易验证成功并完成时


654
00:31:43,003 --> 00:31:46,073 line:-1
反映在JSON响应中


655
00:31:47,975 --> 00:31:49,409 line:-1
但我们不会止步于此


656
00:31:49,710 --> 00:31:52,613 line:-1
我们也将部署服务器到服务器通知


657
00:31:52,679 --> 00:31:54,715 line:-1
以便你可以在所有平台上立即解锁


658
00:31:54,781 --> 00:31:58,151 line:-2
用户的访问权限
并关闭与客户的这次交互


659
00:31:58,218 --> 00:32:00,120 line:-2
让他们知道
你的账户现在已经没问题了


660
00:32:02,489 --> 00:32:03,891 line:-1
这是非自愿流失


661
00:32:04,057 --> 00:32:06,293 line:-1
客户没有从技术上做出选择


662
00:32:06,360 --> 00:32:08,328 line:-1
退订你的app


663
00:32:09,696 --> 00:32:11,098 line:-1
什么是自愿流失呢？


664
00:32:12,366 --> 00:32:16,837 line:-2
自愿流失是由于客户做出选择
而导致的订户流失


665
00:32:17,337 --> 00:32:19,940 line:-1
其可能是取消订阅或请求退款


666
00:32:20,774 --> 00:32:23,777 line:-1
明确来说 该用户主动做出选择


667
00:32:23,844 --> 00:32:25,512 line:-1
来离开你的订阅产品


668
00:32:26,847 --> 00:32:29,049 line:-1
那么作为一名开发人员你能做什么


669
00:32:29,116 --> 00:32:32,119 line:-2
来最大限度地减少
app内部的自愿流失呢？


670
00:32:33,320 --> 00:32:36,657 line:-2
Pete刚介绍了如何进行状态轮询
你可以实现它


671
00:32:36,723 --> 00:32:39,726 line:-2
以获取有关用户的一些
关键的订阅详细信息


672
00:32:40,527 --> 00:32:41,828 line:-1
当你获得该信息后


673
00:32:41,895 --> 00:32:45,766 line:-2
你可以使用它来提供
有吸引力的替代订阅产品


674
00:32:45,832 --> 00:32:47,801 line:-1
以尽可能保住该用户


675
00:32:51,104 --> 00:32:53,707 line:-1
所以让我们再多谈一下状态轮询


676
00:32:55,108 --> 00:32:57,611 line:-1
随着服务器到服务器通知的发布


677
00:32:57,811 --> 00:32:59,680 line:-1
你仍然需要进行状态轮询


678
00:32:59,746 --> 00:33:01,515 line:-1
实际上只有两个关键原因


679
00:33:03,183 --> 00:33:05,018 line:-1
首先是想知道


680
00:33:05,085 --> 00:33:08,555 line:-2
我的订阅用户是否会在
下一个订阅期内流失


681
00:33:09,556 --> 00:33:12,025 line:-1
第二个是 我的用户续订了吗


682
00:33:14,228 --> 00:33:17,464 line:-2
我们经常被问到 作为开发人员
我应该在何时进行轮询


683
00:33:17,531 --> 00:33:21,535 line:-2
我什么时候应该尝试找到这些用户
并查看其订阅状态的改变


684
00:33:23,537 --> 00:33:27,007 line:-2
我们认为进行状态轮训
最有效的时间是


685
00:33:27,074 --> 00:33:29,543 line:-1
在订阅期的开始或结束时


686
00:33:30,143 --> 00:33:31,645 line:-1
通过响应式的部署


687
00:33:32,346 --> 00:33:34,681 line:-1
你很可能会找到订阅产品中


688
00:33:35,015 --> 00:33:38,352 line:-1
自愿流失的大多数用户


689
00:33:40,854 --> 00:33:42,055 line:-1
但当你进行状态轮询时


690
00:33:42,122 --> 00:33:45,526 line:-1
你还可以访问一些其他订户状态字段


691
00:33:46,860 --> 00:33:50,397 line:-2
你可能想要获取这些字段并将对
/verifyReceipt的调用


692
00:33:50,464 --> 00:33:51,999 line:-1
所返回的解码JSON响应


693
00:33:52,466 --> 00:33:54,468 line:-1
保存到数据库的用户表中


694
00:33:55,435 --> 00:33:58,472 line:-1
或者 你可以解析出特定的字段


695
00:33:59,072 --> 00:34:02,442 line:-2
例如结算重试状态
以便细分客户


696
00:34:02,509 --> 00:34:05,112 line:-1
并且了解哪些人处于重试状态


697
00:34:05,179 --> 00:34:06,180 line:-1
而哪些不是


698
00:34:07,915 --> 00:34:11,150 line:-1
客户是否会自愿流失的标志


699
00:34:11,217 --> 00:34:14,721 line:-1
通过称为auto_renew_status的字段显示


700
00:34:17,224 --> 00:34:19,993 line:-1
auto_renew_status会让你知道


701
00:34:20,194 --> 00:34:23,664 line:-2
如果其值为1 则该用户将
在随后的订阅期内恢复订阅


702
00:34:24,331 --> 00:34:27,835 line:-1
若值为0则代表他们会在


703
00:34:27,900 --> 00:34:29,870 line:-1
下一个续订日期自愿流失


704
00:34:31,804 --> 00:34:34,208 line:-2
让我们看看这在我们的示例订阅中
看起来如何


705
00:34:35,708 --> 00:34:38,745 line:-1
我们有一个3月26日购买的用户


706
00:34:41,114 --> 00:34:43,250 line:-1
他已经通过管理订阅设置界面


707
00:34:43,317 --> 00:34:45,485 line:-1
禁用了自动续订功能


708
00:34:47,020 --> 00:34:50,456 line:-2
碰巧的是 我们在该事件发生后不久
就进行了状态轮训


709
00:34:51,123 --> 00:34:53,960 line:-1
我们可以通过收据响应看到


710
00:34:54,261 --> 00:34:56,563 line:-1
auto_renew_status已变为0了


711
00:34:58,031 --> 00:35:01,134 line:0
这时你可以更新你服务器上的


712
00:35:01,201 --> 00:35:04,538 line:0
数据库中的用户表
并将该客户归类为


713
00:35:04,605 --> 00:35:07,140 line:0
潜在自愿流失客户


714
00:35:10,010 --> 00:35:13,313 line:0
如果回到我们刚才的示例订阅
我们执行了状态轮询


715
00:35:13,380 --> 00:35:16,550 line:0
我们了解到这位顾客可能会离开


716
00:35:16,617 --> 00:35:17,784 line:0
那我们该怎么办？


717
00:35:18,652 --> 00:35:21,088 line:0
作为开发者
这是你在同一个订阅组中展示


718
00:35:21,154 --> 00:35:24,758 line:0
更具吸引力的降级优惠的机会


719
00:35:25,526 --> 00:35:28,328 line:-2
在这里 我们可以看到
Peak正试图留住该用户


720
00:35:28,395 --> 00:35:30,697 line:-1
通过向他们提供更短的使用期


721
00:35:30,764 --> 00:35:33,700 line:-1
或更低价的订阅期


722
00:35:33,767 --> 00:35:35,335 line:-1
或是另一个不同的产品


723
00:35:37,771 --> 00:35:40,841 line:-1
如果该用户决定接受这些


724
00:35:40,908 --> 00:35:42,509 line:-1
就像Pete向你展示的


725
00:35:42,576 --> 00:35:45,612 line:-2
通过在你的app中
显示升级和降级一样


726
00:35:46,346 --> 00:35:49,416 line:-1
我们想让你知道他们在接下来


727
00:35:49,483 --> 00:35:50,751 line:-1
将续订的产品


728
00:35:52,920 --> 00:35:56,356 line:-2
我们通过JSON响应中的
auto_renew_product_id字段来完成此操作


729
00:35:57,224 --> 00:35:59,026 line:-1
这与产品ID不同


730
00:35:59,092 --> 00:36:03,263 line:-2
因为这将是订阅者续订后的
下一个产品


731
00:36:06,266 --> 00:36:08,402 line:0
我们可以在该示例订阅中看到


732
00:36:09,203 --> 00:36:12,206 line:0
我们的用户选择降级而不是流失


733
00:36:12,873 --> 00:36:15,008 line:0
我们已将auto_renew_status更改为1


734
00:36:15,876 --> 00:36:17,945 line:0
并且添加了auto_renew_product_id字段


735
00:36:19,680 --> 00:36:21,014 line:0
立即获悉此更改


736
00:36:21,181 --> 00:36:23,283 line:0
也是非常有益的


737
00:36:23,517 --> 00:36:26,987 line:0
为此 我们将发送一个
服务器到服务器通知


738
00:36:27,254 --> 00:36:31,425 line:0
让你知道你的订阅者
改变了他们的续订偏好


739
00:36:33,160 --> 00:36:37,064 line:0
如果你这时向用户说明
他们当前使用的服务级别


740
00:36:37,130 --> 00:36:39,399 line:0
与他们将在下一个订阅期
得到的服务级别


741
00:36:39,633 --> 00:36:42,169 line:0
有何不同 这将是非常有益的


742
00:36:44,271 --> 00:36:48,342 line:-2
开展一个能100%留住用户的
订阅业务是不可能的


743
00:36:48,842 --> 00:36:52,145 line:-2
所以重要的是要了解
你怎样做才有可能赢回


744
00:36:52,312 --> 00:36:54,815 line:-1
流失的部分订阅用户


745
00:36:56,683 --> 00:37:00,087 line:-1
赢回是指已流失用户的再次回归


746
00:37:00,621 --> 00:37:02,556 line:-2
这可能是通过向他们显示
重新订阅优惠


747
00:37:03,056 --> 00:37:06,226 line:-1
或调查他们离开的原因来达到的


748
00:37:08,028 --> 00:37:10,030 line:-1
现在看看我们的示例订阅


749
00:37:10,097 --> 00:37:12,633 line:-1
让我们看看自愿取消是什么样子的


750
00:37:12,699 --> 00:37:15,102 line:-1
以及我们如何在app内部利用它


751
00:37:16,069 --> 00:37:19,740 line:-2
在这里 我们的用户已选择
通过AppleCare取消


752
00:37:20,941 --> 00:37:23,343 line:-1
为了让你知道这个事件


753
00:37:23,410 --> 00:37:25,746 line:-2
我们将在JSON响应中
添加cancellation_date字段


754
00:37:26,580 --> 00:37:30,684 line:-2
这是你知道
此客户已联系AppleCare


755
00:37:30,751 --> 00:37:32,853 line:-1
并取消或要求退款的标志


756
00:37:33,654 --> 00:37:37,758 line:0
但作为开发人员
你希望立即知道这些信息


757
00:37:38,992 --> 00:37:41,728 line:0
为此我们将部署一个
服务器到服务器通知


758
00:37:42,829 --> 00:37:46,200 line:0
这很重要
因为你想要立即关闭所有平台上


759
00:37:46,266 --> 00:37:47,935 line:0
这些用户的访问权限


760
00:37:48,569 --> 00:37:52,105 line:0
并可能向他们显示其他订阅优惠


761
00:37:54,208 --> 00:37:56,410 line:0
现在当这个用户流失后


762
00:37:56,476 --> 00:37:58,011 line:-1
能够分辨他是自愿取消订阅


763
00:37:58,078 --> 00:38:01,348 line:-1
还是由于某些支付或结算问题


764
00:38:02,216 --> 00:38:04,484 line:-1
而非自愿取消订阅


765
00:38:04,551 --> 00:38:06,186 line:-1
非常重要


766
00:38:07,054 --> 00:38:11,859 line:-2
为此我们在JSON响应中
添加了expiration_intent字段


767
00:38:12,626 --> 00:38:17,097 line:-2
为了清晰起见
这只会在订阅失效后显示


768
00:38:18,031 --> 00:38:20,267 line:-1
我们真正关心的是两个关键值


769
00:38:20,767 --> 00:38:24,905 line:-2
第一个值是1
表示属于自愿流失


770
00:38:25,639 --> 00:38:30,744 line:-2
第二个值是2
表示属于非自愿流失


771
00:38:33,046 --> 00:38:35,315 line:0
回到我们的示例订阅


772
00:38:35,382 --> 00:38:37,518 line:0
我们的客户
通过AppleCare取消了订阅


773
00:38:37,584 --> 00:38:40,320 line:0
可以看到我们已在收据响应中
添加了expiration_intent字段


774
00:38:40,387 --> 00:38:42,789 line:0
且其值为1


775
00:38:45,425 --> 00:38:47,060 line:0
那么你作为一名开发人员


776
00:38:47,127 --> 00:38:49,062 line:0
当看到用户处于这种状态


777
00:38:49,129 --> 00:38:51,732 line:0
并且你能分辨他们属于
自动或非自动流失的情况下


778
00:38:51,798 --> 00:38:54,868 line:0
你该怎么做？


779
00:38:56,537 --> 00:39:00,007 line:-2
对于自愿的情况
你可能想对这些在你的新系统中


780
00:39:00,073 --> 00:39:02,176 line:-1
建立过账户的订户进行调查


781
00:39:02,476 --> 00:39:05,846 line:-1
你可以问他们为什么服务不适合他们


782
00:39:06,180 --> 00:39:07,748 line:-1
以及你可以如何改善它


783
00:39:07,814 --> 00:39:11,318 line:-2
从而为他们或其他用户
提供更好的体验


784
00:39:12,553 --> 00:39:16,089 line:-2
此外 你还可以显示
同类的其他订阅产品


785
00:39:16,323 --> 00:39:19,459 line:-1
因为如果他们重新订阅这些产品


786
00:39:19,526 --> 00:39:23,163 line:-2
你希望继续为85/15的
收入分成积累时间


787
00:39:25,265 --> 00:39:28,735 line:-2
当用户自愿流失时
我们可以看到Peak在这里


788
00:39:29,403 --> 00:39:33,240 line:-2
显示了重新订阅优惠
在这个例子中为一个60%的折扣


789
00:39:36,743 --> 00:39:40,080 line:-2
对于非自愿流失
由于用户没有主动做出


790
00:39:40,147 --> 00:39:41,215 line:-1
要退订的决定


791
00:39:41,281 --> 00:39:44,651 line:-1
只需显示相同或替代的订阅产品即可


792
00:39:45,252 --> 00:39:47,554 line:-2
你可能想要在用户登录到
你的app中时


793
00:39:47,621 --> 00:39:50,123 line:-1
显示一些持久的消息


794
00:39:50,190 --> 00:39:53,594 line:-2
让他们知道他们已经失效
但随时都可以回来


795
00:39:54,494 --> 00:39:57,865 line:-1
你也可能想要部署受限订阅体验


796
00:39:58,298 --> 00:40:01,602 line:-2
比如在娱乐app中只能浏览
但不能观看的体验


797
00:40:02,936 --> 00:40:04,304 line:-1
这是Tinder的界面


798
00:40:04,771 --> 00:40:08,742 line:-2
当用户与专业级或订阅级功能
进行交互时


799
00:40:08,809 --> 00:40:11,245 line:-1
他们不断被提示订阅


800
00:40:12,913 --> 00:40:15,782 line:-2
总而言之 如果说你能
从这部分中学到


801
00:40:15,849 --> 00:40:17,384 line:-1
任何关于减少用户流失的方法


802
00:40:17,584 --> 00:40:18,986 line:-1
那就是你应该好好利用


803
00:40:19,052 --> 00:40:21,788 line:-1
这些订阅收据字段


804
00:40:23,657 --> 00:40:26,260 line:-1
然后你可以通过状态轮询来了解


805
00:40:26,326 --> 00:40:28,729 line:-1
何时你的用户可能会自愿流失


806
00:40:32,466 --> 00:40:33,934 line:-1
然后你可以使用该状态轮询


807
00:40:34,001 --> 00:40:36,837 line:-2
来部署一些有针对性
并且有效的客户通知


808
00:40:38,672 --> 00:40:40,841 line:-1
最后


809
00:40:40,908 --> 00:40:43,977 line:-1
向这些用户展示相应的订阅优惠


810
00:40:44,044 --> 00:40:46,747 line:-2
以此希望赢回他们
或者从一开始预防他们流失


811
00:40:49,349 --> 00:40:51,818 line:-1
现在我想将话筒交回同事Pete


812
00:40:51,885 --> 00:40:53,253 line:-1
来讨论分析和报告的话题


813
00:40:53,320 --> 00:40:54,388 line:-1
谢谢


814
00:41:02,829 --> 00:41:03,830 line:-1
谢谢Michael


815
00:41:04,565 --> 00:41:07,234 line:-1
如果你还没处理过这些JSON字段


816
00:41:07,301 --> 00:41:09,503 line:-1
我们强烈建议你尝试一下


817
00:41:09,570 --> 00:41:11,405 line:-1
并感受它对客户保有率的巨大作用


818
00:41:11,471 --> 00:41:13,307 line:-2
作为工程师
我们很少有这样的机会


819
00:41:13,373 --> 00:41:14,942 line:-1
通过如此简单的架构调整


820
00:41:15,008 --> 00:41:18,478 line:-2
就可以对业务收入产生
如此大的影响


821
00:41:18,545 --> 00:41:19,913 line:-1
所以我们一起来看看


822
00:41:19,980 --> 00:41:21,815 line:-1
今天我们在分析和报告领域


823
00:41:21,882 --> 00:41:24,351 line:-1
带来的一些很棒的新升级


824
00:41:24,751 --> 00:41:26,386 line:-1
在App Store Connect中


825
00:41:26,453 --> 00:41:30,090 line:-1
销售和趋势部分包含大量有用的信息


826
00:41:30,157 --> 00:41:32,993 line:-2
现在你甚至可以更深入的了解
你的app的表现


827
00:41:33,427 --> 00:41:35,963 line:-1
当前的这个订阅摘要仪表板


828
00:41:36,029 --> 00:41:38,065 line:-1
现在还可以监控


829
00:41:38,131 --> 00:41:40,601 line:-1
处于结算重试状态的订阅


830
00:41:41,268 --> 00:41:44,004 line:-1
这对了解用户行为


831
00:41:44,071 --> 00:41:46,039 line:-1
以及确定最有效的宽限期长短


832
00:41:46,106 --> 00:41:47,341 line:-1
非常有用


833
00:41:47,407 --> 00:41:49,076 line:-1
就像刚才Michael谈到的


834
00:41:50,978 --> 00:41:53,447 line:-1
今年我们还为订阅保有情况


835
00:41:53,514 --> 00:41:55,182 line:-1
推出了一个全新的仪表板


836
00:41:55,883 --> 00:41:58,852 line:-1
这个页面显示了推介价格的表现


837
00:41:59,219 --> 00:42:01,221 line:-1
以及多少用户属于


838
00:42:01,288 --> 00:42:02,422 line:-1
高提成客户


839
00:42:02,489 --> 00:42:04,691 line:-2
也就是当用户订阅超过一年时
你能够得到的


840
00:42:04,758 --> 00:42:06,660 line:-1
85/15提成


841
00:42:08,095 --> 00:42:09,763 line:-1
仪表板包含新的图表


842
00:42:10,464 --> 00:42:12,866 line:0
来帮助你快速识别哪些订阅群组


843
00:42:12,933 --> 00:42:14,234 line:0
是表现最好的


844
00:42:14,301 --> 00:42:17,571 line:0
而且你可以随时监控你的订阅效果


845
00:42:17,638 --> 00:42:21,141 line:-1
并比较你的app在不同时期的表现


846
00:42:22,276 --> 00:42:25,179 line:-1
现在 所有这些新信息不仅可以


847
00:42:25,245 --> 00:42:27,014 line:-1
在App Store Connect报告中显示


848
00:42:27,080 --> 00:42:29,983 line:-2
还可以通过新的
App Store Connect API获取


849
00:42:30,784 --> 00:42:33,120 line:-1
这里的报告数据每天都会提供给你


850
00:42:33,187 --> 00:42:36,190 line:-1
你可以编写自己的程序


851
00:42:36,256 --> 00:42:39,226 line:-2
来将其存入你自己的数据仓库
以进行进一步分析


852
00:42:39,893 --> 00:42:41,628 line:-1
我们不会讨论更多关于


853
00:42:41,695 --> 00:42:42,863 line:-1
App Store Connect API的细节


854
00:42:42,930 --> 00:42:44,264 line:-1
但我强烈建议你观看


855
00:42:44,331 --> 00:42:47,201 line:-1
周四下午3点在三号厅举办的


856
00:42:47,267 --> 00:42:48,635 line:-1
“自动化App Store Connect”演讲


857
00:42:48,702 --> 00:42:52,005 line:-2
其在自动化领域有一些
非常令人兴奋的改进


858
00:42:53,006 --> 00:42:55,375 line:-1
我们讨论了你可以从收据中得到什么


859
00:42:55,442 --> 00:42:57,878 line:-2
以及你可以从这些
App Store Connect报告中获得的信息


860
00:42:57,945 --> 00:42:59,580 line:-1
现在总结一下


861
00:42:59,646 --> 00:43:01,448 line:-1
App Store收据可以用来


862
00:43:01,515 --> 00:43:04,251 line:-1
验证那些StoreKit交易


863
00:43:04,318 --> 00:43:07,120 line:-2
并更新用户的订阅状态
以及在你的服务器上维护该状态


864
00:43:07,387 --> 00:43:10,524 line:-1
你也能像Michael演示的那样


865
00:43:10,591 --> 00:43:12,159 line:-1
使用它们来了解个人用户的行为


866
00:43:13,327 --> 00:43:15,963 line:0
对于App Store Connect报告而言
它的原因稍有不同


867
00:43:16,029 --> 00:43:18,298 line:0
它们更适合宏观层面的分析


868
00:43:18,365 --> 00:43:21,902 line:0
比如了解用户的订阅路径


869
00:43:21,969 --> 00:43:25,172 line:0
或者最重要的是
了解你能通过用户订阅


870
00:43:25,239 --> 00:43:27,374 line:0
获得多少收入


871
00:43:29,543 --> 00:43:32,779 line:-2
今天我们谈论了很多主题
但作为总结


872
00:43:33,213 --> 00:43:37,050 line:-1
请记住 当涉及到订阅管理时


873
00:43:37,117 --> 00:43:39,453 line:-2
服务器端状态管理
为你提供了更多的灵活性


874
00:43:40,687 --> 00:43:42,890 line:-2
如果你尚未这样做
请使用之前提到的URL


875
00:43:42,956 --> 00:43:45,158 line:-1
接收来自App Store的通知


876
00:43:46,293 --> 00:43:48,262 line:-1
考虑在你的app中设置推介价格


877
00:43:48,328 --> 00:43:50,130 line:-1
这是让用户开始


878
00:43:50,197 --> 00:43:51,498 line:-1
订阅你的app的好方法


879
00:43:52,633 --> 00:43:55,435 line:-2
使用Michael向我们介绍的
那些字段


880
00:43:55,502 --> 00:43:57,804 line:-2
来添加一些简单的消息
以减少订户流失


881
00:43:57,871 --> 00:43:59,706 line:-1
对于实际已失效的用户


882
00:44:00,741 --> 00:44:02,442 line:-1
提供一些替代的的订阅选项


883
00:44:02,509 --> 00:44:03,844 line:-1
也许这样可以赢回他们


884
00:44:04,745 --> 00:44:06,813 line:0
最后 别忘了试试这些新的报告工具


885
00:44:06,880 --> 00:44:08,649 line:0
它们可在App Store Connect中找到


886
00:44:10,384 --> 00:44:12,519 line:0
有关本次演讲和视频的更多信息


887
00:44:12,586 --> 00:44:14,154 line:0
本次演讲编号为705


888
00:44:14,521 --> 00:44:17,324 line:0
我们稍后和星期四上午9:00


889
00:44:17,391 --> 00:44:18,926 line:0
都会有实验室


890
00:44:18,992 --> 00:44:20,794 line:0
我们将有来自StoreKit


891
00:44:20,861 --> 00:44:22,095 line:-1
和App Store Connect团队的工程师


892
00:44:22,162 --> 00:44:23,730 line:-1
随时准备回答你可能遇到的


893
00:44:23,797 --> 00:44:25,499 line:-1
任何关于订阅工程的问题


894
00:44:25,566 --> 00:44:26,400 line:-1
非常感谢

