1
00:00:07,016 --> 00:00:15,500
[ 音乐 ]


2
00:00:23,516 --> 00:00:27,616
[ 掌声 ]


3
00:00:28,116 --> 00:00:28,656
>> 大家好


4
00:00:29,016 --> 00:00:29,686
我是 Kyle


5
00:00:29,686 --> 00:00:30,776
我是一名 Apple 的软件工程师


6
00:00:30,876 --> 00:00:32,195
今天我们要将深入


7
00:00:32,195 --> 00:00:33,386
研究一下 iOS 内存


8
00:00:34,066 --> 00:00:35,986
要知道的是


9
00:00:35,986 --> 00:00:36,986
尽管这里说的是 iOS


10
00:00:36,986 --> 00:00:38,536
我们接下来涉及到的很多内容


11
00:00:38,536 --> 00:00:42,546
也适用于其他平台


12
00:00:43,186 --> 00:00:44,626
我们首先要讨论的


13
00:00:44,626 --> 00:00:46,706
是为什么要减少内存


14
00:00:48,886 --> 00:00:50,836
当我们提到减少内存时


15
00:00:50,836 --> 00:00:51,746
我们实际上


16
00:00:51,746 --> 00:00:53,116
是在讨论减少内存占用


17
00:00:53,296 --> 00:00:53,976
那么我们就来谈谈这点


18
00:00:55,326 --> 00:00:56,586
我们将讨论一些


19
00:00:56,586 --> 00:00:57,986
可以用来分析内存占用的工具


20
00:00:59,146 --> 00:01:00,706
我们会有一些针对图像的提醒


21
00:01:00,706 --> 00:01:03,116
还会讲到后台优化


22
00:01:03,196 --> 00:01:05,096
最后 我们会用一个很好的演示作为总结


23
00:01:06,446 --> 00:01:08,786
为什么减少内存呢


24
00:01:10,496 --> 00:01:12,196
简单的回答是


25
00:01:12,196 --> 00:01:13,086
为了使用户获得更好的体验


26
00:01:13,396 --> 00:01:14,986
不仅你的 App 会启动得更快


27
00:01:15,056 --> 00:01:16,276
系统会表现得更好


28
00:01:16,906 --> 00:01:18,016
你的 App 也会在内存中保留


29
00:01:18,016 --> 00:01:18,436
更长的时间


30
00:01:18,666 --> 00:01:19,646
其他 App 也会在内存中保留


31
00:01:19,646 --> 00:01:20,036
更长的时间


32
00:01:20,266 --> 00:01:21,466
几乎一切都变得更好


33
00:01:22,266 --> 00:01:23,176
现在 如果你看看周围


34
00:01:23,356 --> 00:01:25,426
你实际上也在通过


35
00:01:25,426 --> 00:01:26,796
减少内存


36
00:01:26,796 --> 00:01:27,676
来帮助其他开发者


37
00:01:28,766 --> 00:01:30,716
我们讨论的是减少内存


38
00:01:30,716 --> 00:01:32,616
但实际上减少的是内存占用


39
00:01:32,976 --> 00:01:34,376
内存和人不同 它们生而“不”平等


40
00:01:34,816 --> 00:01:35,616
这是什么意思呢


41
00:01:36,856 --> 00:01:38,186
我们需要谈谈 “Pages”


42
00:01:38,656 --> 00:01:39,646
不是这个 “Pages 文稿”


43
00:01:40,436 --> 00:01:41,876
我们将要讨论内存的页面


44
00:01:42,436 --> 00:01:44,196
系统给了你一个内存页


45
00:01:44,196 --> 00:01:46,096
它可以堆的形式


46
00:01:46,096 --> 00:01:47,676
存储多个对象


47
00:01:48,126 --> 00:01:50,206
有些对象实际上


48
00:01:50,206 --> 00:01:51,496
可以跨越多个内存页


49
00:01:52,056 --> 00:01:55,866
它们的大小一般是 16KB


50
00:01:56,276 --> 00:01:57,816
可以是净页


51
00:01:57,816 --> 00:01:58,176
也可以是脏页


52
00:02:00,236 --> 00:02:01,806
App 的内存使用


53
00:02:01,806 --> 00:02:03,036
实际上指的是页面数量


54
00:02:03,116 --> 00:02:04,686
乘以页面大小


55
00:02:05,366 --> 00:02:10,586
这有一个净页和脏页的例子


56
00:02:10,586 --> 00:02:13,766
假设我分配了一个含有 20000 个


57
00:02:13,766 --> 00:02:14,196
整数的数组


58
00:02:14,816 --> 00:02:16,916
系统可能会分配给我 6 个内存页面


59
00:02:18,036 --> 00:02:19,966
当我分配这些页面时


60
00:02:19,966 --> 00:02:20,676
它们是净页


61
00:02:21,156 --> 00:02:22,386
但是 当我开始


62
00:02:22,386 --> 00:02:23,816
对数据缓冲区进行写入时


63
00:02:23,816 --> 00:02:25,406
例如 如果我写入到这个数组的第一个位置


64
00:02:25,406 --> 00:02:27,766
这个内存页就会变成脏页


65
00:02:28,856 --> 00:02:30,996
类似地


66
00:02:30,996 --> 00:02:33,396
如果我写入到


67
00:02:33,396 --> 00:02:34,646
缓冲区中的最后一个位置


68
00:02:34,646 --> 00:02:35,686
最后一页也会变成 脏页


69
00:02:36,436 --> 00:02:37,416
请注意 中间的四个页面


70
00:02:37,416 --> 00:02:38,566
仍然是 净页


71
00:02:38,566 --> 00:02:42,896
因为 App 还没有写入它们


72
00:02:42,896 --> 00:02:45,556
另一个有趣的话题是内存映射文件


73
00:02:45,856 --> 00:02:48,206
它是一种在磁盘上的文件


74
00:02:48,206 --> 00:02:49,306
但加载到了内存中


75
00:02:50,296 --> 00:02:51,506
如果你用的是只读文件


76
00:02:51,506 --> 00:02:52,976
这些将一直是净页


77
00:02:53,846 --> 00:02:55,066
内核实际上


78
00:02:55,066 --> 00:02:57,056
是在它们离开磁盘写入 RAM 时进行管理的


79
00:02:57,746 --> 00:03:01,266
JPEG 就是一个很好的例子


80
00:03:01,656 --> 00:03:03,036
如果我有一个 JPEG 文件


81
00:03:03,036 --> 00:03:05,586
比如说 它有 50KB 大


82
00:03:05,646 --> 00:03:07,416
当它被映射到内存中时


83
00:03:07,416 --> 00:03:09,746
它实际上被映射到


84
00:03:09,746 --> 00:03:10,576
大约 4 页内存中


85
00:03:10,976 --> 00:03:12,436
第 4 页实际上


86
00:03:12,436 --> 00:03:13,936
并没有被完全填满


87
00:03:13,936 --> 00:03:14,876
所以它可以用来做其他的事情


88
00:03:14,876 --> 00:03:16,846
内存就是像这样复杂


89
00:03:16,936 --> 00:03:18,376
但是之前的那三页


90
00:03:18,456 --> 00:03:21,736
总是可以被系统释放


91
00:03:22,056 --> 00:03:26,156
当我们讨论某个典型的 App 时


92
00:03:26,446 --> 00:03:28,366
它们的内存占用和分析文件


93
00:03:28,366 --> 00:03:30,146
都会有一个脏的 一个压缩的


94
00:03:30,146 --> 00:03:31,166
以及一个干净的内存段


95
00:03:32,136 --> 00:03:32,926
让我分别来看看


96
00:03:34,766 --> 00:03:37,826
净内存是可以被分页的数据


97
00:03:38,346 --> 00:03:40,676
这些是我们刚刚讨论过的内存映射文件


98
00:03:41,016 --> 00:03:43,216
可以是图像文件 Blob.data


99
00:03:43,566 --> 00:03:44,376
或者 Training.model


100
00:03:44,916 --> 00:03:47,126
也可以是框架


101
00:03:48,546 --> 00:03:50,566
每个框架都有一个


102
00:03:50,566 --> 00:03:51,486
_DATA_CONST 部分


103
00:03:52,506 --> 00:03:53,466
它通常是 净内存


104
00:03:53,466 --> 00:03:54,406
但是如果你做了任何运行时的小把戏 


105
00:03:54,406 --> 00:03:55,726
比如 “Method Swizzling（方法交换）”


106
00:03:55,726 --> 00:04:00,876
那么它就会变成脏内存


107
00:04:01,056 --> 00:04:03,146
脏内存是


108
00:04:03,146 --> 00:04:04,556
App 写入的任何内存


109
00:04:05,676 --> 00:04:07,516
它们可以是对象


110
00:04:07,946 --> 00:04:09,016
比如 malloc


111
00:04:09,146 --> 00:04:10,416
字符串 数组等等


112
00:04:11,056 --> 00:04:14,186
它可以是已解码的图像缓冲


113
00:04:14,366 --> 00:04:15,426
我们稍后会讲到这点


114
00:04:15,926 --> 00:04:18,576
它也可以是框架


115
00:04:19,305 --> 00:04:21,196
框架也有一个 _DATA 部分


116
00:04:21,196 --> 00:04:23,356
和一个 _DATA_DIRTY 部分


117
00:04:24,256 --> 00:04:26,786
它们总是指向脏内存


118
00:04:27,926 --> 00:04:29,216
你可能注意到了


119
00:04:29,216 --> 00:04:30,446
我曾两次提到了框架


120
00:04:30,776 --> 00:04:32,486
是的 你链接的框架


121
00:04:32,486 --> 00:04:34,976
实际上使用内存


122
00:04:34,976 --> 00:04:35,286
和脏内存


123
00:04:35,766 --> 00:04:36,976
它是一个


124
00:04:36,976 --> 00:04:39,066
连接框架的必要部分


125
00:04:39,066 --> 00:04:39,756
但如果你要保持自己的框架


126
00:04:39,756 --> 00:04:41,776
可以使用单例


127
00:04:41,776 --> 00:04:43,726
和全局初始化器


128
00:04:43,726 --> 00:04:45,256
来减少他们使用的


129
00:04:45,256 --> 00:04:46,786
脏内存


130
00:04:46,786 --> 00:04:48,146
因为单例


131
00:04:48,226 --> 00:04:49,246
在被创建之后


132
00:04:49,366 --> 00:04:51,376
才会进入内存 初始化器也只有


133
00:04:51,376 --> 00:04:53,976
在框架被链接或类被加载时


134
00:04:57,346 --> 00:05:00,986
才会运行 压缩内存非常酷


135
00:05:00,986 --> 00:05:03,066
iOS 没有传统的磁盘交换系统


136
00:05:03,946 --> 00:05:06,446
取而代之 它使用内存压缩器


137
00:05:06,626 --> 00:05:10,606
它是在 iOS 7 中被引入的内存压缩器


138
00:05:10,606 --> 00:05:12,526
接收未访问的内存页


139
00:05:12,526 --> 00:05:13,776
并压缩它们


140
00:05:13,776 --> 00:05:15,656
这实际上可以创建更多的空间


141
00:05:16,366 --> 00:05:17,586
但在访问时


142
00:05:17,586 --> 00:05:19,226
压缩器会对它们进行解压


143
00:05:19,516 --> 00:05:20,266
以便读取内存


144
00:05:20,936 --> 00:05:22,076
让我们看一个例子


145
00:05:23,296 --> 00:05:25,316
假设我有一个用于缓存的字典


146
00:05:25,876 --> 00:05:27,336
它占用了 3 页的内存


147
00:05:27,336 --> 00:05:29,796
但是如果我有一段时间


148
00:05:29,796 --> 00:05:31,266
没有访问过它


149
00:05:31,266 --> 00:05:32,436
且系统需要一些空间


150
00:05:32,436 --> 00:05:33,366
系统就可以把它


151
00:05:33,366 --> 00:05:35,436
压缩到一个内存页中


152
00:05:35,896 --> 00:05:38,156
它现在被压缩了


153
00:05:38,716 --> 00:05:40,806
但同时我节省了空间


154
00:05:40,806 --> 00:05:42,246
或者说我现在有了两个额外的内存页


155
00:05:42,896 --> 00:05:44,056
如果在未来的某个时刻我想访问它


156
00:05:44,056 --> 00:05:45,786
它将会恢复原来的大小


157
00:05:46,456 --> 00:05:48,696
我们来谈谈内存警告


158
00:05:49,446 --> 00:05:51,586
App 并不总是


159
00:05:51,946 --> 00:05:52,876
引起内存警告的原因


160
00:05:53,736 --> 00:05:54,736
如果你在一个低内存的设备上


161
00:05:54,736 --> 00:05:57,196
接到一个电话


162
00:05:57,256 --> 00:05:58,156
那也可能会触发一个内存警告


163
00:05:58,156 --> 00:05:59,036
你就有麻烦了


164
00:05:59,126 --> 00:06:00,586
所以不要想当然地认为


165
00:06:00,996 --> 00:06:02,826
内存警告是你造成的


166
00:06:03,986 --> 00:06:06,386
压缩器使内存的释放


167
00:06:06,386 --> 00:06:08,636
变得复杂


168
00:06:09,516 --> 00:06:10,146
因为根据压缩的内容


169
00:06:10,146 --> 00:06:12,106
实际上你可以 比以前使用更多的内存


170
00:06:12,356 --> 00:06:15,986
因此我们建议修改策略


171
00:06:15,986 --> 00:06:17,136
比如暂时不缓存任何内容


172
00:06:17,686 --> 00:06:18,896
或者在发生内存警告时


173
00:06:18,896 --> 00:06:21,106
限制一些后台工作


174
00:06:22,536 --> 00:06:24,386
我们中的一些人可能在 App 中


175
00:06:24,386 --> 00:06:24,846
遇到这种情况


176
00:06:25,476 --> 00:06:27,726
我们得到一个内存警告


177
00:06:27,726 --> 00:06:28,826
并决定从缓存中


178
00:06:28,826 --> 00:06:31,126
删除所有对象


179
00:06:31,336 --> 00:06:33,856
回到压缩字典的例子


180
00:06:34,646 --> 00:06:35,606
会发生什么呢


181
00:06:35,896 --> 00:06:37,446
既然我正在访问这个字典


182
00:06:37,446 --> 00:06:39,496
我现在比以前


183
00:06:39,496 --> 00:06:41,216
使用了更多的内存页


184
00:06:42,046 --> 00:06:43,866
在内存受限的环境中


185
00:06:43,926 --> 00:06:45,546
我们并不希望这样


186
00:06:46,466 --> 00:06:47,726
因为我删除了所有的对象


187
00:06:47,726 --> 00:06:50,186
我做了很多工作


188
00:06:50,186 --> 00:06:51,306
只是为了让它回到


189
00:06:51,306 --> 00:06:52,356
之前被压缩时的样子


190
00:06:52,356 --> 00:06:53,016
也就是只占用一个内存页


191
00:06:54,246 --> 00:06:57,796
所以我们要注意记忆警告


192
00:06:59,376 --> 00:07:02,466
这就提出了一个关于缓存的重要问题


193
00:07:03,276 --> 00:07:05,926
当我们缓存时 我们实际上是在试图


194
00:07:05,926 --> 00:07:07,466
避免 CPU 重复工作


195
00:07:07,466 --> 00:07:08,826
但是如果我们缓存太多


196
00:07:08,826 --> 00:07:10,306
我们将耗尽所有的内存


197
00:07:10,716 --> 00:07:12,476
这可能会给系统带来问题


198
00:07:13,436 --> 00:07:15,316
所以请记住 我们有


199
00:07:15,316 --> 00:07:16,536
内存压缩器和缓存


200
00:07:16,696 --> 00:07:17,966
最好平衡一下


201
00:07:17,966 --> 00:07:20,326
缓存与重新计算的内容


202
00:07:21,386 --> 00:07:22,676
另一个注意事项是


203
00:07:22,676 --> 00:07:23,796
如果使用的不是字典


204
00:07:23,796 --> 00:07:25,706
而是 NSCache


205
00:07:25,706 --> 00:07:28,146
这将是存储缓存对象的安全方法


206
00:07:28,506 --> 00:07:30,336
由于 NSCache


207
00:07:30,336 --> 00:07:31,326
分配内存的方式


208
00:07:31,326 --> 00:07:32,806
它实际上是可被释放的


209
00:07:32,806 --> 00:07:33,396
所以在内存受限的环境中


210
00:07:33,396 --> 00:07:34,436
它的效果更好


211
00:07:34,876 --> 00:07:38,396
回到典型的 App 中的


212
00:07:38,396 --> 00:07:40,136
这三个部分


213
00:07:40,136 --> 00:07:41,166
当我们讨论 App 的内存占用时


214
00:07:41,166 --> 00:07:42,636
我们实际上是在讨论那些脏的


215
00:07:42,636 --> 00:07:44,046
和压缩的部分


216
00:07:44,146 --> 00:07:46,766
净内存在这里并不重要


217
00:07:47,876 --> 00:07:51,646
每个 App 都有一个内存占用限制


218
00:07:53,016 --> 00:07:54,816
这个限制对于一个 App 来说


219
00:07:54,816 --> 00:07:56,486
是相当高的


220
00:07:56,556 --> 00:07:57,786
但是请记住 根据设备的不同


221
00:07:58,276 --> 00:07:59,386
这个限制也会改变


222
00:07:59,506 --> 00:08:01,346
因此 你不能像


223
00:08:01,346 --> 00:08:02,556
在内存 4GB 设备上那样 


224
00:08:02,556 --> 00:08:03,946
在 1GB 的设备上


225
00:08:03,946 --> 00:08:10,286
使用同样多的内存 还有扩展


226
00:08:10,636 --> 00:08:11,896
扩展的内存占用要小得多


227
00:08:11,896 --> 00:08:13,726
所以在使用扩展时


228
00:08:13,726 --> 00:08:16,426
你需要更加注意这一点


229
00:08:17,696 --> 00:08:19,836
当你超过了内存占用限制


230
00:08:19,836 --> 00:08:21,356
就会出现异常


231
00:08:22,146 --> 00:08:24,356
这种异常就是


232
00:08:24,356 --> 00:08:26,196
EXC_RESOURCE_EXCEPTION


233
00:08:27,366 --> 00:08:30,066
现在我想邀请


234
00:08:30,066 --> 00:08:31,616
James 来谈谈


235
00:08:31,616 --> 00:08:32,765
如何分析我们的内存占用


236
00:08:34,515 --> 00:08:36,775
[ 掌声 ]


237
00:08:37,275 --> 00:08:37,686
谢谢 James


238
00:08:38,236 --> 00:08:38,616
>> 谢谢你


239
00:08:40,655 --> 00:08:41,066
谢谢 Kyle


240
00:08:41,256 --> 00:08:42,035
好的


241
00:08:42,226 --> 00:08:42,736
我是 James


242
00:08:42,736 --> 00:08:44,155
我是一名 Apple 的软件工程师


243
00:08:44,456 --> 00:08:45,706
我想向你们介绍一些


244
00:08:45,706 --> 00:08:47,886
更高级的工具用于分析和研究


245
00:08:47,886 --> 00:08:49,406
App 的内存占用情况


246
00:08:51,456 --> 00:08:52,346
你可能已经熟悉了


247
00:08:52,346 --> 00:08:53,906
Xcode 内存测量计


248
00:08:54,436 --> 00:08:57,036
它就在调试导航器中


249
00:08:57,166 --> 00:08:59,086
它是帮助你快速查看 App 内存占用


250
00:08:59,086 --> 00:09:00,546
很好的一种方式


251
00:09:00,966 --> 00:09:03,086
在 Xcode 10 中


252
00:09:03,086 --> 00:09:04,516
它现在可向你输出


253
00:09:04,516 --> 00:09:05,696
系统对你的评分值


254
00:09:05,696 --> 00:09:06,526
所以如果看起来与 Xcode 9 不同


255
00:09:06,526 --> 00:09:08,186
不要太在意


256
00:09:09,226 --> 00:09:11,676
我正在 Xcode 中运行我的 App


257
00:09:11,676 --> 00:09:12,606
我发现它消耗了更多的内存


258
00:09:13,386 --> 00:09:14,636
那么下一步我应该用什么工具呢


259
00:09:15,316 --> 00:09:17,306
显然是 Instruments


260
00:09:18,356 --> 00:09:19,826
它提供了许多方法


261
00:09:19,826 --> 00:09:21,186
来调查 App 的内存占用


262
00:09:21,916 --> 00:09:24,256
你可能已经熟悉


263
00:09:24,256 --> 00:09:25,556
“Allocations” 和 “Leaks”


264
00:09:25,776 --> 00:09:27,316
“Allocations”


265
00:09:27,316 --> 00:09:28,466
分析由你的 App 所分配的堆


266
00:09:28,886 --> 00:09:29,866
“Leaks”


267
00:09:29,866 --> 00:09:31,056
会检查一个进程中的内存泄漏


268
00:09:31,226 --> 00:09:32,756
但是你可能不太熟悉


269
00:09:32,756 --> 00:09:33,946
“VM Tracker”


270
00:09:33,946 --> 00:09:34,826
和 “Virtual memory trace（虚拟内存追踪）”


271
00:09:35,376 --> 00:09:37,326
如果你还记得


272
00:09:37,326 --> 00:09:38,066
Kyle 谈论过的


273
00:09:38,066 --> 00:09:39,416
iOS 内存的主要类别


274
00:09:39,486 --> 00:09:41,456
他谈到了脏内存


275
00:09:41,456 --> 00:09:42,516
和压缩内存


276
00:09:42,946 --> 00:09:44,556
VM Tracker 提供了一种


277
00:09:44,556 --> 00:09:45,806
很好的分析方式


278
00:09:47,116 --> 00:09:48,616
它为脏内存


279
00:09:48,616 --> 00:09:50,046
以及交换内存即 iOS 中的压缩内存


280
00:09:50,046 --> 00:09:51,646
分别提供了独立的追踪


281
00:09:51,646 --> 00:09:52,386
并告诉你


282
00:09:52,386 --> 00:09:53,186
关于常驻内存大小的信息


283
00:09:53,996 --> 00:09:55,176
我认为这对于


284
00:09:55,176 --> 00:09:57,926
研究 App 的脏内存大小 非常有用


285
00:09:58,516 --> 00:09:59,866
Instruments 中的最后一项是


286
00:09:59,866 --> 00:10:01,046
“Virtual memory trace（虚拟内存追踪）”


287
00:10:01,786 --> 00:10:03,326
你可以凭借它


288
00:10:03,326 --> 00:10:04,446
与你 App 相关的虚拟内存系统的性能


289
00:10:04,446 --> 00:10:06,726
进行深入的了解


290
00:10:08,736 --> 00:10:10,486
我发现这里的 “By Operation” 标签页


291
00:10:10,486 --> 00:10:11,226
非常有用


292
00:10:11,916 --> 00:10:12,996
它为你提供了一个


293
00:10:12,996 --> 00:10:14,386
虚拟内存系统文件


294
00:10:14,386 --> 00:10:16,376
并向你展示虚拟内存的内存页缓存命中


295
00:10:16,376 --> 00:10:18,826
以及内存页零填充之类的内容


296
00:10:21,016 --> 00:10:22,536
Kyle 前面提到


297
00:10:22,536 --> 00:10:23,726
如果你接近设备的内存限制


298
00:10:23,726 --> 00:10:25,146
你将收到


299
00:10:25,146 --> 00:10:26,766
EXC_RESOURCE_EXCEPTION 的异常


300
00:10:27,276 --> 00:10:28,346
如果你正在 Xcode 10 中


301
00:10:28,346 --> 00:10:31,136
运行你的 App


302
00:10:31,136 --> 00:10:32,586
Xcode 将会捕获这个异常


303
00:10:32,586 --> 00:10:33,266
并暂停你的 App


304
00:10:33,636 --> 00:10:35,636
这意味着你可以启动内存调试器


305
00:10:35,636 --> 00:10:36,816
并从那里开始调查


306
00:10:37,066 --> 00:10:38,436
我认为这真的十分有用


307
00:10:39,016 --> 00:10:42,006
Xcode 的内存调试器


308
00:10:42,006 --> 00:10:43,606
是在 Xcode 8 中提供的


309
00:10:43,606 --> 00:10:44,926
它可以帮助你跟踪对象的依赖


310
00:10:44,926 --> 00:10:46,546
声明周期和泄漏


311
00:10:46,996 --> 00:10:48,336
在 Xcode 10 中


312
00:10:48,336 --> 00:10:50,036
内存调试器更新了布局


313
00:10:50,536 --> 00:10:52,066
它非常适合用来查看


314
00:10:52,066 --> 00:10:52,986
非常大的内存图文件


315
00:10:53,926 --> 00:10:55,836
在内部


316
00:10:55,836 --> 00:10:57,456
Xcode 使用 Memgraph 文件格式


317
00:10:57,456 --> 00:10:58,916
存储有关 App 的


318
00:10:58,916 --> 00:10:59,706
内存使用的信息


319
00:11:00,106 --> 00:11:01,356
你可能不知道


320
00:11:01,726 --> 00:11:03,066
你可以搭配我们的多种命令行工具


321
00:11:03,066 --> 00:11:04,496
使用 Memgraph


322
00:11:06,366 --> 00:11:07,566
首先 你需要从 Xcode 中


323
00:11:07,566 --> 00:11:08,586
导出 Memgraph


324
00:11:08,956 --> 00:11:09,856
这很简单


325
00:11:10,976 --> 00:11:12,336
你只需点按 “File（文件）”菜单中的


326
00:11:12,336 --> 00:11:14,006
“Export Memory Graph...（导出内存图）”


327
00:11:14,006 --> 00:11:14,686
并将其保存


328
00:11:15,336 --> 00:11:18,216
然后 你就可以将 Memgraph


329
00:11:18,256 --> 00:11:19,506
传递给命令行工具


330
00:11:19,506 --> 00:11:20,456
而不是目标本身


331
00:11:20,456 --> 00:11:21,036
这样就可以了


332
00:11:22,176 --> 00:11:23,796
我在 Xcode 10 中运行我的 App


333
00:11:23,796 --> 00:11:25,216
然后收到一个


334
00:11:25,216 --> 00:11:25,996
内存资源异常


335
00:11:26,356 --> 00:11:26,986
这可不太好


336
00:11:27,176 --> 00:11:29,536
我也许应该提取 Memgraph 来进一步研究


337
00:11:29,536 --> 00:11:30,536
但接下来我该怎么做呢


338
00:11:31,046 --> 00:11:32,526
显然 去终端


339
00:11:33,176 --> 00:11:35,396
我经常使用的第一个工具


340
00:11:35,536 --> 00:11:36,026
是 vmmap


341
00:11:36,626 --> 00:11:37,486
通过输出


342
00:11:37,486 --> 00:11:38,696
分配给进程的虚拟内存区域


343
00:11:38,696 --> 00:11:40,306
它给你的 App 提供了


344
00:11:40,306 --> 00:11:42,106
内存消耗的高级分析


345
00:11:43,576 --> 00:11:45,856
-summary 参数 是一个很好的起点


346
00:11:46,716 --> 00:11:49,866
它可以打印出很多细节 


347
00:11:49,866 --> 00:11:52,946
比如该区域的内存大小


348
00:11:52,946 --> 00:11:55,546
脏区域的数量


349
00:11:55,546 --> 00:11:56,286
以及交换内存


350
00:11:56,286 --> 00:11:58,026
也就是 iOS 中的压缩内存的数量


351
00:11:58,196 --> 00:12:00,956
请记住这里的脏和交换区域大小 是非常重要的


352
00:12:02,016 --> 00:12:03,646
值得注意的一点是


353
00:12:03,646 --> 00:12:05,066
交换区域大小指的是


354
00:12:05,066 --> 00:12:07,486
数据压缩前的大小


355
00:12:07,486 --> 00:12:08,746
而不是压缩后的大小


356
00:12:10,226 --> 00:12:11,686
如果你真的需要深入了解


357
00:12:11,756 --> 00:12:13,186
想要更多的信息


358
00:12:13,546 --> 00:12:14,956
你可以在 Memgraph 上


359
00:12:14,956 --> 00:12:16,186
运行 vmmap


360
00:12:16,186 --> 00:12:17,786
你会得到所有区域的具体信息


361
00:12:17,896 --> 00:12:19,606
我们首先向你们展示


362
00:12:19,606 --> 00:12:20,686
“Non-writable regions（不可写入区域）”


363
00:12:20,686 --> 00:12:22,156
比如程序的文本


364
00:12:22,156 --> 00:12:24,536
或可执行代码


365
00:12:24,536 --> 00:12:26,156
然后是 “Writable regions（可写入区域）”


366
00:12:26,156 --> 00:12:27,186
比如数据部分


367
00:12:27,256 --> 00:12:28,786
这就是你的进程堆


368
00:12:29,286 --> 00:12:30,436
所在的位置


369
00:12:30,676 --> 00:12:31,986
除了这些之外还有很酷的一点


370
00:12:31,986 --> 00:12:33,456
就是所有这些工具


371
00:12:33,456 --> 00:12:34,836
都可以很好地使用


372
00:12:34,836 --> 00:12:35,976
标准命令行实用程序


373
00:12:36,526 --> 00:12:38,286
例如 前几天


374
00:12:38,286 --> 00:12:39,356
我在 VM Tracker 中分析我的 App


375
00:12:39,356 --> 00:12:41,506
然后我看到了


376
00:12:41,506 --> 00:12:42,526
脏内存增加的情况


377
00:12:43,106 --> 00:12:45,316
所以我导出了 Memgraph 文件


378
00:12:45,316 --> 00:12:48,036
我想知道这些脏数据


379
00:12:48,036 --> 00:12:49,166
是否有一部分是由我链接的


380
00:12:49,166 --> 00:12:52,076
框架或库造成的


381
00:12:52,276 --> 00:12:54,216
于是我在这个 Memgraph 上


382
00:12:54,216 --> 00:12:55,296
运行 vmmap


383
00:12:56,296 --> 00:12:58,456
我使用了 -pages 参数


384
00:12:58,866 --> 00:13:00,206
这意味着 vmmap 将输出


385
00:13:00,206 --> 00:13:01,496
内存页的数量


386
00:13:01,496 --> 00:13:02,376
而不仅仅是原始字节


387
00:13:02,866 --> 00:13:06,796
然后我将它传输到 grep


388
00:13:06,886 --> 00:13:08,206
并在那搜索 ‘.dylib’


389
00:13:08,206 --> 00:13:09,456
所以我在这里需要动态库


390
00:13:11,046 --> 00:13:12,166
最后 我将它导入到


391
00:13:12,166 --> 00:13:13,536
一个特别简单的 awk 脚本中


392
00:13:14,116 --> 00:13:15,816
来合计脏列


393
00:13:15,816 --> 00:13:16,826
然后最终将其输出为


394
00:13:16,826 --> 00:13:17,886
脏内存页的数量


395
00:13:19,386 --> 00:13:20,556
我觉得这很酷


396
00:13:20,556 --> 00:13:22,286
而且我一直在使用它


397
00:13:22,286 --> 00:13:23,676
它让你能够


398
00:13:23,676 --> 00:13:25,096
为你和你的团队编写


399
00:13:25,096 --> 00:13:26,216
非常强大的调试工作流


400
00:13:26,656 --> 00:13:30,466
另一个 macOS 开发人员


401
00:13:30,466 --> 00:13:31,686
可能已经熟悉的


402
00:13:31,686 --> 00:13:33,066
命令行实用程序是 leaks


403
00:13:33,836 --> 00:13:35,306
它在运行时跟踪堆中


404
00:13:35,696 --> 00:13:37,396
没有根的对象


405
00:13:37,726 --> 00:13:38,586
所以请记住


406
00:13:38,586 --> 00:13:39,816
如果你在 leaks 中看到一个对象


407
00:13:39,816 --> 00:13:41,466
那它占用的是你无法释放的脏内存


408
00:13:41,846 --> 00:13:44,866
让我们看看 内存调试器中的内存泄漏


409
00:13:46,176 --> 00:13:48,176
这里我有 3 个对象


410
00:13:48,176 --> 00:13:49,356
它们相互之间都有很强的引用


411
00:13:49,356 --> 00:13:51,166
创建了一个经典的 “Retain Cycle（留置环）”


412
00:13:51,876 --> 00:13:53,766
让我们在 leaks 工具中


413
00:13:54,216 --> 00:13:56,446
看看这个泄漏


414
00:13:56,646 --> 00:13:57,686
今年 leaks 已被更新


415
00:13:57,686 --> 00:13:59,676
不仅可以显示


416
00:13:59,676 --> 00:14:05,396
泄漏的对象 还可显示它们所属的 Retain Cycle


417
00:14:05,396 --> 00:14:07,126
如果进程中启用了


418
00:14:07,126 --> 00:14:08,856
malloc 堆栈日志记录


419
00:14:08,856 --> 00:14:10,666
我们甚至为你提供了


420
00:14:11,786 --> 00:14:14,146
根节点 回溯


421
00:14:14,416 --> 00:14:15,796
我经常问自己的一个问题是


422
00:14:15,906 --> 00:14:17,276
内存都去哪了


423
00:14:18,096 --> 00:14:19,606
我查看了 vmmap


424
00:14:19,606 --> 00:14:20,716
发现堆很大


425
00:14:20,966 --> 00:14:22,006
但是接下来要做什么呢


426
00:14:22,626 --> 00:14:24,426
heap 工具提供了


427
00:14:24,426 --> 00:14:25,366
关于进程堆中


428
00:14:25,366 --> 00:14:26,836
对象分配的各种信息


429
00:14:27,046 --> 00:14:28,616
它可以帮助你追踪


430
00:14:28,616 --> 00:14:30,216
非常复杂的分配


431
00:14:30,216 --> 00:14:32,086
或者很多同类的对象


432
00:14:34,036 --> 00:14:36,236
我这里有一个 Memgraph 文件


433
00:14:36,236 --> 00:14:37,516
它是我在 Xcode 捕获到


434
00:14:37,516 --> 00:14:39,336
内存资源异常时得到的


435
00:14:39,336 --> 00:14:40,366
我想研究它的堆


436
00:14:40,906 --> 00:14:43,416
所以我把它传递给了 heap


437
00:14:43,926 --> 00:14:45,186
它告诉我


438
00:14:45,186 --> 00:14:49,696
每个对象的类名


439
00:14:49,696 --> 00:14:50,546
它们的数量


440
00:14:50,546 --> 00:14:52,366
它们的平均大小


441
00:14:52,366 --> 00:14:54,976
以及这类对象的总大小


442
00:14:54,976 --> 00:14:56,446
在这里


443
00:14:56,656 --> 00:14:58,156
我看到了很多很多小对象


444
00:14:58,156 --> 00:14:58,976
但我不认为


445
00:14:58,976 --> 00:14:59,676
这是什么问题


446
00:14:59,946 --> 00:15:01,066
我不认为


447
00:15:01,066 --> 00:15:01,786
这是主要的问题


448
00:15:05,336 --> 00:15:07,456
默认情况下 堆将按数量排序


449
00:15:08,376 --> 00:15:09,786
但是我希望看到的


450
00:15:09,936 --> 00:15:11,176
是最大的对象


451
00:15:11,176 --> 00:15:12,586
而不是数量最多的对象


452
00:15:12,586 --> 00:15:14,086
因此将 -sortBySize 参数传递给堆


453
00:15:14,086 --> 00:15:15,176
能让它们按大小排序


454
00:15:16,616 --> 00:15:17,606
这里我看到了一些


455
00:15:17,606 --> 00:15:19,576
硕大的 NSConcreteData 对象


456
00:15:19,926 --> 00:15:21,246
我应该将这个输出


457
00:15:21,246 --> 00:15:22,586
和 Memgraph


458
00:15:22,586 --> 00:15:24,726
附加到 Bug 报告中


459
00:15:24,726 --> 00:15:25,216
但这还不够


460
00:15:25,216 --> 00:15:25,966
我得弄清楚


461
00:15:25,966 --> 00:15:26,446
这些对象是怎么来的


462
00:15:27,806 --> 00:15:29,186
首先 我需要获得


463
00:15:29,186 --> 00:15:30,896
其中一个 NSConcreteData 对象的地址


464
00:15:31,606 --> 00:15:33,006
然后是 heap 工具中的 -addresses 参数


465
00:15:33,396 --> 00:15:34,436
当你将 -addresses 参数


466
00:15:34,436 --> 00:15:35,456
与一个类名一起传给 heap 工具时


467
00:15:35,456 --> 00:15:36,656
它将为你提供堆上的


468
00:15:36,656 --> 00:15:38,306
每个实例的地址


469
00:15:39,516 --> 00:15:41,186
现在我有了这些地址


470
00:15:41,186 --> 00:15:42,656
我可以知道它们每一个都来自哪里


471
00:15:43,926 --> 00:15:44,866
这就是 malloc 堆栈日志记录


472
00:15:44,866 --> 00:15:45,756
派上用场的地方


473
00:15:46,526 --> 00:15:47,976
当启用时


474
00:15:47,976 --> 00:15:49,826
系统将记录每个分配的回溯


475
00:15:50,316 --> 00:15:52,196
当我们记录一个 Memgraph 时


476
00:15:52,196 --> 00:15:53,576
这些日志就会被捕获


477
00:15:53,576 --> 00:15:54,616
它们将用于为我们的一些工具


478
00:15:54,616 --> 00:15:56,366
注释现有的输出 你可以在


479
00:15:57,136 --> 00:15:58,306
“Scheme Editor（Scheme 编辑器）”中的


480
00:15:58,306 --> 00:16:00,576
“Diagnostics（诊断）”标签页中 轻松启用它


481
00:16:01,426 --> 00:16:02,576
我建议你们


482
00:16:02,576 --> 00:16:03,696
在 Memgraph 中


483
00:16:03,696 --> 00:16:06,726
使用实时分配选项


484
00:16:06,726 --> 00:16:08,986
我的 Memgraph 文件


485
00:16:08,986 --> 00:16:10,196
在 malloc 堆栈日志记录中被捕获


486
00:16:10,866 --> 00:16:12,926
现在我们要找到分配的回溯


487
00:16:13,226 --> 00:16:14,776
这就是 malloc_history 发挥作用的地方


488
00:16:15,566 --> 00:16:16,946
你只需传递 malloc_history


489
00:16:17,136 --> 00:16:18,576
Memgraph


490
00:16:18,576 --> 00:16:19,886
以及内存中实例的地址


491
00:16:19,886 --> 00:16:20,876
那么 如果捕获到它的回溯


492
00:16:20,876 --> 00:16:24,016
malloc_history 就会将其提供给你


493
00:16:24,136 --> 00:16:25,276
这里我取了其中


494
00:16:25,276 --> 00:16:27,276
一个很大的 NSConcreteData 的地址


495
00:16:27,496 --> 00:16:28,376
我把它传递给了 malloc_history


496
00:16:28,376 --> 00:16:31,026
然后我就得到了一个回溯记录


497
00:16:31,486 --> 00:16:32,646
有趣的是


498
00:16:32,646 --> 00:16:34,166
看起来我的 NoirFilter.apply() 方法


499
00:16:34,166 --> 00:16:36,376
创建了一个巨大的 NSConcreteData


500
00:16:37,126 --> 00:16:38,526
我应该将这个和 Memgraph


501
00:16:38,526 --> 00:16:40,186
附加到一个 Bug 报告中


502
00:16:40,186 --> 00:16:43,206
其他人就可以查看它


503
00:16:43,476 --> 00:16:44,696
这些只是几种


504
00:16:44,696 --> 00:16:46,756
可以深入研究


505
00:16:46,756 --> 00:16:48,216
App 行为的方法


506
00:16:48,626 --> 00:16:49,526
当遇到内存问题时


507
00:16:49,526 --> 00:16:51,086
你会选择哪个工具


508
00:16:52,096 --> 00:16:53,676
有 3 种思考方式


509
00:16:53,956 --> 00:16:55,656
你想看到对象的创建吗


510
00:16:55,656 --> 00:16:56,956
你想要查看内存中


511
00:16:56,956 --> 00:16:58,696
引用对象或地址的内容吗


512
00:16:59,056 --> 00:17:00,926
或者你只是想看看 一个实例有多大


513
00:17:02,376 --> 00:17:03,366
如果你在进程启动时


514
00:17:03,366 --> 00:17:05,046
启用了 malloc 堆栈日志记录


515
00:17:05,046 --> 00:17:06,185
那么 malloc_history


516
00:17:06,185 --> 00:17:09,455
可以帮助你查找 该对象的回溯


517
00:17:10,896 --> 00:17:11,646
如果你只是想看看


518
00:17:11,646 --> 00:17:12,896
在内存中引用对象的内容


519
00:17:13,486 --> 00:17:15,576
你可以使用 leaks


520
00:17:15,576 --> 00:17:16,766
和在内存页面中


521
00:17:16,766 --> 00:17:17,915
提供的其他工具来帮助你


522
00:17:17,915 --> 00:17:20,366
最后 如果你只是想了解


523
00:17:20,366 --> 00:17:23,296
一个区域或一个实例有多大 vmmap


524
00:17:23,296 --> 00:17:24,056
和 heap 是首选工具


525
00:17:24,626 --> 00:17:27,376
作为起始点 我建议在进程的 Memgraph 上


526
00:17:27,376 --> 00:17:30,436
运行带有 -summary 命令的 vmmap


527
00:17:30,626 --> 00:17:34,096
然后顺着线程继续进行


528
00:17:34,096 --> 00:17:36,286
现在 我想请回 Kyle 他将会讨论


529
00:17:36,436 --> 00:17:37,736
iOS App 中最大的对象


530
00:17:37,736 --> 00:17:39,936
那就是图像


531
00:17:40,646 --> 00:17:40,856
有请 Kyle


532
00:17:42,516 --> 00:17:45,856
[ 掌声 ]


533
00:17:46,356 --> 00:17:46,916
>> 谢谢 James


534
00:17:47,916 --> 00:17:49,486
说到图像


535
00:17:50,306 --> 00:17:51,586
关于图像需要记住的


536
00:17:51,586 --> 00:17:54,296
最重要的就是


537
00:17:54,296 --> 00:17:55,506
内存使用与图像的尺寸有关


538
00:17:55,506 --> 00:17:58,536
而不与它的文件大小有关


539
00:17:59,696 --> 00:18:01,846
举个例子


540
00:18:01,996 --> 00:18:03,786
我有一张非常漂亮的图片


541
00:18:03,786 --> 00:18:04,986
并且我想把它作为


542
00:18:04,986 --> 00:18:05,496
一个 iPad App 的壁纸


543
00:18:06,646 --> 00:18:10,786
它的尺寸是 2048*1536


544
00:18:10,786 --> 00:18:13,436
磁盘上文件的大小是 590KB


545
00:18:13,966 --> 00:18:16,086
但是它实际使用了多少内存呢


546
00:18:18,516 --> 00:18:19,646
10MB


547
00:18:20,056 --> 00:18:21,746
10MB 这可够大的


548
00:18:22,146 --> 00:18:23,746
这是因为


549
00:18:23,746 --> 00:18:25,066
把像素的宽度乘以高


550
00:18:25,066 --> 00:18:28,406
即 2048 乘以 1536


551
00:18:28,406 --> 00:18:30,016
然后每像素乘以 4 字节


552
00:18:30,016 --> 00:18:30,786
就会达到 10MB


553
00:18:31,706 --> 00:18:33,956
那么为什么它会大这么多呢


554
00:18:35,016 --> 00:18:36,916
我们要谈谈图像


555
00:18:36,916 --> 00:18:38,076
是如何在 iOS 上工作的


556
00:18:38,196 --> 00:18:39,676
有加载 解码


557
00:18:39,706 --> 00:18:40,346
和渲染三个阶段


558
00:18:41,306 --> 00:18:43,516
在加载阶段


559
00:18:43,516 --> 00:18:45,646
这个被压缩的 590KB 的 JPEG 文件被接收


560
00:18:45,646 --> 00:18:48,646
并被加载到内存中


561
00:18:49,856 --> 00:18:51,996
在解码阶段 JPEG 文件


562
00:18:51,996 --> 00:18:55,366
将被转换为 GPU 可以读取的格式


563
00:18:55,936 --> 00:18:56,966
图像需要被解压


564
00:18:56,966 --> 00:18:58,996
这使得文件大小增至 10 mb


565
00:18:59,926 --> 00:19:01,446
被解码之后


566
00:19:01,446 --> 00:19:02,556
图像就可以被随意渲染了


567
00:19:03,136 --> 00:19:05,206
要了解更多关于图像的信息


568
00:19:05,526 --> 00:19:06,936
以及如何对它们进行优化


569
00:19:06,936 --> 00:19:08,346
我建议你们查看


570
00:19:08,346 --> 00:19:10,296
本周早些时候举行的


571
00:19:10,416 --> 00:19:11,646
“Images and Graphics


572
00:19:11,646 --> 00:19:13,946
Best Practices” 的讨论会


573
00:19:14,216 --> 00:19:16,076
在 SRGB 格式中


574
00:19:16,176 --> 00:19:17,286
每个像素有 4 个字节


575
00:19:18,236 --> 00:19:19,186
这通常是图形中


576
00:19:19,186 --> 00:19:21,856
图像最常见的格式


577
00:19:22,356 --> 00:19:26,196
它是每个像素 8 位


578
00:19:26,816 --> 00:19:28,776
所以红色 1 字节 绿色 1 字节


579
00:19:28,776 --> 00:19:30,816
蓝色 1 字节


580
00:19:30,816 --> 00:19:31,596
Alpha 通道 1 字节


581
00:19:33,126 --> 00:19:36,036
但是 我们还可以将其继续变大


582
00:19:36,036 --> 00:19:39,176
iOS 硬件可以渲染宽格式


583
00:19:39,356 --> 00:19:40,736
宽格式中


584
00:19:40,736 --> 00:19:42,476
为了得到有表现力的颜色


585
00:19:42,476 --> 00:19:44,356
每个像素需要 2 个字节


586
00:19:44,356 --> 00:19:45,456
所以我们将图像的大小加倍


587
00:19:46,356 --> 00:19:49,176
iPhone 7 iPhone 8 iPhone X


588
00:19:49,356 --> 00:19:51,006
以及一些 iPad Pro 上的摄像头


589
00:19:51,436 --> 00:19:53,036
非常适合捕捉这种


590
00:19:53,266 --> 00:19:55,006
高保真的内容


591
00:19:55,576 --> 00:19:56,966
你也可以用它来制作


592
00:19:56,966 --> 00:19:57,976
非常精确的颜色


593
00:19:57,976 --> 00:19:58,946
比如运动商标等等


594
00:20:00,066 --> 00:20:01,706
但是这些只在


595
00:20:01,706 --> 00:20:02,856
宽格式显示器中有用


596
00:20:02,856 --> 00:20:03,766
所以我们不希望


597
00:20:03,766 --> 00:20:04,616
在不需要的时候使用它


598
00:20:05,756 --> 00:20:07,766
另一方面 我们也可以使图像变小


599
00:20:08,356 --> 00:20:10,066
比如 AL8 格式


600
00:20:10,606 --> 00:20:13,176
这种格式只存储灰度值


601
00:20:13,176 --> 00:20:14,236
和 Alpha 值


602
00:20:14,886 --> 00:20:16,486
它通常用于着色器


603
00:20:16,486 --> 00:20:18,626
比如 Metal App 等等


604
00:20:19,306 --> 00:20:21,246
这个格式并不常用 实际上 


605
00:20:21,446 --> 00:20:22,776
我们还可以让它继续变小


606
00:20:23,736 --> 00:20:24,936
我们可以使用所谓的


607
00:20:24,936 --> 00:20:26,086
Alpha 8 格式


608
00:20:26,516 --> 00:20:28,096
Alpha 8 只有 1 个通道


609
00:20:28,156 --> 00:20:30,196
每个像素 1 个字节 非常小


610
00:20:30,196 --> 00:20:32,056
它比 SRGB 小 75%


611
00:20:33,026 --> 00:20:34,546
这很适合蒙版


612
00:20:34,546 --> 00:20:36,246
或单色文本


613
00:20:36,246 --> 00:20:37,966
因为我们节省了 75% 的内存


614
00:20:39,096 --> 00:20:41,396
如果我们分开来看


615
00:20:42,296 --> 00:20:43,966
我们可以从 Alpha 8 格式的


616
00:20:44,006 --> 00:20:45,786
每个像素 1 个字节开始


617
00:20:45,786 --> 00:20:47,096
一直增加到宽格式的每个像素 8 个字节


618
00:20:47,466 --> 00:20:48,606
这个范围很大


619
00:20:48,916 --> 00:20:50,806
所以我们真正需要做的是


620
00:20:50,806 --> 00:20:52,046
知道如何选择正确的格式


621
00:20:52,926 --> 00:20:54,906
那么我们如何选择正确的格式呢


622
00:20:55,656 --> 00:20:58,126
简短的回答是不要选择格式


623
00:20:58,456 --> 00:20:59,646
让格式来选择你


624
00:21:01,106 --> 00:21:03,006
如果你不再使用


625
00:21:03,006 --> 00:21:04,876
自 iOS 诞生起就存在于 iOS 的


626
00:21:04,876 --> 00:21:07,416
UIGraphicsBeginImageContext


627
00:21:07,416 --> 00:21:09,276
WithOptions API


628
00:21:09,276 --> 00:21:12,576
而是切换到 UIGraphicsImageRenderer 格式


629
00:21:12,576 --> 00:21:14,206
你可以节省很多内存


630
00:21:15,036 --> 00:21:17,456
因为 UIGraphicsBeginImage


631
00:21:17,456 --> 00:21:19,006
ContextWithOptions 总是一个


632
00:21:19,356 --> 00:21:20,916
每像素 4 字节的格式


633
00:21:21,886 --> 00:21:22,866
它总是 SRGB 格式


634
00:21:23,186 --> 00:21:25,446
所以只要你不想 你就不会得到宽格式


635
00:21:25,446 --> 00:21:27,216
也不会得到


636
00:21:27,216 --> 00:21:28,596
每像素 1 字节的 A8 格式


637
00:21:28,716 --> 00:21:30,966
如果你使用在 iOS 10 中引入的


638
00:21:31,566 --> 00:21:33,576
UIGraphicsImageRenderer API


639
00:21:33,626 --> 00:21:35,156
在 iOS 12 中


640
00:21:35,156 --> 00:21:36,396
它会自动为你选择最好的图形格式


641
00:21:36,866 --> 00:21:39,176
这有一个例子


642
00:21:39,716 --> 00:21:41,146
假设我画了一个圆作为一个蒙版


643
00:21:41,956 --> 00:21:43,666
使用旧 API


644
00:21:43,666 --> 00:21:45,626
高亮的部分是


645
00:21:45,626 --> 00:21:46,866
我的绘制代码


646
00:21:46,866 --> 00:21:48,326
只是为了绘制一个黑色圆圈


647
00:21:48,326 --> 00:21:49,586
我得到的却是每个像素 4 字节的格式


648
00:21:51,026 --> 00:21:52,366
如果我转而使用新的 API


649
00:21:52,366 --> 00:21:54,826
我使用的是完全相同的绘制代码


650
00:21:55,676 --> 00:21:57,406
通过使用新的 API


651
00:21:57,406 --> 00:21:59,096
我现在得到的是每个像素 1 字节的图像


652
00:21:59,176 --> 00:22:01,396
这意味着它减少了


653
00:22:01,706 --> 00:22:02,346
75% 的内存使用


654
00:22:02,786 --> 00:22:04,316
在保证相同保真度的同时


655
00:22:04,316 --> 00:22:05,086
也获得了可观的内存节省


656
00:22:05,676 --> 00:22:11,916
另外一个好处是 如果我想再次使用这个蒙版


657
00:22:11,916 --> 00:22:13,476
我可以在一个 imageView 上


658
00:22:13,476 --> 00:22:16,006
改变 tintColor


659
00:22:16,006 --> 00:22:17,366
而且只用一个点号就可以做到


660
00:22:17,366 --> 00:22:20,906
这意味着我不必再分配内存了


661
00:22:21,216 --> 00:22:23,006
我不仅可以把它


662
00:22:23,006 --> 00:22:24,196
设成一个黑色的圆圈


663
00:22:24,196 --> 00:22:25,646
还可以设成蓝色的 红色的 绿色的圆圈


664
00:22:25,646 --> 00:22:26,896
且没有额外的内存占用


665
00:22:27,216 --> 00:22:27,826
这很酷


666
00:22:32,236 --> 00:22:34,136
我们通常对图像做的另一件事是


667
00:22:34,136 --> 00:22:34,876
对它们进行下采样


668
00:22:35,516 --> 00:22:36,936
当我们想要制作


669
00:22:36,936 --> 00:22:38,286
比如缩略图的时候


670
00:22:38,286 --> 00:22:38,866
我们想要缩小它


671
00:22:39,196 --> 00:22:41,426
我们不应该


672
00:22:41,426 --> 00:22:42,836
用 UIImage 进行缩小


673
00:22:42,956 --> 00:22:44,336
如果我们使用 UIImage 绘图


674
00:22:44,336 --> 00:22:46,126
由于内部坐标空间变换


675
00:22:46,126 --> 00:22:48,856
这种方法性能并不高


676
00:22:49,316 --> 00:22:50,946
就像我们之前看到的


677
00:22:50,946 --> 00:22:52,656
它会解压缩内存中的整个图像


678
00:22:53,616 --> 00:22:55,886
取而代之 我们可以使用 ImageIO 框架


679
00:22:56,536 --> 00:22:58,196
ImageIO 可以对图像进行下采样


680
00:22:58,196 --> 00:23:00,036
它使用 Streaming API


681
00:23:00,036 --> 00:23:03,136
这样你只需为生成图像


682
00:23:03,136 --> 00:23:03,996
使用一些脏内存


683
00:23:04,196 --> 00:23:05,566
这将为你节省一个内存峰值


684
00:23:06,076 --> 00:23:09,126
例如 这里有一些代码


685
00:23:09,196 --> 00:23:10,346
以及我在磁盘上获得的一个文件


686
00:23:10,506 --> 00:23:11,996
也可以是我下载的一个文件


687
00:23:12,916 --> 00:23:16,456
我现在用 UIImage 绘制一个


688
00:23:16,546 --> 00:23:17,696
更小的矩形


689
00:23:18,106 --> 00:23:19,796
仍然会有一个大峰值


690
00:23:21,036 --> 00:23:22,626
如果切换到 ImageIO


691
00:23:22,626 --> 00:23:25,236
我仍然需要从磁盘加载文件


692
00:23:25,896 --> 00:23:27,846
因为它是一个较低级的 API


693
00:23:27,846 --> 00:23:29,476
我设置了一些参数


694
00:23:29,476 --> 00:23:30,936
来表示我希望这个图像有多大


695
00:23:31,186 --> 00:23:33,126
所以我让它用


696
00:23:33,126 --> 00:23:34,206
CGImageSourceCreateThumbnailAtIndex


697
00:23:34,246 --> 00:23:35,346
创建图像


698
00:23:35,916 --> 00:23:37,506
现在 我可以用 UIImage 封装这个 CGImage


699
00:23:37,506 --> 00:23:38,956
并准备好进行下一步了


700
00:23:39,096 --> 00:23:40,246
我有一个小得多的图像


701
00:23:40,526 --> 00:23:43,486
而且比之前的代码快 50%


702
00:23:45,146 --> 00:23:47,086
我们要讨论的


703
00:23:47,086 --> 00:23:48,406
另一件事是


704
00:23:48,406 --> 00:23:49,096
如何进行后台优化


705
00:23:49,946 --> 00:23:53,316
假设我在一个 App 中


706
00:23:53,616 --> 00:23:54,886
有一个全屏的图像 它很美


707
00:23:54,886 --> 00:23:55,446
我很喜欢


708
00:23:55,906 --> 00:23:57,376
但之后 我需要


709
00:23:57,376 --> 00:23:58,706
到我的主屏幕上处理通知


710
00:23:58,706 --> 00:24:00,376
或者转到


711
00:24:00,376 --> 00:24:01,316
另一个 App 上


712
00:24:01,986 --> 00:24:03,586
那张图像还在内存中


713
00:24:04,626 --> 00:24:06,806
经验之谈


714
00:24:06,806 --> 00:24:08,486
我们建议你卸载


715
00:24:08,486 --> 00:24:09,826
看不到的大型资源


716
00:24:10,276 --> 00:24:13,756
有两种方法可供选择


717
00:24:13,986 --> 00:24:15,246
第一种是 App 生命周期


718
00:24:15,296 --> 00:24:16,466
如果你把你的 App


719
00:24:16,466 --> 00:24:17,656
放在后台或者前台


720
00:24:17,656 --> 00:24:19,976
App 生命周期事件


721
00:24:19,976 --> 00:24:20,736
可以帮助你了解它


722
00:24:21,686 --> 00:24:22,926
这主要适用于


723
00:24:22,926 --> 00:24:24,486
屏幕上的视图


724
00:24:24,536 --> 00:24:25,316
因为它们不遵循


725
00:24:25,316 --> 00:24:27,106
UIViewController 外观的生命周期


726
00:24:27,756 --> 00:24:28,886
UIViewController 方法


727
00:24:28,886 --> 00:24:30,576
适用于标签控制器


728
00:24:31,476 --> 00:24:32,526
或导航控制器


729
00:24:32,526 --> 00:24:34,446
因为你会有多个视图控制器


730
00:24:34,446 --> 00:24:36,066
但只有一个出现在屏幕上


731
00:24:36,716 --> 00:24:37,486
如果你利用


732
00:24:37,486 --> 00:24:38,296
viewWillAppear 和


733
00:24:38,296 --> 00:24:39,946
viewDidDisappear 的代码或回调


734
00:24:40,176 --> 00:24:41,516
就可以使


735
00:24:41,726 --> 00:24:42,766
内存占用更小


736
00:24:44,036 --> 00:24:46,476
举一个例子


737
00:24:46,476 --> 00:24:48,246
如果我为进入后台的


738
00:24:48,246 --> 00:24:49,466
App 注册通知


739
00:24:49,566 --> 00:24:50,916
我可以卸载我的大型资源


740
00:24:50,916 --> 00:24:52,726
在这里就是图像


741
00:24:53,826 --> 00:24:54,696
当 App 回到前台时


742
00:24:54,696 --> 00:24:56,786
我就会收到通知


743
00:24:57,556 --> 00:24:59,686
如果我在这里重新加载图像


744
00:24:59,856 --> 00:25:00,746
当用户返回时


745
00:25:00,746 --> 00:25:02,406
我就可以在后台保存内存


746
00:25:02,406 --> 00:25:04,206
并保持同样的保真度


747
00:25:04,396 --> 00:25:05,436
这对他们来说是完全一样的


748
00:25:05,436 --> 00:25:07,226
但是系统有


749
00:25:07,226 --> 00:25:10,476
更多的内存可用


750
00:25:10,476 --> 00:25:12,306
与此类似 如果我在导航控制器


751
00:25:12,306 --> 00:25:14,056
或标签控制器中


752
00:25:14,536 --> 00:25:15,776
我的视图控制器可以


753
00:25:15,776 --> 00:25:17,146
在图像消失时卸载它们


754
00:25:17,746 --> 00:25:18,976
在返回 viewWillAppear() 方法之前


755
00:25:18,976 --> 00:25:21,916
我可以重新加载它们


756
00:25:22,116 --> 00:25:23,076
用户还是不会注意到


757
00:25:23,076 --> 00:25:24,066
有什么不同


758
00:25:24,216 --> 00:25:25,506
我们的 App 如今使用更少的内存


759
00:25:25,506 --> 00:25:26,696
这很好


760
00:25:27,286 --> 00:25:31,176
现在 我想邀请 Kris


761
00:25:31,216 --> 00:25:32,746
用一个很好的演示


762
00:25:32,746 --> 00:25:33,566
向你们展示之前的内容 


763
00:25:34,376 --> 00:25:34,646
Kris


764
00:25:35,516 --> 00:25:39,586
[ 掌声 ]


765
00:25:40,086 --> 00:25:41,436
>> 好的 我现在要


766
00:25:41,436 --> 00:25:42,376
切换到演示机器


767
00:25:43,316 --> 00:25:43,756
我们开始吧


768
00:25:44,116 --> 00:25:45,526
我一直在开发这个 App


769
00:25:45,606 --> 00:25:47,596
这些是我从


770
00:25:47,636 --> 00:25:50,386
NASA 那里得到的


771
00:25:50,796 --> 00:25:52,426
太阳系的高分辨率图像


772
00:25:52,426 --> 00:25:54,056
这个 App 可以让你


773
00:25:54,056 --> 00:25:55,866
对它们应用不同的滤镜


774
00:25:56,406 --> 00:25:57,416
接下来我们会看到一个


775
00:25:57,416 --> 00:26:00,386
简单的例子 在太阳上应用一个滤镜


776
00:26:00,996 --> 00:26:02,496
我对目前的进展非常满意


777
00:26:02,496 --> 00:26:04,396
所以我把它发给 James


778
00:26:04,396 --> 00:26:05,926
征求他的意见


779
00:26:05,926 --> 00:26:07,956
他给我回了一封


780
00:26:08,056 --> 00:26:09,146
带有两个附件的邮件


781
00:26:09,826 --> 00:26:12,196
一个附件是 Memgraph 文件


782
00:26:12,196 --> 00:26:13,626
另一个是这个图像


783
00:26:15,776 --> 00:26:19,916
James 是一个相当保守和低调的人


784
00:26:19,916 --> 00:26:21,676
所以当他发送了两个红色的惊叹号


785
00:26:21,676 --> 00:26:23,746
和一个尖叫的表情符号时


786
00:26:23,746 --> 00:26:24,706
我知道他很难过


787
00:26:25,546 --> 00:26:27,156
所以我去找 James


788
00:26:27,516 --> 00:26:28,496
我说 “你知道


789
00:26:28,496 --> 00:26:29,386
我不明白这有什么大不了的


790
00:26:29,736 --> 00:26:31,626
很明显我需要


791
00:26:31,626 --> 00:26:33,026
再使用至少 0.5 GB 


792
00:26:33,086 --> 00:26:34,266
才能出现内存不足的情况


793
00:26:34,266 --> 00:26:35,776
然而我还有一些可用的内存


794
00:26:35,866 --> 00:26:36,796
我难道不能用它吗”


795
00:26:37,826 --> 00:26:39,646
James 一个比我


796
00:26:39,646 --> 00:26:41,016
优秀得多的开发者


797
00:26:41,016 --> 00:26:42,736
他指出了一些


798
00:26:42,736 --> 00:26:43,926
我的逻辑有问题的地方


799
00:26:44,156 --> 00:26:46,976
首先 这个测量计


800
00:26:47,026 --> 00:26:49,926
测量的是一个有 2GB 内存的设备


801
00:26:50,566 --> 00:26:51,866
并不是所有的设备


802
00:26:51,866 --> 00:26:52,406
都有那么多的内存


803
00:26:52,876 --> 00:26:54,106
如果这段代码运行在


804
00:26:54,106 --> 00:26:55,696
只有 1GB 内存的设备上


805
00:26:55,696 --> 00:26:57,306
那么很有可能


806
00:26:57,306 --> 00:27:00,056
我们的 App 已经被操作系统终止了


807
00:27:00,866 --> 00:27:04,076
其次 操作系统


808
00:27:04,076 --> 00:27:06,796
在决定何时


809
00:27:06,926 --> 00:27:08,396
终止 App 时


810
00:27:08,396 --> 00:27:09,606
不仅依照你的 App


811
00:27:09,606 --> 00:27:11,176
使用的内存大小


812
00:27:11,176 --> 00:27:13,206
还依照操作系统中的其他内容


813
00:27:13,696 --> 00:27:15,446
所以仅仅因为


814
00:27:15,446 --> 00:27:16,956
我们还没有耗尽内存


815
00:27:16,956 --> 00:27:19,176
并不意味着我们没有被终止的危险


816
00:27:20,076 --> 00:27:22,196
最后 这对用户来说


817
00:27:22,376 --> 00:27:24,076
是一种糟糕的体验


818
00:27:24,636 --> 00:27:25,706
事实上 如果你查看


819
00:27:25,706 --> 00:27:27,736
使用比较图表


820
00:27:27,736 --> 00:27:29,776
你可以看到其他进程的


821
00:27:29,776 --> 00:27:30,856
内存为 0KB


822
00:27:31,496 --> 00:27:32,726
那是因为它们都被


823
00:27:32,726 --> 00:27:33,866
操作系统抛弃了


824
00:27:33,866 --> 00:27:36,906
只是为我们的 App 腾出空间


825
00:27:36,906 --> 00:27:38,266
你们可能都在静静地看着我


826
00:27:38,266 --> 00:27:39,856
然后摆出一个嫌弃的表情


827
00:27:40,376 --> 00:27:41,686
因为当用户想去


828
00:27:41,686 --> 00:27:43,156
看你们的 App 时


829
00:27:43,156 --> 00:27:44,076
它必须从头开始加载


830
00:27:45,246 --> 00:27:47,046
James 说得很有道理


831
00:27:47,046 --> 00:27:48,316
我认为 总的来说


832
00:27:48,316 --> 00:27:49,566
我们应该让这个内存指针


833
00:27:49,566 --> 00:27:51,856
尽可能向左


834
00:27:51,856 --> 00:27:53,216
而不是向右


835
00:27:54,076 --> 00:27:55,766
看看我们能做什么


836
00:27:56,256 --> 00:27:57,496
让我先来看看


837
00:27:57,496 --> 00:27:58,706
Memgraph 文件


838
00:27:59,266 --> 00:28:03,496
我有一些


839
00:28:04,286 --> 00:28:06,686
在使用 Memgraph 文件


840
00:28:06,686 --> 00:28:08,216
的日常技巧


841
00:28:08,216 --> 00:28:08,946
或者说是策略


842
00:28:09,426 --> 00:28:10,756
第一个


843
00:28:10,856 --> 00:28:12,636
我需要把它向上拖动一下


844
00:28:13,076 --> 00:28:14,846
就是寻找泄漏


845
00:28:15,406 --> 00:28:18,286
如果我前往过滤器工具栏


846
00:28:18,286 --> 00:28:19,846
轻点泄漏过滤器


847
00:28:19,846 --> 00:28:22,106
它就会显示 Memgraph 文件中的


848
00:28:22,106 --> 00:28:23,736
每一个泄漏


849
00:28:24,666 --> 00:28:27,746
这个 Memgraph 文件没有泄漏


850
00:28:27,986 --> 00:28:29,526
这既是好消息


851
00:28:29,526 --> 00:28:30,656
又是坏消息


852
00:28:31,136 --> 00:28:32,136
好处在于 没有泄漏


853
00:28:32,136 --> 00:28:33,516
但现在我得弄清楚


854
00:28:33,516 --> 00:28:35,046
到底发生了什么


855
00:28:35,906 --> 00:28:37,746
Memgraph 的


856
00:28:37,746 --> 00:28:40,046
另一个好处是


857
00:28:40,046 --> 00:28:41,926
告诉我一个对象


858
00:28:41,926 --> 00:28:43,036
在内存中有多少个实例


859
00:28:43,036 --> 00:28:44,226
以及是否比我预期的要多


860
00:28:44,876 --> 00:28:46,166
当我查看这个 Memgraph 文件时


861
00:28:46,166 --> 00:28:47,476
如果我特意关注


862
00:28:47,476 --> 00:28:49,136
代码中的对象


863
00:28:49,136 --> 00:28:52,146
就可以看到


864
00:28:52,146 --> 00:28:53,966
内存中只有 5 个对象


865
00:28:53,966 --> 00:28:55,526
且每种都只有 1 个


866
00:28:56,136 --> 00:28:57,266
如果内存中


867
00:28:57,266 --> 00:28:59,066
有多个 RootViewController


868
00:28:59,336 --> 00:29:01,586
多个 NoirFilter


869
00:29:01,586 --> 00:29:03,366
多个滤镜


870
00:29:03,366 --> 00:29:04,676
或其他预料之外的对象


871
00:29:04,676 --> 00:29:05,716
那些就是我可以调查的东西


872
00:29:06,496 --> 00:29:09,736
这里的实例数量


873
00:29:09,736 --> 00:29:10,816
在我的预料内


874
00:29:10,816 --> 00:29:12,076
但也许其中存在一个很大的实例


875
00:29:12,186 --> 00:29:13,726
尽管不太可能


876
00:29:13,726 --> 00:29:14,366
我还是得检查一下


877
00:29:14,566 --> 00:29:17,386
所以我需要使用内存检查器


878
00:29:17,386 --> 00:29:18,206
我要看看这些


879
00:29:18,286 --> 00:29:19,576
它们中的每一个


880
00:29:19,576 --> 00:29:20,666
都列出了每个对象的大小


881
00:29:21,016 --> 00:29:23,486
我可以看到我的 AppDelegate 是 32 字节


882
00:29:23,966 --> 00:29:25,796
DataViewController 是 1500 字节


883
00:29:26,216 --> 00:29:27,556
当我浏览每一个的时候


884
00:29:28,506 --> 00:29:30,056
没有一个明显地占用了


885
00:29:30,056 --> 00:29:33,596
我的 App 正在使用的


886
00:29:33,596 --> 00:29:36,436
1GB 多的内存


887
00:29:37,096 --> 00:29:38,766
这就是我在 Xcode 中


888
00:29:38,766 --> 00:29:40,936
处理 Memgraph 的技巧


889
00:29:41,466 --> 00:29:42,436
我接下来要做什么


890
00:29:43,256 --> 00:29:45,106
我刚刚看了这个


891
00:29:45,356 --> 00:29:48,236
关于在 Memgraph 文件中


892
00:29:48,366 --> 00:29:50,646
使用命令行工具的 WWDC 讨论会


893
00:29:51,516 --> 00:29:53,276
让我来试试


894
00:29:53,276 --> 00:29:55,876
能不能找到什么


895
00:29:55,876 --> 00:29:57,236
回想起来


896
00:29:57,236 --> 00:29:59,036
James 提出的第一件事


897
00:29:59,036 --> 00:30:01,636
就是使用 vmmap 的 -summary 参数


898
00:30:02,846 --> 00:30:04,196
所以我来试试


899
00:30:04,386 --> 00:30:06,816
传入 Memgraph 文件


900
00:30:06,886 --> 00:30:10,696
我们来看看这个输出


901
00:30:11,756 --> 00:30:13,016
现在 我应该在这里


902
00:30:13,016 --> 00:30:13,706
寻找什么呢


903
00:30:14,476 --> 00:30:15,716
总的来说


904
00:30:15,716 --> 00:30:16,776
我在寻找非常大的数字


905
00:30:16,776 --> 00:30:17,846
我想弄清楚


906
00:30:17,846 --> 00:30:19,196
是什么在使用这些内存


907
00:30:19,196 --> 00:30:20,946
大的数字意味着更多的内存使用


908
00:30:21,566 --> 00:30:25,876
这里有很多列


909
00:30:25,876 --> 00:30:27,196
有些列比其他列更重要


910
00:30:27,806 --> 00:30:30,166
首先 “VIRTUAL SIZE（虚拟内存大小）”


911
00:30:30,166 --> 00:30:32,226
虚拟意味着不是实际的


912
00:30:32,516 --> 00:30:34,846
我几乎可以忽略这一列


913
00:30:34,916 --> 00:30:36,246
它是 App 所需的内存


914
00:30:36,246 --> 00:30:38,056
但不一定要使用


915
00:30:38,736 --> 00:30:40,356
脏内存听起来像是


916
00:30:40,356 --> 00:30:42,036
我绝对不希望在 App 里存在的东西


917
00:30:42,546 --> 00:30:44,466
我希望我的 App 是干净的


918
00:30:44,466 --> 00:30:45,896
而不是脏的


919
00:30:45,896 --> 00:30:46,916
所以我想要这个数字尽量小


920
00:30:47,356 --> 00:30:48,416
然后交换内存


921
00:30:48,446 --> 00:30:49,456
因为我们谈的是 iOS 


922
00:30:49,456 --> 00:30:52,316
所以指的是压缩内存


923
00:30:52,316 --> 00:30:55,156
正如 Kyle 和 James 之前提到的


924
00:30:55,236 --> 00:30:57,386
操作系统凭借


925
00:30:57,386 --> 00:30:59,606
脏内存大小


926
00:30:59,606 --> 00:31:00,816
加上压缩内存大小的总和


927
00:31:00,816 --> 00:31:02,586
来确定我的 App 实际


928
00:31:02,586 --> 00:31:03,726
实际使用了多少内存


929
00:31:04,266 --> 00:31:05,516
所以这就是我想要


930
00:31:05,516 --> 00:31:06,796
关注的两列


931
00:31:06,796 --> 00:31:08,596
我们再来看一些较大的数字


932
00:31:08,596 --> 00:31:11,636
我马上就看到了 “CG image” 非常显眼


933
00:31:11,636 --> 00:31:13,996
它占用了非常多的


934
00:31:13,996 --> 00:31:15,206
脏内存和交换内存


935
00:31:15,256 --> 00:31:16,906
这是一个危险信号


936
00:31:16,956 --> 00:31:17,846
让我们继续观察


937
00:31:18,496 --> 00:31:21,616
我可以看到


938
00:31:21,616 --> 00:31:23,676
“IOSurface” 占用了很多的 脏内存


939
00:31:23,676 --> 00:31:24,686
但不占用交换内存


940
00:31:25,156 --> 00:31:29,876
“MALLOC_LARGE” 占用了很多脏内存


941
00:31:30,146 --> 00:31:31,256
但占用较少的交换内存


942
00:31:31,256 --> 00:31:33,396
之后就没有


943
00:31:33,396 --> 00:31:35,056
这么大的数字了


944
00:31:35,576 --> 00:31:37,696
基于我在这里看到的


945
00:31:37,696 --> 00:31:39,036
我认为我应该集中处理


946
00:31:39,036 --> 00:31:42,376
CG image 的虚拟内存区域


947
00:31:43,096 --> 00:31:44,606
让我们把它复制下来


948
00:31:45,586 --> 00:31:47,426
下一步该是什么呢


949
00:31:48,096 --> 00:31:50,266
我们想要了解更多


950
00:31:50,266 --> 00:31:52,326
关于虚拟内存的信息


951
00:31:52,326 --> 00:31:53,986
所以 vmmap 似乎还是我们要用的工具


952
00:31:54,636 --> 00:31:55,616
这次我将不再


953
00:31:55,616 --> 00:31:57,216
使用 -summary 参数


954
00:31:57,216 --> 00:32:00,376
而是传递我的 Memgraph 文件


955
00:32:01,266 --> 00:32:02,806
但我只关心


956
00:32:02,896 --> 00:32:04,126
“CG image” 的内存


957
00:32:04,336 --> 00:32:05,936
并不关心 vmmap


958
00:32:05,936 --> 00:32:09,186
会告诉我的其他


959
00:32:09,186 --> 00:32:10,516
虚拟内存区域


960
00:32:10,516 --> 00:32:12,026
所以我应该使用 “grep”


961
00:32:12,026 --> 00:32:15,876
只向我展示


962
00:32:15,906 --> 00:32:17,736
关于 “CG image” 的行


963
00:32:18,016 --> 00:32:19,116
让我们看看会发生什么


964
00:32:20,016 --> 00:32:21,336
现在 我有三行信息


965
00:32:21,646 --> 00:32:25,096
我可以看到 有两个虚拟内存区域


966
00:32:25,426 --> 00:32:26,646
在那里我可以看到


967
00:32:26,646 --> 00:32:28,576
它们的起始地址和终止地址


968
00:32:28,906 --> 00:32:30,416
然后我可以看到


969
00:32:30,416 --> 00:32:31,636
和之前相同的列


970
00:32:31,636 --> 00:32:34,006
分别是虚拟内存 常驻内存


971
00:32:34,516 --> 00:32:36,066
脏内存和压缩内存


972
00:32:36,686 --> 00:32:37,736
这里显示的最后一行


973
00:32:37,736 --> 00:32:39,586
是总结行


974
00:32:40,536 --> 00:32:43,666
也就是和上面一样的数据


975
00:32:44,506 --> 00:32:45,966
看看这两个区域


976
00:32:45,966 --> 00:32:47,616
我有一个很小的区域


977
00:32:47,696 --> 00:32:49,026
和一个很大的区域


978
00:32:49,416 --> 00:32:50,986
我显然更想了解


979
00:32:50,986 --> 00:32:53,706
这个大一点的区域


980
00:32:53,906 --> 00:32:55,876
那么我怎样才能找到


981
00:32:55,876 --> 00:32:58,286
更多关于这个虚拟内存区域的信息呢


982
00:32:58,936 --> 00:33:00,366
我查看了


983
00:33:00,366 --> 00:33:02,286
vmmap 的文档


984
00:33:02,286 --> 00:33:03,746
然后注意到一个 -verbose 参数


985
00:33:03,746 --> 00:33:05,786
顾名思义


986
00:33:05,786 --> 00:33:08,506
它会输出更多的信息


987
00:33:08,806 --> 00:33:10,446
我想知道它能告诉我什么


988
00:33:11,486 --> 00:33:12,676
让我们继续


989
00:33:12,706 --> 00:33:16,186
传入 -verbose 和 Memgraph 文件


990
00:33:17,536 --> 00:33:21,266
同样 我只关心 “CG image” 区域


991
00:33:22,306 --> 00:33:24,226
所以我用 “grep”


992
00:33:24,226 --> 00:33:25,946
来进行过滤


993
00:33:26,886 --> 00:33:28,396
现在我看到了


994
00:33:28,396 --> 00:33:29,616
更多的区域


995
00:33:30,156 --> 00:33:31,116
为什么会这样


996
00:33:31,826 --> 00:33:33,576
默认情况下 


997
00:33:33,576 --> 00:33:35,166
如果 vmmap 找到连续的区域


998
00:33:35,256 --> 00:33:37,686
它会把它们


999
00:33:37,686 --> 00:33:38,466
合并在一起


1000
00:33:38,856 --> 00:33:39,896
实际上


1001
00:33:39,896 --> 00:33:41,276
如果你从第二行开始看


1002
00:33:41,276 --> 00:33:43,346
这个区域的终止地址


1003
00:33:43,346 --> 00:33:44,596
和这个区域的起始地址


1004
00:33:44,596 --> 00:33:46,106
是一样的


1005
00:33:46,426 --> 00:33:48,496
下面也一样


1006
00:33:48,966 --> 00:33:51,076
因此 vmmap 在默认情况下


1007
00:33:51,076 --> 00:33:52,426
将其折叠成一个区域


1008
00:33:52,886 --> 00:33:54,086
但是看看这里的细节


1009
00:33:54,086 --> 00:33:54,976
却能发现一些


1010
00:33:54,976 --> 00:33:55,776
不同之处


1011
00:33:55,836 --> 00:33:57,746
特别是其中一些区域


1012
00:33:57,746 --> 00:34:00,826
使用了更多的 脏内存


1013
00:34:00,826 --> 00:34:02,016
而另一些使用了更多的压缩内存


1014
00:34:02,016 --> 00:34:04,426
这就会帮助我找到


1015
00:34:04,426 --> 00:34:06,126
应该关注的地方


1016
00:34:06,126 --> 00:34:07,626
但这里我要用


1017
00:34:07,626 --> 00:34:08,786
另一种策略


1018
00:34:09,216 --> 00:34:10,775
我知道 操作系统中


1019
00:34:10,775 --> 00:34:14,266
虽然不一定 但一般来说


1020
00:34:14,266 --> 00:34:17,076
虚拟内存区域创建得越晚


1021
00:34:17,166 --> 00:34:19,696
在 App 生命周期中


1022
00:34:19,846 --> 00:34:21,565
它发生得就越晚


1023
00:34:22,136 --> 00:34:23,466
由于这个 Memgraph 文件


1024
00:34:23,466 --> 00:34:25,576
是在内存使用峰值时获取的


1025
00:34:25,576 --> 00:34:27,596
所以很有可能


1026
00:34:27,666 --> 00:34:29,775
这些后面的区域


1027
00:34:29,896 --> 00:34:31,775
与导致峰值的原因更有关联


1028
00:34:32,426 --> 00:34:33,686
所以我不想寻找


1029
00:34:33,686 --> 00:34:35,295
最大的 脏内存


1030
00:34:35,295 --> 00:34:36,565
和压缩内存数字


1031
00:34:36,565 --> 00:34:38,056
而是要从底部这里开始


1032
00:34:38,676 --> 00:34:40,666
我要获取最后一个区域


1033
00:34:40,666 --> 00:34:42,406
的起始地址


1034
00:34:43,166 --> 00:34:44,786
我该怎么做呢


1035
00:34:45,366 --> 00:34:47,755
James 提到的一个工具是 heap


1036
00:34:47,755 --> 00:34:50,815
但它作用于堆上的对象


1037
00:34:50,815 --> 00:34:51,856
而我正在处理一个


1038
00:34:51,856 --> 00:34:53,196
虚拟内存区域


1039
00:34:53,196 --> 00:34:56,366
所以它并不适用


1040
00:34:56,366 --> 00:34:58,436
还有 leaks 工具


1041
00:34:58,436 --> 00:34:59,516
但是我这里并没有泄漏


1042
00:34:59,516 --> 00:35:00,466
我已经从 Memgraph 中


1043
00:35:00,466 --> 00:35:01,796
知道了这里没有泄漏


1044
00:35:02,096 --> 00:35:03,346
所以它看起来不像是


1045
00:35:03,346 --> 00:35:04,276
我可以使用的工具


1046
00:35:04,696 --> 00:35:06,636
但是我查看了


1047
00:35:06,776 --> 00:35:09,896
关于 leaks 的帮助信息


1048
00:35:09,896 --> 00:35:11,466
发现 leaks 可以做很多事情


1049
00:35:11,466 --> 00:35:14,016
包括告诉我


1050
00:35:14,016 --> 00:35:16,296
哪些对堆上的对象


1051
00:35:16,296 --> 00:35:18,736
或虚拟内存区域有引用


1052
00:35:19,226 --> 00:35:20,236
我们来看看


1053
00:35:20,236 --> 00:35:21,016
它会告诉我们什么


1054
00:35:21,696 --> 00:35:23,556
我将使用 leaks


1055
00:35:23,556 --> 00:35:25,746
然后传递


1056
00:35:25,806 --> 00:35:27,326
-traceTree 参数


1057
00:35:27,986 --> 00:35:29,146
它的作用是


1058
00:35:29,146 --> 00:35:32,056
给了我一个树形视图


1059
00:35:32,056 --> 00:35:33,556
可以涵盖所有


1060
00:35:33,556 --> 00:35:34,826
与我要传入的地址有关的东西


1061
00:35:34,826 --> 00:35:36,916
在这个例子中 我传入的是


1062
00:35:36,916 --> 00:35:39,786
虚拟内存区域的


1063
00:35:39,786 --> 00:35:41,886
起始地址


1064
00:35:42,446 --> 00:35:44,006
最后我们提供


1065
00:35:44,006 --> 00:35:44,956
这个 Memgraph 文件


1066
00:35:45,906 --> 00:35:47,276
它会是什么样子呢


1067
00:35:47,466 --> 00:35:49,526
这里我们能看到


1068
00:35:49,636 --> 00:35:50,936
所有引用的树


1069
00:35:50,936 --> 00:35:52,136
如果我们向上滚动到顶部


1070
00:35:53,196 --> 00:35:55,076
在这里 我可以看到


1071
00:35:55,076 --> 00:35:56,746
这是我的虚拟内存区域


1072
00:35:56,746 --> 00:35:58,716
这是我的 “CG image” 区域


1073
00:35:58,716 --> 00:35:59,856
然后我可以看到


1074
00:35:59,856 --> 00:36:02,346
这个树视图


1075
00:36:02,346 --> 00:36:03,336
包含了所有具有引用的东西


1076
00:36:03,336 --> 00:36:04,676
以及引用它们的东西


1077
00:36:04,676 --> 00:36:06,006
以及引用这些东西的东西


1078
00:36:06,006 --> 00:36:06,616
等等等等


1079
00:36:06,616 --> 00:36:08,646
如果我们回到 Xcode


1080
00:36:08,646 --> 00:36:11,026
我们实际上过滤了


1081
00:36:11,026 --> 00:36:14,066
相同的地址


1082
00:36:14,066 --> 00:36:16,766
我来看看这个对象


1083
00:36:16,766 --> 00:36:18,406
这个树视图和我从 leaks 中


1084
00:36:18,406 --> 00:36:19,246
看到的一样


1085
00:36:19,436 --> 00:36:20,626
如果我想的话


1086
00:36:20,626 --> 00:36:22,146
我可以沿着树走下去


1087
00:36:22,146 --> 00:36:23,876
并展开每一个节点


1088
00:36:23,876 --> 00:36:25,436
看看每个节点的细节


1089
00:36:25,436 --> 00:36:26,946
但是这需要一段时间


1090
00:36:26,946 --> 00:36:28,306
而且有点乏味


1091
00:36:28,386 --> 00:36:29,986
leaks 的输出的优点是


1092
00:36:29,986 --> 00:36:32,566
我不仅可以


1093
00:36:32,566 --> 00:36:33,946
快速浏览它


1094
00:36:33,946 --> 00:36:36,296
还可以随意搜索或筛选


1095
00:36:36,296 --> 00:36:37,736
或者我可以把它放进


1096
00:36:37,736 --> 00:36:39,676
一个 Bug 报告或电子邮件中


1097
00:36:39,676 --> 00:36:40,786
然而我却不能对 Xcode 中的图形视图


1098
00:36:40,786 --> 00:36:42,786
进行上述的操作


1099
00:36:43,686 --> 00:36:44,996
那么在这个 leaks 的输出中


1100
00:36:44,996 --> 00:36:45,536
我要找什么呢


1101
00:36:46,116 --> 00:36:48,286
理想情况下


1102
00:36:48,286 --> 00:36:49,876
我会找到一个


1103
00:36:49,876 --> 00:36:51,326
我负责的类


1104
00:36:51,326 --> 00:36:52,146
一个来自我的 App 的类


1105
00:36:52,306 --> 00:36:54,066
我之前看过这个


1106
00:36:54,066 --> 00:36:55,106
我知道这里


1107
00:36:55,106 --> 00:36:56,846
没有我的类


1108
00:36:56,846 --> 00:36:57,976
那么我还能找到什么呢


1109
00:36:58,376 --> 00:37:00,236
我正在创建的类


1110
00:37:00,236 --> 00:37:01,566
比如一个框架类


1111
00:37:01,566 --> 00:37:02,766
它也许是以我的名义创建的


1112
00:37:02,766 --> 00:37:04,156
也可能是我


1113
00:37:04,206 --> 00:37:05,186
直接创建的


1114
00:37:05,596 --> 00:37:08,276
我知道我的 App 有 UIViews


1115
00:37:08,276 --> 00:37:09,156
它有 UIImages


1116
00:37:09,156 --> 00:37:11,966
我可以用这些 Core Image 类


1117
00:37:12,156 --> 00:37:13,926
来进行过滤


1118
00:37:13,926 --> 00:37:15,516
我们继续看这里


1119
00:37:15,606 --> 00:37:18,866
我用的是一个非常复杂的 


1120
00:37:18,866 --> 00:37:20,716
叫做 “My Eyeballs” 的调试工具


1121
00:37:21,566 --> 00:37:23,576
我们继续寻找


1122
00:37:23,786 --> 00:37:29,346
我看看能不能找到我想要的


1123
00:37:29,836 --> 00:37:32,576
这是一个很大的终端输出


1124
00:37:32,826 --> 00:37:34,356
所以让人更加困惑


1125
00:37:35,116 --> 00:37:36,686
举个例子


1126
00:37:36,686 --> 00:37:38,376
这里有一个字体引用


1127
00:37:38,376 --> 00:37:39,546
我知道我的 App


1128
00:37:39,546 --> 00:37:42,196
使用字体


1129
00:37:42,196 --> 00:37:44,706
但是字体并不会导致


1130
00:37:44,706 --> 00:37:46,156
很多的内存使用


1131
00:37:46,156 --> 00:37:47,886
所以它没有帮助


1132
00:37:47,886 --> 00:37:49,126
我们再往下看


1133
00:37:49,126 --> 00:37:51,476
我可以看到有很多


1134
00:37:51,476 --> 00:37:54,976
这样的 CI 类


1135
00:37:54,976 --> 00:37:56,346
它们是 Core Image 滤镜


1136
00:37:56,346 --> 00:37:57,666
或者是 Core Image 


1137
00:37:57,666 --> 00:37:58,926
在我的 App 中


1138
00:37:58,926 --> 00:38:00,346
起滤镜作用的东西


1139
00:38:00,746 --> 00:38:02,076
它也许也是我该


1140
00:38:02,076 --> 00:38:04,036
进一步研究的东西


1141
00:38:04,036 --> 00:38:05,406
我已经做了


1142
00:38:05,406 --> 00:38:08,906
但没有发现任何有用的东西


1143
00:38:09,296 --> 00:38:11,286
我无法进一步研究


1144
00:38:11,286 --> 00:38:13,006
leaks 的输出


1145
00:38:13,216 --> 00:38:15,566
这很不幸


1146
00:38:15,666 --> 00:38:17,976
接下来我该做什么呢


1147
00:38:18,826 --> 00:38:21,716
幸运的是


1148
00:38:23,106 --> 00:38:25,536
James 在捕获


1149
00:38:25,536 --> 00:38:26,456
这个 Memgraph 时


1150
00:38:26,456 --> 00:38:29,736
打开了配置内存的回溯记录


1151
00:38:29,736 --> 00:38:31,366
这意味着我可以使用


1152
00:38:31,366 --> 00:38:33,336
他谈到的另一个工具


1153
00:38:33,336 --> 00:38:36,896
来查看对象的创建回溯


1154
00:38:36,896 --> 00:38:38,566
我将使用 malloc_history


1155
00:38:40,096 --> 00:38:42,206
这一次 我先传入


1156
00:38:42,206 --> 00:38:43,866
Memgraph 文件


1157
00:38:44,136 --> 00:38:48,836
然后再传入这个从帮助文档中获知的


1158
00:38:48,836 --> 00:38:50,256
-fullStacks 参数


1159
00:38:51,046 --> 00:38:52,546
它的功能就是


1160
00:38:52,546 --> 00:38:55,216
使每一帧都在它自己的行上显示


1161
00:38:55,216 --> 00:38:56,646
这样让人更容易阅读


1162
00:38:57,096 --> 00:38:58,366
然后我将传递


1163
00:38:58,556 --> 00:39:00,156
虚拟内存区域的


1164
00:39:00,156 --> 00:39:01,096
起始内存地址


1165
00:39:01,806 --> 00:39:02,856
让我们看看是什么样子


1166
00:39:04,036 --> 00:39:05,386
实际上这并不是一个


1167
00:39:05,386 --> 00:39:06,566
很大的回溯


1168
00:39:06,566 --> 00:39:09,066
我可以看到我的代码


1169
00:39:09,066 --> 00:39:10,126
出现在这里的几行


1170
00:39:10,576 --> 00:39:12,676
第 6 行到第 9 行


1171
00:39:12,676 --> 00:39:14,106
实际上来自我的 App 代码


1172
00:39:14,106 --> 00:39:16,066
我可以在第 6 行看到


1173
00:39:16,066 --> 00:39:19,046
NoirFilter.apply() 函数


1174
00:39:19,046 --> 00:39:21,186
负责创建


1175
00:39:21,186 --> 00:39:24,486
这个特定的虚拟内存区域


1176
00:39:24,996 --> 00:39:27,626
这是一个很好的证据


1177
00:39:27,626 --> 00:39:28,826
展示了我如何在 App 中


1178
00:39:28,826 --> 00:39:31,216
找到造成这些内存使用的东西


1179
00:39:31,746 --> 00:39:34,806
如果我们回到 Memgraph 文件


1180
00:39:34,806 --> 00:39:36,586
就可以发现这和 Xcode 中


1181
00:39:36,586 --> 00:39:38,626
出现的回溯是一样的


1182
00:39:39,186 --> 00:39:40,446
你可以看到这里


1183
00:39:40,446 --> 00:39:42,526
也是 NoirFilter.apply() 方法


1184
00:39:42,886 --> 00:39:44,046
我们没有像


1185
00:39:44,046 --> 00:39:45,646
通常在回溯视图中看到的那样


1186
00:39:45,646 --> 00:39:47,176
得到很好的高亮显示


1187
00:39:47,176 --> 00:39:48,796
因为我们没有调试一个活动进程


1188
00:39:48,796 --> 00:39:50,116
我们正在加载一个 Memgraph 文件


1189
00:39:50,526 --> 00:39:51,686
但是你可以看到它的输出


1190
00:39:51,686 --> 00:39:52,796
和我们从 malloc_history 中得到的输出


1191
00:39:52,796 --> 00:39:53,566
是完全一样的


1192
00:39:53,926 --> 00:39:57,786
事实上


1193
00:39:57,986 --> 00:39:59,616
为了进一步确认


1194
00:39:59,616 --> 00:40:02,036
我需要查看


1195
00:40:02,136 --> 00:40:05,956
“CG image” 虚拟内存区域的完整列表


1196
00:40:05,956 --> 00:40:09,066
接下来我选取了


1197
00:40:09,066 --> 00:40:10,156
倒数第二个


1198
00:40:10,156 --> 00:40:11,916
我们来看看


1199
00:40:11,916 --> 00:40:13,176
这个区域的回溯


1200
00:40:15,146 --> 00:40:17,326
结果是相同的回溯


1201
00:40:17,526 --> 00:40:18,896
同样的代码路径


1202
00:40:18,896 --> 00:40:20,496
也指向这个区域


1203
00:40:20,966 --> 00:40:23,486
如果继续观察


1204
00:40:23,486 --> 00:40:24,976
其中的几个区域


1205
00:40:24,976 --> 00:40:26,276
实际上仍使用了相同的回溯


1206
00:40:26,766 --> 00:40:27,886
这样我就明白了


1207
00:40:27,886 --> 00:40:30,086
在我的 App 中


1208
00:40:30,086 --> 00:40:32,326
是什么创建了这些


1209
00:40:32,326 --> 00:40:33,636
占用了 App 中


1210
00:40:33,636 --> 00:40:34,896
大量内存的


1211
00:40:34,896 --> 00:40:35,776
虚拟内存区域


1212
00:40:36,706 --> 00:40:37,836
那么我们能做些什么呢


1213
00:40:38,636 --> 00:40:40,186
让我们回到 Xcode


1214
00:40:40,186 --> 00:40:42,276
我现在可以关闭 Memgraph 文件


1215
00:40:43,396 --> 00:40:46,196
我要做的第一件事是


1216
00:40:46,196 --> 00:40:47,626
看看这里的代码


1217
00:40:48,406 --> 00:40:52,536
如果看看与我的滤镜相关的代码


1218
00:40:52,536 --> 00:40:54,436
我可以看到这里是 apply() 函数


1219
00:40:54,436 --> 00:40:55,926
我可以马上看到


1220
00:40:55,926 --> 00:40:57,026
一些东西跳出来


1221
00:40:57,026 --> 00:40:58,776
它们是我正在使用的


1222
00:40:58,776 --> 00:41:02,886
UIGraphicsBeginImageContextWithOptions


1223
00:41:02,886 --> 00:41:04,866
以及 UIGraphicsEndImageContext


1224
00:41:04,866 --> 00:41:06,086
我记得 Kyle 说过


1225
00:41:06,086 --> 00:41:06,846
你们不应该使用它


1226
00:41:06,846 --> 00:41:08,986
在那些情况下有更好的 API 可以使用


1227
00:41:09,346 --> 00:41:10,946
这是我肯定想要


1228
00:41:10,946 --> 00:41:12,386
再次讨论的内容


1229
00:41:12,386 --> 00:41:13,606
但我首先需要的


1230
00:41:13,606 --> 00:41:14,576
是某种基线


1231
00:41:14,576 --> 00:41:15,716
我需要知道


1232
00:41:15,716 --> 00:41:17,736
我的 App 使用了多少内存


1233
00:41:17,736 --> 00:41:18,886
这样我就可以确保我的更改


1234
00:41:18,886 --> 00:41:19,826
能让结果变得不同


1235
00:41:20,496 --> 00:41:21,726
我要运行


1236
00:41:21,726 --> 00:41:24,566
我的 App


1237
00:41:24,566 --> 00:41:26,786
然后找到调试导航器


1238
00:41:26,786 --> 00:41:28,456
查看内存报告


1239
00:41:28,626 --> 00:41:30,896
现在 我可以看到我的 App


1240
00:41:30,896 --> 00:41:32,566
在运行时使用的内存


1241
00:41:33,366 --> 00:41:35,946
我真的很喜欢这个


1242
00:41:35,946 --> 00:41:37,266
土星北极的图像


1243
00:41:37,836 --> 00:41:39,766
它是一个奇怪的六边形


1244
00:41:39,836 --> 00:41:41,346
炫酷的同时


1245
00:41:41,346 --> 00:41:42,356
又有点古怪


1246
00:41:42,816 --> 00:41:44,326
我们来看看这个


1247
00:41:44,326 --> 00:41:45,996
应用这个滤镜


1248
00:41:45,996 --> 00:41:46,716
然后看看会得到什么


1249
00:41:47,706 --> 00:41:51,336
1GB 3GB 4GB


1250
00:41:51,336 --> 00:41:52,576
6GB 7GB


1251
00:41:53,156 --> 00:41:54,706
这可不太好


1252
00:41:54,856 --> 00:41:58,636
不过可以


1253
00:41:58,636 --> 00:41:59,846
很好地告诉我们


1254
00:41:59,946 --> 00:42:02,006
它根本不会在设备上流畅运行


1255
00:42:02,336 --> 00:42:03,186
所以当你在模拟器中运行时


1256
00:42:03,186 --> 00:42:04,586
你必须记住


1257
00:42:04,586 --> 00:42:06,036
它对于调试和


1258
00:42:06,036 --> 00:42:07,226
测试变更很有用


1259
00:42:07,226 --> 00:42:08,706
但是你也需要在设备上


1260
00:42:08,706 --> 00:42:09,796
验证所有的东西


1261
00:42:09,796 --> 00:42:11,206
但同时 另一件好事是


1262
00:42:11,206 --> 00:42:13,976
模拟器永远不会耗尽内存


1263
00:42:14,276 --> 00:42:15,616
如果我遇到了 App 在设备上


1264
00:42:15,616 --> 00:42:16,736
被关闭的情况


1265
00:42:16,736 --> 00:42:18,876
可以在模拟器中试试


1266
00:42:19,106 --> 00:42:20,296
我可以等待一个


1267
00:42:20,296 --> 00:42:21,836
非常大的分配


1268
00:42:21,836 --> 00:42:23,476
而不会被关闭


1269
00:42:23,476 --> 00:42:24,946
然后从那里进行调查


1270
00:42:25,666 --> 00:42:26,716
我想指出的一点是


1271
00:42:26,716 --> 00:42:28,786
我们其实给你们看了


1272
00:42:28,786 --> 00:42:31,336
这里标志的内存峰值


1273
00:42:31,336 --> 00:42:34,406
在这个例子中 我最多使用了 7.7GB


1274
00:42:35,226 --> 00:42:35,816
这很糟糕


1275
00:42:36,636 --> 00:42:39,126
我们来看看能做些什么


1276
00:42:39,226 --> 00:42:43,706
回到我的 apply() 函数


1277
00:42:44,326 --> 00:42:46,386
现在


1278
00:42:46,386 --> 00:42:47,026
我想使用这个


1279
00:42:47,026 --> 00:42:48,396
beginImageContextWithOptions


1280
00:42:48,396 --> 00:42:50,086
但是回想一下 Kyle 说过的


1281
00:42:50,086 --> 00:42:52,046
当你处理图像时


1282
00:42:52,046 --> 00:42:54,296
内存使用中


1283
00:42:54,296 --> 00:42:56,236
最重要的是什么


1284
00:42:56,696 --> 00:42:58,986
是图像的尺寸


1285
00:42:58,986 --> 00:43:00,446
让我们看看它是什么样子


1286
00:43:00,446 --> 00:43:03,056
我要再次


1287
00:43:03,056 --> 00:43:04,176
使用这个滤镜


1288
00:43:04,536 --> 00:43:07,896
我在调试器中停止时


1289
00:43:07,896 --> 00:43:11,936
就可以看到


1290
00:43:11,936 --> 00:43:14,476
这个图像的尺寸


1291
00:43:14,546 --> 00:43:15,556
在我按回车


1292
00:43:15,836 --> 00:43:19,516
我要先喝一小口水


1293
00:43:19,586 --> 00:43:22,836
我其实并不想喝水


1294
00:43:24,646 --> 00:43:27,466
它是 15000*13000


1295
00:43:27,986 --> 00:43:29,876
我检查过文档


1296
00:43:29,956 --> 00:43:32,196
在 UIImage 上


1297
00:43:32,476 --> 00:43:33,766
那是点（pt） 不是像素（px）


1298
00:43:33,766 --> 00:43:36,656
如果这是 2X 设备


1299
00:43:36,656 --> 00:43:38,896
或 3X 设备


1300
00:43:38,896 --> 00:43:40,906
你必须把它乘以一个很大的数字


1301
00:43:41,446 --> 00:43:43,026
Kyle 会很生气


1302
00:43:43,026 --> 00:43:44,846
因为一张图片就占用了 10MB


1303
00:43:45,276 --> 00:43:47,146
没人告诉他这件事


1304
00:43:47,986 --> 00:43:49,816
为了证实这一点


1305
00:43:49,816 --> 00:43:51,486
我想尝试一下


1306
00:43:51,486 --> 00:43:55,396
我要将 15000 乘以 13000


1307
00:43:56,126 --> 00:44:00,786
iPhone X 是一个 3X 设备


1308
00:44:00,786 --> 00:44:02,766
所以是 3 倍的宽度


1309
00:44:02,766 --> 00:44:06,436
乘以 3 倍的高度


1310
00:44:06,436 --> 00:44:09,696
再乘以 4 字节每像素


1311
00:44:10,506 --> 00:44:13,706
这个数字看起来很熟悉


1312
00:44:15,876 --> 00:44:17,786
所以我很确定


1313
00:44:17,786 --> 00:44:19,306
我清楚地知道到底是什么


1314
00:44:19,306 --> 00:44:20,886
使用了 7.5GB 的内存


1315
00:44:20,886 --> 00:44:24,386
并不一定是


1316
00:44:24,386 --> 00:44:25,966
我的 beginImageContext


1317
00:44:25,966 --> 00:44:27,376
而是图像的尺寸


1318
00:44:27,746 --> 00:44:29,186
没有理由需要


1319
00:44:29,186 --> 00:44:30,506
这么大的图像


1320
00:44:30,966 --> 00:44:32,146
我要做的是把它缩小成


1321
00:44:32,146 --> 00:44:33,826
和我的视图


1322
00:44:33,826 --> 00:44:34,666
相同的尺寸


1323
00:44:34,666 --> 00:44:36,086
这样 它就会占用


1324
00:44:36,086 --> 00:44:36,826
更少的内存


1325
00:44:37,526 --> 00:44:38,766
那么 我要回到


1326
00:44:38,766 --> 00:44:40,026
上面的图像加载代码


1327
00:44:40,136 --> 00:44:41,216
实际上 在我这么做之前


1328
00:44:41,216 --> 00:44:42,276
我想先禁用这个断点


1329
00:44:42,276 --> 00:44:45,146
让我们看看


1330
00:44:45,146 --> 00:44:46,286
它是做什么的


1331
00:44:46,286 --> 00:44:47,666
很简单


1332
00:44:47,666 --> 00:44:49,016
它从一个 Bundle 中获取 URL


1333
00:44:49,016 --> 00:44:51,176
它从那个 URL 中


1334
00:44:51,176 --> 00:44:52,796
加载一些数据


1335
00:44:52,796 --> 00:44:55,166
并将其加载到 UIImage 中


1336
00:44:55,346 --> 00:44:56,856
然后传递给滤镜


1337
00:44:57,406 --> 00:44:58,906
我想做的是


1338
00:44:58,906 --> 00:45:00,276
在我把它发送到滤镜之前


1339
00:45:00,276 --> 00:45:01,746
我想缩小这个图像


1340
00:45:02,096 --> 00:45:04,226
然而 我还记得 Kyle 说的


1341
00:45:04,536 --> 00:45:05,656
我不应该在 UIImage 上进行缩放


1342
00:45:05,656 --> 00:45:07,406
因为它仍然会


1343
00:45:07,406 --> 00:45:08,816
把整个图像


1344
00:45:08,816 --> 00:45:10,266
加载到内存中


1345
00:45:10,266 --> 00:45:11,396
这是我要避免的


1346
00:45:11,906 --> 00:45:13,876
把这个函数


1347
00:45:13,986 --> 00:45:15,826
折叠起来


1348
00:45:16,106 --> 00:45:17,556
我要用 Kyle 建议的代码


1349
00:45:17,676 --> 00:45:19,946
来替换它


1350
00:45:20,496 --> 00:45:23,386
好的 我们来看看


1351
00:45:23,386 --> 00:45:24,656
这段代码在做什么


1352
00:45:25,886 --> 00:45:28,696
这里是一样的


1353
00:45:28,996 --> 00:45:31,286
我们从 Bundle 中获取图像


1354
00:45:31,286 --> 00:45:33,206
但是这一次


1355
00:45:33,206 --> 00:45:35,376
我得稍微调宽一点


1356
00:45:35,746 --> 00:45:38,066
我调用了 CGImageSourceCreateWithURL


1357
00:45:38,066 --> 00:45:39,796
来获取对图像的引用


1358
00:45:39,796 --> 00:45:41,016
然后将其传递给


1359
00:45:41,096 --> 00:45:43,816
CGImageSourceCreateThumbnailAtIndex


1360
00:45:44,156 --> 00:45:45,906
现在 我可以将图像


1361
00:45:45,906 --> 00:45:47,526
缩放到我想要的大小


1362
00:45:47,526 --> 00:45:49,026
而不需要将整个内容载入内存


1363
00:45:49,656 --> 00:45:51,366
让我们试一试


1364
00:45:51,366 --> 00:45:52,506
看看会不会有什么不同


1365
00:45:52,626 --> 00:45:53,506
我将重新构建


1366
00:45:53,506 --> 00:45:56,866
然后等待它


1367
00:45:56,866 --> 00:45:58,176
在 App 上启动


1368
00:45:59,486 --> 00:46:02,356
重新生成中


1369
00:46:02,356 --> 00:46:05,636
哦 有一个警告


1370
00:46:06,216 --> 00:46:09,566
我需要再调整一下这个


1371
00:46:10,996 --> 00:46:11,676
再来看一下


1372
00:46:12,786 --> 00:46:14,226
好了 正在构建


1373
00:46:15,256 --> 00:46:16,466
构建 构建 构建


1374
00:46:17,236 --> 00:46:19,576
好的 正在启动 没有问题


1375
00:46:19,636 --> 00:46:20,406
现在 让我们来看看


1376
00:46:20,406 --> 00:46:21,526
内存报告


1377
00:46:22,886 --> 00:46:25,646
让我们回到


1378
00:46:25,686 --> 00:46:27,036
我一直很喜欢的


1379
00:46:27,036 --> 00:46:28,556
土星北极的图像


1380
00:46:29,926 --> 00:46:32,036
我们应用这个图像


1381
00:46:32,036 --> 00:46:33,496
看看会占用多少内存


1382
00:46:33,496 --> 00:46:35,936
现在是 75


1383
00:46:35,936 --> 00:46:36,456
93MB


1384
00:46:36,966 --> 00:46:38,786
在这里 我们的内存峰值


1385
00:46:38,786 --> 00:46:41,046
是 93MB


1386
00:46:41,626 --> 00:46:42,866
明显地改善


1387
00:46:44,946 --> 00:46:46,816
[ 掌声 ] 这要比


1388
00:46:46,816 --> 00:46:48,126
几乎百分百被关闭的


1389
00:46:48,176 --> 00:46:50,886
7.5GB 的内存占用要好得多


1390
00:46:51,516 --> 00:46:53,076
但现在 我记得有件事


1391
00:46:53,076 --> 00:46:55,126
我想回去


1392
00:46:55,126 --> 00:46:58,186
先停止运行


1393
00:46:58,186 --> 00:46:59,806
我还是想回到


1394
00:46:59,806 --> 00:47:03,556
我的 filter() 方法


1395
00:47:03,556 --> 00:47:05,456
改变这个 UIBeginImageContext 代码


1396
00:47:05,456 --> 00:47:06,746
然后按照 Kyle 的建议去做


1397
00:47:06,826 --> 00:47:08,206
所以我要删除这段代码


1398
00:47:08,746 --> 00:47:12,986
然后添加新的滤镜


1399
00:47:14,456 --> 00:47:16,126
在这里


1400
00:47:16,126 --> 00:47:18,136
我要创建一个


1401
00:47:18,136 --> 00:47:19,076
UIGraphicsImageRenderer


1402
00:47:19,356 --> 00:47:21,946
我要在这个渲染器中


1403
00:47:21,946 --> 00:47:24,136
使用 CIFilter


1404
00:47:24,786 --> 00:47:26,506
来应用这个滤镜


1405
00:47:26,956 --> 00:47:28,936
让我们运行这段代码


1406
00:47:29,306 --> 00:47:30,866
希望它可以成功构建


1407
00:47:30,866 --> 00:47:32,076
然后看看是否会对我的内存使用


1408
00:47:32,076 --> 00:47:33,876
产生影响


1409
00:47:35,316 --> 00:47:37,286
让我们回到调试导航器


1410
00:47:37,286 --> 00:47:39,616
和内存报告中


1411
00:47:40,586 --> 00:47:42,406
再一次


1412
00:47:42,406 --> 00:47:46,516
我们回到土星图像


1413
00:47:46,746 --> 00:47:50,306
然后应用我们的滤镜


1414
00:47:51,076 --> 00:47:51,766
让我们来看看


1415
00:47:51,766 --> 00:47:54,846
这次的内存峰值是多少


1416
00:47:54,846 --> 00:47:55,496
98MB


1417
00:47:56,066 --> 00:47:59,136
这和上次基本是一样的


1418
00:47:59,136 --> 00:48:00,206
但是如果你仔细思考


1419
00:48:00,206 --> 00:48:01,666
这个其实就是我所期望的结果


1420
00:48:02,216 --> 00:48:03,496
在这种情况下


1421
00:48:03,496 --> 00:48:05,346
我的图像仍然是


1422
00:48:05,346 --> 00:48:07,006
每个像素 4 个字节


1423
00:48:07,006 --> 00:48:08,076
所以我不会使用


1424
00:48:08,076 --> 00:48:10,476
这个新方法来节省内存


1425
00:48:10,906 --> 00:48:12,176
然而 如果有一个


1426
00:48:12,176 --> 00:48:13,926
节省内存的机会


1427
00:48:14,406 --> 00:48:17,356
例如 如果操作系统可以判断


1428
00:48:17,356 --> 00:48:20,666
图像可以每像素使用更少


1429
00:48:20,666 --> 00:48:21,866
或更多的字节


1430
00:48:21,866 --> 00:48:23,156
那么系统就可以做出正确的处理


1431
00:48:23,156 --> 00:48:24,206
我就不需要担心了


1432
00:48:24,546 --> 00:48:25,886
因此 在代码经过这些更改后


1433
00:48:25,886 --> 00:48:28,636
即使我没有看到很大的改进


1434
00:48:28,636 --> 00:48:29,486
我也知道它变得更好了


1435
00:48:30,526 --> 00:48:33,246
我还可以做更多


1436
00:48:33,566 --> 00:48:35,956
我想确保当 App 进入后台时


1437
00:48:35,956 --> 00:48:37,686
我们会卸载图像


1438
00:48:37,686 --> 00:48:39,536
而且我们不会在屏幕之外的视图中


1439
00:48:39,536 --> 00:48:41,346
显示任何图像


1440
00:48:41,346 --> 00:48:42,286
我还有很多可以做的


1441
00:48:42,286 --> 00:48:44,026
但是我对这些结果


1442
00:48:44,026 --> 00:48:45,516
已经很满意了


1443
00:48:45,516 --> 00:48:46,896
所以我想把它们送回给 James


1444
00:48:47,156 --> 00:48:48,416
我要抓取一个屏幕快照


1445
00:48:48,416 --> 00:48:50,096
并给 James 添加一点备注


1446
00:48:50,096 --> 00:48:53,236
让他知道


1447
00:48:53,236 --> 00:48:55,716
我对这一切是多么的满意


1448
00:48:56,286 --> 00:48:57,476
我想我们可以


1449
00:48:57,476 --> 00:48:59,466
给他发一个


1450
00:49:01,516 --> 00:49:03,616
星星眼的表情符号


1451
00:49:04,526 --> 00:49:06,166
希望 James 会对这些结果


1452
00:49:06,166 --> 00:49:07,326
感到满意


1453
00:49:07,326 --> 00:49:11,876
现在 我想请回 Kyle


1454
00:49:11,876 --> 00:49:12,816
他会帮我们整理一遍


1455
00:49:13,326 --> 00:49:13,696
谢谢大家


1456
00:49:14,386 --> 00:49:16,386
[ 掌声 ]


1457
00:49:16,756 --> 00:49:17,186
>> 谢谢 Kris


1458
00:49:20,096 --> 00:49:20,526
谢谢 Kris


1459
00:49:21,566 --> 00:49:22,366
太棒了


1460
00:49:22,666 --> 00:49:24,096
只做了一点点工作


1461
00:49:24,326 --> 00:49:30,076
我们就能大大减少内存的使用


1462
00:49:30,786 --> 00:49:34,896
总结起来 内存是有限的


1463
00:49:34,896 --> 00:49:35,356
也是共享的


1464
00:49:36,516 --> 00:49:37,786
我们使用得越多


1465
00:49:37,786 --> 00:49:39,156
系统就为其他 App 分配越少的内存


1466
00:49:39,236 --> 00:49:40,076
我们真的需要做一个好市民


1467
00:49:40,076 --> 00:49:41,786
并注意我们对内存的使用


1468
00:49:41,786 --> 00:49:43,366
只使用我们需要的内存


1469
00:49:46,336 --> 00:49:47,706
在调试时


1470
00:49:47,706 --> 00:49:50,276
Xcode 中的内存报告是至关重要的


1471
00:49:50,636 --> 00:49:51,726
当我们的 App 运行时我们就可以打开它


1472
00:49:51,726 --> 00:49:52,756
因为当我们监视它的时候


1473
00:49:52,756 --> 00:49:54,516
随着调试的进行


1474
00:49:54,516 --> 00:49:57,206
我们能注意到内存使用的消退


1475
00:49:59,076 --> 00:50:01,076
我们要确保 iOS


1476
00:50:01,956 --> 00:50:03,496
可以为我们选择图像格式


1477
00:50:03,746 --> 00:50:06,156
通过使用新的 UIImage 的


1478
00:50:06,156 --> 00:50:08,766
GraphicsRenderer API


1479
00:50:08,766 --> 00:50:10,576
我们可以从 SRGB 到 alpha 8 的转变过程中


1480
00:50:10,846 --> 00:50:11,996
节省 75% 的内存使用


1481
00:50:11,996 --> 00:50:14,596
这对蒙版和文本来说都很重要


1482
00:50:16,376 --> 00:50:18,166
除此之外 我们可以使用 ImageIO


1483
00:50:18,936 --> 00:50:20,446
来对图像进行下采样


1484
00:50:21,176 --> 00:50:22,836
它可以防止过高的内存峰值


1485
00:50:22,836 --> 00:50:24,646
相较于将 UIImage 绘制到


1486
00:50:24,646 --> 00:50:25,836
更小的环境中时


1487
00:50:25,836 --> 00:50:26,776
它也会更快


1488
00:50:27,176 --> 00:50:30,856
最后 我们要卸载


1489
00:50:30,856 --> 00:50:32,706
不在屏幕上的


1490
00:50:32,706 --> 00:50:33,516
大型图像和资源


1491
00:50:33,886 --> 00:50:34,886
使用这些内存是没有意义的


1492
00:50:34,886 --> 00:50:36,836
因为用户看不到它们


1493
00:50:38,166 --> 00:50:39,936
即使经历了所有这些努力


1494
00:50:40,156 --> 00:50:40,896
我们仍然没有完成


1495
00:50:42,006 --> 00:50:44,216
正如我们刚才看到的


1496
00:50:44,326 --> 00:50:45,926
使用 Memgraph 可以帮助我们


1497
00:50:46,346 --> 00:50:47,606
进一步了解发生了什么


1498
00:50:47,606 --> 00:50:48,306
并减少内存占用


1499
00:50:48,686 --> 00:50:49,576
结合 malloc_history


1500
00:50:49,576 --> 00:50:50,906
我们可以深入了解


1501
00:50:50,906 --> 00:50:52,966
内存的去向以及用途


1502
00:50:54,026 --> 00:50:56,046
所以我建议


1503
00:50:56,046 --> 00:50:58,456
大家能在讨论会后打开 malloc_history


1504
00:50:58,456 --> 00:51:00,426
分析你的工具


1505
00:51:00,426 --> 00:51:02,106
然后开始深入研究


1506
00:51:03,256 --> 00:51:04,726
要了解更多的信息


1507
00:51:04,726 --> 00:51:06,816
你们可以查看我们的幻灯片


1508
00:51:07,426 --> 00:51:11,956
除此之外 如果你们还有其他问题的话


1509
00:51:11,956 --> 00:51:13,786
我们稍后会去技术实验室


1510
00:51:15,116 --> 00:51:15,906
谢谢大家 希望你们享受


1511
00:51:15,906 --> 00:51:17,286
WWDC 中的其他讨论会


1512
00:51:18,516 --> 00:51:22,500
[ 掌声 ]

