1
00:00:17,417 --> 00:00:22,856 line:0
（LLVM新特性 演讲409）


2
00:00:27,427 --> 00:00:30,297 line:-2
早上好 欢迎来到
LLVM新特性的演讲


3
00:00:31,265 --> 00:00:33,901 line:-2
我是Jim Grosbach
你友好的尖尖发型的老板街坊


4
00:00:33,967 --> 00:00:38,805 line:-2
今天在我们将深入了解
为大家带来的所有激动人心的


5
00:00:38,872 --> 00:00:41,008 line:-2
新事物的技术细节之前
我先在此给你们讲些


6
00:00:41,074 --> 00:00:44,311 line:-1
关于LLVM的背景知识


7
00:00:45,379 --> 00:00:49,716 line:-1
首先 LLVM不仅仅是编译器


8
00:00:50,217 --> 00:00:53,153 line:-1
它是Clang编译器


9
00:00:53,220 --> 00:00:56,089 line:-1
和我们每天都使用的C族语言的背景


10
00:00:56,456 --> 00:01:01,929 line:-2
它也为静态分析器 杀毒软件
LLDB调试器提供了动力


11
00:01:02,362 --> 00:01:05,232 line:-1
并且是GPU着色器编译器下的


12
00:01:05,498 --> 00:01:11,171 line:-2
所有Apple移动平台的
优化代码生成框架


13
00:01:11,939 --> 00:01:16,343 line:-2
除此之外
它还为你可能时不时听说过的


14
00:01:16,410 --> 00:01:19,813 line:-2
一个叫做Swift的额外小项目
提供了动力


15
00:01:21,014 --> 00:01:24,918 line:-2
和Swift一样
LLVM也是一个开源项目


16
00:01:26,353 --> 00:01:30,557 line:0
我们都在我们的LLVM
这个飞龙的监视下工作


17
00:01:30,824 --> 00:01:32,826 line:-1
他通常是个很友好的家伙


18
00:01:32,893 --> 00:01:35,863 line:-2
不过我得提醒你
如果你称他为龙的话


19
00:01:35,963 --> 00:01:38,165 line:-2
他可能会变得有点暴躁
所以不要那样做


20
00:01:39,499 --> 00:01:43,303 line:-2
作为一个开源项目
LLVM是一个合作伙伴


21
00:01:44,137 --> 00:01:47,341 line:-1
我们与来自世界各地


22
00:01:47,407 --> 00:01:50,677 line:-2
不同行业的合作伙
学者、研究人员和爱好者合作


23
00:01:50,744 --> 00:01:56,483 line:-1
还有世界各地更多的人


24
00:01:56,583 --> 00:01:59,319 line:-2
这真是太棒了
我们共同努力


25
00:01:59,386 --> 00:02:02,089 line:-1
创造出最伟大的工具


26
00:02:02,322 --> 00:02:03,790 line:-1
来推动科技的发展


27
00:02:04,825 --> 00:02:09,395 line:-1
如果你对编译器有兴趣的话


28
00:02:09,729 --> 00:02:12,766 line:-1
我们乐意邀请你加入我们


29
00:02:13,267 --> 00:02:16,170 line:-2
你可以去访问LLVM的网站
llvm.org


30
00:02:16,603 --> 00:02:20,941 line:-2
或者你可以在今天晚些时候
在LLVM实验室和我们交谈


31
00:02:21,008 --> 00:02:23,977 line:-2
我们的许多来自Apple的
编译器工程师都将在那里


32
00:02:24,044 --> 00:02:27,848 line:-1
我肯定会非常高兴地与你讲解


33
00:02:27,915 --> 00:02:30,117 line:-1
与所有编译器相关


34
00:02:30,384 --> 00:02:31,652 line:-1
任何一切你想知道的事情


35
00:02:32,986 --> 00:02:37,591 line:-2
今天我们有一套很好的东西
要和你们分享


36
00:02:37,658 --> 00:02:40,160 line:-1
我们有自动引用计数的更新


37
00:02:40,227 --> 00:02:44,464 line:-2
这使得编译器
更容易帮助你进行内存管理


38
00:02:44,731 --> 00:02:49,937 line:-2
Xcode 10中有了新诊断方法
静态分析器中有了新检查方法


39
00:02:50,170 --> 00:02:53,974 line:-2
在构建时它能够帮助
更快地捕获项目中的错误


40
00:02:54,208 --> 00:02:56,376 line:-1
从而提高代码的质量


41
00:02:56,710 --> 00:02:58,979 line:-2
我们的编译器功能
无论是对于Apple平台


42
00:02:59,046 --> 00:03:01,949 line:-2
还是你的app
都可以提高它们的安全性


43
00:03:02,249 --> 00:03:05,419 line:-2
以及还有新的特性
使你能够利用硬件结构上的


44
00:03:05,485 --> 00:03:07,588 line:-1
所有真正伟大的新东西


45
00:03:07,654 --> 00:03:09,389 line:-1
以便能够从我们的平台


46
00:03:09,456 --> 00:03:11,692 line:-1
和架构中


47
00:03:11,992 --> 00:03:13,994 line:-1
获得我们都想要的性能


48
00:03:14,728 --> 00:03:17,664 line:-1
因此 我想邀请我的同事


49
00:03:18,098 --> 00:03:19,533 line:-1
Alex上来谈谈ARC


50
00:03:20,400 --> 00:03:21,301 line:-1
Alex


51
00:03:21,368 --> 00:03:23,136 line:0
（ARC最新情况）


52
00:03:27,908 --> 00:03:28,842 line:-1
谢谢Jim


53
00:03:29,676 --> 00:03:31,445 line:-1
自从我们在几年前引入了


54
00:03:31,512 --> 00:03:34,214 line:-1
自动引用计数以来


55
00:03:34,915 --> 00:03:37,184 line:0
它大大简化了
Object-C编程


56
00:03:38,051 --> 00:03:41,088 line:0
一些限制使得从旧的


57
00:03:41,355 --> 00:03:45,225 line:0
手动保留释放模式迁移到
ARC变得更加困难


58
00:03:45,292 --> 00:03:48,395 line:-2
我很高兴地说
我们现在已经解除了这样的限制


59
00:03:49,029 --> 00:03:51,064 line:0
Xcode 10支持


60
00:03:51,131 --> 00:03:54,635 line:0
C结构中的
ARC对象指针字段


61
00:03:54,701 --> 00:03:56,670 line:-1
（C结构中的ARC对象指针！）


62
00:04:00,507 --> 00:04:02,176 line:-1
让我们来看一个例子


63
00:04:02,242 --> 00:04:04,811 line:-2
假设我们想编写一个
食品订购app


64
00:04:05,379 --> 00:04:09,149 line:-2
我们想要创建一个
表示菜单项的数据结构


65
00:04:09,216 --> 00:04:10,617 line:-1
（工程师）


66
00:04:10,684 --> 00:04:14,521 line:-2
对于Xcode 9和更早的版本
实际上我们不可能


67
00:04:14,588 --> 00:04:18,591 line:-2
使用一个带有ARC对象指针字段的
C结构


68
00:04:18,992 --> 00:04:22,829 line:-2
所以我们必须在这里使用一个C
一个Objective-C类


69
00:04:24,264 --> 00:04:27,935 line:-2
而现在Xcode 10
允许我们实际创建一个


70
00:04:28,135 --> 00:04:30,671 line:-1
具有ARC对象指针字段的C结构


71
00:04:34,474 --> 00:04:37,644 line:-1
让我们继续写我们的食品订购app


72
00:04:38,045 --> 00:04:41,248 line:-2
让我们创建一个
为我们订购免费食物的函数


73
00:04:41,615 --> 00:04:45,719 line:-2
在这个函数中
让我们创建一个价格为零的


74
00:04:45,919 --> 00:04:47,054 line:-1
MenuItem类的变量项目


75
00:04:48,388 --> 00:04:51,124 line:-1
然后 让我们把这个项目传递到


76
00:04:51,191 --> 00:04:53,393 line:-2
另一个实际上
为我们订购食物的函数中去


77
00:04:54,761 --> 00:04:59,733 line:-1
创建项时编译器必须合成那个


78
00:05:00,033 --> 00:05:03,871 line:0
保留项目中
ARC对象指针字段的代码


79
00:05:05,038 --> 00:05:06,707 line:-1
幻灯片上的代码注释演示了


80
00:05:07,074 --> 00:05:10,444 line:-1
编译器所合成的代码


81
00:05:11,044 --> 00:05:14,848 line:-1
此代码确保在实际使用项目之前


82
00:05:15,182 --> 00:05:18,785 line:-1
不会提前发布项目的名称和价格


83
00:05:21,255 --> 00:05:24,858 line:0
在函数的末尾
“项目”超出了作用域


84
00:05:25,292 --> 00:05:27,227 line:0
并从栈中被释放


85
00:05:27,394 --> 00:05:30,664 line:0
因此编译器必须合成


86
00:05:30,864 --> 00:05:34,601 line:0
释放条目中
ARC对象指针字段的代码


87
00:05:35,536 --> 00:05:40,841 line:-2
这可以确保在项目释放时
不会泄露它的名称和价格


88
00:05:42,943 --> 00:05:47,147 line:-2
以前在使用手动保留释放模式时
可以使用


89
00:05:47,581 --> 00:05:50,184 line:-2
Objective-C
对象指针字段


90
00:05:50,984 --> 00:05:54,521 line:-1
但是你必须自己编写保留和释放


91
00:05:55,122 --> 00:05:59,293 line:-1
使用ARC编译器会为你


92
00:05:59,459 --> 00:06:02,930 line:-2
隐藏所有这些复杂性
并合成那个保留和释放字段的代码


93
00:06:03,630 --> 00:06:05,666 line:-1
所以编译器实际上是你的朋友


94
00:06:05,999 --> 00:06:09,136 line:-1
它对栈上的变量


95
00:06:09,203 --> 00:06:10,904 line:-1
以及其他结构中的字段


96
00:06:11,772 --> 00:06:14,575 line:-1
以及Objective-C类中的


97
00:06:14,875 --> 00:06:18,245 line:-2
实例变量
都进行了正确的管理


98
00:06:19,680 --> 00:06:23,684 line:-1
但是有一个地方


99
00:06:23,750 --> 00:06:26,587 line:-2
我们需要做一些额外的工作
来支持使用


100
00:06:27,788 --> 00:06:29,489 line:-2
ARC对象指针字段的结构
这个地方就是堆


101
00:06:30,624 --> 00:06:31,992 line:-1
让我们回到我们的结构


102
00:06:32,125 --> 00:06:36,096 line:-2
我们假设
你希望在堆中分配一个菜单项数组


103
00:06:36,797 --> 00:06:41,835 line:-2
若这是Objective-C接口
我们就可以在此用NSArray


104
00:06:42,536 --> 00:06:45,205 line:-2
但它不是 所以让我们使用
malloc和free


105
00:06:46,173 --> 00:06:49,176 line:-1
现在这段代码实际上有两个问题


106
00:06:49,977 --> 00:06:54,815 line:-1
首先内存在分配时不是零初始化的


107
00:06:55,048 --> 00:06:58,185 line:-1
这意味着它们的指针是无效的


108
00:06:58,585 --> 00:07:01,822 line:-1
这将导致程序在运行时


109
00:07:01,889 --> 00:07:03,323 line:-1
出现不希望的运行时行为


110
00:07:05,225 --> 00:07:09,062 line:-1
第二个问题是在释放内存之前


111
00:07:09,129 --> 00:07:12,065 line:-1
ARC对象指针字段未被清除


112
00:07:12,499 --> 00:07:17,070 line:-1
这将导致你的程序运行时内存泄漏


113
00:07:19,139 --> 00:07:25,212 line:-2
要解决第一个问题
可将对malloc的调用替换为对calloc的调用


114
00:07:25,746 --> 00:07:29,449 line:-1
这将确保你的内存是零初始化的


115
00:07:30,050 --> 00:07:34,688 line:-2
这将消除所有那些令人不快的
意想不到的运行时问题


116
00:07:35,722 --> 00:07:39,059 line:0
要解决第二个问题


117
00:07:39,459 --> 00:07:41,728 line:0
你可以在循环分配到内存之前


118
00:07:42,129 --> 00:07:45,532 line:0
编写一个循环以清除项目中的
所有ARC对象指针字段


119
00:07:46,266 --> 00:07:49,803 line:-1
这将确保在释放条目时


120
00:07:49,937 --> 00:07:52,239 line:-1
条目中的名称和价格不会泄漏


121
00:07:56,009 --> 00:07:58,478 line:-1
现在这是一个令人兴奋的新特性


122
00:07:59,046 --> 00:08:03,217 line:-2
如果你们当中
由于缺少这样的特性


123
00:08:03,517 --> 00:08:06,119 line:-1
而推迟迁移到ARC中的话


124
00:08:06,186 --> 00:08:10,524 line:-2
我希望Xcode 10中
对ARC对象指针字段的支持


125
00:08:10,991 --> 00:08:12,860 line:-1
可以帮助你重新考虑你的选择


126
00:08:14,027 --> 00:08:18,732 line:-2
我们来看看Objective-C
指针和一般的结构


127
00:08:18,799 --> 00:08:23,270 line:-2
看看在Xcode 10中
在不同的语言模式中


128
00:08:23,570 --> 00:08:26,273 line:-1
在哪里以及如何使用这些结构


129
00:08:27,774 --> 00:08:31,745 line:-2
在Xcode 10中
你可以使用具有


130
00:08:31,812 --> 00:08:34,248 line:-1
Objective-C


131
00:08:34,515 --> 00:08:36,216 line:-2
对象指针字段的结构
来跨越不同的语言模式


132
00:08:36,549 --> 00:08:41,788 line:-2
例如你可以在C、Objective-C
甚至Objective-C++中


133
00:08:41,855 --> 00:08:43,789 line:-1
使用相同的结构


134
00:08:44,791 --> 00:08:50,330 line:-2
而且即使在ARC或
手动保留释放模式下编译代码时


135
00:08:50,564 --> 00:08:52,666 line:-1
它也会正常工作


136
00:08:54,067 --> 00:08:58,839 line:-2
在Xcode 10中
实际上我们在调用函数之间


137
00:08:59,306 --> 00:09:04,745 line:-2
统一了
Objective-C++ ABI


138
00:09:04,811 --> 00:09:07,915 line:-2
这些函数接收或返回具有
Objective-C++中的ARC对象指针字段的结构


139
00:09:08,715 --> 00:09:12,653 line:-2
这是通过Xcode 10中的
ABI更改来完成的


140
00:09:13,053 --> 00:09:17,291 line:-2
这种ABI变化影响了
Objective-C++中的函数


141
00:09:17,858 --> 00:09:21,195 line:-1
这些函数通过值返回或接受


142
00:09:21,528 --> 00:09:26,466 line:-1
具有ARC对象指针字段的结构


143
00:09:26,533 --> 00:09:28,635 line:-2
而没有像构造函数或析构函数
那样的特殊成员函数


144
00:09:30,037 --> 00:09:33,106 line:-1
现在如果你不确定这对你意味着什么


145
00:09:33,173 --> 00:09:36,643 line:-2
或者你的代码是否受到
此ABI更改的影响


146
00:09:37,077 --> 00:09:39,713 line:-1
请查看Xcode的发行说明


147
00:09:39,947 --> 00:09:41,882 line:-1
描述了此ABI更改的


148
00:09:42,182 --> 00:09:45,352 line:-1
效果和影响


149
00:09:45,419 --> 00:09:48,922 line:-2
（结构中的
OBJECTIVE-C对象）


150
00:09:48,989 --> 00:09:50,224 line:-1
对于ARC对象指针字段


151
00:09:50,290 --> 00:09:54,494 line:-1
和C结构 我们有一个警告


152
00:09:55,629 --> 00:09:57,431 line:-1
它们在Swift中没有支持


153
00:09:57,698 --> 00:09:59,733 line:-1
因此如果你尝试使用一个具有


154
00:09:59,967 --> 00:10:02,669 line:-2
Swift中
ARC对象指针字段的结构


155
00:10:03,203 --> 00:10:07,040 line:-2
你只会得到一个编译错误
因为找不到该结构


156
00:10:07,107 --> 00:10:10,344 line:-2
（对于某些函数的ABI更改
通过值传递或返回结构）


157
00:10:10,410 --> 00:10:13,814 line:-2
（Swift不支持使用
ARC对象指针字段导入结构）


158
00:10:13,881 --> 00:10:19,019 line:-2
除了像支持ARC对指针字段的
新特性之外


159
00:10:19,453 --> 00:10:24,358 line:-2
Xcode 10
还附带了许多新的编译器诊断


160
00:10:24,825 --> 00:10:28,061 line:-2
在Xcode 10中
我们实际上有超过100个新的警告


161
00:10:28,762 --> 00:10:30,797 line:-1
今天我想谈谈其中的两个


162
00:10:30,864 --> 00:10:31,965 line:-1
（Xcode 10中的新诊断）


163
00:10:32,032 --> 00:10:34,902 line:-2
第一个警告可能对那些混合了
Swift和Objective-C代码


164
00:10:35,602 --> 00:10:39,072 line:-1
的人感兴趣


165
00:10:39,840 --> 00:10:44,444 line:-2
因如你所知Swift代码
可以导入Objective-C


166
00:10:45,312 --> 00:10:50,017 line:-2
Xcode允许你
通过生成一个使用


167
00:10:50,217 --> 00:10:54,855 line:-2
Objective-C声明描述
Swift接口的头文件来实现这点


168
00:10:54,922 --> 00:10:56,456 line:-2
（SWIFT和
OBJECTIVE-C互操作性）


169
00:10:56,523 --> 00:10:59,860 line:-2
你可以将这个头文件导入到你自己的
Objective-C代码中


170
00:11:00,360 --> 00:11:04,031 line:-1
以便访问底层的Swift声明


171
00:11:04,798 --> 00:11:06,333 line:-1
现在让我们更具体地讨论一下


172
00:11:06,400 --> 00:11:09,636 line:-1
如何将Swift的闭包参数


173
00:11:09,703 --> 00:11:11,438 line:-1
导入到Objective-C中


174
00:11:12,172 --> 00:11:13,841 line:-1
现在屏幕上


175
00:11:14,107 --> 00:11:17,945 line:-2
你看到了一个叫Executor的
Swift协议的例子


176
00:11:18,712 --> 00:11:22,716 line:-2
该协议定义了一个名为
performOperation的函数成员


177
00:11:22,883 --> 00:11:25,986 line:-2
它接受一个名为
handler的闭包参数


178
00:11:27,487 --> 00:11:31,225 line:0
现在Swift中闭包参数
在默认情况下是不转义的


179
00:11:31,491 --> 00:11:35,362 line:0
这意味着在函数返回后


180
00:11:35,429 --> 00:11:37,097 line:0
它们不应该被保留或调用


181
00:11:38,599 --> 00:11:43,770 line:0
现在当符合
Objective-C时


182
00:11:43,871 --> 00:11:47,374 line:0
程序员很容易忘记这个契约是存在的


183
00:11:48,175 --> 00:11:51,178 line:-1
例如 正如你现在幻灯片上看到的


184
00:11:51,512 --> 00:11:55,215 line:-2
在Objective-C中
我们有一个调度执行器接口


185
00:11:55,282 --> 00:11:57,751 line:-1
并且符合Executor协议


186
00:11:58,352 --> 00:12:00,921 line:-2
因此它提供了
performOperation方法


187
00:12:01,321 --> 00:12:03,390 line:-1
该方法接受与Swift的


188
00:12:03,457 --> 00:12:06,827 line:-2
处理程序闭包参数对应的
处理程序块参数


189
00:12:07,427 --> 00:12:09,863 line:-2
但仅仅通过查看
Objective-C代码


190
00:12:10,097 --> 00:12:11,865 line:-1
我们无法知道


191
00:12:11,932 --> 00:12:14,568 line:-1
处理程序参数是否可以转义


192
00:12:16,003 --> 00:12:21,341 line:-2
Xcode 10
现在提供了一个警告


193
00:12:21,708 --> 00:12:24,878 line:-2
帮助我们记住这个参数
实际上不是转义的


194
00:12:27,481 --> 00:12:31,151 line:-2
为了修正这个警告 你可以使用
NS_NOESCAPE注释


195
00:12:31,218 --> 00:12:33,587 line:-1
来注释你的块参数


196
00:12:34,588 --> 00:12:35,856 line:-1
你还应该用


197
00:12:35,923 --> 00:12:39,059 line:-2
NS_NOESCAPE注释
来注释方法的实现


198
00:12:39,126 --> 00:12:42,796 line:-1
或方法实现中的参数


199
00:12:44,164 --> 00:12:49,770 line:-2
NS_NOESCAPE注释只是
一个对程序员的提醒


200
00:12:50,204 --> 00:12:54,741 line:-1
以确保在执行操作方法返回后


201
00:12:54,808 --> 00:12:57,578 line:-1
你不存储或调用处理程序块


202
00:12:59,012 --> 00:13:02,316 line:-1
因此这是为了帮助你记住


203
00:13:02,382 --> 00:13:07,454 line:-2
Swift和Object-C代码
之间存在这样的契约


204
00:13:09,990 --> 00:13:13,260 line:-2
现在第二个警告
可能对那些使用


205
00:13:14,228 --> 00:13:15,929 line:-1
更低级别代码并关心


206
00:13:15,996 --> 00:13:20,601 line:-1
结构在内存中的布局方式的人感兴趣


207
00:13:21,835 --> 00:13:23,470 line:-1
让我们来看看一个结构


208
00:13:23,770 --> 00:13:28,809 line:-2
在C语言中结构必须遵循严格的
布局和对齐规则


209
00:13:29,810 --> 00:13:32,679 line:-2
在这个特殊的结构中
你可以在幻灯片上看到


210
00:13:32,813 --> 00:13:35,916 line:-2
编译器必须在
结构的第二个和第三个字段之间


211
00:13:36,250 --> 00:13:39,253 line:-1
插入一个2字节的填充


212
00:13:40,721 --> 00:13:44,024 line:-1
有时你可能想要放松这些规则


213
00:13:44,124 --> 00:13:47,528 line:-2
编译器提供了一个
pragma pack指令


214
00:13:47,594 --> 00:13:51,965 line:-1
你可以用它来控制布局和结构的对齐


215
00:13:52,032 --> 00:13:54,434 line:-2
（用#PRAGMA PACK
填充结构构件）


216
00:13:54,501 --> 00:13:59,173 line:-2
现在这个示例中我们使用
pragma pack push 1指令


217
00:13:59,706 --> 00:14:03,277 line:-1
来删除这个固定的布局


218
00:14:03,343 --> 00:14:06,280 line:-1
并确保我们的结构是紧凑的


219
00:14:07,347 --> 00:14:10,984 line:-1
这在序列化结构或通过网络


220
00:14:11,051 --> 00:14:13,654 line:-1
传输结构时非常有用


221
00:14:14,788 --> 00:14:19,760 line:-2
现在pragma pack通常
与push和pop指令一起使用


222
00:14:20,360 --> 00:14:25,465 line:-2
但是程序员很容易忘记将
pop插入到代码中


223
00:14:27,234 --> 00:14:29,770 line:-2
Xcode 10现在会警告那些
没有相应的


224
00:14:30,404 --> 00:14:34,074 line:-2
pragma pack pop
指令的代码


225
00:14:34,875 --> 00:14:37,511 line:-1
它会将你指向push的位置


226
00:14:37,578 --> 00:14:39,680 line:-2
（找到不平衡的
#PRAGMA PACK指令）


227
00:14:39,746 --> 00:14:41,114 line:-1
为了修复这个警告


228
00:14:41,315 --> 00:14:44,685 line:-1
你应该查看push指令的位置


229
00:14:45,285 --> 00:14:47,221 line:-1
并将pop指令


230
00:14:47,554 --> 00:14:50,457 line:-1
插入到代码中的相应位置


231
00:14:51,725 --> 00:14:55,963 line:-2
在我们的例子中我们可以在
填充结构之后直接插入pop


232
00:14:57,130 --> 00:14:58,732 line:-1
一旦我们这样做了


233
00:14:59,566 --> 00:15:03,570 line:-1
新的布局规则将只适用于填充结构


234
00:15:03,804 --> 00:15:07,674 line:-2
因此它们不会影响程序中的
任何其他结构


235
00:15:11,812 --> 00:15:17,017 line:-2
我提到的这两个新警告
在Xcode 10中默认启用


236
00:15:17,951 --> 00:15:22,589 line:-2
它们可以帮助你
编写更正确更健壮的代码


237
00:15:23,390 --> 00:15:26,627 line:-1
为了更多地讨论更正确更健壮的代码


238
00:15:26,860 --> 00:15:28,962 line:-1
我想请George上台


239
00:15:29,029 --> 00:15:29,963 line:0
他将讨论


240
00:15:30,030 --> 00:15:33,233 line:0
Xcode 10中
新的静态分析改进


241
00:15:34,101 --> 00:15:35,002 line:0
George


242
00:15:35,068 --> 00:15:37,070 line:0
（CLANG静态分析器）


243
00:15:41,508 --> 00:15:42,442 line:-1
谢谢 Alex


244
00:15:42,876 --> 00:15:45,546 line:-1
我想向你介绍一些


245
00:15:45,612 --> 00:15:49,449 line:-2
我们为Clang静态分析器
Xcode 10所做的改进


246
00:15:50,284 --> 00:15:52,786 line:-2
Clang静态分析器
是一个很好的工具


247
00:15:52,853 --> 00:15:56,490 line:-2
可以在你的程序中找到边缘案例
难以再现的漏洞


248
00:15:57,224 --> 00:15:59,927 line:-1
静态分析器不仅为你查找漏洞


249
00:16:00,227 --> 00:16:03,030 line:-1
还在列出漏洞的路径的


250
00:16:03,096 --> 00:16:04,932 line:-1
Xcode中显示其可视化


251
00:16:05,566 --> 00:16:10,604 line:-2
NSMutableArray中
添加了nil 可能在稍后导致崩溃


252
00:16:11,071 --> 00:16:14,274 line:-2
静态分析器向你展示了
这个崩溃的路径


253
00:16:14,341 --> 00:16:16,577 line:-2
这样你就可以看到
app是如何被修复的


254
00:16:18,045 --> 00:16:22,049 line:-2
我想告诉你们
我们所做的三项新的改进


255
00:16:23,083 --> 00:16:28,055 line:-2
首先我们有了一个新的检查
用来检测伟大的中央调度反模式


256
00:16:28,422 --> 00:16:31,692 line:-2
这可能会导致不良的性能
和挂起你的app


257
00:16:32,359 --> 00:16:35,729 line:-2
其次我们有一项新的检查
用于检测


258
00:16:35,996 --> 00:16:39,132 line:-1
动释放池中的自动释放变量的误用


259
00:16:39,433 --> 00:16:41,802 line:-1
这可能会导致释放后使用崩溃


260
00:16:42,970 --> 00:16:46,473 line:-2
最后我们改进了
Clang静态分析器的


261
00:16:46,540 --> 00:16:47,975 line:-1
性能和可视


262
00:16:49,376 --> 00:16:52,079 line:-1
那么让我们从一个


263
00:16:52,145 --> 00:16:54,081 line:-1
检测伟大的中央调度反模式检查开始


264
00:16:54,915 --> 00:16:58,852 line:-1
我们平台上的许多API都是异步的


265
00:16:59,186 --> 00:17:01,822 line:-1
但有时开发人员出于某种原因


266
00:17:01,889 --> 00:17:04,491 line:-1
希望以同步的方式使用它们


267
00:17:05,559 --> 00:17:06,693 line:-1
可能是因为他们的代码


268
00:17:06,760 --> 00:17:08,896 line:-1
已经在后台队列上运行了


269
00:17:09,496 --> 00:17:11,832 line:-1
或者是因为函数在必需的值可用之前


270
00:17:11,898 --> 00:17:13,934 line:-1
根本无法继续运行


271
00:17:14,734 --> 00:17:16,336 line:-1
而那里诱人的解决方案是


272
00:17:16,403 --> 00:17:19,473 line:-1
使用信号量来确保同步


273
00:17:20,273 --> 00:17:22,776 line:-1
这就是这个例子中的情况


274
00:17:23,042 --> 00:17:27,314 line:-2
所以这里有一个SXPC对象
self.connection


275
00:17:27,814 --> 00:17:31,685 line:-2
我们使用它的属性
remoteObjectProxy


276
00:17:31,885 --> 00:17:34,922 line:-1
从另一个进程异步地


277
00:17:35,088 --> 00:17:36,590 line:-1
获取递归任务的名称


278
00:17:37,558 --> 00:17:42,629 line:-2
然后我们等待一个信号量
它是回调内部的一个信号


279
00:17:43,297 --> 00:17:46,700 line:-1
这有助于确保在函数返回任务名时


280
00:17:47,434 --> 00:17:49,002 line:-1
任务名是可用的


281
00:17:49,770 --> 00:17:53,674 line:0
因此这种方法是可行的
但它具有一定的性能含义


282
00:17:54,408 --> 00:17:55,809 line:0
因此这里的主要问题是


283
00:17:55,876 --> 00:18:00,447 line:0
当你在某个异步进程上
等待使用信号量时


284
00:18:00,814 --> 00:18:02,482 line:0
你可能会等待一个优先级


285
00:18:02,549 --> 00:18:04,852 line:0
比你的队列低得多的队列


286
00:18:05,118 --> 00:18:06,687 line:0
这会导致优先级反转


287
00:18:06,920 --> 00:18:09,289 line:0
这会恶化性能并导致挂起


288
00:18:10,057 --> 00:18:13,794 line:-1
而且以这种方式使用信号量


289
00:18:13,994 --> 00:18:17,598 line:-2
也会产生无用的线程
从而进一步降低性能


290
00:18:18,966 --> 00:18:21,268 line:-1
为了帮助你解决这个问题


291
00:18:21,435 --> 00:18:24,471 line:-1
现在静态分析器对这种情况提出警告


292
00:18:26,807 --> 00:18:29,076 line:-1
帮助了解问题发生的地点


293
00:18:29,142 --> 00:18:31,478 line:-1
（伟大的中央调度性能反模式）


294
00:18:31,545 --> 00:18:33,514 line:-1
现在让我们看看如何解决这个问题


295
00:18:34,014 --> 00:18:38,385 line:-2
在最好的情况下
有一个可供使用的同步API


296
00:18:38,452 --> 00:18:39,720 line:-1
可以替代使用


297
00:18:40,187 --> 00:18:44,491 line:-2
因此对于SXPC连接
有了一个类似的API


298
00:18:44,558 --> 00:18:47,127 line:-1
即synchronousRemoteObjectProxy


299
00:18:47,661 --> 00:18:51,164 line:-2
当使用它时
它消除了对信号量的需求


300
00:18:51,398 --> 00:18:53,000 line:-1
运行速度要快得多


301
00:18:55,135 --> 00:18:59,273 line:-1
或者如果没有这样的同步API可用


302
00:18:59,740 --> 00:19:03,143 line:-2
你可以重构app
以使用安装的连续程序


303
00:19:03,410 --> 00:19:06,180 line:-1
只需在回调中调用所需的函数即可


304
00:19:09,216 --> 00:19:11,285 line:-1
这个检查在默认情况下是不启用的


305
00:19:11,552 --> 00:19:14,087 line:-1
但是我们鼓励你在构建设置中启用它


306
00:19:14,254 --> 00:19:17,824 line:-2
以确保在你的app中
不会出现这样的问题


307
00:19:17,891 --> 00:19:19,560 line:-1
并尽可能快地运行


308
00:19:21,328 --> 00:19:23,363 line:-1
现在让我们讨论第二个检查


309
00:19:23,430 --> 00:19:25,866 line:-1
用于检测


310
00:19:25,933 --> 00:19:28,502 line:-2
比自动释放池的生命周期
更长的自动释放变量


311
00:19:30,404 --> 00:19:35,175 line:-2
自动释放限定符指定
一旦控件退出自动释放池


312
00:19:35,409 --> 00:19:37,878 line:-1
就必须释放该值


313
00:19:38,545 --> 00:19:42,816 line:-2
这里有一个例子
我们在自动释放池中


314
00:19:43,016 --> 00:19:44,451 line:-1
创建一个错误变量


315
00:19:44,685 --> 00:19:47,254 line:-1
一旦控件在自动释放池之外


316
00:19:47,321 --> 00:19:50,490 line:-1
个变量就会被释放 然后被销毁


317
00:19:51,058 --> 00:19:55,128 line:-2
自动释放池是
Objective-C的有用特性


318
00:19:55,395 --> 00:19:58,565 line:-1
它有助于控制app的大内存占用


319
00:19:58,632 --> 00:20:01,602 line:-1
并确保在必要时销毁临时内存


320
00:20:03,036 --> 00:20:06,373 line:-1
然而它可能会导致意外的崩溃


321
00:20:07,040 --> 00:20:09,042 line:-1
而且它们更令人意外


322
00:20:09,109 --> 00:20:12,212 line:-2
因为你甚至不需要在app中
编写“自动释放”这个词


323
00:20:12,279 --> 00:20:14,681 line:-1
就可以发生这些崩溃


324
00:20:15,082 --> 00:20:18,318 line:-1
例如这里有一个验证函数


325
00:20:19,019 --> 00:20:21,588 line:-1
它接受out参数NSError


326
00:20:22,289 --> 00:20:23,624 line:-1
而out参数


327
00:20:23,690 --> 00:20:27,494 line:-2
在Objective-C中
默认为ARC


328
00:20:28,095 --> 00:20:32,866 line:-2
所以当我们把这个out参数
写在自动释放池中时


329
00:20:35,269 --> 00:20:39,206 line:-2
然后函数退出时
错误值就被释放了


330
00:20:39,840 --> 00:20:43,610 line:-2
如果调用者试图
读取这个错误变量的值


331
00:20:43,810 --> 00:20:46,747 line:-1
他们可能会释放后使用中崩溃


332
00:20:46,813 --> 00:20:48,849 line:-1
（OUT参数和自动存储池）


333
00:20:48,916 --> 00:20:50,684 line:-1
（获块中的自恢复变量）


334
00:20:50,751 --> 00:20:55,856 line:-2
这种模式已经很难被发现
但是当你甚至不控制


335
00:20:55,989 --> 00:20:58,559 line:-1
拥有自动存储池的app的部分时


336
00:20:58,625 --> 00:21:00,127 line:-1
这种模式会变得更糟


337
00:21:00,694 --> 00:21:05,566 line:-2
这里有一个类似的函数
它也接受out参数错误


338
00:21:06,166 --> 00:21:09,837 line:-2
然后调用
一个enumerateObjectsUsingBlock


339
00:21:09,937 --> 00:21:12,706 line:-2
这是一个流行的
foundation API


340
00:21:12,773 --> 00:21:15,709 line:-1
它在集合的每个元素上调用一个块


341
00:21:16,476 --> 00:21:18,979 line:-1
但是enumerateObjectsUsingBlock


342
00:21:19,479 --> 00:21:23,550 line:-2
实际上把x称为返回的
自动释放返回池中的一个给定块


343
00:21:24,051 --> 00:21:25,919 line:-1
因此这里也出现了一个类似的问题


344
00:21:26,286 --> 00:21:30,123 line:-1
当我们在块中创建一个错误值


345
00:21:30,190 --> 00:21:31,925 line:-1
并将其写入out参数时


346
00:21:32,559 --> 00:21:34,194 line:-2
当控件到达
enumerateObjectsUsingBlock时


347
00:21:34,261 --> 00:21:38,131 line:-1
它实际上会被释放


348
00:21:39,533 --> 00:21:42,636 line:-1
然后当调用者试图阅读它时


349
00:21:42,803 --> 00:21:45,205 line:-1
它们也可能会释放后使用中崩溃


350
00:21:47,975 --> 00:21:51,044 line:-2
在此之前
我们已经介绍了编译器警告


351
00:21:51,378 --> 00:21:55,048 line:-1
它在块中捕获隐式自动发出的参数时


352
00:21:55,115 --> 00:21:56,517 line:-1
发出警告


353
00:21:56,984 --> 00:21:58,118 line:-1
编译器警告


354
00:21:58,185 --> 00:22:01,355 line:-1
建议显式地使这些参数自动发送


355
00:22:02,089 --> 00:22:04,691 line:-2
但是我们注意到
这样的问题一直在发生


356
00:22:05,526 --> 00:22:07,160 line:-1
所以在Xcode 10中


357
00:22:07,227 --> 00:22:10,864 line:-2
我们引入了一个功能更强大的
Clang静态分析器警告


358
00:22:11,865 --> 00:22:14,168 line:-1
它知道哪些API


359
00:22:15,169 --> 00:22:17,871 line:-1
调用了自动释放池中提供的块


360
00:22:18,172 --> 00:22:20,073 line:-1
并对此类情况进行警告


361
00:22:21,108 --> 00:22:22,843 line:-2
（Xcode 10：
检查自动释放误用）


362
00:22:23,610 --> 00:22:25,679 line:-1
现在让我们看看如何解决这个问题


363
00:22:26,213 --> 00:22:27,814 line:-1
这里最简单的方法就是


364
00:22:28,081 --> 00:22:30,417 line:-1
引入一个强大的局部变量


365
00:22:31,084 --> 00:22:33,320 line:-1
然后当你在块中时


366
00:22:33,654 --> 00:22:36,857 line:-1
将一个值写入内部的强变量中


367
00:22:37,624 --> 00:22:40,194 line:-1
将一个值写入内部的强变量中


368
00:22:40,561 --> 00:22:42,696 line:-1
只复制到out参数


369
00:22:42,863 --> 00:22:45,432 line:-1
并且你知道它不在自动释放池中


370
00:22:45,499 --> 00:22:48,202 line:-1
因此写入自动释放变量是安全的


371
00:22:50,103 --> 00:22:53,140 line:-1
（改进性能和报告可视化）


372
00:22:53,207 --> 00:22:57,077 line:-1
最后我们还改进了


373
00:22:57,144 --> 00:22:58,545 line:-2
Clang静态分析器的性能
和可视化


374
00:22:59,580 --> 00:23:03,283 line:-2
因此在Xcode 10中
我们改进了分析器


375
00:23:03,350 --> 00:23:05,519 line:-1
以更有效的方式探索你的程序


376
00:23:05,752 --> 00:23:10,991 line:-2
现在它在相同的分析时间内
发现的漏洞比以前多出15%


377
00:23:12,392 --> 00:23:16,630 line:-2
它不仅发现了更多的漏洞
而且它现在生成的漏洞


378
00:23:17,264 --> 00:23:19,933 line:-1
报告往往更小也更容易理解


379
00:23:20,033 --> 00:23:23,737 line:-2
我的意思是
有时候在Xcode 10中


380
00:23:24,638 --> 00:23:25,739 line:-1
你会得到


381
00:23:25,806 --> 00:23:28,509 line:-1
很多步骤和箭头的例子


382
00:23:28,575 --> 00:23:30,744 line:-1
这些例子有些难以理解


383
00:23:31,445 --> 00:23:35,282 line:-2
在Xcode的新版本中的
许多示例中


384
00:23:35,849 --> 00:23:39,820 line:-2
我们提供了一个更小的错误路径
它更容易查看


385
00:23:39,887 --> 00:23:41,655 line:-1
你可以更快地看到问题


386
00:23:43,390 --> 00:23:47,261 line:-1
因此为了在项目中使用静态分析器


387
00:23:47,327 --> 00:23:53,734 line:-2
你可以使用产品 分析
甚至可以在构建期间启用分析


388
00:23:53,967 --> 00:23:56,637 line:-1
以确保分析器问题不被忽略


389
00:23:57,271 --> 00:23:59,573 line:-1
所以我鼓励你使用静态分析器


390
00:23:59,973 --> 00:24:02,409 line:-2
它是一个很好的工具
可以在用户使用之前发现你的错误


391
00:24:03,110 --> 00:24:06,980 line:0
现在我的同事Ahmed
将会讨论低水平的改进


392
00:24:07,047 --> 00:24:10,250 line:0
（加强安全）


393
00:24:10,317 --> 00:24:11,151 line:0
谢谢George


394
00:24:14,555 --> 00:24:18,058 line:-2
如Alex和George告诉你的
我们在编译器中有很多警告


395
00:24:18,125 --> 00:24:20,894 line:-1
和静态分析器检查


396
00:24:21,428 --> 00:24:23,197 line:-1
但是你也有杀毒软件


397
00:24:23,363 --> 00:24:25,432 line:-2
和所有这些工具
可以帮助你发现很多漏洞


398
00:24:25,499 --> 00:24:26,667 line:-1
包括安全漏洞


399
00:24:28,135 --> 00:24:31,238 line:0
所以我相信你们都有很多测试
并且使用所有这些工具


400
00:24:31,538 --> 00:24:34,374 line:0
来发现这些测试中的所有漏洞


401
00:24:35,008 --> 00:24:37,578 line:0
但是对于一些最恶劣的安全漏洞


402
00:24:38,111 --> 00:24:41,148 line:-2
如果它们以某种方式
通过了所有的测试


403
00:24:41,381 --> 00:24:43,517 line:-2
我们希望确保它们
不会在发布版构建中出现


404
00:24:45,152 --> 00:24:49,156 line:-2
因此对于那些
我们在代码生成器中有缓解的东西


405
00:24:49,223 --> 00:24:51,358 line:-1
即使在发布版本中我们也希望如此


406
00:24:52,593 --> 00:24:54,862 line:-2
我是Ahmed
我做代码生成器工作


407
00:24:54,962 --> 00:24:58,332 line:-2
今天我将告诉大家
Xcode 10中新的缓解措施


408
00:25:00,033 --> 00:25:01,001 line:-1
要了解它是如何工作的


409
00:25:01,068 --> 00:25:02,936 line:-1
我们就需要了解栈是如何工作的


410
00:25:04,972 --> 00:25:08,709 line:-2
这里我有一个简单的C函数
叫做dlog


411
00:25:09,309 --> 00:25:13,080 line:-2
我用它来打印
我传入dlog错误的字符串


412
00:25:14,781 --> 00:25:17,284 line:-2
在这种情况下
用字符串hello来调用它


413
00:25:18,352 --> 00:25:19,319 line:-1
它的工作方式是


414
00:25:19,386 --> 00:25:23,957 line:-1
我们需分配一些内存来跟踪这个调用


415
00:25:26,126 --> 00:25:28,996 line:-1
我们把它分配到一个叫做栈的区域


416
00:25:29,730 --> 00:25:33,500 line:-1
栈向空指针或地址0方向向下延伸


417
00:25:35,903 --> 00:25:38,172 line:-2
因此当我们执行
dlog“hello”调用时


418
00:25:38,705 --> 00:25:40,741 line:-1
这会分配所谓的堆栈帧


419
00:25:41,441 --> 00:25:43,944 line:-1
堆栈帧包含类似返回地址的内容


420
00:25:44,211 --> 00:25:46,480 line:-2
这样我们就知道
如何返回main


421
00:25:47,714 --> 00:25:50,884 line:-2
但它也包含其他东西
如参数和局部变量


422
00:25:51,718 --> 00:25:55,088 line:-2
因此例如
如果我有一个日志文件路径局部变量


423
00:25:56,056 --> 00:25:57,658 line:-1
它就驻留在堆栈框架中


424
00:26:00,260 --> 00:26:04,331 line:-2
如果我尝试对这个dlog文件
函数进行另一个函数调用


425
00:26:05,766 --> 00:26:07,901 line:-2
那么这个函数
就会分配它自己的堆栈帧


426
00:26:09,369 --> 00:26:12,506 line:-2
当它完成时
它将重新分配堆栈帧


427
00:26:12,639 --> 00:26:14,107 line:-1
并返回给调用者


428
00:26:16,810 --> 00:26:20,013 line:-1
现在我们更详细地看看这个堆栈框架


429
00:26:21,515 --> 00:26:25,385 line:-1
假设我将函数改成一个本地缓冲区


430
00:26:25,452 --> 00:26:27,321 line:-1
这是一个4字节的字符数组


431
00:26:29,790 --> 00:26:31,959 line:-1
我正在尝试通过先做一个


432
00:26:32,226 --> 00:26:36,530 line:-2
我传递到缓冲区中的字符串的
strcpy来准备调试字符串


433
00:26:38,565 --> 00:26:44,571 line:-2
strcpy来准备调试字符串
H-E-L-L


434
00:26:46,039 --> 00:26:49,276 line:-2
但问题是在这一点上
我们已经写了4个字节


435
00:26:49,877 --> 00:26:53,280 line:-2
我们已经用尽了在我们的缓冲区中
可用的所有4个字节


436
00:26:54,581 --> 00:26:57,184 line:-2
所以如果我们继续
这就是Strcpy所做的


437
00:26:57,518 --> 00:26:59,720 line:-1
那么我们将重写返回地址


438
00:27:01,054 --> 00:27:02,589 line:-1
这是一个很大的安全问题


439
00:27:02,856 --> 00:27:07,427 line:-2
如果攻击者控制了
我正在复制的字符串 这并不难


440
00:27:07,961 --> 00:27:09,763 line:-1
那么它可以控制返回地址


441
00:27:10,197 --> 00:27:11,932 line:-1
如果它能控制返回地址


442
00:27:11,999 --> 00:27:14,368 line:-2
那么他们就基本上控制了
程序下一步做什么


443
00:27:14,434 --> 00:27:15,836 line:-1
所以这是很大的安全问题


444
00:27:18,772 --> 00:27:21,909 line:-1
因此如果你有一个测试捕捉到了这个


445
00:27:22,509 --> 00:27:24,278 line:-1
并且运行了地址消毒器


446
00:27:24,878 --> 00:27:27,881 line:-2
那么你将有一个简单的方法
来解决这个问题


447
00:27:28,415 --> 00:27:30,551 line:-1
实际上 我在这里应该做的是


448
00:27:30,784 --> 00:27:33,420 line:-1
strncpy 它知道大小


449
00:27:33,854 --> 00:27:36,957 line:-2
甚至更好 使用更高级别的API
NSString或STD字符串


450
00:27:39,026 --> 00:27:42,229 line:-2
但是有时候这些漏洞
仍然可以在发布版构建中存活下来


451
00:27:43,063 --> 00:27:47,835 line:-2
我们通过使用
所谓的堆栈保护器来避免它们


452
00:27:49,770 --> 00:27:51,972 line:-2
栈保护器改变了堆栈框架的布局
添加一个新的字段


453
00:27:52,039 --> 00:27:54,007 line:-1
金丝雀


454
00:27:55,642 --> 00:27:57,477 line:-1
这样当我们写的时候


455
00:27:58,378 --> 00:28:01,715 line:-1
我们会在函数返回之前有一些代码


456
00:28:02,015 --> 00:28:04,117 line:-1
来检查金丝雀是否有效


457
00:28:06,186 --> 00:28:09,623 line:-2
所以如我们继续用strcpy来写
我们首先要覆盖金丝雀


458
00:28:11,491 --> 00:28:14,962 line:-1
然后在返回之前先检查金丝雀


459
00:28:15,696 --> 00:28:16,964 line:-1
然后就会终止


460
00:28:17,664 --> 00:28:21,235 line:-2
因此我们将一个潜在的
可利用的安全漏洞


461
00:28:21,401 --> 00:28:24,771 line:-2
转化为可靠的崩溃
这对攻击者是不利的


462
00:28:26,573 --> 00:28:28,642 line:-1
这就是所谓的堆栈保护器


463
00:28:31,545 --> 00:28:32,746 line:-1
（堆栈保护器）


464
00:28:32,813 --> 00:28:35,983 line:-1
它检测到某些类型的堆栈缓冲区溢出


465
00:28:36,049 --> 00:28:37,651 line:-1
就是我们刚才看到的攻击


466
00:28:38,418 --> 00:28:41,388 line:-2
在许多版本的Xcode中
它已经默认启用了


467
00:28:44,391 --> 00:28:47,261 line:-1
下来我要讲一个更复杂的例子


468
00:28:47,327 --> 00:28:49,029 line:-1
我们引入了一个新的缓解措施


469
00:28:50,697 --> 00:28:54,201 line:-2
假设我取了我的函数
也是我的dlog函数


470
00:28:55,068 --> 00:28:58,005 line:-2
我改变了缓冲区
现在它是一个可变长度的数组


471
00:28:59,106 --> 00:29:01,508 line:-1
长度来自一个叫做len的参数


472
00:29:04,044 --> 00:29:09,716 line:-2
假设在一个特定的调用中
len是很大的 比如15000


473
00:29:10,984 --> 00:29:14,054 line:-2
所以现在堆栈帧必须至少有
15000字节长


474
00:29:16,924 --> 00:29:19,693 line:-1
但是内存并不是立即可用的


475
00:29:20,127 --> 00:29:22,062 line:-1
所以内存被分成了几页


476
00:29:22,663 --> 00:29:25,732 line:-1
而堆栈只在需要时才增长


477
00:29:26,633 --> 00:29:30,804 line:-2
例如当我们试图访问
堆栈下一页中


478
00:29:30,871 --> 00:29:35,075 line:-2
缓冲区的10000个字节时
这仍然是不可用的


479
00:29:35,509 --> 00:29:37,211 line:-1
所以它在CPU中做了一个


480
00:29:37,277 --> 00:29:38,879 line:-1
与操作系统对话的页面错误


481
00:29:39,012 --> 00:29:41,915 line:-1
操作系统看到我们有权力增长堆栈


482
00:29:42,049 --> 00:29:44,084 line:-2
并且它增长了它
我们可以继续编写


483
00:29:44,918 --> 00:29:46,486 line:-1
这些都发生在引擎盖下面


484
00:29:49,056 --> 00:29:53,560 line:-2
但是 如果攻击者控制了长度
它使长度变得很大


485
00:29:53,994 --> 00:29:56,230 line:-1
大到足以跨越许多页


486
00:29:57,865 --> 00:29:59,199 line:-1
所以现在就有了一个新问题


487
00:29:59,867 --> 00:30:04,438 line:-2
内存不是无限的
所以如果我们继续在这个堆栈中分配


488
00:30:04,505 --> 00:30:05,439 line:-1
最终我们会到达


489
00:30:05,506 --> 00:30:07,641 line:-1
另一个已经分配的内存区域


490
00:30:08,008 --> 00:30:09,343 line:-1
通常是堆


491
00:30:10,811 --> 00:30:13,413 line:-2
当我们这样做的时候
我们将会与堆发生冲突


492
00:30:13,714 --> 00:30:15,349 line:-2
与已使用的
任何东西发生冲突


493
00:30:15,415 --> 00:30:17,451 line:-2
这通常是像
malloc和new此类东西


494
00:30:20,587 --> 00:30:23,790 line:-2
如果我们试着看看
strcpy例子会发生什么


495
00:30:24,591 --> 00:30:27,794 line:-2
然后我们试着
把字节一个一个地写下来


496
00:30:30,097 --> 00:30:32,766 line:-1
我们做H-E-L等等


497
00:30:33,667 --> 00:30:35,502 line:-1
从CPU的角度来看


498
00:30:35,569 --> 00:30:37,704 line:-1
生成的代码和操作系统


499
00:30:37,771 --> 00:30:38,805 line:-1
这都没问题


500
00:30:39,006 --> 00:30:42,943 line:-2
因为我们只是在写一个已经可用的
和已经被分配的页面


501
00:30:44,811 --> 00:30:47,681 line:-2
但实际上并非如此
因为这是堆的一部分


502
00:30:47,748 --> 00:30:50,784 line:-1
这不是本地堆栈分配数组的一部分


503
00:30:51,552 --> 00:30:53,353 line:-2
所以当我们写东西的时候
我们实际上是在覆盖


504
00:30:53,420 --> 00:30:56,256 line:-1
一些完全不相关的信息


505
00:30:56,323 --> 00:30:59,693 line:-2
比如我不知道一个布尔值
用来检查我们是否应该检查密码


506
00:31:00,327 --> 00:31:02,663 line:-1
这是另一个重要的安全漏洞


507
00:31:06,967 --> 00:31:09,736 line:-1
这是我们用一个新特性来缓解的


508
00:31:10,871 --> 00:31:14,007 line:-1
这个特性是通过在函数的入口


509
00:31:14,474 --> 00:31:15,676 line:-1
发出些新代码来工作的


510
00:31:16,910 --> 00:31:20,380 line:-1
这个函数检查堆栈框架是否可以使用


511
00:31:21,381 --> 00:31:24,451 line:-1
所以它询问操作系统堆栈的最大空间


512
00:31:25,285 --> 00:31:27,821 line:-1
如果你尝试做一个大于那个的分配


513
00:31:27,888 --> 00:31:29,456 line:-1
那么它实际上就会终止


514
00:31:31,124 --> 00:31:35,028 line:-2
这将把一个潜在的
可利用的安全漏洞


515
00:31:35,395 --> 00:31:38,665 line:-2
变成了可靠的崩溃
这对攻击者没有好处


516
00:31:41,101 --> 00:31:43,670 line:-2
所以这就是堆栈检查
它检测所说的堆栈冲突


517
00:31:43,737 --> 00:31:46,206 line:-1
你可能听说过它


518
00:31:46,907 --> 00:31:48,809 line:-1
在Xcode 10中默认启用它


519
00:31:48,876 --> 00:31:49,877 line:-1
（堆栈检查）


520
00:31:49,943 --> 00:31:52,779 line:-2
（检测“堆栈冲突”
在Xcode 10中默认启用）


521
00:31:53,347 --> 00:31:57,384 line:-2
接下来我想谈谈我们在
Xcode 10中添的一组新特性


522
00:31:57,751 --> 00:32:00,787 line:-2
这就是对新扩展的支持：
设置扩展


523
00:32:02,990 --> 00:32:06,059 line:-2
那么大家都知道
我们有很多很棒的Apple设备


524
00:32:06,793 --> 00:32:10,764 line:-2
Xcode的一个伟大之处在于
只要使用少量的构建设置


525
00:32:10,998 --> 00:32:13,467 line:-2
你就可以针对
这些设备中的每一个设定代码


526
00:32:15,202 --> 00:32:18,872 line:-2
因此在macOS、iOS
watchOS等等的引擎盖下


527
00:32:19,139 --> 00:32:24,278 line:-2
我们对每个都进行了调整
这样它就可以使用特定硬件上


528
00:32:24,511 --> 00:32:26,013 line:-1
所有可用的东西


529
00:32:26,413 --> 00:32:29,449 line:-2
因此无论我们在哪里运行
它都能保证它的最大的性能


530
00:32:31,185 --> 00:32:35,289 line:-2
因此如果你的app
具有极高的性能要求


531
00:32:35,455 --> 00:32:37,724 line:-1
这也是你可能要做的事情


532
00:32:39,760 --> 00:32:41,895 line:-1
因此我们有三个功能可以讨论


533
00:32:42,095 --> 00:32:45,332 line:-2
它们可以用在iMac Pro
和iPhone 8 Plus和X上


534
00:32:47,067 --> 00:32:48,569 line:-1
让我们从iMac Pro开始


535
00:32:51,305 --> 00:32:54,107 line:-2
iMac Pro
有Intel Xeon的CPU


536
00:32:55,976 --> 00:32:59,880 line:-2
它有一组名为
AVX-512的新特性


537
00:33:02,049 --> 00:33:05,853 line:-2
AVX-512是一组
带有矢量寄存器的新指令


538
00:33:08,689 --> 00:33:13,493 line:-1
这些是X86-64的好


539
00:33:13,627 --> 00:33:19,633 line:-2
在X86-64中 我们只能假设
我们有128位矢量可用


540
00:33:20,033 --> 00:33:23,837 line:-2
这在任何Mac电脑上都是可以保证的
这是 Intel提供的


541
00:33:25,105 --> 00:33:28,175 line:-2
现在任何新的Mac电脑
都有了更多的功能


542
00:33:28,742 --> 00:33:32,846 line:-2
但是iMac Pro是第一个有
512位寄存器的


543
00:33:35,682 --> 00:33:39,653 line:-2
在Xcode Clang中
启用了自动矢量化器


544
00:33:40,454 --> 00:33:43,090 line:-2
这很好
因为它意味着


545
00:33:43,156 --> 00:33:45,192 line:-1
我们可以在向量中有更多的元素


546
00:33:46,126 --> 00:33:48,228 line:-1
这样可以大大提高吞吐量


547
00:33:51,198 --> 00:33:53,166 line:-1
AVX-512还有其他好处


548
00:33:53,567 --> 00:33:57,538 line:-1
例如我们不仅有更大的向量


549
00:33:57,905 --> 00:33:59,239 line:-1
我们还有更多的向量


550
00:33:59,840 --> 00:34:03,343 line:-2
所以在X86-64上我们只有16
现在我们有32


551
00:34:03,710 --> 00:34:05,412 line:-1
所以是大量的数据需要处理


552
00:34:07,247 --> 00:34:09,783 line:-1
即使由于某种原因自动向量器


553
00:34:09,850 --> 00:34:13,253 line:-1
无法使用这些向量


554
00:34:13,620 --> 00:34:16,290 line:-1
那么我们仍然有更多的技能寄存器


555
00:34:16,356 --> 00:34:18,692 line:-2
甚至对于那些只会浮动或加倍的代码
也是如此


556
00:34:20,127 --> 00:34:22,329 line:-1
在AVX-512中有很多性能优势


557
00:34:24,197 --> 00:34:26,900 line:-1
以让我们看看我们如何


558
00:34:27,000 --> 00:34:29,536 line:-2
利用我的计算
量大、昂贵的函数来开发它


559
00:34:31,772 --> 00:34:35,509 line:-2
所以我要做的第一件事就是
保留现有的功能


560
00:34:36,076 --> 00:34:39,880 line:-2
因为这将是我在所有Mac上
运行的可以依靠的东西


561
00:34:41,681 --> 00:34:43,684 line:-1
接下来我可以尝试专门化我的函数


562
00:34:44,217 --> 00:34:46,786 line:-1
一种方法是使用目标属性


563
00:34:49,188 --> 00:34:51,692 line:-2
这告诉编译器
可以假设


564
00:34:51,757 --> 00:34:55,395 line:-2
这个函数有AVX-512
它只运行在iMac Pro上


565
00:34:57,364 --> 00:35:01,735 line:-2
因此如果你使用simd.h 例如
simd_float4 128位向量类型


566
00:35:02,636 --> 00:35:05,572 line:-2
现在我们可以使用相同的代码
在AVX-512 版本上


567
00:35:05,839 --> 00:35:06,840 line:-1
获得更好的性能


568
00:35:09,109 --> 00:35:11,445 line:-1
如果你使用更大的向量类型


569
00:35:11,512 --> 00:35:13,514 line:-1
比如 simd浮点数16


570
00:35:13,580 --> 00:35:16,583 line:-2
那么现在你的性能要比
AVX-512版本好得多


571
00:35:17,117 --> 00:35:19,453 line:-2
AVX-512版本中
512位矢量实际是负的


572
00:35:22,022 --> 00:35:24,691 line:-1
如果你一直伸入到到X86本质


573
00:35:24,925 --> 00:35:27,694 line:-2
那么现在你可以开始使用新的
AVX-512方差


574
00:35:28,095 --> 00:35:29,796 line:-1
和M512类型


575
00:35:32,866 --> 00:35:35,602 line:-1
因此如果你想专攻更大的代码单元


576
00:35:35,669 --> 00:35:40,307 line:-2
那么不仅是单个函数
还有文件、目标、库


577
00:35:40,707 --> 00:35:43,577 line:-1
然后你可以使用附加向量扩展构建


578
00:35:43,644 --> 00:35:46,113 line:-1
设置的新的AVX-512值


579
00:35:46,180 --> 00:35:49,349 line:-2
（在XCODE中
启用AVX-512）


580
00:35:49,416 --> 00:35:51,919 line:-2
所以当你这样做的时候
有一些事情要记住


581
00:35:51,985 --> 00:35:56,790 line:-2
如果你熟悉AVX-1和AVX-2
这些都是非常相似的问题


582
00:35:56,857 --> 00:35:58,759 line:-1
（AVX-512考虑）


583
00:35:58,825 --> 00:36:02,629 line:-2
所以你只能从
AVX-512函数传递或


584
00:36:03,197 --> 00:36:05,265 line:-2
向AVX-512函数传递大的向量
比如256位和更大的位


585
00:36:05,566 --> 00:36:09,436 line:-2
因此如果ABI与
一般的和特殊的方差是不一样的话


586
00:36:09,770 --> 00:36:11,138 line:-1
你就不能把它们传递给它们


587
00:36:14,107 --> 00:36:17,144 line:-1
此外这些向量很大


588
00:36:17,211 --> 00:36:20,681 line:-2
而且它们足够大
以至于它们的自然对齐度太大


589
00:36:20,948 --> 00:36:23,083 line:-2
无法像malloc
这样的东西来保证


590
00:36:23,150 --> 00:36:25,786 line:-2
因此在将这些分配到
堆栈以外的任何地方时


591
00:36:26,353 --> 00:36:27,754 line:-1
都必须考虑到这一点


592
00:36:30,457 --> 00:36:32,659 line:-2
所以总的来说
所有这些都是


593
00:36:32,726 --> 00:36:36,196 line:-1
我们在操作系统中已经历过的


594
00:36:36,263 --> 00:36:39,733 line:-1
例如你可以使用加速框架


595
00:36:39,800 --> 00:36:41,368 line:-1
就容易多了


596
00:36:41,568 --> 00:36:43,871 line:-1
因为我们已经专门为每一个微架构


597
00:36:44,004 --> 00:36:45,739 line:-1
提供了所有的功能


598
00:36:48,542 --> 00:36:49,810 line:-1
这就是AVX-512


599
00:36:51,545 --> 00:36:56,149 line:-2
iPhone 8、8 Plus
和X都有新功能


600
00:36:59,286 --> 00:37:03,457 line:-2
那么第一个功能是
ARM v8.1原子


601
00:37:04,958 --> 00:37:09,696 line:-2
这得益于iPhone X
的一个伟大的东西


602
00:37:10,497 --> 00:37:12,232 line:-1
这是A11 Bionic芯片


603
00:37:16,370 --> 00:37:22,843 line:-2
因此与A10相比
A11 Bionic芯片有很棒的新功能


604
00:37:23,043 --> 00:37:28,182 line:-2
它支持六个CPU
六个核心同时运行


605
00:37:28,949 --> 00:37:30,083 line:-1
这在iOS系统中


606
00:37:32,452 --> 00:37:34,288 line:-1
是第一个而且由于你有更多的内核


607
00:37:34,354 --> 00:37:36,823 line:-1
所以你可能同时拥有更多的线程


608
00:37:37,124 --> 00:37:37,991 line:-1
使用更多的线程


609
00:37:38,058 --> 00:37:41,328 line:-2
你可能需要更多的同步
来使这些线程协作


610
00:37:42,729 --> 00:37:44,498 line:-1
这是用原子实现的


611
00:37:45,699 --> 00:37:49,570 line:-2
A11 Bionic还引入了
一个新的原子指令系列


612
00:37:49,837 --> 00:37:54,808 line:-1
更好地优化了新的额外的核心


613
00:37:57,344 --> 00:37:58,745 line:-1
让我们来看看它是如何工作的


614
00:38:00,681 --> 00:38:05,085 line:-2
原子的工作方式
是通过一个小的代码序列


615
00:38:05,853 --> 00:38:09,489 line:-2
假设我有一个线程
它试图访问主存储器


616
00:38:10,424 --> 00:38:13,093 line:-1
所以它在那里有一个原子共享变量


617
00:38:13,694 --> 00:38:15,362 line:-1
它只是想要增加它


618
00:38:15,429 --> 00:38:17,431 line:-1
（原子）


619
00:38:17,497 --> 00:38:21,134 line:-2
因此在引擎盖下
代码生成器将发出一个小代码序列


620
00:38:22,002 --> 00:38:25,405 line:-2
该代码首先对高速缓存
行进行独占访问


621
00:38:25,939 --> 00:38:27,774 line:-1
这是完全包含


622
00:38:27,941 --> 00:38:30,844 line:-1
该原子变量的一个小的内存区域


623
00:38:33,747 --> 00:38:36,783 line:-2
现在我们拥有独占访问权
可以从变量加载


624
00:38:37,351 --> 00:38:40,254 line:-1
并且可以在临时加载值上进行增量


625
00:38:40,754 --> 00:38:42,456 line:-1
并将结果存储起来


626
00:38:44,825 --> 00:38:47,427 line:-2
我们知道这是安全的
因为我们有独占访问权


627
00:38:47,694 --> 00:38:49,930 line:-1
所以在计算临时结果时


628
00:38:50,030 --> 00:38:52,366 line:-1
没有其他线程可以更改值


629
00:38:53,934 --> 00:38:57,804 line:-2
但是现在假设有另一个线程
也要访问同一缓存行中的


630
00:38:57,871 --> 00:39:00,107 line:-1
相同变量或另一个变量


631
00:39:02,709 --> 00:39:04,211 line:-1
所以两者都会尝试


632
00:39:04,278 --> 00:39:06,780 line:-1
对这个变量进行排他性访问


633
00:39:07,614 --> 00:39:10,517 line:-2
这是不可能的
这就是排他性的意思


634
00:39:12,219 --> 00:39:15,656 line:-1
因此它们都将无法获得独家访问权


635
00:39:16,557 --> 00:39:19,426 line:-2
它们将不得不再次尝试
直到其中一个成功


636
00:39:22,029 --> 00:39:23,730 line:-1
这对性能来说并不是好东西


637
00:39:25,966 --> 00:39:31,171 line:-2
因此在ARM v8.1中
它是A10 CPU中的体系结构


638
00:39:31,371 --> 00:39:33,974 line:-2
我们有新的指令
在一步内完成所有这些操作


639
00:39:34,408 --> 00:39:37,010 line:-1
在某些情况下这可以极大地提高性能


640
00:39:38,412 --> 00:39:41,215 line:-2
因此这也是你可以
使用每个函数专门化方法或


641
00:39:41,448 --> 00:39:45,986 line:-1
针对整个目标而专门化代码的东西


642
00:39:47,120 --> 00:39:49,122 line:-2
只有当你有自己的C11
或C++ 11原子时


643
00:39:49,189 --> 00:39:52,125 line:-1
它才是真正有用的东西


644
00:39:53,093 --> 00:39:56,697 line:-2
因此一般来说
使用更高级别的库


645
00:39:56,763 --> 00:39:59,533 line:-2
例如像GCD或PThread
或os_unfair_lock等容易得多


646
00:40:00,901 --> 00:40:03,070 line:-2
这些已经对
ARM v8.1进行了调整


647
00:40:03,303 --> 00:40:05,506 line:-1
但它们也与操作系统合作


648
00:40:05,606 --> 00:40:07,107 line:-1
以获得更好的性能


649
00:40:11,144 --> 00:40:15,349 line:-2
A11 CPU的另一个特性是
16位浮点数


650
00:40:16,250 --> 00:40:20,587 line:-1
大家都很熟悉两种标准的浮点类型


651
00:40:20,654 --> 00:40:22,956 line:-1
所以我们有两者64位


652
00:40:23,290 --> 00:40:24,958 line:-1
和浮点32位


653
00:40:26,093 --> 00:40:29,897 line:-2
所以在A11中我们也有
16位浮点数16


654
00:40:30,931 --> 00:40:37,104 line:-2
它的范围和精度都要小得多
所以它在很多情况下都不那么有用


655
00:40:38,038 --> 00:40:39,339 line:-1
但在某些情况下 比如机器学习


656
00:40:39,406 --> 00:40:41,441 line:-2
或当你试图通过Metal
与GPU交谈时


657
00:40:41,608 --> 00:40:44,378 line:-2
这是很棒的
因为它更小 计算更快


658
00:40:45,445 --> 00:40:47,714 line:-2
如果把它们放到向量中
这就更对了


659
00:40:47,948 --> 00:40:50,450 line:-2
在此你可以把它们更多的放在
同一个ARM向量中


660
00:40:53,353 --> 00:40:55,956 line:-1
因此这也是你可以专门化代码的东西


661
00:40:56,890 --> 00:40:59,826 line:-1
一般来说需要记住的是


662
00:41:00,494 --> 00:41:02,429 line:-1
这些特性并不是随处可见的


663
00:41:03,463 --> 00:41:06,533 line:-2
因此当你想使用它们时
必须始终确保它们


664
00:41:06,600 --> 00:41:08,569 line:-2
在运行的设备上是动态可用的
并且可以使用


665
00:41:08,635 --> 00:41:09,937 line:-1
sysctlbyname


666
00:41:10,337 --> 00:41:12,239 line:-1
来实现


667
00:41:12,306 --> 00:41:14,074 line:-1
（检测指令集扩展）


668
00:41:14,141 --> 00:41:16,577 line:-2
因此总的来说
我们已经在


669
00:41:16,643 --> 00:41:18,946 line:-2
系统框架中完成了所有工作
靠这些就更容易了


670
00:41:21,849 --> 00:41:24,084 line:-1
这是三个新的指令集扩展


671
00:41:24,484 --> 00:41:26,320 line:-2
在iMac Pro
AVX-512上


672
00:41:26,386 --> 00:41:30,824 line:-2
在iPhone X、8和8 Plus上
我们有原子和16位浮点数


673
00:41:30,891 --> 00:41:33,360 line:-1
（新指令集扩展）


674
00:41:33,827 --> 00:41:36,563 line:-2
这就是Xcode中
所有新特性的一部分


675
00:41:37,264 --> 00:41:41,668 line:-2
所以从C结构的ARC对象指针
到改进的静态分析器


676
00:41:41,969 --> 00:41:43,837 line:-2
Xcode 10中
有很多很棒的东西


677
00:41:45,005 --> 00:41:47,174 line:-1
还有一些我们甚至没有讨论过的东西


678
00:41:47,441 --> 00:41:49,610 line:-1
比如超过100个新的警告


679
00:41:49,810 --> 00:41:53,614 line:-1
支持C++ 17标准库函数


680
00:41:55,782 --> 00:41:57,284 line:-1
如果你想了解更多


681
00:41:57,351 --> 00:42:00,487 line:-2
我们将很快有视频和幻灯片
在网站上提供


682
00:42:01,088 --> 00:42:04,424 line:-2
如果你出席了本场会议
今天下午和我们一起去实验室吧


683
00:42:04,892 --> 00:42:05,893 line:-1
谢谢大家

