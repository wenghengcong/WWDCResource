1
00:00:17,484 --> 00:00:21,822 line:0
（在SwiftShot内
创建增强现实游戏）


2
00:00:21,889 --> 00:00:23,123 line:0
（演讲605）


3
00:00:29,530 --> 00:00:33,233 line:-2
大家好 我是Alex 我是
Apple工具基础小组的一名员工


4
00:00:33,300 --> 00:00:36,403 line:-2
通常我们会做一些有意思的东西
比如操作系统和编译器


5
00:00:36,803 --> 00:00:38,739 line:-1
但今年我们做了一些不同的东西


6
00:00:38,972 --> 00:00:40,641 line:-2
我们创建了一个叫做
SwiftShot的游戏


7
00:00:41,041 --> 00:00:45,179 line:-2
有些人可能在今天早些时候见过它了
你可能在楼下玩过这个游戏了


8
00:00:46,213 --> 00:00:48,849 line:-1
但重要的部分是SwiftShot


9
00:00:48,916 --> 00:00:52,352 line:-2
是ARKit中一些新功能的
一个展示


10
00:00:53,053 --> 00:00:56,990 line:-2
ARKit 2现在可在
成千上万台设备上可用了


11
00:00:57,558 --> 00:01:00,727 line:-1
提供了一个增强AR体验的平台


12
00:01:01,161 --> 00:01:04,197 line:-1
你可以通过它实现尽可能多的观众


13
00:01:04,864 --> 00:01:06,033 line:-1
并没有什么特别的设置


14
00:01:06,533 --> 00:01:10,003 line:-2
只是把设备的摄像头指向
某个表面然后就开始游戏


15
00:01:12,072 --> 00:01:13,841 line:-1
它已经集成到iOS中


16
00:01:14,875 --> 00:01:17,945 line:-2
第一方和第三方引擎 比如
SceneKit和SpriteKit


17
00:01:18,278 --> 00:01:21,481 line:-2
以及第三方
比如Unreal和Unity


18
00:01:22,115 --> 00:01:23,884 line:-1
在这点上都是完全集成


19
00:01:28,689 --> 00:01:29,756 line:-1
这是一个演讲概述


20
00:01:30,123 --> 00:01:32,492 line:-1
首先我们要讲一些游戏设计原则


21
00:01:32,559 --> 00:01:35,762 line:-2
针对增强现实
是我们在开发过程中学到的东西


22
00:01:36,864 --> 00:01:40,601 line:-1
我们要深入到内部 特别是


23
00:01:40,667 --> 00:01:43,837 line:-2
要讲到WorldMap分享
它是ARKit 2中的新功能


24
00:01:44,505 --> 00:01:47,875 line:-2
我们还要讲网络和物理
以及我们要如何使用它们


25
00:01:49,109 --> 00:01:52,145 line:-2
首先让我们 你知道的
深入了解一下游戏


26
00:02:25,879 --> 00:02:30,918 line:-1
（胜利！）


27
00:02:31,685 --> 00:02:32,519 line:-1
好的


28
00:02:34,488 --> 00:02:37,724 line:-2
让我们稍微讲一下
针对增强现实设计游戏


29
00:02:40,460 --> 00:02:43,163 line:-1
游戏设置高于一切


30
00:02:45,032 --> 00:02:46,900 line:-2
你该问自己
如果你正在设计一款游戏


31
00:02:46,967 --> 00:02:51,939 line:-2
如果它只是70年代的图形
或平面、灰色的方块


32
00:02:52,005 --> 00:02:55,475 line:-1
这个游戏会有意思和令人兴奋吗？


33
00:02:56,343 --> 00:02:59,513 line:-1
值得用那种插图来设计原型


34
00:03:00,180 --> 00:03:02,082 line:-1
搞定游戏设置


35
00:03:02,149 --> 00:03:04,551 line:-2
因为如果那些无聊的灰色方框
有意思的话


36
00:03:04,852 --> 00:03:07,454 line:-2
那么当你稍后添加这些图形
和声音时也会很有意思


37
00:03:08,922 --> 00:03:10,724 line:-1
你应该花点时间改良一下


38
00:03:10,791 --> 00:03:14,928 line:-2
不要说服你自己说
如果我只增加5%的图形


39
00:03:14,995 --> 00:03:17,798 line:-2
或者哪一个功能
游戏就会突然变得有意思了


40
00:03:18,465 --> 00:03:20,734 line:-1
因为你知道的有许多被遗弃的游戏


41
00:03:20,801 --> 00:03:22,803 line:-1
从一开始就一点儿意思都没有


42
00:03:22,870 --> 00:03:24,938 line:-1
因此请不要尝试愚弄你自己


43
00:03:27,040 --> 00:03:28,242 line:-1
让我们从游戏设置开始


44
00:03:31,445 --> 00:03:32,613 line:-1
保持游戏简短


45
00:03:34,014 --> 00:03:36,650 line:-1
你正在寻找一个典型的移动设备体验


46
00:03:37,284 --> 00:03:38,552 line:-1
轻松进入 轻松退出


47
00:03:41,455 --> 00:03:46,293 line:-2
你想保留各种各样的内容
新鲜、避免心理疲劳


48
00:03:46,360 --> 00:03:49,196 line:-2
就游戏玩家而言
他们不想一遍一遍地重复同一件事


49
00:03:52,332 --> 00:03:54,701 line:-2
我们所了解到的其中一件事就是
观看游戏看起来


50
00:03:54,768 --> 00:03:56,203 line:-1
跟玩游戏一样有意思


51
00:03:56,503 --> 00:03:59,106 line:-2
坐在场外并观看游戏
就像它是一场运动比赛


52
00:03:59,173 --> 00:04:00,340 line:-1
从这边到那边


53
00:04:00,974 --> 00:04:03,510 line:-1
那就是一种很愉悦的体验


54
00:04:03,977 --> 00:04:04,978 line:-1
你们需要思考这一点


55
00:04:07,814 --> 00:04:10,717 line:-1
游戏是社交和私人互动的关键形式


56
00:04:12,619 --> 00:04:16,055 line:-1
增强现实可以提供一种私人触碰


57
00:04:16,490 --> 00:04:19,793 line:-2
你以前可能有过这种感觉
在玩比如说传统卡牌游戏时


58
00:04:19,860 --> 00:04:21,562 line:-1
和家里的长辈一起围在桌子旁边


59
00:04:22,029 --> 00:04:25,666 line:-2
但现在有一种技术
可以帮助你改善这种体验


60
00:04:29,036 --> 00:04:33,707 line:-2
做一个3D游戏并把它放在
你面前的桌子上还远远不够


61
00:04:34,374 --> 00:04:37,077 line:-2
通过增强现实
你知道设备是如何放置的


62
00:04:37,644 --> 00:04:40,514 line:-1
你还对用户的环境有了一些了解


63
00:04:40,881 --> 00:04:43,116 line:-1
你应该尝试在游戏中利用这一点


64
00:04:43,183 --> 00:04:46,620 line:-2
并营造一种
以增强现实为首要的良好体验


65
00:04:52,192 --> 00:04:56,163 line:-2
你的设备可以用作一个摄像头
用于查看聚焦对象的内部


66
00:04:57,064 --> 00:04:59,600 line:-1
在本例中 这是一个3D解谜游戏


67
00:04:59,666 --> 00:05:02,135 line:-1
我们想修复一个坏掉的花瓶


68
00:05:02,202 --> 00:05:03,370 line:-1
我们可以四处查看


69
00:05:03,670 --> 00:05:06,607 line:-2
了解哪个碎片在哪里
并尽我们最大努力进行修复


70
00:05:07,574 --> 00:05:09,676 line:-2
在SwiftShot中
用了类似概念


71
00:05:10,010 --> 00:05:13,380 line:-2
重点是你正在玩游戏的桌子
并且你可以在桌子周围四处走动


72
00:05:13,947 --> 00:05:17,384 line:-2
但桌子并不只是用于
增强现实的一个追踪表面


73
00:05:17,451 --> 00:05:18,952 line:-1
它是游戏设置不可分割的部分


74
00:05:19,920 --> 00:05:23,891 line:-1
桌子的高度实际上很重要


75
00:05:23,957 --> 00:05:26,994 line:-2
因此你会在游戏中
看到有不同高度的弹弓


76
00:05:27,060 --> 00:05:31,465 line:-2
在砖堆顶部
以便给你提供更好的射击


77
00:05:31,532 --> 00:05:34,735 line:-1
或稍微利用一下玩家的闪避和穿梭


78
00:05:37,771 --> 00:05:41,408 line:-2
另一个原则是你的设备即是
你用来四处查看的摄像机


79
00:05:43,343 --> 00:05:44,211 line:-1
在本例中


80
00:05:46,246 --> 00:05:48,115 line:-1
我们要寻找藏在荒野中的独角兽


81
00:05:48,348 --> 00:05:50,817 line:-1
并且我们会给它们拍照片


82
00:05:53,387 --> 00:05:55,622 line:-1
它们就在你周围而非里面


83
00:06:00,060 --> 00:06:02,729 line:-2
设备还可以是
进入另一个时空的大门


84
00:06:02,963 --> 00:06:05,332 line:-1
你不需要直接看摄像机所看到的东西


85
00:06:06,333 --> 00:06:08,168 line:-1
可以彻底替换你所处的环境


86
00:06:08,535 --> 00:06:11,538 line:-1
可能会打破或完全修改物理定律


87
00:06:12,272 --> 00:06:13,740 line:-2
无论你需做什么
要让它有意思


88
00:06:14,208 --> 00:06:16,977 line:-2
在本例中 我们可以看到星星
即使在白天也很亮


89
00:06:21,381 --> 00:06:23,450 line:-1
同时 你的设备自身就可以是控制器


90
00:06:26,019 --> 00:06:28,355 line:-1
你可以让自己融合到虚拟世界中


91
00:06:29,022 --> 00:06:30,591 line:-1
把设备作为控制器


92
00:06:30,858 --> 00:06:34,494 line:-1
在这个例子中 我们用磁力拿起砖头


93
00:06:34,561 --> 00:06:35,896 line:-1
并把它们放在立方体中


94
00:06:36,663 --> 00:06:38,632 line:-2
这就是SwiftShot中
交互作用的重点


95
00:06:39,766 --> 00:06:42,102 line:-1
你想鼓励设备进行缓慢的移动


96
00:06:42,903 --> 00:06:45,606 line:-2
那就会给相机提供最佳图像
而不是运动模糊的图像


97
00:06:45,672 --> 00:06:47,274 line:-1
然后就能在追踪时做到最好


98
00:06:48,709 --> 00:06:51,211 line:-1
不管这些设备有多么细、多么轻


99
00:06:51,879 --> 00:06:54,681 line:-2
用手臂的力量四处摇晃它们
看起来会有些累


100
00:06:54,748 --> 00:06:56,917 line:-1
因此你要寻找慢并且从容的动作


101
00:06:59,786 --> 00:07:02,089 line:-1
你想鼓励玩家在场地四周移动


102
00:07:02,623 --> 00:07:05,526 line:-1
在本例中 我们对敌人的弹弓射击


103
00:07:05,592 --> 00:07:07,394 line:-1
被那些砖块阻碍了


104
00:07:07,995 --> 00:07:10,397 line:-1
所以我们要移动到另一个弹弓处


105
00:07:10,631 --> 00:07:11,865 line:-1
清除障碍


106
00:07:19,339 --> 00:07:21,275 line:-1
控制反馈对于沉浸式体验来说很重要


107
00:07:22,943 --> 00:07:26,613 line:-2
在SwiftShot中
我们通过音频和触觉来提供反馈


108
00:07:27,548 --> 00:07:31,818 line:-2
有各种各样的动态行为
手机上有拉伸弹弓带的声音


109
00:07:32,452 --> 00:07:36,957 line:-2
和触觉效果
给你一种你正在打弹弓的感觉


110
00:07:37,391 --> 00:07:40,127 line:-1
我们稍后再具体讲动态音频


111
00:07:43,263 --> 00:07:45,832 line:-2
接下来我要邀请
David Paschich上台


112
00:07:45,899 --> 00:07:48,235 line:-2
他会深入讲解SwiftShot
具体信息 谢谢


113
00:07:50,237 --> 00:07:51,071 line:-1
David？


114
00:07:54,074 --> 00:07:55,542 line:-1
谢谢Alex 大家好


115
00:07:56,977 --> 00:08:00,347 line:-2
我只是想重复一下
Alex刚才所说的内容


116
00:08:00,414 --> 00:08:02,983 line:-2
我们从参加SwiftShot演讲的人那儿
得到的响应是非常令人吃惊的


117
00:08:03,050 --> 00:08:06,386 line:-1
我们看到有些人已经下载它


118
00:08:06,453 --> 00:08:08,488 line:-2
创建它和用示例代码替换它
我们很欣慰


119
00:08:08,555 --> 00:08:10,991 line:-1
那么谢谢大家 我们真的非常激动


120
00:08:11,925 --> 00:08:15,162 line:-1
我首先想要谈谈


121
00:08:15,229 --> 00:08:16,230 line:-1
用于创建SwiftShot的技术


122
00:08:17,064 --> 00:08:18,799 line:-2
第一个也是最重要的一个
是ARKit


123
00:08:19,132 --> 00:08:21,869 line:-2
可以让我们把内容
渲染到玩家周围的物理世界中


124
00:08:21,935 --> 00:08:24,571 line:-1
让他们沉浸到游戏体验中


125
00:08:26,640 --> 00:08:31,612 line:-2
我们用SceneKit来管理
和绘制内容 用高级3D渲染


126
00:08:31,678 --> 00:08:33,580 line:-1
和现实物理来实现有趣的游戏设置


127
00:08:35,148 --> 00:08:39,586 line:-2
Metal可以让我们更好地利用
GPU设备


128
00:08:39,653 --> 00:08:43,924 line:-2
它在SceneKit内
用于着色和渲染


129
00:08:43,991 --> 00:08:47,361 line:-1
也用于旗子模拟 我稍后会讲到


130
00:08:48,829 --> 00:08:51,465 line:-2
GameplayKit
给我们的游戏对象


131
00:08:51,865 --> 00:08:52,699 line:-1
提供了组件架构实体


132
00:08:52,766 --> 00:08:55,869 line:-2
它让我们在游戏的对象之间
轻松地分享行为


133
00:08:57,671 --> 00:09:00,541 line:-1
多点连通提供了网络层


134
00:09:01,208 --> 00:09:04,144 line:-1
包括发现周围的设备和同步


135
00:09:04,711 --> 00:09:06,113 line:-1
以及加密


136
00:09:07,581 --> 00:09:10,684 line:-2
AV Foundation
既控制音乐气氛


137
00:09:10,751 --> 00:09:13,020 line:-1
又给设备提供声音效果


138
00:09:13,086 --> 00:09:15,022 line:-1
真的给你营造了那种沉浸式体验


139
00:09:16,089 --> 00:09:18,959 line:-2
最后我们在Swift中
创建了完整的app


140
00:09:19,393 --> 00:09:22,329 line:-1
Swift的键入安全性、性能


141
00:09:24,031 --> 00:09:26,466 line:-1
和高级功能 比如协议扩展


142
00:09:26,533 --> 00:09:28,235 line:-1
可以让我们更多地关注游戏设置


143
00:09:28,302 --> 00:09:29,903 line:-1
不那么担心崩溃


144
00:09:29,970 --> 00:09:32,239 line:-1
和代码层之间的界面不匹配


145
00:09:35,309 --> 00:09:37,177 line:-1
那就是我们所使用的iOS技术


146
00:09:37,578 --> 00:09:38,946 line:-1
谈谈我们如何使用这些技术


147
00:09:39,012 --> 00:09:41,348 line:-1
帮助我们实施游戏中的某些功能


148
00:09:41,782 --> 00:09:44,051 line:-1
建立共享坐标空间、


149
00:09:44,751 --> 00:09:48,922 line:-1
网络、物理、资产重要性和管理


150
00:09:49,756 --> 00:09:52,125 line:-1
旗子模拟和动态音频


151
00:09:55,162 --> 00:09:58,098 line:-1
我们要从设置共享坐标空间开始讲


152
00:09:59,466 --> 00:10:02,569 line:-2
游戏体验的关键因素是让玩家
看到同一个空间中的同一个对象


153
00:10:02,636 --> 00:10:04,471 line:-1
在各自的设备上


154
00:10:04,838 --> 00:10:07,374 line:-1
为此我们需要一个共享坐标空间


155
00:10:07,975 --> 00:10:11,445 line:-2
允许他们以跟现实世界中
相同的方式谈论位置信息


156
00:10:13,647 --> 00:10:16,750 line:-2
ARKit提供了一系列
可用于设置这个的功能


157
00:10:17,384 --> 00:10:20,854 line:-2
在iOS 11.3中
我们引入了图像识别


158
00:10:20,921 --> 00:10:23,423 line:-1
允许你的app识别你周围的图像


159
00:10:24,758 --> 00:10:28,262 line:-2
现在在iOS 12中
我们添加了两个额外的技术：


160
00:10:28,529 --> 00:10:31,031 line:-1
对象检测和世界地图共享


161
00:10:32,332 --> 00:10:34,768 line:-1
图像检测和对象检测


162
00:10:34,835 --> 00:10:37,871 line:-2
都可以让你针对用户在现实世界中
看到的东西添加内容


163
00:10:37,938 --> 00:10:41,208 line:-2
但它们要求你必须对这些对象
进行预录 用于稍后的识别


164
00:10:41,675 --> 00:10:43,777 line:-1
你可在Lego演示的演讲稿中看到


165
00:10:43,844 --> 00:10:46,046 line:-1
识别建造模型和添加内容


166
00:10:48,015 --> 00:10:50,851 line:-2
对于这款游戏 我们想让用户
在有桌子的任何地方玩游戏


167
00:10:50,918 --> 00:10:52,853 line:-1
比如咖啡馆、他们的厨房等等


168
00:10:53,120 --> 00:10:54,588 line:-2
我们的实现方式是
WorldMap共享


169
00:10:55,689 --> 00:10:58,492 line:-2
你还可以在游戏以外的app中
app此技术


170
00:10:58,559 --> 00:11:01,728 line:-2
比如在零售环境
或博物馆中的固定安装


171
00:11:02,763 --> 00:11:06,400 line:-2
楼下游戏室内 我们用了
iBeacon 因此设备就知道


172
00:11:06,466 --> 00:11:11,772 line:-2
它们相邻的桌子是哪个并为该区域
加载正确的WorldMap


173
00:11:12,272 --> 00:11:14,007 line:-1
那真的会让体验变得很魔幻


174
00:11:16,577 --> 00:11:17,911 line:-1
SwiftShot的一个特性


175
00:11:17,978 --> 00:11:19,746 line:-2
你可能用过
如果你自己创建过app


176
00:11:19,813 --> 00:11:24,451 line:-2
即允许玩家把游戏板
放在虚拟世界中的能力


177
00:11:24,885 --> 00:11:27,354 line:-2
在楼下的桌子上
我们使用了预加载地图


178
00:11:27,421 --> 00:11:29,756 line:-2
但这里有一个例子
关于创建你自己的游戏板


179
00:11:29,823 --> 00:11:31,425 line:-1
并把它放在虚拟世界中


180
00:11:33,894 --> 00:11:35,028 line:-1
这是如何创建


181
00:11:36,029 --> 00:11:38,799 line:-2
正如你在视频中所看到的
你从扫描表面开始


182
00:11:38,866 --> 00:11:40,934 line:-1
让ARKit创建该区域的地图


183
00:11:42,603 --> 00:11:44,872 line:-1
然后你可以把那个地图序列化为数据


184
00:11:44,938 --> 00:11:46,507 line:-1
并把它转换到另一台设备上


185
00:11:47,975 --> 00:11:51,178 line:-2
目标设备就会把地图加载到
ARKit中并使用它


186
00:11:51,245 --> 00:11:52,880 line:-1
来识别同一个表面


187
00:11:53,247 --> 00:11:56,416 line:-2
在那点上
我们拥有现实世界中的共享基准点


188
00:11:56,483 --> 00:12:00,687 line:-2
两台设备都可以把游戏板
渲染到那个世界中的同一个位置


189
00:12:02,856 --> 00:12:04,458 line:-1
实施的第一个步骤


190
00:12:04,525 --> 00:12:07,294 line:-2
从第一台设备上的
ARSession中获取世界地图


191
00:12:08,161 --> 00:12:12,866 line:0
这就是iOS 12在ARSession中
对一个新API的调用 getCurrentWorldMap


192
00:12:13,367 --> 00:12:15,135 line:0
它创建了一个
ARWorldMap对象


193
00:12:15,202 --> 00:12:17,771 line:0
根据会话当前对你周围世界的了解


194
00:12:18,172 --> 00:12:20,340 line:0
然后把它返回到一个异步回调中


195
00:12:20,941 --> 00:12:22,776 line:0
然后我们使用
NSKeyedArchiver


196
00:12:23,677 --> 00:12:25,879 line:0
把它序列化为数据对象


197
00:12:26,380 --> 00:12:28,882 line:0
然后你可以保存数据
或把它发送到网络上


198
00:12:31,585 --> 00:12:33,187 line:-1
一旦你拥有那个数据对象


199
00:12:33,520 --> 00:12:36,056 line:-2
然后你要决定如何把它
从一台设备转到另台设备上


200
00:12:36,557 --> 00:12:39,026 line:-2
对于特设游戏
比如你在视频中看到的游戏


201
00:12:39,459 --> 00:12:41,595 line:-2
SwiftShot使用
点对点网络连接


202
00:12:41,662 --> 00:12:43,497 line:-1
我们会在立刻获得更多细节


203
00:12:44,565 --> 00:12:46,567 line:-1
当第二胎设备连接到网络会话中时


204
00:12:47,000 --> 00:12:50,370 line:-2
第一台设备序列化WorldMap
并把它发送到网络上


205
00:12:50,838 --> 00:12:52,806 line:-1
这对于博弈游戏的情况来说很棒


206
00:12:52,873 --> 00:12:56,243 line:-2
用户在任何拥有一个表面的地方
都能玩游戏


207
00:12:58,846 --> 00:13:01,615 line:-2
对于楼下的游戏桌而言
我们用了一个不同的方式


208
00:13:01,682 --> 00:13:04,384 line:-1
我们在设置期间花了一些时间


209
00:13:04,451 --> 00:13:06,520 line:-2
让大会录制每张桌子的
WorldMap


210
00:13:06,954 --> 00:13:08,322 line:-1
确保我们从多角度本地化


211
00:13:08,388 --> 00:13:10,591 line:-1
那个共享坐标空间


212
00:13:11,191 --> 00:13:13,327 line:-1
每张桌子都有自己的唯一特性


213
00:13:13,393 --> 00:13:16,063 line:-1
并且灯光和位置都稍微有点不一样


214
00:13:17,030 --> 00:13:19,833 line:-2
然后我们把文件保存到
每台设备上的本地存储中


215
00:13:20,634 --> 00:13:23,270 line:-2
因为使用中的设备
是由我们的会议团队管理的


216
00:13:23,337 --> 00:13:25,405 line:-1
我们可以使用移动设备管理


217
00:13:25,472 --> 00:13:30,878 line:-2
来确保同样的文件
出现在游戏中的每台设备上


218
00:13:32,546 --> 00:13:36,450 line:-2
要让方案更加流畅
你在每台桌子上使用iBeacon


219
00:13:36,717 --> 00:13:40,721 line:-2
通过用特定的WorldMap
关联iBeacon的标识符


220
00:13:40,787 --> 00:13:42,890 line:-2
SwiftShot app
的每个实例


221
00:13:42,956 --> 00:13:44,858 line:-2
都可自动加载正确的
WorldMap


222
00:13:45,626 --> 00:13:49,463 line:-2
现在如果你正在创建一个消费者app
你也可以使用


223
00:13:49,763 --> 00:13:52,966 line:-1
像iOS的按需资源一样的东西


224
00:13:53,033 --> 00:13:56,770 line:-2
或你自己的云共享方案
在设备间共享WorldMap


225
00:13:57,171 --> 00:14:00,474 line:-2
这将允许你
比如说选择正确的WorldMap


226
00:14:00,541 --> 00:14:03,477 line:-1
针对世界上的某个特定的零售位置


227
00:14:04,311 --> 00:14:06,213 line:-1
这里真的有很多的可能性


228
00:14:06,280 --> 00:14:08,982 line:-2
可以剪裁用户的体验
并创建一些真正很棒的体验


229
00:14:12,152 --> 00:14:14,521 line:-2
那些是获取
WorldMap数据的一些方式


230
00:14:14,588 --> 00:14:15,856 line:-1
从一台设备到另一台设备


231
00:14:16,356 --> 00:14:19,259 line:-2
让我们谈谈
你要如何在第二台设备上加载它


232
00:14:19,860 --> 00:14:21,995 line:-2
在本例中 我们使用了
NSKeyUnarchiveder


233
00:14:22,496 --> 00:14:27,034 line:-2
来重新加载WorldMap
根据我们所接收的数据


234
00:14:28,202 --> 00:14:30,838 line:-2
然后我们创建了一个
ARWorldTracking配置


235
00:14:31,171 --> 00:14:34,074 line:-2
并把WorldMap
添加到那个配置对象中


236
00:14:34,141 --> 00:14:35,576 line:-1
按照我们希望的方式设置


237
00:14:36,777 --> 00:14:39,046 line:-1
最后 我们请求ARSession


238
00:14:39,112 --> 00:14:43,750 line:-2
运行那个配置
重新设置现有的锚点并追踪


239
00:14:44,918 --> 00:14:48,755 line:-2
然后目标设备上的ARKit
就开始扫描你周围的世界


240
00:14:48,822 --> 00:14:51,592 line:-1
从原始地图中关联这些功能点


241
00:14:52,659 --> 00:14:53,994 line:-1
通过它在那看到的那些东西


242
00:14:54,061 --> 00:14:55,562 line:-1
一旦可以这么做了


243
00:14:55,629 --> 00:14:57,397 line:-1
你就得到了那个共享坐标空间


244
00:14:57,664 --> 00:15:01,235 line:-2
两台设备上的000
都在现实世界中的同一个位置


245
00:15:04,137 --> 00:15:06,240 line:-1
快速提一下WorldMap隐私权


246
00:15:06,807 --> 00:15:08,475 line:-1
在录制WorldMap的过程中


247
00:15:08,942 --> 00:15:11,311 line:-1
我们考虑到了你周围世界的特征


248
00:15:11,378 --> 00:15:13,881 line:-1
对象的物理排列等等


249
00:15:14,982 --> 00:15:17,217 line:-1
因为它的确包含地理信息


250
00:15:17,284 --> 00:15:20,654 line:-2
比如经度和纬度 因此
你的app不需要请求


251
00:15:20,721 --> 00:15:22,856 line:-1
位置允许使用ARKit


252
00:15:23,824 --> 00:15:26,326 line:-1
它可能包括可识别的私人信息


253
00:15:26,393 --> 00:15:27,828 line:-1
关于用户所处的环境


254
00:15:28,662 --> 00:15:31,431 line:-2
因此我们建议你处理
序列化WorldMap时要采用


255
00:15:31,498 --> 00:15:34,935 line:-2
与处理其它
由用户创建的私人数据的相同的方式


256
00:15:36,136 --> 00:15:39,773 line:-1
这意味着你要确保你加密了数据


257
00:15:40,541 --> 00:15:42,943 line:-1
无论是休息时或是当在网络中移动时


258
00:15:43,644 --> 00:15:45,245 line:-1
你可能还想让用户知道


259
00:15:45,312 --> 00:15:48,081 line:-2
你是否计划保存
那个WorldMap信息


260
00:15:48,148 --> 00:15:52,019 line:-2
在app的单一会话
结束后的一段时间内


261
00:15:53,253 --> 00:15:57,691 line:-2
在SwiftShot中
我们可以利用iOS的内置加密


262
00:15:58,058 --> 00:16:00,794 line:-1
在玩家休息时加密数据


263
00:16:01,361 --> 00:16:06,633 line:-2
我要谈一下
我们如何在网络上实现加密


264
00:16:09,236 --> 00:16:13,240 line:-2
现在除了针对SwiftShot
设置共享坐标空间


265
00:16:13,307 --> 00:16:14,508 line:-1
我们还需告诉另台设备


266
00:16:14,575 --> 00:16:16,910 line:-1
用户选择在哪里定位游戏板


267
00:16:17,711 --> 00:16:19,346 line:-2
为此我们使用了
一个ARAnchor


268
00:16:20,280 --> 00:16:22,749 line:-2
当你创建ARAnchor时
你要提供一个名称


269
00:16:22,816 --> 00:16:25,452 line:-1
以及位置和旋转信息


270
00:16:25,519 --> 00:16:26,987 line:-1
作为4 x 4转换


271
00:16:28,722 --> 00:16:32,693 line:-2
然后ARKit就会在我们生成的
ARWorldMap中包含锚点


272
00:16:32,759 --> 00:16:36,296 line:-2
并将其序列化 然后我们就可把那个
游戏板信息迁移到


273
00:16:36,363 --> 00:16:37,598 line:-1
另一台设备上


274
00:16:39,499 --> 00:16:40,834 line:-1
系统ARAnchor类


275
00:16:40,901 --> 00:16:43,871 line:-1
只有我们所创建的名称和定向


276
00:16:44,171 --> 00:16:46,340 line:-1
我们可以查询我们感兴趣的锚点


277
00:16:46,406 --> 00:16:47,541 line:-1
通过名称 在另一方面


278
00:16:48,208 --> 00:16:51,378 line:-2
对于我们的app来说
我们需要包含一些额外信息


279
00:16:51,445 --> 00:16:56,049 line:-2
针对另一台设备
就是用户选择的游戏板的尺寸


280
00:16:56,283 --> 00:17:00,287 line:-2
决定他们是否在 你知道的
一张小桌子顶部和表面上玩


281
00:17:00,354 --> 00:17:03,757 line:-2
或者他们想把游戏板
变成篮球场那么大的尺寸


282
00:17:06,627 --> 00:17:09,096 line:-2
我们思考了一下
把那个添加到我们的网络协议中


283
00:17:09,162 --> 00:17:12,266 line:-2
和WorldMap一起
但是我们遇到了一个更好的方案


284
00:17:13,200 --> 00:17:17,171 line:-2
我们创建了ARAnchor
的自定义子类 称其为游戏板锚点


285
00:17:17,871 --> 00:17:21,040 line:-2
并把那个信息添加到那个类中
即游戏板的尺寸


286
00:17:22,175 --> 00:17:25,546 line:-1
然后我们确保我们实施了


287
00:17:25,945 --> 00:17:28,916 line:-2
NSCoding所需的类
或覆盖它们


288
00:17:29,183 --> 00:17:32,819 line:-2
当对象被序列化时
以便包含那个信息


289
00:17:33,387 --> 00:17:36,590 line:-2
现在信息被直接包含在
WorldMap内


290
00:17:36,790 --> 00:17:38,825 line:-1
当我们把它迁移到另一台设备上时


291
00:17:39,193 --> 00:17:40,861 line:-1
这样很简单 也很直截了当


292
00:17:42,095 --> 00:17:44,998 line:-2
有一件事需要记住
这给我们增加了一点困扰


293
00:17:45,465 --> 00:17:51,305 line:-2
当你用Swift来做这样的子类时
当你序列化子类时


294
00:17:51,672 --> 00:17:52,773 line:-1
模块的名称


295
00:17:52,840 --> 00:17:55,609 line:-1
或app的名称会包含在类的名称之中


296
00:17:55,976 --> 00:17:57,244 line:-1
你要引起注意


297
00:17:57,311 --> 00:18:00,681 line:-2
如果你计划在不同app之间
移动WorldMap


298
00:18:01,048 --> 00:18:03,517 line:-2
NSKeyedArchiver
可以帮助你调整


299
00:18:05,185 --> 00:18:09,056 line:-2
那么这是WorldMap共享
它是iOS 12中的新特性


300
00:18:09,122 --> 00:18:11,992 line:-2
我们真的期待看到你们大家
能用它做出来什么东西


301
00:18:14,494 --> 00:18:16,763 line:-2
接下来让我们谈谈
我们嵌入到游戏中的网络


302
00:18:17,798 --> 00:18:20,701 line:-2
我们使用了iOS的
多点连通性API


303
00:18:20,767 --> 00:18:23,837 line:-2
自从iOS 7开始就存在于
系统中了 目的是嵌入网络


304
00:18:24,638 --> 00:18:25,806 line:-1
多点连通性


305
00:18:25,873 --> 00:18:29,276 line:-2
允许我们在本地网络上设置一个
点对点会话


306
00:18:29,543 --> 00:18:31,812 line:-1
允许会话中的设备进行通讯


307
00:18:31,879 --> 00:18:33,647 line:-1
而无需通过专用服务器


308
00:18:34,481 --> 00:18:37,851 line:-2
现在在我们的app中
我们指定其中一台设备作为服务器


309
00:18:38,051 --> 00:18:40,187 line:-1
但是我们为我们的app所做的事


310
00:18:40,254 --> 00:18:41,688 line:-1
它并不是协议所固有的


311
00:18:43,023 --> 00:18:46,326 line:-1
加密和验证内嵌到多点连通性中


312
00:18:46,860 --> 00:18:48,695 line:-1
在我们的例子中 我们没有使用验证


313
00:18:48,762 --> 00:18:51,465 line:-2
因为我们想得到非常迅速地
进入和退出的体验


314
00:18:51,532 --> 00:18:53,066 line:-1
但我们使用了加密


315
00:18:53,767 --> 00:18:57,604 line:-1
我们发现打开加密真的不会影响性能


316
00:18:57,671 --> 00:19:01,542 line:-1
无论是在网络数据尺寸还是计算方面


317
00:19:01,608 --> 00:19:03,277 line:-1
因此没有什么原因让我们不使用它


318
00:19:05,078 --> 00:19:09,483 line:-2
多点连通性
还给API提供了广告和发现


319
00:19:10,217 --> 00:19:12,052 line:-1
我们用它来推广可用的游戏


320
00:19:12,119 --> 00:19:13,854 line:-1
并允许玩家选择一个游戏加入


321
00:19:15,255 --> 00:19:16,790 line:-1
这就是我们如何设置会话的


322
00:19:17,524 --> 00:19:18,725 line:-1
首先在一台设备上


323
00:19:18,792 --> 00:19:22,162 line:-1
用户决定把自己设置为app的主机


324
00:19:23,330 --> 00:19:26,033 line:-2
他们可以扫描世界
把游戏板放在那个世界中


325
00:19:27,234 --> 00:19:31,538 line:-2
然后设备就开启一个新会话
一个多点连通性会话


326
00:19:31,605 --> 00:19:34,374 line:-2
并开始在本地网络上
把它推广到其它设备


327
00:19:36,109 --> 00:19:39,179 line:-2
另一台设备上的用户
查看了一个可用游戏列表


328
00:19:39,980 --> 00:19:43,817 line:-2
当他选择了某个游戏时 他的设备
就发送一个请求 请求加入现有会话


329
00:19:45,552 --> 00:19:47,888 line:-1
一旦第一台设备接受请求


330
00:19:47,955 --> 00:19:50,657 line:-2
多点连通性就设置一个
真正的点对点网络


331
00:19:51,058 --> 00:19:52,993 line:-1
网络中的任何设备


332
00:19:53,060 --> 00:19:55,229 line:-1
都可以向网络中的任意设备发送信息


333
00:19:55,929 --> 00:19:59,499 line:-2
在SwiftShot中
我们指定了开启会话的设备


334
00:19:59,566 --> 00:20:01,468 line:-1
作为游戏状态的事实来源


335
00:20:01,702 --> 00:20:05,172 line:-2
这是我们在网络协议顶层
所做出的决策


336
00:20:05,239 --> 00:20:07,274 line:-1
它并不是多点连通性所固有的


337
00:20:10,077 --> 00:20:11,578 line:-1
一旦设置好会话


338
00:20:11,645 --> 00:20:15,482 line:-2
多点连通性就让我们以三种方式
在点之间发送数据：


339
00:20:15,916 --> 00:20:17,117 line:-1
作为数据包


340
00:20:17,651 --> 00:20:20,654 line:-2
作为资源
在本地存储上把URL归档


341
00:20:21,054 --> 00:20:22,155 line:-1
以及作为数据流


342
00:20:22,723 --> 00:20:25,659 line:-2
你可以发送数据对象
向网络中的所有点推送


343
00:20:25,993 --> 00:20:28,795 line:-1
而资源和数据流是设备对设备的操作


344
00:20:29,730 --> 00:20:35,102 line:-2
在SwiftShot中
我们主要把数据包用于共享游戏事件


345
00:20:35,169 --> 00:20:37,671 line:-1
以及物理状态 我们稍后再谈


346
00:20:38,839 --> 00:20:41,108 line:-2
然后我们使用资源
来迁移WorldMap


347
00:20:42,176 --> 00:20:44,111 line:-2
然后它就结束了
我们的app不需要数据流


348
00:20:46,079 --> 00:20:48,015 line:-1
在底层 多点连通性


349
00:20:48,081 --> 00:20:50,617 line:-2
依赖于UDP
用于在设备间进行迁移


350
00:20:51,285 --> 00:20:55,656 line:-2
这就提供了低延迟
对于游戏这样的app来说非常棒


351
00:20:56,490 --> 00:20:58,825 line:-1
现在固有的UDP并不能保证交付


352
00:20:59,259 --> 00:21:02,763 line:-2
因此多点连通性
允许你做出决策并确定


353
00:21:02,829 --> 00:21:06,767 line:-1
可靠或不可靠地发送特定数据包


354
00:21:07,434 --> 00:21:08,735 line:-1
如果你选择可靠地发送


355
00:21:09,203 --> 00:21:11,972 line:-1
多点连通性会替你不断重试


356
00:21:12,039 --> 00:21:14,441 line:-1
因此你不需要在代码中担忧这个问题


357
00:21:15,843 --> 00:21:18,712 line:-1
即使当你向会话中的所有成员推广时


358
00:21:21,648 --> 00:21:23,350 line:-1
现在我们有一个网络层


359
00:21:23,417 --> 00:21:25,619 line:-2
我们要在网络层顶部
创建我们的app协议


360
00:21:26,386 --> 00:21:29,823 line:-2
带相关联类型SwiftEnums
让这个过程变得非常简单


361
00:21:30,757 --> 00:21:32,759 line:-1
每个例子中都有一个数据结构


362
00:21:33,126 --> 00:21:36,196 line:-2
确保类型的安全性
当信息在系统中移动时


363
00:21:37,464 --> 00:21:39,600 line:-1
其中有些可以进一步枚举


364
00:21:39,833 --> 00:21:42,636 line:-2
比如在本例中
gameAction包括


365
00:21:42,703 --> 00:21:46,440 line:-2
像玩家抓取弹弓
弹丸发射等等这样的东西


366
00:21:47,307 --> 00:21:49,810 line:-2
PhysicsSyncData
是一个结构 我们稍后再具体谈谈


367
00:21:49,877 --> 00:21:51,645 line:-1
我们是如何进行编码的


368
00:21:53,480 --> 00:21:55,449 line:-1
Swift让这个过程变得很简单


369
00:21:55,516 --> 00:21:58,552 line:-2
对于结构 如果结构中的全部成员
都是可编码的


370
00:21:58,919 --> 00:22:01,822 line:-2
你所要做的就是把那个结构
标记为可编码


371
00:22:01,889 --> 00:22:03,624 line:-2
然后Swift编译器
会替你做剩下的事


372
00:22:04,057 --> 00:22:06,426 line:-1
创建全部基础结构用于序列化


373
00:22:07,995 --> 00:22:09,863 line:0
Swift并不会针对枚举这样做


374
00:22:09,930 --> 00:22:12,132 line:0
因此我们得自己来实施


375
00:22:12,466 --> 00:22:16,436 line:0
实施初始化和编码方法


376
00:22:16,503 --> 00:22:18,805 line:0
从可编码协议中


377
00:22:20,908 --> 00:22:22,709 line:-1
然后序列化就非常简单了


378
00:22:22,776 --> 00:22:26,280 line:-2
只需要创建一个属性列表编码器
并让它编码对象


379
00:22:27,314 --> 00:22:30,984 line:-2
然后我们可以在多点连通性会话内
发送一个数据包


380
00:22:32,486 --> 00:22:34,188 line:-1
现在这里有一个合乎情理的提问


381
00:22:34,254 --> 00:22:37,224 line:-1
它对尺寸和性能会有什么影响？


382
00:22:38,592 --> 00:22:42,663 line:-2
二进制属性列表非常紧凑
并且编码器的速度也非常快


383
00:22:43,664 --> 00:22:44,998 line:-1
但有时候 你知道的


384
00:22:45,332 --> 00:22:49,269 line:-2
温和的实施在许多方面
都针对开发者时间进行了优化


385
00:22:49,336 --> 00:22:51,805 line:-1
有时候是你在对象上的最宝贵的资源


386
00:22:54,074 --> 00:22:55,776 line:-1
现在我们遇到了一些限制


387
00:22:55,843 --> 00:22:59,179 line:-2
当我们开始创建下一个功能时
我们要谈谈该如何克服这个问题


388
00:23:01,882 --> 00:23:04,318 line:-1
接下来让我们谈谈游戏中的物理模拟


389
00:23:04,952 --> 00:23:07,688 line:-2
像SwiftShot一样的游戏
物理非常关键


390
00:23:07,754 --> 00:23:11,158 line:-2
对于创建
源于现实的有趣的交互作用来说


391
00:23:11,225 --> 00:23:14,027 line:-2
在对象和游戏之间
它是一个很棒的体验


392
00:23:14,094 --> 00:23:17,130 line:-2
拉动弹弓
然后对准游戏中的一个对象发射


393
00:23:17,197 --> 00:23:18,532 line:-1
并缴获对手的弹弓


394
00:23:19,700 --> 00:23:21,368 line:-1
那其实是源自物理模拟


395
00:23:23,670 --> 00:23:25,672 line:-2
我们用了SceneKit
内置物理引擎


396
00:23:26,039 --> 00:23:27,641 line:-1
它集成了渲染引擎


397
00:23:27,708 --> 00:23:30,444 line:-1
在场景中自动更新对象的位置


398
00:23:30,911 --> 00:23:33,113 line:-1
如果发生碰撞就通过委托提醒我们


399
00:23:34,581 --> 00:23:37,050 line:-2
在我们的实施中
我们决定最好的方式是


400
00:23:37,117 --> 00:23:41,722 line:-2
让会话中的一台设备
担任事实来源或服务器


401
00:23:42,256 --> 00:23:46,260 line:-2
它会把物理状态的定期更新
发送到网络中的其它设备上


402
00:23:46,326 --> 00:23:50,931 line:-1
通过多点连通性推送方法


403
00:23:52,699 --> 00:23:56,970 line:-1
现在其它设备也拥有物理模拟了


404
00:23:57,704 --> 00:24:00,741 line:-2
这是因为我们并不是发送
游戏中每一个对象的信息


405
00:24:01,074 --> 00:24:04,511 line:-2
只发送那些与游戏设置相关的
对象的信息 比如方框


406
00:24:04,578 --> 00:24:06,413 line:-1
落弹数和弹弩


407
00:24:06,914 --> 00:24:11,018 line:-2
还有一些东西
比如模拟绳子和投石器的摇摆


408
00:24:11,084 --> 00:24:16,089 line:-2
微粒等等
这些只是在每台设备上本地实现的


409
00:24:16,156 --> 00:24:19,660 line:-2
因为它对于游戏来说并不是关键因素
它们可出现在每台设备上的同一位置


410
00:24:24,031 --> 00:24:26,867 line:-2
现在在我们的实现过程中
我们发现的其中一件事就是


411
00:24:26,934 --> 00:24:29,870 line:-1
物理引擎的响应很不一样


412
00:24:29,937 --> 00:24:31,572 line:-1
取决于对象的比例


413
00:24:32,206 --> 00:24:34,107 line:-1
那么物理模拟认为


414
00:24:34,174 --> 00:24:37,678 line:-2
对象比你在现实世界中看到的尺寸
要大十倍


415
00:24:38,278 --> 00:24:41,181 line:-2
我们发现
那会提供最佳的游戏设置体验


416
00:24:41,248 --> 00:24:42,416 line:-1
和最好的性能


417
00:24:43,150 --> 00:24:44,685 line:-1
我们需要改善一些物理定律


418
00:24:44,751 --> 00:24:47,988 line:-2
让一切看起来都正常 但是你知道的
当你创建游戏时


419
00:24:48,055 --> 00:24:50,357 line:-2
若看起来还不错 感觉也不错
而且它还有意思


420
00:24:50,691 --> 00:24:51,558 line:-1
那就对了


421
00:24:53,760 --> 00:24:56,930 line:-2
现在要共享那个物理状态
并确保一切看起来都正常


422
00:24:56,997 --> 00:24:59,166 line:-1
我们需要共享四个信息：


423
00:24:59,633 --> 00:25:00,501 line:-1
位置


424
00:25:02,269 --> 00:25:03,203 line:-1
速度


425
00:25:04,638 --> 00:25:07,541 line:-1
角速度和定向


426
00:25:08,342 --> 00:25:10,711 line:-2
对于游戏中的每一个对象来说
信息量相当大


427
00:25:11,144 --> 00:25:14,348 line:-2
因此我们最小化实际要用到的位数
是至关重要的


428
00:25:14,982 --> 00:25:17,417 line:-1
我会以位置作为例子具体讲一下


429
00:25:18,886 --> 00:25:22,356 line:-2
SceneKit把位置表示为
一个矢量 是三个浮点值


430
00:25:23,257 --> 00:25:24,725 line:-1
这是原生格式


431
00:25:24,791 --> 00:25:27,895 line:-1
在运行时间给计算提供了最好的性能


432
00:25:30,163 --> 00:25:32,766 line:-1
然而 其实还有更多不必要的位数


433
00:25:32,833 --> 00:25:34,401 line:-1
用于指定对象的位置


434
00:25:35,169 --> 00:25:39,273 line:-2
一个30位的浮点有8位指数
和23位小数


435
00:25:39,740 --> 00:25:42,442 line:-1
对于正负十的范围 相对于38米


436
00:25:43,043 --> 00:25:44,912 line:-2
这比我们需要在游戏中使用的长度
长多了


437
00:25:47,347 --> 00:25:51,385 line:-2
那么因为物理模拟认为
我们的桌子有27米长


438
00:25:51,985 --> 00:25:55,055 line:-2
我们说过你知道的
80米会提供给我们足够的缓冲空间


439
00:25:55,122 --> 00:25:56,523 line:-2
在桌子周围
无论哪一边都行


440
00:25:58,625 --> 00:26:03,096 line:0
当我们写代码时
那么我们就能消除信号位


441
00:26:03,530 --> 00:26:06,867 line:0
通过把那个正常化到0和80米之间


442
00:26:06,934 --> 00:26:08,669 line:0
即使我们的原始位置在桌子的中心


443
00:26:09,403 --> 00:26:10,704 line:0
现在所有值都是正值


444
00:26:12,172 --> 00:26:15,108 line:0
然后我们把那个值削减到0和1之间


445
00:26:15,676 --> 00:26:17,578 line:0
那样我们就不需要指数信息


446
00:26:17,644 --> 00:26:20,747 line:0
协议内固有的指数信息


447
00:26:22,649 --> 00:26:24,484 line:-1
最后 我们把这个数


448
00:26:24,551 --> 00:26:26,453 line:-1
按比例缩减为可用的位数


449
00:26:26,954 --> 00:26:32,926 line:0
从而所有值都是一个浮点值
并且所有的0都是浮点0


450
00:26:34,094 --> 00:26:38,532 line:0
这就给我们提供了毫米比例精度
我们发现它已经足够


451
00:26:38,966 --> 00:26:41,735 line:0
用于实现游戏中流畅、同步的体验


452
00:26:43,403 --> 00:26:46,607 line:-2
现在我们对你所看到的其它值
应用了一个类似的技巧


453
00:26:46,673 --> 00:26:49,543 line:-1
速度、角速度和定向


454
00:26:51,078 --> 00:26:53,680 line:-1
缩减范围和位数


455
00:26:53,747 --> 00:26:56,183 line:-1
以便确保我们对信息的传输


456
00:26:56,250 --> 00:26:57,551 line:-1
保持了最小的数据量


457
00:26:58,051 --> 00:27:02,589 line:-2
总之 我们对每个对象
减少了半数以上的位数


458
00:27:04,658 --> 00:27:06,793 line:-1
现在即使我们压缩了位数


459
00:27:07,761 --> 00:27:10,330 line:-1
属性列表仍然有大量的超额负载


460
00:27:10,397 --> 00:27:11,865 line:-1
对于它的元数据而言


461
00:27:12,633 --> 00:27:13,834 line:-1
按名称发送每一个字段


462
00:27:14,801 --> 00:27:18,238 line:-2
我们说过那是无缘无故的
我们都知道这些对象是什么


463
00:27:18,572 --> 00:27:19,940 line:-1
这不是我们需要的信息


464
00:27:20,707 --> 00:27:25,746 line:-1
为此我们实施了一个新的序列化策略


465
00:27:26,146 --> 00:27:27,181 line:-1
称之为BitStream


466
00:27:28,382 --> 00:27:30,417 line:-2
BitStream
用于把信息打包到


467
00:27:30,484 --> 00:27:31,952 line:-1
尽可能少的字节中


468
00:27:32,319 --> 00:27:35,022 line:-1
同时提供快速的序列化和反序列化


469
00:27:35,856 --> 00:27:37,925 line:-1
现在我们的实施是为特定目的创建的


470
00:27:37,991 --> 00:27:39,560 line:-1
用于传递二进制数据


471
00:27:40,093 --> 00:27:42,162 line:-1
以低延迟 在一个类似这样的app中


472
00:27:42,896 --> 00:27:47,568 line:-2
这样的策略对于需要持久的数据来说
效果不会太好


473
00:27:48,001 --> 00:27:50,270 line:-1
或者是你需要追踪架构


474
00:27:50,337 --> 00:27:51,772 line:-1
并随时间观察它的变化的数据


475
00:27:52,439 --> 00:27:55,676 line:-2
但对于类似这样的短暂的app来说
用它正合适


476
00:27:58,178 --> 00:28:01,114 line:-1
要实施它 我们创建了两个协议


477
00:28:01,181 --> 00:28:03,951 line:-2
BitStream Encodable
和BitStream Decodable


478
00:28:04,651 --> 00:28:06,520 line:-2
把两个结合起来就能得到
BitStream Codable


479
00:28:07,387 --> 00:28:11,124 line:-2
然后我们用它标记
我们需要序列化的所有对象


480
00:28:11,191 --> 00:28:13,594 line:-1
使用那个协议 帮助我们获得实施


481
00:28:14,027 --> 00:28:17,898 line:-2
那既包括我们自己的数据对象
也包括我们从系统中使用的对象


482
00:28:17,965 --> 00:28:22,269 line:-1
比如simD浮点矢量类型


483
00:28:25,272 --> 00:28:27,908 line:-1
那么这是压缩浮点的实施


484
00:28:28,509 --> 00:28:31,578 line:-1
压缩器配置了最小和最大范围


485
00:28:31,645 --> 00:28:33,347 line:-1
以及我们想要使用的位数


486
00:28:35,115 --> 00:28:39,253 line:-2
它把值压缩到那个范围
然后把它转化为一个整数值


487
00:28:39,319 --> 00:28:41,722 line:-1
用于编码 使用指定位数


488
00:28:42,823 --> 00:28:45,859 line:-2
场景中每个对象的每个组件
都是以这种方式压缩的


489
00:28:46,593 --> 00:28:48,829 line:-1
我们之前还使用额外位数


490
00:28:48,896 --> 00:28:51,298 line:-2
来表示对象自上次更新后
是否发生了移动


491
00:28:51,999 --> 00:28:54,735 line:-2
如果它没有移动过
我们就不再重复发送那个信息


492
00:28:57,271 --> 00:28:59,940 line:-2
那么让我们返回我们的行动枚举
有三个不同的行动


493
00:29:00,007 --> 00:29:02,042 line:-2
谈谈如何通过
BitStream来实现


494
00:29:03,844 --> 00:29:07,514 line:-2
对于常规的codable
如果你正在做你自己的序列化


495
00:29:07,581 --> 00:29:11,385 line:-2
你要在枚举中的不同情况下
指定枚举的编码关键字


496
00:29:12,186 --> 00:29:16,857 line:-2
对于BitStream
我们用了整数值而非字符串值


497
00:29:18,525 --> 00:29:23,330 line:0
然后再我们的编码方法中
我们可以先附加那个值


498
00:29:23,397 --> 00:29:27,601 line:0
接着是与那个枚举情况
相关联的数据结构


499
00:29:28,468 --> 00:29:31,205 line:0
现在 如果你查找这个代码
这里有一个陷阱


500
00:29:31,805 --> 00:29:36,577 line:0
我们知道这个例子有三种不同的情况


501
00:29:37,211 --> 00:29:39,213 line:-1
我们只需要两个位元来编码它


502
00:29:40,681 --> 00:29:45,452 line:-2
但当我们添加另一情况后会怎样呢？
四个位元对应四种情况仍然还不错


503
00:29:45,752 --> 00:29:49,923 line:-2
我们添加了第五种情况
现在我们就要修改那个


504
00:29:49,990 --> 00:29:53,427 line:-2
我们每次这样做时
我们用的是三个位元而非两个


505
00:29:54,061 --> 00:29:57,197 line:-2
现在这就有点乏味了
这个代码有点重复了


506
00:29:57,264 --> 00:29:59,666 line:-2
并且你知道的
这里的内容可能会发生错误


507
00:29:59,733 --> 00:30:02,703 line:-2
如果我们不记得这个
我们只能得到一个糟糕的结果


508
00:30:03,804 --> 00:30:05,339 line:-1
那么让我们查看一下


509
00:30:05,405 --> 00:30:08,909 line:-1
想想Swift是否可以提供帮助


510
00:30:11,078 --> 00:30:15,482 line:-2
我们用了Swift 4.2新特性
叫做情况可迭代


511
00:30:16,450 --> 00:30:21,688 line:-2
我们在我们的枚举类型中
添加了协议一致性


512
00:30:22,489 --> 00:30:26,827 line:-2
当你这样做时 Swift
就会添加一个类型的新静态成员


513
00:30:26,894 --> 00:30:29,897 line:-2
叫做全部情况
包括枚举中的每一种情况


514
00:30:30,664 --> 00:30:34,034 line:-1
让就让我们自动获得情况数量


515
00:30:34,968 --> 00:30:38,772 line:-2
然后我们添加了另一个扩展
这一次是在原生的可描绘类型上


516
00:30:38,839 --> 00:30:42,543 line:-1
所有带数字类型的枚举都会遵循它


517
00:30:43,110 --> 00:30:46,346 line:-1
这种情况可迭代 并且数字是整数


518
00:30:47,047 --> 00:30:50,117 line:-1
为此我们要自动获取情况的数量


519
00:30:50,184 --> 00:30:54,254 line:-2
并算出表达全部那些情况
需要多少位元数


520
00:30:56,356 --> 00:31:01,128 line:-2
最后我们添加了通用方法
在可写入BitStream类型上


521
00:31:01,195 --> 00:31:02,763 line:-1
允许我们编码那个枚举


522
00:31:03,397 --> 00:31:07,467 line:-2
它会附加那个类型的东西
并且会使用那个新的静态属性来计算


523
00:31:07,534 --> 00:31:09,736 line:-1
所需要使用的位元数


524
00:31:11,705 --> 00:31:13,740 line:-1
现在我们的编码方法变得更简单了


525
00:31:14,208 --> 00:31:17,845 line:-2
在适当的代码键上
我们只使用了附加枚举


526
00:31:17,911 --> 00:31:19,346 line:-1
Swift会替我们完成剩下的事


527
00:31:19,980 --> 00:31:23,717 line:-2
当我们向枚举中添加更多情况时
BitField会自动扩展


528
00:31:23,984 --> 00:31:26,286 line:-1
如果我们移除情况 它会自动缩小


529
00:31:26,520 --> 00:31:27,754 line:-1
我们不用担心它


530
00:31:31,658 --> 00:31:34,695 line:-2
BitStreamCodable
到底有多快多紧凑呢？


531
00:31:35,028 --> 00:31:38,298 line:-2
我们运行一些测试
使用XE测试支持用于性能测试


532
00:31:38,665 --> 00:31:42,503 line:-2
使用代表性的信息
我们发送关于对象移动的信息


533
00:31:44,004 --> 00:31:47,841 line:-2
结果令人印象深刻：十分之一的尺寸
两倍速度的编码


534
00:31:47,908 --> 00:31:49,376 line:-1
十倍速度的解码


535
00:31:50,177 --> 00:31:54,581 line:-2
现在当我们谈到从75毫秒
降低到6毫秒时


536
00:31:54,648 --> 00:31:56,116 line:-1
看起来微不足道


537
00:31:56,917 --> 00:32:00,254 line:-2
但游戏中有大约200个对象
我们要非常频繁地操作


538
00:32:00,320 --> 00:32:03,023 line:-2
从而确保每一个参与者
都能流畅地玩游戏


539
00:32:03,524 --> 00:32:04,992 line:-1
通过使用这个编码格式


540
00:32:05,058 --> 00:32:08,495 line:-2
我们就能以60帧/秒
来实现物理更新


541
00:32:08,562 --> 00:32:11,164 line:-2
确保游戏中的每一个人
都能拥有流畅的体验


542
00:32:13,400 --> 00:32:16,737 line:-2
现在 我已经讲过了
我们对codable做了一些事


543
00:32:16,803 --> 00:32:20,174 line:-2
还有BitStream Codable
你可能会有一个问题


544
00:32:20,240 --> 00:32:22,075 line:-1
因为我们用了两种不同的方式来编码


545
00:32:22,309 --> 00:32:24,077 line:-1
那意味着需要两种不同的代码路径


546
00:32:24,144 --> 00:32:25,012 line:-1
在我们的app中


547
00:32:26,113 --> 00:32:29,149 line:-2
Swift再次给我们提供了帮助
算出如何把它们结合在一起


548
00:32:30,117 --> 00:32:33,086 line:-1
然后我们添加了受约束的扩展


549
00:32:33,153 --> 00:32:36,390 line:-2
因此BitStream Codable中
任何对象都可编码


550
00:32:36,657 --> 00:32:39,860 line:-2
我们提供了BitStream
编码的默认实施


551
00:32:40,460 --> 00:32:45,199 line:-2
然后我们只需要继续
并使用一个二进制属性列表编码器


552
00:32:45,832 --> 00:32:48,168 line:-2
来编码数据并把它放在
BitStream中


553
00:32:49,236 --> 00:32:52,105 line:0
然后任何对象
任何结构都是可编码的


554
00:32:52,172 --> 00:32:54,575 line:0
我们只需要添加它并把它标记为
BitStream Codable


555
00:32:54,908 --> 00:32:58,011 line:0
现在这个实施并不是那么快速和紧凑


556
00:32:58,078 --> 00:33:01,315 line:0
如果我们继续并让一切对象都直接
BitStream Codable


557
00:33:01,849 --> 00:33:04,651 line:0
但我们发现我们不需要针对
游戏中的每一个对象这样做


558
00:33:04,718 --> 00:33:06,587 line:0
只针对最频繁的信息即可


559
00:33:06,653 --> 00:33:10,691 line:-2
这让我们的移动非常快速
并让它在游戏中保持运行


560
00:33:12,526 --> 00:33:13,961 line:-1
那么这是我们如何处理物理


561
00:33:14,228 --> 00:33:17,097 line:-2
接下来我想谈谈如何针对游戏等级
处理资产


562
00:33:17,164 --> 00:33:20,033 line:-1
楼下有很多人提到了这个问题


563
00:33:22,002 --> 00:33:24,404 line:-1
你知道的 资产包括3D模块、纹理


564
00:33:24,471 --> 00:33:25,772 line:-1
动画等等


565
00:33:26,406 --> 00:33:28,342 line:-2
Apple中有些文本角度的
艺术作品


566
00:33:28,709 --> 00:33:31,445 line:-2
并且它们使用了一些商业工具
来针对游戏创建视觉效果


567
00:33:31,512 --> 00:33:33,280 line:-1
砖块、弹弩等等


568
00:33:34,047 --> 00:33:38,185 line:-2
然后他们把资产导出为
常用的DAE文件格式


569
00:33:38,252 --> 00:33:40,921 line:-1
我们想要让商业工具支持USDZ


570
00:33:41,255 --> 00:33:42,789 line:-2
但对于这个游戏
还没达到目标


571
00:33:44,424 --> 00:33:49,162 line:-2
在Swift中创建了命令行工具
使用SceneKit API


572
00:33:49,229 --> 00:33:52,733 line:-2
将对象从DAE转换为
SceneKit文件


573
00:33:53,133 --> 00:33:56,937 line:-2
因为SceneKit在iOS
和macOS上提供相同的API


574
00:33:57,337 --> 00:34:01,241 line:-2
我们可以把这个工具
作为macOS上创建过程的一部分


575
00:34:01,308 --> 00:34:04,945 line:-2
并在app的iOS创建中直接包括
SceneKit文件


576
00:34:06,780 --> 00:34:09,949 line:-2
我们把数据结构化
这样每个单一的组块类型


577
00:34:10,016 --> 00:34:11,518 line:-1
都在自己的文件中


578
00:34:12,018 --> 00:34:14,521 line:-2
然后对于每个等级
我们把那些组块结合在一起


579
00:34:15,455 --> 00:34:18,492 line:-1
这就允许我们迭代外观和物理行为


580
00:34:18,559 --> 00:34:21,628 line:-2
每一个单一组块的
然后把它们拉到一起


581
00:34:21,695 --> 00:34:24,097 line:-1
针对那些等级 并迭代游戏设置设计


582
00:34:24,364 --> 00:34:26,333 line:-2
尝试些不同等级 你会看到
如果你浏览


583
00:34:26,400 --> 00:34:28,135 line:-1
app的源代码的话


584
00:34:30,370 --> 00:34:33,639 line:-1
要进一步优化不同的距离


585
00:34:33,907 --> 00:34:38,045 line:-2
根据所需要的等级细节
SceneKit支持改变所用资产


586
00:34:39,079 --> 00:34:42,149 line:-2
附近的对象使用较多的多边形
和较多的详细纹理


587
00:34:42,216 --> 00:34:45,652 line:-2
而远处的对象使用较少的多边形
和较少的详细纹理


588
00:34:45,985 --> 00:34:48,388 line:-1
这样就真正优化了场景的渲染


589
00:34:51,190 --> 00:34:54,027 line:-2
然而 我们仍然希望游戏设置
保持一致性


590
00:34:54,460 --> 00:34:56,929 line:-1
因此我们分别制定了物理实体


591
00:34:57,865 --> 00:35:00,234 line:-2
SceneKit提供一系列
内置物理实体类型


592
00:35:00,300 --> 00:35:02,603 line:-1
比如立方体、球体、圆柱体


593
00:35:03,303 --> 00:35:06,073 line:-2
如果你使用这些
你就会获得最佳性能


594
00:35:06,807 --> 00:35:08,475 line:-1
如果你不指定其中一个


595
00:35:08,542 --> 00:35:12,579 line:-2
SceneKit将自动为你创建
一个凸壳 你就得用那个


596
00:35:12,913 --> 00:35:16,850 line:-1
但可能会得到较慢的性能实施


597
00:35:17,150 --> 00:35:19,953 line:-1
通过添加这些对象 当它们可用


598
00:35:20,020 --> 00:35:23,023 line:-2
并且当它们的存在有意义时
我们真的会加速游戏的性能


599
00:35:25,959 --> 00:35:28,762 line:-1
那么这是一些关于物理成品的示例


600
00:35:29,329 --> 00:35:30,898 line:-1
第一个是游戏中的一个组块


601
00:35:30,964 --> 00:35:34,034 line:-2
在本例中 一个带纹理的圆柱体
营造了一种木纹效果


602
00:35:35,068 --> 00:35:37,237 line:-1
接下来是弹弓 悬带是松弛的


603
00:35:37,905 --> 00:35:40,474 line:-2
我们在RunTime时
用着色器添加了团队颜色


604
00:35:40,541 --> 00:35:43,477 line:-2
并针对弹弓在游戏设置中的动作
创建了一些自定义动画


605
00:35:44,912 --> 00:35:48,415 line:-2
最后我们引入了一些额外的资产
并不包含在游戏设置中


606
00:35:48,749 --> 00:35:50,284 line:-1
即便我们要牺牲掉它们


607
00:35:50,350 --> 00:35:53,153 line:-2
我们希望你拥有它们
并在你自己的示例代码中使用它们


608
00:35:56,190 --> 00:35:59,493 line:-2
因此我们包括在内的另一个
有意思的东西是这个旗子动画


609
00:35:59,726 --> 00:36:01,828 line:-2
它很好地改善了
游戏环境中的沉浸体验


610
00:36:02,596 --> 00:36:04,831 line:-1
我们想要一个真实的刮风的效果


611
00:36:05,165 --> 00:36:08,168 line:-2
现在我们可以在物理引擎外部
使用布料模拟


612
00:36:09,469 --> 00:36:13,040 line:-2
但相反 我们决定使用GPU
并用Metal实现


613
00:36:15,275 --> 00:36:18,011 line:-2
我们从由技术设计师创建的
SceneKit资产开始


614
00:36:18,478 --> 00:36:22,449 line:-2
要在旗子上获取Apple标识
我们在Runtime时应用了纹理


615
00:36:23,684 --> 00:36:26,253 line:-2
然后在Metal设备周围
创建了一个Swift类


616
00:36:26,787 --> 00:36:30,424 line:-2
Swift代码创建了metal
命令队列并插入


617
00:36:30,490 --> 00:36:33,193 line:-1
从游戏状态中获取的信息 比如风向


618
00:36:34,561 --> 00:36:37,164 line:-2
那个命令队列运行的是
自定义Metal计算着色器


619
00:36:37,798 --> 00:36:39,900 line:-1
它来自用C创建的老程序


620
00:36:40,133 --> 00:36:44,805 line:-2
但因Metal基于现代的C++
所以这是一个很简单的转换


621
00:36:45,772 --> 00:36:49,776 line:-2
然后我们还运行了另一个计算着色器
来计算表面的法线


622
00:36:49,843 --> 00:36:52,346 line:-2
这样我们就得到了一个很棒
很流畅的旗子效果


623
00:36:52,579 --> 00:36:54,915 line:-1
而不需要在场景中有大量的多边形


624
00:36:55,582 --> 00:36:57,251 line:-1
旗子效果看起来真的很棒


625
00:36:58,252 --> 00:37:01,722 line:-2
每一帧 着色器都会把
匹配的几何结构更新为


626
00:37:01,788 --> 00:37:02,789 line:-1
它的新位置


627
00:37:03,257 --> 00:37:05,459 line:-1
通过以这种方式利用GPU


628
00:37:05,526 --> 00:37:09,730 line:-2
我们得到了一个很棒的效果
而它也不会影响主CPU


629
00:37:12,399 --> 00:37:15,769 line:-2
最后我想谈谈
SwiftShot中的音频实施


630
00:37:16,670 --> 00:37:19,806 line:-2
音频可以让任何游戏变得
更加拟真和迷人


631
00:37:20,674 --> 00:37:23,443 line:-1
我们知道我们想提供真实的声音效果


632
00:37:23,510 --> 00:37:26,813 line:-2
并在虚拟世界中适当地投放
从而得到真正拟真的体验


633
00:37:26,880 --> 00:37:28,315 line:-1
并给用户提供很好的反馈


634
00:37:28,382 --> 00:37:30,017 line:-1
关于他们要如何与那个世界交互


635
00:37:30,884 --> 00:37:33,453 line:-1
我们还想确保这个速度够快并关注


636
00:37:33,520 --> 00:37:36,390 line:-1
添加多少音频会增加我们app的大小


637
00:37:37,057 --> 00:37:39,326 line:-2
那么我们遇到了一个
我们认为很棒的方案


638
00:37:40,294 --> 00:37:42,963 line:-1
我们创建了一些代表性的声音示例


639
00:37:43,030 --> 00:37:46,099 line:-2
通过我们从团队员工的孩子们那儿
借来的玩具


640
00:37:47,301 --> 00:37:52,439 line:-2
然后我们录制了那些声音
并把它们结合到一个AU预设文件中


641
00:37:52,739 --> 00:37:56,343 line:-2
并用这些声音在AV Foundation中
创建自定义Midi乐器


642
00:37:56,677 --> 00:37:58,712 line:-2
使用AV Audio Unit
Midi Instrument


643
00:37:59,413 --> 00:38:02,115 line:-2
那样就能在合适的时候
快速播放合适的声音


644
00:38:02,182 --> 00:38:04,551 line:-1
以响应用户在游戏中的输入和碰撞


645
00:38:06,987 --> 00:38:08,655 line:-1
我们并不只是播放原声音


646
00:38:09,122 --> 00:38:11,992 line:-2
为了给用户提供良好的反馈
我们拉动弹弓


647
00:38:12,059 --> 00:38:14,194 line:-1
我们用多种方式区分了声音


648
00:38:14,795 --> 00:38:18,398 line:-2
我们修改了音高
根据他们向后拉动弹弓的距离


649
00:38:21,702 --> 00:38:24,705 line:-2
并且我们区分了音量
根据你向后拉动的速度


650
00:38:24,771 --> 00:38:27,708 line:-2
且在RunTime时实现
通过选择合适的Midi记录


651
00:38:27,774 --> 00:38:30,310 line:-1
然后使用一些额外的Midi命令


652
00:38:30,377 --> 00:38:31,879 line:-1
在播放那个声音之前进行替换


653
00:38:32,379 --> 00:38:34,815 line:-1
那么让我们听一下这个是…很安静


654
00:38:53,700 --> 00:38:57,604 line:-1
现在我们还想确保当你使用弹弓时


655
00:38:57,671 --> 00:39:01,208 line:-1
我们还向用户提供一些音频反馈


656
00:39:01,275 --> 00:39:03,377 line:-1
关于他们是否在弹弓的射程范围内


657
00:39:03,443 --> 00:39:04,845 line:-1
以及他们是否捕获了东西


658
00:39:04,912 --> 00:39:06,747 line:-1
这是你在一开始听到的哔哔声


659
00:39:07,347 --> 00:39:09,783 line:-2
因为那些对于用户来说
都属于用户界面反馈


660
00:39:10,217 --> 00:39:12,119 line:-1
设备才会发出那些声音


661
00:39:12,186 --> 00:39:14,488 line:-1
仅当用户与弹弓进行交互时


662
00:39:14,922 --> 00:39:18,158 line:-2
然而我们还希望
游戏中的每个人都了解


663
00:39:18,225 --> 00:39:21,028 line:-2
弹弓那儿发生了什么
无论其他人是否拉动弹弓


664
00:39:21,094 --> 00:39:23,297 line:-2
或做出类似操作
但我们希望那些声音小点儿


665
00:39:23,797 --> 00:39:27,334 line:-2
那么我们使用了位置性音频
这样如果我的对手


666
00:39:27,401 --> 00:39:30,571 line:-2
正在拉动他们的弹弓
我也能从我的设备上听到那个声音


667
00:39:30,637 --> 00:39:32,840 line:-2
但音量较小
且它被正确投放到了虚拟世界中


668
00:39:35,175 --> 00:39:38,679 line:-2
对于碰撞砖块
我们采用了一个类似但稍不同的方法


669
00:39:39,112 --> 00:39:43,917 line:-1
我们真的想要一个刺耳的效果


670
00:39:43,984 --> 00:39:46,887 line:-2
砖块通常不会出现在
任何一名玩家附近


671
00:39:46,954 --> 00:39:51,091 line:-2
所以SceneKit位置性支持
可以让这个声音变得很棒


672
00:39:52,092 --> 00:39:53,727 line:-1
每台设备都会独立发声


673
00:39:54,628 --> 00:39:56,797 line:-1
你不用担心设备之间的同步性


674
00:39:56,864 --> 00:39:59,766 line:-2
因为我们希望它是个刺耳的声音
砖块粉碎的声音


675
00:40:00,434 --> 00:40:02,469 line:-1
我们使用了自定义Midi乐器


676
00:40:03,003 --> 00:40:05,005 line:-1
采用了少量声音 然后把它们区分开


677
00:40:05,339 --> 00:40:07,841 line:-2
在本例中是按照碰撞冲量的力量
来区分攻击率的


678
00:40:07,908 --> 00:40:10,878 line:-2
碰撞冲量
来自SceneKit物理引擎


679
00:40:13,614 --> 00:40:15,883 line:-1
这些声音在3D坐标中进行了本地化


680
00:40:15,949 --> 00:40:17,885 line:-1
根据设备在场景中的位置


681
00:40:17,951 --> 00:40:20,921 line:-2
因此桌子最远处的碰撞
比近处的碰撞声音要小


682
00:40:21,522 --> 00:40:22,689 line:-1
让我们来听一下


683
00:40:38,572 --> 00:40:39,406 line:-1
再发射一次


684
00:40:40,574 --> 00:40:41,408 line:-1
好了


685
00:40:42,376 --> 00:40:43,210 line:-1
很棒


686
00:40:46,346 --> 00:40:48,282 line:-1
那么我们想分享另一个小技巧


687
00:40:48,348 --> 00:40:50,117 line:-1
是我们在实现这个的过程中发现的


688
00:40:50,784 --> 00:40:52,352 line:-1
在设置声音的过程中


689
00:40:52,419 --> 00:40:55,389 line:-2
我们发现我们需要
在Runtime时运行一个脚本


690
00:40:55,455 --> 00:40:59,159 line:-2
用于在属性列表上做一些
文件名称路径转换 用于EAU预设


691
00:41:00,260 --> 00:41:02,563 line:-2
我们发现我们可以用Swift
创建那个工具


692
00:41:02,896 --> 00:41:04,798 line:-1
但却把它设置为一个命令行工具


693
00:41:05,532 --> 00:41:06,967 line:-1
你注意到顶部了吗


694
00:41:07,034 --> 00:41:10,304 line:-2
脚本顶部传统的Unix shebang
样式状态


695
00:41:10,671 --> 00:41:14,374 line:-2
会告诉你的shell
启动Swift来运行这个


696
00:41:15,509 --> 00:41:18,679 line:-2
这样我们就可以将Swift
作为一个脚本语言


697
00:41:19,947 --> 00:41:22,282 line:-2
你可以通过Swift Playground
来开发其中一个


698
00:41:22,749 --> 00:41:26,053 line:-2
可以交互地编写代码
并确保代码的正确性


699
00:41:26,920 --> 00:41:31,058 line:-2
写好后 你只需要保存到一个文件中
并在顶部添加shebang行


700
00:41:31,491 --> 00:41:34,228 line:-1
并让文件在文件系统中可执行


701
00:41:35,229 --> 00:41:38,966 line:-2
现在你得到了一个命令行工具
你可以用来 你知道的


702
00:41:39,032 --> 00:41:42,803 line:-2
在app外使用或在Xcode中
通过RunScript语句使用


703
00:41:43,770 --> 00:41:48,242 line:-1
很简单 它会让你获取全部系统框架


704
00:41:48,308 --> 00:41:50,544 line:-1
在本例中 我们可直接编辑属性列表


705
00:41:51,044 --> 00:41:51,979 line:-1
这是一个非常棒的技巧


706
00:41:52,045 --> 00:41:54,515 line:-1
我们希望你们能好好利用它


707
00:41:57,417 --> 00:42:00,754 line:-2
那么今天 我希望你们了解了
AR如何提供新机会


708
00:42:00,821 --> 00:42:02,789 line:-1
给迷人的游戏和其它体验


709
00:42:03,657 --> 00:42:06,026 line:-2
我们鼓励你们从一开始设计
就考虑到AR


710
00:42:06,493 --> 00:42:08,662 line:-1
请记住对于游戏来说 玩才是重点


711
00:42:08,729 --> 00:42:11,198 line:-1
你不能在最后才体验游戏的趣味性


712
00:42:13,100 --> 00:42:16,904 line:-2
我们真心希望你会下载SwiftShot
开发者示例代码


713
00:42:16,970 --> 00:42:19,206 line:-1
并使用它来指导你创建你自己的app


714
00:42:19,506 --> 00:42:23,277 line:-2
我们计划在iOS 12的
每次更新中都更新它


715
00:42:23,343 --> 00:42:24,478 line:-1
只要我们发布新版本


716
00:42:25,045 --> 00:42:28,081 line:-1
最后如果你还没有机会这么做


717
00:42:28,148 --> 00:42:30,851 line:-2
希望你去楼下游戏室
和我们一起玩SwiftShot


718
00:42:32,486 --> 00:42:35,923 line:0
要获取更多信息 这场演讲之后
就有一个ARKit研究会


719
00:42:35,989 --> 00:42:37,257 line:0
今晚还有一次聚会


720
00:42:37,858 --> 00:42:40,727 line:0
我也很开心地宣布
对于参加了这场大会的你们


721
00:42:41,061 --> 00:42:44,097 line:0
我们在本周五的中午到下午两点
有一场SwiftShot联赛


722
00:42:44,164 --> 00:42:47,267 line:-1
我们希望你们能来参加 非常感谢

