1
00:00:17,417 --> 00:00:19,953 line:0
（为你的iOS app增添光彩
使其变得奇妙的六个专业技巧）


2
00:00:20,020 --> 00:00:20,854 line:0
嘿 伙计们！


3
00:00:21,321 --> 00:00:22,456 line:0
下午好


4
00:00:22,523 --> 00:00:23,657 line:0
（演讲233）


5
00:00:27,794 --> 00:00:30,964 line:-2
欢迎来到
“为你的iOS app增添光彩”


6
00:00:31,598 --> 00:00:32,633 line:-1
我叫Ben


7
00:00:32,698 --> 00:00:33,934 line:-1
我叫Peter


8
00:00:34,001 --> 00:00:37,271 line:-2
我们将向你展示六个专业技巧
来让你的app变得奇妙


9
00:00:38,005 --> 00:00:40,774 line:-1
我们将从外部显示器支持开始


10
00:00:41,441 --> 00:00:44,011 line:-1
将你的app体验带到大屏幕上


11
00:00:46,046 --> 00:00:50,050 line:-2
接下来我们将为你介绍一种
全新的编程模式


12
00:00:50,117 --> 00:00:51,451 line:-1
它被称为布局驱动UI


13
00:00:52,653 --> 00:00:53,687 line:-1
然后我们将向你展示


14
00:00:53,754 --> 00:00:56,523 line:-1
如何通过极速启动让你的客户


15
00:00:56,590 --> 00:00:59,560 line:-1
尽可能快地获得愉快体验


16
00:01:00,260 --> 00:01:02,462 line:-1
我们将重点关注平滑滚动


17
00:01:02,529 --> 00:01:04,631 line:-1
并让用户体验感觉良好


18
00:01:05,566 --> 00:01:08,669 line:-1
连贯性是iOS上最神奇的体验之一


19
00:01:08,902 --> 00:01:11,705 line:-1
我们将向你展示在你的app中


20
00:01:11,772 --> 00:01:12,906 line:-1
实现接力是多么容易


21
00:01:13,574 --> 00:01:17,744 line:-2
最后 我们将教你一些
超高级的调试技巧


22
00:01:17,811 --> 00:01:19,313 line:-1
并像专业人员一样进行调试


23
00:01:20,414 --> 00:01:22,816 line:-2
我们有很多内容要涵盖
所以让我们开始吧


24
00:01:28,455 --> 00:01:33,861 line:-2
iOS设备因其令人惊叹的
集成显示屏而声名远扬


25
00:01:35,562 --> 00:01:38,532 line:-2
而你可以通过添加
对外部显示器的支持


26
00:01:38,966 --> 00:01:41,802 line:-1
来进一步提升app的体验


27
00:01:43,403 --> 00:01:46,006 line:-2
为了演示这一点
我们构建了一个演示app


28
00:01:47,174 --> 00:01:50,210 line:-1
内置于iOS中的屏幕镜像


29
00:01:50,277 --> 00:01:52,646 line:-1
它能够将整个系统UI


30
00:01:52,713 --> 00:01:55,182 line:-1
复制到外部连接显示器上


31
00:01:56,416 --> 00:01:57,484 line:-1
这是演示app


32
00:01:57,885 --> 00:01:59,887 line:-2
如你所见
这是一个简单的照片查看器


33
00:02:00,254 --> 00:02:04,591 line:-2
当你点击照片缩略图时
照片会滑入并全屏显示


34
00:02:05,392 --> 00:02:09,630 line:-1
这整个体验都会复制到外部显示器上


35
00:02:11,331 --> 00:02:15,002 line:-2
为了充分利用外部显示器的尺寸
我们可以将iPhone旋转为横向


36
00:02:15,068 --> 00:02:17,104 line:-1
从而填充它


37
00:02:19,006 --> 00:02:20,007 line:-1
这很棒


38
00:02:20,073 --> 00:02:23,443 line:-2
我们不需要做任何工作
就能够获得这种体验


39
00:02:24,578 --> 00:02:27,281 line:-1
但我们可以做得更好


40
00:02:28,382 --> 00:02:31,285 line:-1
还有一些内置于iOS中的API


41
00:02:31,351 --> 00:02:35,355 line:-2
允许你创建一个完全自定义的
第二用户界面


42
00:02:35,422 --> 00:02:37,591 line:-1
并显示在此外接显示器上


43
00:02:39,593 --> 00:02:42,729 line:-2
让我们来看看
这样做的几个app示例


44
00:02:45,532 --> 00:02:47,501 line:-1
Keynote就是一个很好的例子


45
00:02:48,135 --> 00:02:50,804 line:-1
你可以在外部显示器上


46
00:02:50,871 --> 00:02:52,940 line:-1
显示当前手头上的幻灯片


47
00:02:53,740 --> 00:02:57,311 line:-2
但在iPhone显示屏上
你可以看到演示笔记


48
00:02:57,377 --> 00:03:01,048 line:-2
和下一张幻灯片
这些是任何演讲必不可少的工具


49
00:03:02,983 --> 00:03:04,218 line:-1
又或者你有一个游戏


50
00:03:05,419 --> 00:03:08,055 line:-1
但通常情况下 它会有覆盖控件


51
00:03:08,989 --> 00:03:13,327 line:-2
现在你可以创建一个
完全自定义的界面来控制你的游戏


52
00:03:13,393 --> 00:03:16,129 line:-1
并将其放在iOS设备的显示屏上


53
00:03:16,763 --> 00:03:21,101 line:-2
从而将完整流畅的
身临其境的游戏体验


54
00:03:21,168 --> 00:03:22,369 line:-1
带到外部显示器上


55
00:03:25,506 --> 00:03:28,842 line:-1
在为外部显示器设计app时


56
00:03:29,409 --> 00:03:31,979 line:-1
你应该考虑一些关键的事情


57
00:03:33,780 --> 00:03:38,919 line:-2
除了明显的尺寸差异外
你的iPhone是私人的


58
00:03:39,353 --> 00:03:41,355 line:-1
所以你应该考虑作为私有信息


59
00:03:41,421 --> 00:03:43,757 line:-1
显示在屏幕上的那类信息


60
00:03:45,392 --> 00:03:48,629 line:0
而外部显示器通常位于


61
00:03:48,695 --> 00:03:53,300 line:0
很多人可以看到它的环境中
例如客厅里的电视


62
00:03:54,067 --> 00:03:56,003 line:0
或会议厅的投影系统


63
00:03:57,571 --> 00:04:01,575 line:0
因此你应该假设在此显示屏上
显示的信息是公开的


64
00:04:03,210 --> 00:04:05,279 line:0
此外 iPhone和iPad的
内置显示屏


65
00:04:05,345 --> 00:04:10,184 line:-2
是可交互的
而外部显示器却不是


66
00:04:10,651 --> 00:04:12,986 line:-1
因此你应该避免在外部显示器上


67
00:04:13,053 --> 00:04:16,322 line:-1
显示UI元素或其它可交互控件


68
00:04:18,024 --> 00:04:21,394 line:-2
所以让我们将这种想法
app到我们的演示app中


69
00:04:21,461 --> 00:04:22,930 line:-1
并看看我们能做出什么


70
00:04:24,198 --> 00:04:27,334 line:-1
这是我们针对外部显示器的优化版本


71
00:04:28,535 --> 00:04:33,106 line:-2
如你所见 现在我们能够
在外部显示器上显示


72
00:04:33,173 --> 00:04:34,575 line:-1
所选照片的完整尺寸


73
00:04:35,409 --> 00:04:38,879 line:-2
而在集成显示屏上
我们只显示缩略图


74
00:04:38,946 --> 00:04:40,514 line:-1
和一个新的选中标志


75
00:04:40,581 --> 00:04:43,550 line:-1
它显示了当前正在全屏显示的照片


76
00:04:45,385 --> 00:04:48,822 line:-2
虽然简单 但这是对该设计的
一种非常强大的用法


77
00:04:50,891 --> 00:04:53,393 line:-2
为了向你展示
我们如何在演示app中构建它


78
00:04:53,460 --> 00:04:55,062 line:-1
我们将讨论三个主题


79
00:04:56,096 --> 00:04:58,131 line:-1
连接、行为


80
00:04:58,532 --> 00:04:59,933 line:-1
和连接转换


81
00:05:01,168 --> 00:05:02,603 line:-1
我们先从连接开始


82
00:05:03,370 --> 00:05:06,507 line:-1
你如何知道是否连接了外接显示器


83
00:05:08,075 --> 00:05:10,611 line:-2
UIScreen有一个类变量
即screens


84
00:05:11,078 --> 00:05:13,480 line:-1
其中包含所有已连接的显示器列表


85
00:05:13,547 --> 00:05:15,849 line:-1
包括内置于iPhone的显示设备


86
00:05:16,884 --> 00:05:19,620 line:-1
因此如果这个数组中的元素不止一个


87
00:05:20,053 --> 00:05:22,656 line:-1
你就知道你连接了一个外部显示器


88
00:05:24,525 --> 00:05:30,097 line:-2
此外 由于外部显示器可以
随意连接和断开


89
00:05:30,931 --> 00:05:34,601 line:-2
UIKit会发布一些通知
以帮助你了解何时发生这种情况


90
00:05:35,602 --> 00:05:39,439 line:-2
因此你应该监听UIScreen.didConnect
Notification


91
00:05:39,506 --> 00:05:41,909 line:-2
和UIScreen.didDisconnect
Notification


92
00:05:42,276 --> 00:05:44,711 line:-1
然后相应地调出或移除你的用户界面


93
00:05:46,180 --> 00:05:48,782 line:-1
Peter 你能告诉我们的开发者


94
00:05:48,849 --> 00:05:50,417 line:-1
设置第二用户界面有多容易吗？


95
00:05:50,918 --> 00:05:52,519 line:-1
Ben 我很乐意


96
00:05:52,886 --> 00:05:56,557 line:-2
让我们看看UIScreen的
连接回调代码


97
00:05:57,724 --> 00:06:01,929 line:-2
我们在这里将一个局部变量
设为屏幕数组中的最后一个屏幕


98
00:06:02,429 --> 00:06:04,565 line:-1
我们知道这是外部屏幕


99
00:06:04,631 --> 00:06:07,734 line:-2
因为我们当前在
didConnectNotification回调中


100
00:06:08,569 --> 00:06:12,773 line:-2
接下来我们将创建一个新的UIWindow
用来显示在此外部显示器上


101
00:06:13,240 --> 00:06:16,910 line:-2
并且我们将其screen属性
设置为该屏幕


102
00:06:17,177 --> 00:06:20,047 line:-1
接下来我们要确保配置此窗口


103
00:06:20,347 --> 00:06:23,283 line:-2
我们将其归因到一个函数中
但我们在这里所做的是


104
00:06:23,350 --> 00:06:26,286 line:-2
创建一个根视图控制器
并将其绑定到窗口上


105
00:06:26,653 --> 00:06:29,256 line:-1
这和我们为板载显示器所做的一样


106
00:06:29,923 --> 00:06:33,493 line:-1
最后我们要将此窗口标记为非隐藏


107
00:06:33,560 --> 00:06:35,295 line:-1
来将其显示在外部屏幕上


108
00:06:36,196 --> 00:06:37,397 line:-1
所以这就是连接


109
00:06:37,764 --> 00:06:40,534 line:-2
现在我们来看看断开连接
这甚至更简单


110
00:06:41,335 --> 00:06:46,106 line:-2
这里我们位于UIScreen.didDisconnect
Notification处理程序中


111
00:06:46,173 --> 00:06:48,609 line:-1
我们在这里要做的只是隐藏窗口


112
00:06:48,942 --> 00:06:52,279 line:-2
并将其局部引用设为nil
以释放任何资源


113
00:06:52,346 --> 00:06:53,247 line:-1
就这么多


114
00:06:53,313 --> 00:06:56,650 line:-2
我们已经在app中实现了
屏幕连接和断开连接


115
00:06:57,384 --> 00:06:58,785 line:-1
哇 Peter 这真容易


116
00:07:00,721 --> 00:07:02,556 line:-1
接下来你要考虑的事情


117
00:07:02,756 --> 00:07:04,691 line:-1
是在连接上外部显示器时


118
00:07:05,125 --> 00:07:07,227 line:-1
更改app的默认行为


119
00:07:09,096 --> 00:07:12,199 line:-2
让我们看看演示app中的
一些代码示例


120
00:07:13,133 --> 00:07:16,904 line:-2
这是我们点击集合视图中的照片时
所调用的代码


121
00:07:18,305 --> 00:07:20,040 line:-1
当我们处于单一显示模式时


122
00:07:20,107 --> 00:07:24,578 line:-2
我们创建一个photoViewController
并将其压入我们的导航栈中


123
00:07:25,579 --> 00:07:28,015 line:-1
但当我们连接了外部显示器时


124
00:07:28,081 --> 00:07:30,717 line:-2
我们已经在第二个UI中
全屏显示了photoViewController


125
00:07:30,784 --> 00:07:35,255 line:-1
因此我们只是告诉它呈现那张照片


126
00:07:35,822 --> 00:07:36,657 line:-1
非常容易


127
00:07:38,091 --> 00:07:41,828 line:-2
在为外部显示器设计app时
应该考虑的第三件事


128
00:07:43,096 --> 00:07:45,098 line:-1
是你应该使用优雅的过渡


129
00:07:45,165 --> 00:07:46,700 line:-1
来处理连接更改


130
00:07:48,836 --> 00:07:51,138 line:-1
让我们回到演示app来说明这一点


131
00:07:52,773 --> 00:07:56,710 line:-2
这里你可以看到我们的演示app
正在显示完整尺寸的照片


132
00:07:57,077 --> 00:07:59,646 line:-1
而且我们还没有连接外部显示器


133
00:08:00,747 --> 00:08:02,416 line:-1
请看当我们连接时会发生什么


134
00:08:06,386 --> 00:08:08,889 line:-2
这里所发生的事情是我们弹出了
viewController


135
00:08:08,956 --> 00:08:12,326 line:-1
返回缩略图视图


136
00:08:12,392 --> 00:08:16,430 line:-2
并同时在外部显示器上以全尺寸
显示刚才选中的照片


137
00:08:17,898 --> 00:08:23,003 line:-2
正是这些优雅的过渡
有效地保留了上下文


138
00:08:23,070 --> 00:08:26,206 line:-2
并帮助你的用户了解
他们在你的app流程中的位置


139
00:08:28,208 --> 00:08:31,545 line:-2
这就是外部显示器支持
它很容易设置


140
00:08:32,546 --> 00:08:34,615 line:-1
只需在设计app时


141
00:08:34,681 --> 00:08:36,183 line:-1
考虑不同的显示上下文


142
00:08:36,717 --> 00:08:39,086 line:-1
并确保能够优雅地处理连接更改


143
00:08:40,153 --> 00:08:44,591 line:-2
若想了解有关此内容的更多信息
请查看2011年WWDC的该演讲


144
00:08:45,325 --> 00:08:46,159 line:-1
谢谢


145
00:08:46,226 --> 00:08:50,564 line:0
（布局驱动UI）


146
00:08:51,698 --> 00:08:54,768 line:-2
布局驱动UI是一种强大的
app开发方式


147
00:08:54,835 --> 00:08:58,038 line:-1
它使你的app便于添加功能


148
00:08:58,438 --> 00:09:00,307 line:-1
并且更容易调试


149
00:09:01,441 --> 00:09:05,445 line:-2
布局驱动UI有助于我们解决iOS
app中大部分问题的首要原因


150
00:09:05,512 --> 00:09:09,917 line:-1
即管理UI复杂性


151
00:09:10,851 --> 00:09:13,787 line:-2
我确信你曾遇到过这些问题
我知道我遇到过


152
00:09:14,454 --> 00:09:16,757 line:-1
你添加了一些代码和手势回调


153
00:09:17,191 --> 00:09:20,627 line:-2
你甚至在通知回调中
添加了更多UI更新代码


154
00:09:20,694 --> 00:09:24,498 line:-2
当UI控件被触发并获取值时
甚至更多


155
00:09:24,965 --> 00:09:29,369 line:-2
突然间 你的app处于这种
奇怪且难以理解的状态


156
00:09:30,003 --> 00:09:32,005 line:-1
你必须沿着这些奇怪的顺序


157
00:09:32,072 --> 00:09:34,007 line:-1
才能重现这些不寻常的漏洞


158
00:09:34,675 --> 00:09:38,912 line:-2
当你向app添加更多功能时
问题会越来越严重


159
00:09:40,214 --> 00:09:46,553 line:-2
如果我们改为遵循一个简单的配方
并将这些UI更新放到布局中


160
00:09:47,120 --> 00:09:50,624 line:-2
我们就可以摆脱这些漏洞
并使添加功能更容易


161
00:09:51,391 --> 00:09:55,662 line:-2
让我们来看看为你的app
添加布局驱动UI的方法


162
00:09:57,497 --> 00:09:58,999 line:-1
你需要做的第一件事是


163
00:09:59,066 --> 00:10:03,904 line:-2
你需要识别并跟踪
影响UI的所有状态


164
00:10:05,506 --> 00:10:07,908 line:-1
然后 每当状态发生变化时


165
00:10:08,242 --> 00:10:11,445 line:-2
你应该通过调用setNeedsLayout
来脏化布局系统


166
00:10:12,846 --> 00:10:13,847 line:-1
最后


167
00:10:14,515 --> 00:10:18,151 line:-2
你需要在layoutSubviews中
使用此状态来更新UI


168
00:10:19,253 --> 00:10:20,153 line:-1
就是这样


169
00:10:20,687 --> 00:10:24,024 line:-1
我喜欢这个配方就是因为它的易用性


170
00:10:25,492 --> 00:10:29,296 line:-2
如果我们将布局驱动UI
全面应用于我们的app


171
00:10:30,531 --> 00:10:33,700 line:-2
同时考虑iOS app的
三个核心组件


172
00:10:34,168 --> 00:10:39,273 line:-2
即布局、动画和手势
你会发现我们对这三者的实现


173
00:10:39,339 --> 00:10:44,645 line:-1
能以一种非常棒的方式和谐地工作


174
00:10:45,879 --> 00:10:47,681 line:-1
让我们从布局开始


175
00:10:49,783 --> 00:10:52,052 line:-1
布局是你在屏幕上定位


176
00:10:52,119 --> 00:10:54,521 line:-1
app内容的过程


177
00:10:55,522 --> 00:11:00,294 line:-2
但我们也建议你在布局中
执行所有其它UI更新


178
00:11:00,761 --> 00:11:04,431 line:-2
看一个我们写的简单示例app
以突出显示这一点


179
00:11:04,965 --> 00:11:06,366 line:-2
Ben 你能带我们
看看这个app吗？


180
00:11:07,234 --> 00:11:08,168 line:-1
当然 Peter


181
00:11:09,069 --> 00:11:12,272 line:-2
这是一个非常简单的示例app
中间有个很酷的家伙


182
00:11:13,140 --> 00:11:14,541 line:-2
当我们感觉很酷时
它会显示


183
00:11:14,942 --> 00:11:16,677 line:-1
否则它会隐藏起来


184
00:11:17,911 --> 00:11:19,680 line:-1
但我们现在感觉很酷 Peter


185
00:11:19,746 --> 00:11:20,914 line:-1
所以让我把它显示出来


186
00:11:21,815 --> 00:11:26,687 line:-2
很好 虽然这是一个简单的例子
但演示它非常重要


187
00:11:26,753 --> 00:11:29,556 line:-2
以便我们可以理解
布局驱动UI的工作原理


188
00:11:30,224 --> 00:11:34,228 line:-1
让我们来看看这个app的骨架


189
00:11:34,294 --> 00:11:37,397 line:-2
以及Ben之前向我们展示的
布局驱动UI配方


190
00:11:38,198 --> 00:11:42,369 line:-2
一管理视图 在coolView中
托管着这个酷家伙的视图


191
00:11:42,436 --> 00:11:45,105 line:-1
这是我预先写好的


192
00:11:45,906 --> 00:11:48,041 line:-2
那么 Ben 我们配方的
第一步是什么？


193
00:11:48,609 --> 00:11:53,046 line:-2
我们需要识别并跟踪
影响我们的UI的状态


194
00:11:53,747 --> 00:11:55,349 line:-1
记住Ben说的话


195
00:11:55,415 --> 00:11:57,985 line:-2
当我们感觉很酷时
酷家伙就出现在那里


196
00:11:58,318 --> 00:11:59,987 line:-1
否则它就不在


197
00:12:00,754 --> 00:12:03,323 line:-2
所以我猜我们会有一个
名为feelingCool的变量


198
00:12:03,891 --> 00:12:04,858 line:-1
好


199
00:12:04,925 --> 00:12:06,927 line:-1
Ben 配方的第二步是什么？


200
00:12:07,494 --> 00:12:09,730 line:-1
现在 每当这种状态改变时


201
00:12:09,796 --> 00:12:13,033 line:-2
我们需要通过调用setNeedsLayout
来脏化布局系统


202
00:12:13,600 --> 00:12:17,371 line:-2
但我们需要确保每次状态发生变化时
都会进行该操作


203
00:12:17,437 --> 00:12:21,141 line:-2
此状态可能会在我们app中的
各个位置发生改变


204
00:12:21,575 --> 00:12:24,678 line:-2
那么 Peter
我们怎样才能确保当变化发生时


205
00:12:24,745 --> 00:12:25,846 line:-1
我们总能脏化布局系统呢？


206
00:12:25,913 --> 00:12:26,847 line:-1
我很高兴你问这点


207
00:12:26,914 --> 00:12:28,749 line:-1
因为我觉得我对此有个好主意


208
00:12:29,316 --> 00:12:32,452 line:-2
我们可以使用一个名为
Swift属性观察器的功能


209
00:12:33,287 --> 00:12:37,257 line:-2
它让我们能够在属性被设置
之前或之后运行代码


210
00:12:37,758 --> 00:12:40,160 line:-2
因此我们可以使用
didSet属性观察器


211
00:12:40,627 --> 00:12:42,129 line:-2
来调用
setNeedsLayout


212
00:12:42,563 --> 00:12:46,366 line:-2
这是在你的app中使用
Swift属性观察器的绝好时机


213
00:12:47,267 --> 00:12:49,102 line:-1
好的 我们差不多完成了


214
00:12:49,536 --> 00:12:51,405 line:-1
Ben 配方的最后一步是什么


215
00:12:51,839 --> 00:12:53,507 line:-1
Peter 通过使用该状态


216
00:12:53,574 --> 00:12:56,376 line:-2
我们需要在layoutSubviews中
更新我们的UI


217
00:12:57,311 --> 00:12:58,879 line:-1
好的 这很简单


218
00:12:59,313 --> 00:13:03,083 line:-2
覆盖layoutSubviews
并基于feelingCool值


219
00:13:03,150 --> 00:13:06,620 line:-2
更新酷家伙视图的
isHidden属性


220
00:13:07,120 --> 00:13:11,191 line:-2
就是这样 这就是为你的app添加
布局驱动UI所需要做的全部工作


221
00:13:11,592 --> 00:13:15,529 line:-1
这不仅对这个简单的例子非常有效


222
00:13:15,596 --> 00:13:17,531 line:-2
它也适用于一些更早
且更复杂的app


223
00:13:18,298 --> 00:13:22,402 line:-2
Ben和我昨晚熬夜玩了
这个新的macOS


224
00:13:22,469 --> 00:13:25,839 line:-2
《万智牌》卡牌游戏
它席卷了整个Apple园区


225
00:13:27,307 --> 00:13:30,177 line:-2
我们写了有趣的卡堆生成器app
来帮助我们赢得


226
00:13:30,244 --> 00:13:32,045 line:-1
下周末的比赛 我们真打算这么干


227
00:13:32,880 --> 00:13:35,215 line:-1
它允许你拿起并拖动这些卡片


228
00:13:35,282 --> 00:13:37,384 line:-1
并且你可以将它们扔进这个卡堆区域


229
00:13:37,718 --> 00:13:41,955 line:-2
它非常迅速、有趣和流畅
我们可以同时拿两张卡


230
00:13:42,422 --> 00:13:46,593 line:-2
我认为我们可以通过该app
真正向你展示布局驱动UI如何工作


231
00:13:47,060 --> 00:13:50,664 line:-2
而且很重要的是
我们可以在下周末击败Ben的同事


232
00:13:51,431 --> 00:13:54,301 line:-1
所以让我们来看看iOS app的


233
00:13:54,368 --> 00:13:55,469 line:-1
另外两个核心组件


234
00:13:55,536 --> 00:13:58,138 line:-2
以及我们如何将布局驱动UI
应用于它们


235
00:13:58,205 --> 00:14:00,207 line:-1
先从动画开始


236
00:14:01,808 --> 00:14:05,612 line:-1
动画是任何卓越iOS体验的标志


237
00:14:06,513 --> 00:14:09,149 line:-1
用户界面的逼真动作


238
00:14:09,216 --> 00:14:10,951 line:-1
真正让app看起来像活的一样


239
00:14:12,452 --> 00:14:14,755 line:-1
UIKit提供了一些很棒的API


240
00:14:14,821 --> 00:14:17,257 line:-1
来帮助你创建这些赏心悦目的动画


241
00:14:18,825 --> 00:14:22,529 line:-2
UIViewPropertyAnimator API
是一个非常强大的工具


242
00:14:23,063 --> 00:14:26,099 line:-1
并且去年它增加了大量新功能


243
00:14:26,967 --> 00:14:28,502 line:-1
若想了解如何使用其所有信息


244
00:14:28,569 --> 00:14:33,340 line:-2
请观看2017年WWDC中的演讲
“使用UIKit实现高级动画”


245
00:14:34,741 --> 00:14:36,109 line:-1
除此之外


246
00:14:36,176 --> 00:14:38,278 line:-1
久经考验的UIView闭包API


247
00:14:38,345 --> 00:14:40,514 line:-1
也是制作这些动画的好方法


248
00:14:42,516 --> 00:14:43,517 line:-1
太棒了


249
00:14:43,884 --> 00:14:48,188 line:-2
我们可以将UIViewAnimations
用于我们的布局驱动UI app


250
00:14:49,022 --> 00:14:52,092 line:-1
要记住的一件事是我们总是想要使用


251
00:14:52,159 --> 00:14:54,828 line:-1
beginFromCurrentState动画选项


252
00:14:55,829 --> 00:14:57,197 line:-1
这告诉UIKit


253
00:14:57,264 --> 00:15:00,234 line:-2
在播放动画时
获取视图的当前屏幕位置


254
00:15:00,300 --> 00:15:03,670 line:-1
即使是在动画运行中期


255
00:15:04,238 --> 00:15:05,772 line:-1
所以这让我们实现了


256
00:15:05,839 --> 00:15:09,243 line:-1
这些非常精彩的和可中断的互动动画


257
00:15:09,810 --> 00:15:13,881 line:-2
让我们来看看macOS上的
《万智牌》卡牌游戏app中的例子


258
00:15:15,382 --> 00:15:19,553 line:-2
这里有一个变量来跟踪
我们卡堆中的牌


259
00:15:19,853 --> 00:15:23,023 line:-2
通过使用我们之前讨论过的
Swift属性观察器


260
00:15:23,390 --> 00:15:26,360 line:-2
每当其发生变化时 我们可以调用
setNeedsLayout()


261
00:15:26,426 --> 00:15:28,061 line:-1
来脏化布局系统


262
00:15:29,997 --> 00:15:34,168 line:-2
然后当我们想要在卡堆中放一张牌时
我们所要做的就是


263
00:15:34,434 --> 00:15:37,838 line:-2
将该卡添加到此数组中
这将脏化我们的布局


264
00:15:38,438 --> 00:15:40,874 line:-1
然后在动画块内


265
00:15:40,941 --> 00:15:45,379 line:-2
设置这个beginFromCurrentState选项
并调用layoutIfNeeded


266
00:15:46,146 --> 00:15:49,316 line:-2
这将触发对layoutSubviews
中的代码调用


267
00:15:49,383 --> 00:15:51,318 line:-1
它会移动我们的视图


268
00:15:51,385 --> 00:15:54,188 line:-1
播放适当的动画以及进行状态转换


269
00:15:54,655 --> 00:15:58,025 line:-2
我想在这里特别强调的
关于这其中最棒的一点是


270
00:15:58,091 --> 00:16:01,495 line:-2
我们没有为这些动画
添加任何特殊情况


271
00:16:02,129 --> 00:16:04,965 line:-1
我们只是通过在动画块内部进行布局


272
00:16:05,265 --> 00:16:08,368 line:-1
而轻易得到这个动画布局


273
00:16:09,203 --> 00:16:10,871 line:-1
这真的非常棒


274
00:16:11,471 --> 00:16:14,975 line:-2
这就是我们如何将动画
添加到布局驱动UI app中


275
00:16:16,310 --> 00:16:17,144 line:-1
最后


276
00:16:17,211 --> 00:16:21,448 line:-2
我们来谈谈iOS app的
第三个核心方面 即手势


277
00:16:21,982 --> 00:16:23,050 line:-1
当然


278
00:16:23,116 --> 00:16:27,454 line:-2
不谈论UIGestureRecognizer
我们就无法谈论手势


279
00:16:27,821 --> 00:16:31,625 line:-2
它是UIKit中用于为你的app
添加手势交互的强大API


280
00:16:33,527 --> 00:16:36,763 line:-2
UIKit提供了许多
UIGestureRecognizer的


281
00:16:36,830 --> 00:16:38,265 line:-1
很棒的具体子类


282
00:16:38,866 --> 00:16:41,935 line:-2
其涵盖从拖动到捏合到滑动
到旋转等所有内容


283
00:16:42,436 --> 00:16:45,539 line:-1
你可以使用它们创建所需的交互类型


284
00:16:45,772 --> 00:16:47,808 line:-1
它们也是高度可定制的


285
00:16:48,942 --> 00:16:51,078 line:-1
如果你想要一些非常疯狂的东西


286
00:16:51,345 --> 00:16:54,114 line:-2
你也可以自己继承
UIGestureRecognizer


287
00:16:56,116 --> 00:16:59,753 line:-2
当查看内置的
UIKitGestureRecognizer时


288
00:16:59,820 --> 00:17:01,722 line:-1
了解离散和连续手势


289
00:17:01,788 --> 00:17:04,758 line:-1
之间的差异非常重要


290
00:17:05,925 --> 00:17:08,795 line:-1
离散手势告诉你某个事件发生了


291
00:17:09,530 --> 00:17:13,333 line:-2
它们从Possible状态开始
然后不经过其它过程


292
00:17:13,400 --> 00:17:15,002 line:-1
它们也不收200美元


293
00:17:15,068 --> 00:17:17,503 line:-2
而是立即进入
Recognized状态


294
00:17:18,472 --> 00:17:22,342 line:-2
这对你的app中的
一次性互动非常有用


295
00:17:22,742 --> 00:17:25,913 line:-1
但不会告诉你交互过程中的各个阶段


296
00:17:27,548 --> 00:17:30,250 line:-1
另一种类型的手势是连续手势


297
00:17:30,617 --> 00:17:33,187 line:-1
它们为你提供更高级别的保真度


298
00:17:34,288 --> 00:17:37,090 line:-2
与离散手势一样
它们也从Possible状态开始


299
00:17:37,758 --> 00:17:41,228 line:-2
但随着它们开始被认出
它们会转移到Began状态


300
00:17:42,629 --> 00:17:45,332 line:-2
在进行跟踪时
它们进入Changed状态


301
00:17:45,632 --> 00:17:48,535 line:-1
当手势四处移动时


302
00:17:48,602 --> 00:17:50,070 line:-1
你会接收到连续的事件流


303
00:17:51,471 --> 00:17:55,576 line:-2
最后 当手势完成后
它会转移到Ended状态


304
00:17:57,611 --> 00:18:00,147 line:-1
我们最喜欢的连续手势之一


305
00:18:00,214 --> 00:18:02,082 line:-1
是UIPanGestureRecognizer


306
00:18:02,749 --> 00:18:05,085 line:-1
而且有两个很棒的函数


307
00:18:05,152 --> 00:18:06,820 line:-1
可以帮助你充分利用它


308
00:18:08,121 --> 00:18:11,558 line:-2
translationInView
会告诉你 相对于你的视图


309
00:18:11,625 --> 00:18:12,926 line:-1
你的手势跟踪的位置


310
00:18:14,194 --> 00:18:17,931 line:-2
而velocityInView
会告诉你手势的移动速度


311
00:18:18,365 --> 00:18:22,169 line:-1
这对于在手势和后续动画之间


312
00:18:22,236 --> 00:18:23,770 line:-1
切换速度非常有用


313
00:18:25,472 --> 00:18:29,743 line:-2
若想了解如何使用它们构建
真正优秀的手势交互


314
00:18:29,810 --> 00:18:32,880 line:-1
请查看2014年WWDC中的演讲


315
00:18:32,946 --> 00:18:34,848 line:-1
构建可中断和响应式交互


316
00:18:36,250 --> 00:18:39,453 line:-2
我也喜欢
UIPanGestureRecognizer


317
00:18:39,520 --> 00:18:40,787 line:-1
我们用它构建了


318
00:18:40,854 --> 00:18:43,590 line:-1
你之前看到的卡片拖动行为


319
00:18:44,391 --> 00:18:47,327 line:-2
让我们看看我们是如何
使用布局驱动UI做到这一点的


320
00:18:49,263 --> 00:18:53,700 line:-2
我们这里也有一个局部变量
用于跟踪已被应用手势的


321
00:18:53,767 --> 00:18:56,703 line:-1
每张卡片的偏移量


322
00:18:57,337 --> 00:19:00,374 line:-1
注意每当此变量发生变化时


323
00:19:00,440 --> 00:19:04,478 line:-2
我们都使用Swift的属性观察器
触发setNeedsLayout


324
00:19:06,280 --> 00:19:10,117 line:-2
接下来 在我们的
PanGestureRecognizer的回调函数中


325
00:19:10,584 --> 00:19:12,619 line:-1
我们将从手势中获取


326
00:19:12,686 --> 00:19:14,254 line:-1
当前的变化和视图


327
00:19:14,755 --> 00:19:18,091 line:-1
并将此手势与我们的一张卡相关联


328
00:19:18,892 --> 00:19:23,931 line:-2
然后我们在该字典中
增加此卡的偏移量


329
00:19:25,499 --> 00:19:29,903 line:-2
最后 在layoutSubviews中
我们将根据卡片在此字典中的偏移量


330
00:19:29,970 --> 00:19:34,908 line:-1
更新它们的视图的位置


331
00:19:36,210 --> 00:19:41,381 line:-2
再次注意 我们并没有做
任何特别的事情


332
00:19:41,448 --> 00:19:43,417 line:-1
除了传统的布局驱动UI事务


333
00:19:44,151 --> 00:19:47,988 line:-2
我们只是使用了这个状态
它碰巧是由手势驱动的


334
00:19:48,055 --> 00:19:50,457 line:-1
并且在layoutSubviews中响应它


335
00:19:51,592 --> 00:19:55,195 line:-2
事实上 如果你在整个app中
遵循此模式


336
00:19:55,262 --> 00:19:57,664 line:-1
你会发现它让很多这类交互


337
00:19:57,731 --> 00:19:59,333 line:-1
变得更容易使用


338
00:20:00,601 --> 00:20:03,971 line:-2
这就是布局驱动UI
请记住该配方


339
00:20:04,638 --> 00:20:07,875 line:-1
查找并跟踪影响UI的所有状态


340
00:20:08,175 --> 00:20:10,143 line:-1
并使用Swift属性观察器


341
00:20:10,210 --> 00:20:13,647 line:-2
来在此状态发生变化时
触发setNeedsLayout


342
00:20:14,681 --> 00:20:17,651 line:-1
最后 在layoutSubviews的实现中


343
00:20:17,918 --> 00:20:22,890 line:-2
确保根据你所跟踪的状态
来更新你的视图状态


344
00:20:23,290 --> 00:20:24,191 line:-1
谢谢


345
00:20:29,062 --> 00:20:32,833 line:-1
iOS体验的核心就是强响应性


346
00:20:34,034 --> 00:20:37,671 line:-1
你希望你的用户可以尽可能快地


347
00:20:38,071 --> 00:20:39,673 line:-1
获得愉悦的体验


348
00:20:40,974 --> 00:20:46,079 line:-2
在点击你的图标并获得这种
愉悦体验之间还差一步


349
00:20:46,947 --> 00:20:50,083 line:-1
而这一步就是你的启动时间


350
00:20:52,486 --> 00:20:55,956 line:-2
为了帮助你优化这点
我们将向你展示


351
00:20:56,023 --> 00:21:00,928 line:-1
构成启动内部过程的五个高级组件


352
00:21:02,763 --> 00:21:03,931 line:-1
从第一个开始


353
00:21:04,665 --> 00:21:05,799 line:-1
即进程分叉


354
00:21:07,000 --> 00:21:09,403 line:-2
Peter 在启动阶段
我们能做些什么呢？


355
00:21:10,103 --> 00:21:13,674 line:-1
至于进程分叉 它真的很复杂


356
00:21:13,740 --> 00:21:16,910 line:-2
你需要阅读
分叉和执行的帮助页面


357
00:21:16,977 --> 00:21:19,780 line:-1
并熟悉POSIX基础知识


358
00:21:20,080 --> 00:21:21,215 line:-1
不 我只是在开玩笑


359
00:21:21,481 --> 00:21:24,384 line:-1
iOS将为你处理进程分叉


360
00:21:25,652 --> 00:21:28,488 line:-2
我们为你处理了第一步
现在来看看第二步


361
00:21:31,358 --> 00:21:32,492 line:-1
动态链接


362
00:21:34,428 --> 00:21:38,832 line:-2
在此阶段 我们分配内存以开始
执行你的app


363
00:21:39,833 --> 00:21:41,969 line:-1
我们链接库和框架


364
00:21:42,636 --> 00:21:45,606 line:-2
我们初始化Swift、Objective-C
和Foundation


365
00:21:46,473 --> 00:21:48,809 line:-1
我们也进行静态对象初始化


366
00:21:50,177 --> 00:21:51,278 line:-1
通常我们会看到


367
00:21:51,345 --> 00:21:55,883 line:-2
它可能占app典型启动时间的
40%到50%


368
00:21:57,251 --> 00:21:58,852 line:-1
要记住的一件重要的事情是


369
00:21:58,919 --> 00:22:01,321 line:-1
此时你的代码还没有开始运行


370
00:22:02,623 --> 00:22:05,392 line:-1
因此了解如何优化它至关重要


371
00:22:06,159 --> 00:22:08,462 line:-2
Peter 你对开发者
有何好建议吗？


372
00:22:08,695 --> 00:22:12,799 line:-1
我很高兴你问这个问题 Ben


373
00:22:12,866 --> 00:22:15,969 line:-2
在优化app启动的链接阶段时
请务必要谨慎


374
00:22:16,303 --> 00:22:20,007 line:-1
因为它占用了大量的启动时间


375
00:22:21,441 --> 00:22:23,177 line:-1
我给你的第一条建议


376
00:22:23,243 --> 00:22:26,346 line:-1
是尽可能避免代码重复


377
00:22:26,980 --> 00:22:32,686 line:-2
如果你有多余的函数、对象或结构
请从你的app中删除它们


378
00:22:32,753 --> 00:22:34,054 line:-1
不要重复自己


379
00:22:35,222 --> 00:22:39,126 line:-1
接下来 你最好限制使用第三方库


380
00:22:40,060 --> 00:22:42,796 line:-1
iOS自己的库会被缓存


381
00:22:42,963 --> 00:22:47,367 line:-2
并且如果另一个app正在使用它们
则它可能已处于活动内存中


382
00:22:48,402 --> 00:22:51,071 line:-1
但第三方库不会被缓存


383
00:22:51,138 --> 00:22:54,341 line:-2
即使其它app使用
与你相同版本的库


384
00:22:55,108 --> 00:22:58,245 line:-2
如果你的app也使用它
我们仍然需要重新加载该框架


385
00:22:58,679 --> 00:23:01,715 line:-1
因此你应该尽可能多地


386
00:23:01,782 --> 00:23:02,950 line:-1
限制使用这些第三方库


387
00:23:03,917 --> 00:23:07,855 line:-1
最后 你要避免使用静态初始化器


388
00:23:08,255 --> 00:23:13,026 line:-2
避免在诸如+initialize
和+load等的方法中有任何行为


389
00:23:13,360 --> 00:23:17,130 line:-2
因为它们必须在你的app
可以执行任何有意义的工作之前运行


390
00:23:18,632 --> 00:23:22,135 line:-2
若想了解有关启动时间
这一重要部分的更多信息


391
00:23:22,202 --> 00:23:26,840 line:-2
请观看2017年WWDC中的演讲
app启动时间：过去、现在和未来


392
00:23:28,709 --> 00:23:32,045 line:-1
启动的下一阶段是UI构建


393
00:23:32,880 --> 00:23:37,217 line:-2
此时你正在准备UI
并构建viewControllers


394
00:23:38,585 --> 00:23:42,289 line:-2
系统会进行状态恢复
并载入你的首选项


395
00:23:43,790 --> 00:23:46,059 line:-1
你也会加载为了让你的app


396
00:23:46,126 --> 00:23:47,728 line:-1
变得具有响应性所需的数据


397
00:23:49,530 --> 00:23:52,933 line:-2
Peter 我们可以在该启动阶段
做些什么来优化呢？


398
00:23:53,734 --> 00:23:56,236 line:-1
你需要尽可能快地优化


399
00:23:56,303 --> 00:23:58,438 line:-1
app中的UI构建阶段


400
00:23:59,339 --> 00:24:01,942 line:-1
这意味着你需要


401
00:24:02,142 --> 00:24:05,112 line:-1
从UI app激活方法中尽快返回


402
00:24:05,579 --> 00:24:07,080 line:-1
即WillFinishLaunching


403
00:24:07,147 --> 00:24:09,783 line:-2
didFinishLaunching
和didBecomeActive


404
00:24:10,184 --> 00:24:13,220 line:-2
因为UIKit只有
在你从这些函数返回之后


405
00:24:13,287 --> 00:24:15,689 line:-1
才将你的app标记为活跃状态


406
00:24:17,024 --> 00:24:21,295 line:-1
接下来 你需要在app启动期间


407
00:24:21,361 --> 00:24:22,930 line:-1
避免任何文件系统写入


408
00:24:23,530 --> 00:24:25,999 line:-2
因为它们是阻塞的
并需要进行系统调用


409
00:24:26,834 --> 00:24:30,204 line:-1
同样的 你也需要在app启动期间


410
00:24:30,270 --> 00:24:32,306 line:-1
避免执行非常大的读取操作


411
00:24:33,006 --> 00:24:35,075 line:-1
相反 你应该只读入


412
00:24:35,142 --> 00:24:38,011 line:-1
你现在绝对需要的数据


413
00:24:39,046 --> 00:24:42,616 line:-1
最后我建议你检查数据库的健康状况


414
00:24:42,683 --> 00:24:44,585 line:-1
保持整洁总是一个好主意


415
00:24:45,452 --> 00:24:47,721 line:-2
如果你使用的是
像Core Data这样的库


416
00:24:48,222 --> 00:24:52,326 line:-1
考虑优化你的模式以使其尽可能快


417
00:24:52,826 --> 00:24:56,797 line:-2
而如果你使用SQLite
或类似技术来实现自己的解决方案


418
00:24:57,064 --> 00:25:00,434 line:-1
考虑定期清空数据库


419
00:25:00,667 --> 00:25:03,203 line:-1
例如在每次你的app更新时


420
00:25:03,871 --> 00:25:05,105 line:-1
谢谢 Peter


421
00:25:06,106 --> 00:25:09,743 line:-2
启动的下一阶段是
我们创建你的第一帧


422
00:25:11,245 --> 00:25:14,581 line:-2
此时Core Animation
正在进行必要的渲染


423
00:25:14,648 --> 00:25:15,849 line:-1
来准备好那个帧


424
00:25:17,050 --> 00:25:18,485 line:-1
它会进行文字绘图


425
00:25:18,552 --> 00:25:20,854 line:-1
并加载和解压缩任何需要


426
00:25:20,921 --> 00:25:22,656 line:-1
在你的UI中显示的图像


427
00:25:24,491 --> 00:25:26,627 line:-1
Peter 你对启动的这个阶段


428
00:25:26,693 --> 00:25:28,028 line:-1
有更多的高见吗？


429
00:25:28,729 --> 00:25:31,265 line:-1
当然有 在准备第一帧时


430
00:25:31,331 --> 00:25:34,268 line:-1
你务必要谨慎


431
00:25:34,334 --> 00:25:37,171 line:-1
并只准备你在启动时


432
00:25:37,237 --> 00:25:38,305 line:-1
绝对需要的用户界面


433
00:25:38,872 --> 00:25:42,843 line:-2
如果你的用户尚未导航到
app的特定部分


434
00:25:43,210 --> 00:25:44,278 line:-1
那就不要加载它


435
00:25:44,344 --> 00:25:47,748 line:-2
相反 你应该将加载操作
延迟到绝对必要的时候


436
00:25:48,715 --> 00:25:53,253 line:-2
此外 你应该避免隐藏不应该显示的
视图和图层


437
00:25:53,320 --> 00:25:54,922 line:-1
当我们首次导航到你的app时


438
00:25:56,023 --> 00:25:57,958 line:-1
即使你隐藏了视图和图层


439
00:25:58,025 --> 00:25:59,426 line:-1
它们也需要成本


440
00:25:59,493 --> 00:26:01,028 line:-1
所以只引入首帧中


441
00:26:01,094 --> 00:26:03,730 line:-1
必要的视图和图层


442
00:26:05,699 --> 00:26:10,571 line:-2
启动的最后阶段就是我们所说的
扩展启动操作


443
00:26:12,406 --> 00:26:14,908 line:-2
这些是你在启动路径中
可能推迟的任务


444
00:26:14,975 --> 00:26:18,679 line:-1
从而帮助你更快地获得响应


445
00:26:19,646 --> 00:26:21,882 line:-2
虽然你的app可能会
在此时做出响应


446
00:26:22,216 --> 00:26:24,117 line:-1
但它还无法使用


447
00:26:25,652 --> 00:26:28,789 line:-2
这个阶段的核心在于
优先考虑下一步该做什么


448
00:26:29,456 --> 00:26:31,859 line:-1
引入当前必须显示在屏幕上的内容


449
00:26:33,026 --> 00:26:35,796 line:-1
并且如果要从远程服务器加载内容


450
00:26:36,330 --> 00:26:39,733 line:-2
请务必考虑你可能处于
不稳定的网络状况


451
00:26:40,000 --> 00:26:43,971 line:-1
必要时可以显示占位符UI


452
00:26:46,440 --> 00:26:48,575 line:-1
所以这些就是构成启动步骤的


453
00:26:48,642 --> 00:26:50,978 line:-1
五个高级组件


454
00:26:52,579 --> 00:26:54,181 line:-1
我们今天还为你准备了一件事


455
00:26:55,682 --> 00:26:57,217 line:-1
ABM


456
00:26:58,151 --> 00:27:01,588 line:-2
A代表总是 B代表进行
M代表测量


457
00:27:01,655 --> 00:27:03,590 line:-1
只有快的app才能享受咖啡


458
00:27:04,358 --> 00:27:08,095 line:-1
你必须了解启动时间花费最多的位置


459
00:27:08,529 --> 00:27:11,365 line:-1
因此使用Time Profiler定期测量它


460
00:27:12,032 --> 00:27:15,669 line:-1
每次更改启动路径中的代码时


461
00:27:15,736 --> 00:27:16,870 line:-1
你都需要重新测量


462
00:27:17,304 --> 00:27:19,072 line:-1
并取统计平均值


463
00:27:19,139 --> 00:27:22,176 line:-2
不要依赖单次测试
来检查你的启动时间


464
00:27:23,977 --> 00:27:27,514 line:-2
这就是极速启动部分的内容
让响应变得快速


465
00:27:27,581 --> 00:27:31,485 line:-2
仅使用你需要的内容
并测量 测量 再测量


466
00:27:31,952 --> 00:27:32,953 line:-1
谢谢


467
00:27:34,821 --> 00:27:39,193 line:0
（平滑滚动）


468
00:27:39,259 --> 00:27:43,697 line:0
滚动是iOS用户体验的关键部分


469
00:27:44,131 --> 00:27:47,534 line:-1
也是你app中的大部分体验


470
00:27:48,702 --> 00:27:52,039 line:-2
iPhone和iPad
是神奇的玻璃板


471
00:27:52,372 --> 00:27:55,876 line:-2
它们可以变成你的app
想要它们变成的任何东西


472
00:27:57,044 --> 00:28:00,480 line:-2
所以你必须努力保持这种
你的app内容


473
00:28:00,547 --> 00:28:03,917 line:-1
在这块神奇的玻璃板上滑动的错觉


474
00:28:05,018 --> 00:28:07,521 line:-1
在Apple 我们有一句老话


475
00:28:07,588 --> 00:28:10,190 line:-1
你的app应该像黄油一样平滑


476
00:28:11,491 --> 00:28:14,962 line:-1
但有时候app会拖沓和卡顿


477
00:28:15,028 --> 00:28:19,032 line:-1
这使它感觉不像黄油 而像是花生酱


478
00:28:20,200 --> 00:28:23,403 line:-2
而且你应该遇到过这种情况
你的app感觉不连贯或卡顿


479
00:28:24,705 --> 00:28:28,342 line:-2
Ben app行为缓慢
的原因有哪些呢？


480
00:28:29,276 --> 00:28:31,945 line:-2
Peter
你所描述的这种缓慢行为


481
00:28:32,012 --> 00:28:34,781 line:-1
其实是由于我们丢帧了


482
00:28:35,215 --> 00:28:37,451 line:-2
所以我们需要理解
为什么会发生这种情况


483
00:28:37,518 --> 00:28:40,387 line:-1
这可能发生在两个关键地方


484
00:28:40,954 --> 00:28:43,824 line:-1
首先 你可能做了太多的计算


485
00:28:44,625 --> 00:28:49,096 line:-2
其次 你可能做了太多
复杂的图形合成


486
00:28:50,531 --> 00:28:53,867 line:-2
让我们依次看一下这些情况
先从计算开始


487
00:28:54,902 --> 00:28:57,404 line:-1
你怎么知道是否做了太多的计算呢？


488
00:28:58,705 --> 00:29:01,508 line:-2
内置于Instruments中的
Time Profiler


489
00:29:01,575 --> 00:29:02,976 line:-1
是此目的的终极工具


490
00:29:03,844 --> 00:29:07,181 line:-1
它可以为你提供


491
00:29:07,247 --> 00:29:09,449 line:-1
执行每个代码行所需的CPU时间


492
00:29:10,150 --> 00:29:13,387 line:-2
这是一个非常强大的工具
我们鼓励你去看看


493
00:29:13,453 --> 00:29:17,691 line:-2
在2016年WWDC中的演讲
“使用Instrument中的Time Profiler”


494
00:29:18,926 --> 00:29:21,161 line:-2
一旦你使用
Time Profiler工具


495
00:29:21,228 --> 00:29:22,896 line:-1
发现了这些热点


496
00:29:23,297 --> 00:29:25,966 line:-1
我们为你提供了一些很棒的优化技巧


497
00:29:27,234 --> 00:29:31,572 line:-2
首先是使用UICollectionView
和UITableView预取


498
00:29:32,239 --> 00:29:35,943 line:-2
这些API会告诉你用户何时
针对某些单元格进行滚动


499
00:29:36,009 --> 00:29:40,781 line:-1
并且为你提供预加载该数据的机会


500
00:29:41,615 --> 00:29:45,586 line:-2
2016年有两位非常英俊的主持人
就此发表了精彩的演讲


501
00:29:45,652 --> 00:29:47,721 line:-1
我非常鼓励你观看它


502
00:29:49,489 --> 00:29:53,894 line:-2
我给你的下一个技巧是
将尽可能多的工作


503
00:29:53,961 --> 00:29:56,930 line:-1
移出主队列并放入后台队列


504
00:29:57,231 --> 00:30:01,668 line:-2
腾出主队列以便更新UI
并处理用户输入


505
00:30:02,469 --> 00:30:05,339 line:-2
Ben 我们可以从主队列
移出哪类工作呢？


506
00:30:06,073 --> 00:30:08,308 line:-1
你期待的可能是一些平常的东西


507
00:30:08,375 --> 00:30:11,345 line:-1
比如网络和文件系统访问


508
00:30:11,411 --> 00:30:13,480 line:-1
它们永远不应该在主线程上运行


509
00:30:14,114 --> 00:30:16,216 line:-1
但你可能没想到其它一些东西


510
00:30:16,283 --> 00:30:18,018 line:-1
比如图像绘制和文本大小调整


511
00:30:18,919 --> 00:30:22,022 line:-2
UIGraphicsImageRenderer
及其分布式字符串


512
00:30:22,256 --> 00:30:24,925 line:-2
都具有可在后台线程上
安全使用的函数


513
00:30:24,992 --> 00:30:27,394 line:-1
这正可以帮助你


514
00:30:27,461 --> 00:30:31,598 line:-1
将一些复杂计算移出主队列


515
00:30:33,200 --> 00:30:34,668 line:-1
哇 Ben 这些都是很棒的技巧


516
00:30:34,735 --> 00:30:37,504 line:-1
我从未想过要在主队列之外做这些事


517
00:30:38,172 --> 00:30:41,208 line:-2
假设我已经运行了
Time Profiler


518
00:30:41,275 --> 00:30:44,111 line:-2
我也使用了预取
就像那些家伙告诉我的那样


519
00:30:44,178 --> 00:30:46,947 line:-2
并且我已将尽可能多的工作
移出了主队列


520
00:30:47,748 --> 00:30:49,383 line:-1
但我的app仍然很慢


521
00:30:49,917 --> 00:30:52,052 line:-2
这肯定不是我的问题
对吧 Ben


522
00:30:52,986 --> 00:30:55,656 line:-2
好吧 Peter
我们可能还没有走出困境


523
00:30:56,323 --> 00:30:58,725 line:-1
虽然我们可能已经优化了计算


524
00:30:59,459 --> 00:31:00,928 line:-1
我们仍然可能


525
00:31:01,395 --> 00:31:02,663 line:-1
遇到图形系统的问题


526
00:31:05,098 --> 00:31:07,534 line:-1
幸运的是 这里有另一个很棒的工具


527
00:31:09,069 --> 00:31:12,573 line:-2
Core Animation Instrument
是一个非常强大的工具


528
00:31:12,639 --> 00:31:14,741 line:-2
可以用来准确了解
你的帧速率正做的事


529
00:31:15,275 --> 00:31:18,745 line:-1
同时它还可以查看你的GPU利用率


530
00:31:19,980 --> 00:31:23,951 line:-2
它是另一个非常强大的工具
若想了解如何使用它


531
00:31:24,017 --> 00:31:28,922 line:-2
请查看2014年WWDC中的演讲
“iOS app中的高级图形和动画”


532
00:31:30,757 --> 00:31:34,094 line:-1
一旦确定你的app是图形约束型的


533
00:31:34,161 --> 00:31:37,264 line:-1
你就可以调查一些很易于发现的问题


534
00:31:38,332 --> 00:31:43,103 line:-2
你有一个图形约束型app
通常是由于过度使用以下两者之一


535
00:31:43,604 --> 00:31:46,340 line:-1
即视觉效果 或遮罩和剪裁


536
00:31:47,107 --> 00:31:49,943 line:-1
视觉效果 如毛玻璃效果


537
00:31:50,010 --> 00:31:54,014 line:-2
它们的代价昂贵
因此你应该在app中适当使用它们


538
00:31:54,815 --> 00:31:59,353 line:-2
你也应该避免做在模糊效果上
继续模糊这样的事


539
00:31:59,686 --> 00:32:03,924 line:-2
因为这导致GPU在高速模式下工作
从而拖慢你的app


540
00:32:05,058 --> 00:32:09,263 line:-1
此外 你应该尽可能避免遮罩和剪裁


541
00:32:09,963 --> 00:32:13,834 line:-2
如果你可以在视图顶部
放置不透明内容


542
00:32:14,101 --> 00:32:17,271 line:-1
即可达到相同的视觉效果


543
00:32:17,804 --> 00:32:19,439 line:-1
那么我鼓励你这样做


544
00:32:19,506 --> 00:32:24,444 line:-2
而不是使用UIViewer CALayer的
遮罩视图或遮罩属性


545
00:32:25,445 --> 00:32:28,715 line:-1
这就是我们如何优化平滑滚动的性能


546
00:32:29,383 --> 00:32:31,251 line:-2
确保在你的app上
运行Time Profiler


547
00:32:31,318 --> 00:32:33,854 line:-2
和Core Animation
Instruments


548
00:32:35,022 --> 00:32:39,092 line:-2
使用预取并尽可能多地
从主队列中移出工作


549
00:32:40,527 --> 00:32:45,098 line:-1
并节制地使用视觉效果和遮罩及剪裁


550
00:32:45,899 --> 00:32:51,705 line:-2
有关分析的更多信息 请查看
2015年WWDC中的精彩演讲


551
00:32:51,939 --> 00:32:52,773 line:0
谢谢


552
00:32:52,840 --> 00:32:56,643 line:0
（保持连贯性）


553
00:32:56,710 --> 00:32:57,811 line:0
连贯性


554
00:32:57,878 --> 00:33:01,215 line:-2
是Apple平台上
最神奇的体验之一


555
00:33:02,282 --> 00:33:06,587 line:-1
而接力是真正让用户满意的绝佳方式


556
00:33:07,688 --> 00:33:10,958 line:-1
能够从一台设备获取任务


557
00:33:11,291 --> 00:33:14,661 line:-1
并将其无缝转移到另一台设备


558
00:33:15,229 --> 00:33:17,731 line:-1
绝对是一次非常棒的体验


559
00:33:19,266 --> 00:33:22,903 line:-2
接力适用于iOS
macOS和watchOS


560
00:33:23,570 --> 00:33:27,374 line:-2
它不需要互联网连接
因为它使用点对点连接


561
00:33:28,675 --> 00:33:32,045 line:-2
而对于你们来说最重要的是
它设置起来非常容易


562
00:33:34,147 --> 00:33:36,950 line:-2
那么你应该如何看待在app中
使用接力呢？


563
00:33:38,085 --> 00:33:42,222 line:-2
让我们来看一些我们在
Apple app中应用它的例子


564
00:33:43,924 --> 00:33:47,194 line:-2
假设我从我的英俊搭档那里
得到一条消息


565
00:33:47,594 --> 00:33:51,064 line:-2
我想在我的iPhone X上
用一个幽默表情回复他


566
00:33:52,199 --> 00:33:54,635 line:-2
我可以用iOS上的
App Switcher


567
00:33:54,968 --> 00:33:57,404 line:-1
直接回到该谈话中


568
00:33:58,805 --> 00:34:02,009 line:-2
或者如果我在Mac上的
Pages中编辑文档


569
00:34:02,809 --> 00:34:05,846 line:-2
而现在我必须离开电脑
所以我想把它传到我的iPad


570
00:34:06,079 --> 00:34:08,482 line:-2
我可以通过点击Dock中的图标
来做到这点


571
00:34:10,117 --> 00:34:13,320 line:-1
或者如果我随意在手表上浏览照片


572
00:34:14,254 --> 00:34:16,489 line:-1
我找到了之前的一张WWDC的照片


573
00:34:16,556 --> 00:34:18,992 line:-1
而我想看看那张专辑中的所有照片


574
00:34:19,726 --> 00:34:22,529 line:-2
我可以在iPhone上
直接回到该照片库


575
00:34:22,596 --> 00:34:24,731 line:-1
而无需搜索那张照片


576
00:34:26,099 --> 00:34:28,001 line:-1
接力非常强大


577
00:34:28,068 --> 00:34:30,504 line:-1
它可以在设备之间传递内容时


578
00:34:30,571 --> 00:34:32,438 line:-1
为你的用户节省大量时间


579
00:34:34,274 --> 00:34:36,510 line:-1
我们将向你展示使用它是多么容易


580
00:34:36,909 --> 00:34:40,447 line:-2
它完全建立在
NSUserActivity API之上


581
00:34:42,049 --> 00:34:46,186 line:-2
NSUserActivity
表示你当前所处的状态


582
00:34:46,253 --> 00:34:47,688 line:-1
或正在进行的活动


583
00:34:47,754 --> 00:34:49,690 line:-2
在这个例子中
我们正在撰写电子邮件


584
00:34:52,893 --> 00:34:57,130 line:-2
创建此活动时 附近所有登陆
同一个iCloud账户的设备


585
00:34:57,197 --> 00:35:01,535 line:-1
都会显示接力可用


586
00:35:02,603 --> 00:35:04,938 line:-2
在Mac上
你将在Dock中看到一个图标


587
00:35:06,673 --> 00:35:09,476 line:-1
当你单击此邮件图标时


588
00:35:09,543 --> 00:35:12,312 line:-1
该活动将转移到Mac


589
00:35:13,213 --> 00:35:16,350 line:-2
而且Mail将会启动
并从你中断的位置继续


590
00:35:18,619 --> 00:35:21,388 line:-1
让我们看一下设置它所需的代码


591
00:35:24,658 --> 00:35:26,026 line:-1
在源设备上


592
00:35:26,093 --> 00:35:29,596 line:-2
首先要创建具有给定类型的
NSUserActivity


593
00:35:30,430 --> 00:35:32,799 line:-1
此类型代表了你的用户


594
00:35:32,866 --> 00:35:34,401 line:-1
当前正在进行的一种活动


595
00:35:36,103 --> 00:35:39,806 line:-2
然后设置标题并将
isEligibleForHandoff设置为true


596
00:35:40,908 --> 00:35:43,677 line:-2
接着你需要填充
userInfo字典


597
00:35:44,545 --> 00:35:47,548 line:-1
你需要填入为了继续此活动


598
00:35:47,614 --> 00:35:49,750 line:-1
所需的所有信息


599
00:35:50,684 --> 00:35:53,153 line:-1
在这个例子中 我们用的是一个视频


600
00:35:53,220 --> 00:35:56,190 line:-2
并且我们填入视频ID
和当前播放时间


601
00:35:58,225 --> 00:36:00,460 line:-1
最后 你需要将此活动设置为


602
00:36:00,527 --> 00:36:03,030 line:-2
viewController的
userActivity属性


603
00:36:03,997 --> 00:36:06,266 line:-2
每当显示该
viewController时


604
00:36:06,333 --> 00:36:08,235 line:-1
这都会使它成为当前活动


605
00:36:09,503 --> 00:36:11,738 line:-2
这就是你需要在源设备上
做的所有事情


606
00:36:12,940 --> 00:36:17,077 line:-2
在后续设备上
首先 你的app需要声明


607
00:36:17,144 --> 00:36:19,446 line:-1
它能够支持你创建的该活动类型


608
00:36:20,113 --> 00:36:23,851 line:-2
然后你需要实现两个
UIApplicationDelegate回调


609
00:36:24,651 --> 00:36:27,754 line:-2
第一个是application(_:willContinue
UserActivityWithType:)


610
00:36:28,055 --> 00:36:31,758 line:-1
只要你点击或点按图标以启动接力


611
00:36:31,825 --> 00:36:33,260 line:-1
就会调用此函数


612
00:36:34,428 --> 00:36:37,698 line:-2
此时 我们还没有准备好
NSUserActivity对象


613
00:36:38,365 --> 00:36:41,101 line:-1
但你知道将要继续的活动类型


614
00:36:41,435 --> 00:36:43,403 line:-1
因此你就可以先开始准备UI了


615
00:36:44,705 --> 00:36:46,573 line:-1
很快 你将收到


616
00:36:46,640 --> 00:36:49,176 line:-2
application(_:continue:
:restorationHandler:)


617
00:36:49,843 --> 00:36:53,280 line:-2
其将包含完全重建的
NSUserActivity对象


618
00:36:54,681 --> 00:36:58,685 line:-1
此后你就可以设置好并在该设备上


619
00:36:58,752 --> 00:36:59,820 line:-1
继续原先的体验了


620
00:37:00,921 --> 00:37:04,892 line:-2
若信息多于userInfo字典中
能够存储的信息


621
00:37:04,958 --> 00:37:07,694 line:-2
你可以使用NSUserActivity的
一个强大功能


622
00:37:08,128 --> 00:37:10,097 line:-1
它被称为延续流


623
00:37:10,697 --> 00:37:14,701 line:-2
你所要做的就是将
supportsContinuationStreams属性


624
00:37:14,768 --> 00:37:15,769 line:-1
设为true


625
00:37:16,270 --> 00:37:18,705 line:-1
然后在后续设备上


626
00:37:19,173 --> 00:37:22,509 line:-2
你将调用
NSUserActivity上的


627
00:37:22,576 --> 00:37:24,011 line:-1
getContinuationStreams方法


628
00:37:24,444 --> 00:37:27,447 line:-1
它将为你提供输入和输出流


629
00:37:28,482 --> 00:37:32,586 line:-2
在源设备上
NSUserActivity的委托方法


630
00:37:32,653 --> 00:37:37,057 line:-2
将收到一个回调
并也为其提供相应的输入和输出流


631
00:37:37,858 --> 00:37:41,495 line:-1
通过这些管道 你就可以在源设备


632
00:37:41,562 --> 00:37:44,565 line:-1
和后续设备之间进行双向通信


633
00:37:45,332 --> 00:37:48,202 line:-1
但你最好尽快完成这个过程


634
00:37:48,268 --> 00:37:51,471 line:-2
因为用户可能正在离开
并断开两个设备的连接


635
00:37:52,439 --> 00:37:53,941 line:-1
关于流的更多信息


636
00:37:54,007 --> 00:37:57,611 line:-2
请查看developer.apple.com上的
“流编程指南”


637
00:37:58,846 --> 00:38:00,480 line:-1
这非常适合传输某些


638
00:38:00,547 --> 00:38:03,183 line:-2
不适合放入userInfo字典
的内容


639
00:38:03,250 --> 00:38:07,487 line:-2
比如图片或视频内容
就像我们刚才的电子邮件接力示例


640
00:38:08,322 --> 00:38:12,326 line:-2
但对于基于文档的app
接力过程更加容易


641
00:38:13,193 --> 00:38:15,262 line:-1
因为你自动获得了很多这种行为


642
00:38:16,263 --> 00:38:20,467 line:-2
UIDocument和NSDocument
会自动创建NSUserActivity对象


643
00:38:20,734 --> 00:38:23,604 line:-1
以表示当前正在编辑的文档


644
00:38:25,339 --> 00:38:28,342 line:-2
这适用于存储在
iCloud中的所有文档


645
00:38:30,043 --> 00:38:33,914 line:-2
你在app中所要做的就是
配置相应的info.plist


646
00:38:36,283 --> 00:38:38,185 line:-1
除了app到app接力


647
00:38:38,986 --> 00:38:41,855 line:-1
我们还支持app到网页浏览器接力


648
00:38:43,023 --> 00:38:47,628 line:-2
如果你拥有出色的网页体验
其可以与原生app体验并驾齐驱


649
00:38:48,996 --> 00:38:51,832 line:-1
而且后续设备未安装原生app


650
00:38:52,733 --> 00:38:57,070 line:-2
你可以接力到Safari
并在网络浏览器中继续该活动


651
00:38:58,872 --> 00:39:02,643 line:-2
接力还支持网页浏览器
到app的接力


652
00:39:03,510 --> 00:39:07,247 line:-2
你需要在网络服务器上配置
已批准的app ID列表


653
00:39:07,681 --> 00:39:10,651 line:-1
然后你需要在iOS app中


654
00:39:10,984 --> 00:39:12,152 line:-1
添加相应的域权利


655
00:39:12,553 --> 00:39:15,022 line:-1
接下来用户可以无缝地


656
00:39:15,088 --> 00:39:18,192 line:-2
从你的网页体验
接力到iOS上的app


657
00:39:18,792 --> 00:39:23,730 line:-2
关于这点的更多信息
请查看2014年关于接力的演讲


658
00:39:25,666 --> 00:39:26,900 line:-1
这就是接力


659
00:39:27,601 --> 00:39:29,770 line:-1
走出去并在你的app中实现它


660
00:39:29,837 --> 00:39:33,140 line:-2
从而真正让你的用户满意
另外作为额外奖励


661
00:39:33,440 --> 00:39:37,110 line:-2
NSUserActivity API
被用于整个系统体验


662
00:39:37,177 --> 00:39:40,647 line:-2
比如类似Spotlight搜索
和新Siri快捷方式这样的功能中


663
00:39:41,882 --> 00:39:45,853 line:-2
有关此内容的更多信息
请查看以前WWDC中的这些演讲


664
00:39:45,919 --> 00:39:47,087 line:-1
谢谢


665
00:39:56,797 --> 00:39:59,900 line:-1
你写出了很棒的app和体验


666
00:40:00,868 --> 00:40:04,838 line:-1
但你有时会遇到需要调查的问题


667
00:40:05,305 --> 00:40:10,177 line:-2
为此我们将教你一些
超高级的调试技巧


668
00:40:10,544 --> 00:40:12,880 line:-1
但首先要提醒一句


669
00:40:14,681 --> 00:40:17,384 line:-1
在我们给你这个红药丸


670
00:40:17,451 --> 00:40:19,086 line:-1
并告诉你兔子洞有多深之前


671
00:40:19,152 --> 00:40:21,955 line:-2
我想告诉你我们在这部分
向你展示的方法


672
00:40:22,022 --> 00:40:24,491 line:-1
虽然非常适合调试


673
00:40:24,892 --> 00:40:27,194 line:-1
但不得提交到App Store


674
00:40:27,961 --> 00:40:30,397 line:-1
如果你这样做 你的申请将被拒绝


675
00:40:30,464 --> 00:40:31,732 line:-1
你将度过糟糕的一天


676
00:40:32,466 --> 00:40:34,535 line:-1
现在有了这个警告 让我们开始吧


677
00:40:35,969 --> 00:40:38,605 line:-1
首先我们将从侦探的心态开始


678
00:40:38,872 --> 00:40:41,975 line:-1
你该如何处理程序中发现的问题


679
00:40:43,043 --> 00:40:44,511 line:-1
接下来 我们将与你讨论


680
00:40:44,578 --> 00:40:47,514 line:-1
如何调试视图和视图控制器中的问题


681
00:40:48,382 --> 00:40:50,317 line:-1
我们将教你LLDB


682
00:40:50,384 --> 00:40:53,554 line:-2
以及如何使用它
来识别app中的状态问题


683
00:40:54,488 --> 00:40:56,456 line:-1
最后 我们将讨论一些技巧


684
00:40:56,523 --> 00:40:59,626 line:-1
用于处理你可能遇到的一些


685
00:40:59,893 --> 00:41:01,728 line:-1
让你感觉糟糕的重大内存问题


686
00:41:02,462 --> 00:41:05,132 line:-1
让我们从侦探心态开始吧


687
00:41:05,899 --> 00:41:09,570 line:-1
当你查看程序中的问题时


688
00:41:09,636 --> 00:41:11,305 line:-1
你需要确保验证你的假设


689
00:41:11,738 --> 00:41:13,841 line:-1
你期待你的程序做什么


690
00:41:14,107 --> 00:41:16,410 line:-1
然后验证它实际上正是这样做的


691
00:41:17,044 --> 00:41:20,681 line:-2
当你开始调试app中的问题时
这可能是一个很好的步骤


692
00:41:21,915 --> 00:41:24,117 line:-1
一旦你非常确定


693
00:41:24,184 --> 00:41:25,385 line:-1
你的哪个假设被违反了


694
00:41:25,986 --> 00:41:29,389 line:-1
你可以从寻找线索开始


695
00:41:29,790 --> 00:41:34,094 line:-2
你将使用我们在本节中
向你展示的工具


696
00:41:34,161 --> 00:41:35,796 line:-1
来仔细检查你的对象和结构


697
00:41:36,697 --> 00:41:39,266 line:-1
然后你需要通过更改app中的状态


698
00:41:39,933 --> 00:41:43,737 line:-2
来测试你的预感
并验证你是否发现了问题


699
00:41:44,738 --> 00:41:47,841 line:-2
让我们从一个示例漏洞开始
这可是一个真正的漏洞


700
00:41:49,109 --> 00:41:50,911 line:-2
作为Apple员工
我得到的最棒特权之一


701
00:41:50,978 --> 00:41:53,981 line:-1
就是可以使用截屏编辑器


702
00:41:54,815 --> 00:41:57,184 line:-1
最近我们正在调试一个问题


703
00:41:57,251 --> 00:42:01,088 line:-2
即我的截屏笔工具丢失了
这非常糟糕


704
00:42:03,156 --> 00:42:06,293 line:-2
Ben 有什么工具可以用来
帮助诊断这个问题吗？


705
00:42:07,160 --> 00:42:08,095 line:-1
当然有


706
00:42:08,495 --> 00:42:11,398 line:-2
Xcode中
有一个内置的视图调试器


707
00:42:12,432 --> 00:42:15,569 line:-2
只需单击底部工具栏中的此图标
即可启动它


708
00:42:16,503 --> 00:42:19,206 line:-1
Xcode会向你展示


709
00:42:19,273 --> 00:42:21,108 line:-1
整个视图层次结构的3D表示


710
00:42:22,709 --> 00:42:25,846 line:-2
正如你在这里看到的
我们的铅笔控件仍然在那里


711
00:42:26,313 --> 00:42:29,550 line:-1
但是它们被前面的全屏视图遮挡了


712
00:42:30,551 --> 00:42:32,653 line:-2
因此我们需查看
我们构建这个UI的位置


713
00:42:32,719 --> 00:42:35,189 line:-2
检查顺序出了什么问题
我这样认为 Peter


714
00:42:35,956 --> 00:42:36,857 line:-1
这很好


715
00:42:36,924 --> 00:42:38,225 line:-1
Xcode视图调试器


716
00:42:38,292 --> 00:42:41,795 line:-1
是调试app中视图问题的绝佳工具


717
00:42:42,863 --> 00:42:45,966 line:-2
还有更多工具可以用来
帮助解决这个问题


718
00:42:48,035 --> 00:42:50,270 line:-1
UIView recursiveDescription


719
00:42:50,671 --> 00:42:52,539 line:-1
UIView _parentDescription


720
00:42:53,006 --> 00:42:56,276 line:-2
以及类方法UIViewController
_printHierarchy


721
00:42:56,710 --> 00:43:00,948 line:-2
是用于在app中调试视图
和视图控制器问题的绝佳工具


722
00:43:01,882 --> 00:43:03,851 line:-1
同样 它们虽然很棒


723
00:43:03,917 --> 00:43:06,119 line:-2
但你无法将其提交到
App Store中


724
00:43:07,354 --> 00:43:10,691 line:-2
重要的是要注意它们是
Objective-C选择器


725
00:43:11,091 --> 00:43:13,861 line:-2
因此在使用它们之前
你需要使用此命令


726
00:43:13,927 --> 00:43:17,331 line:-2
将调试器设为
Objective-C模式


727
00:43:18,365 --> 00:43:22,269 line:-1
我们将逐步介绍每种调试方法


728
00:43:22,336 --> 00:43:23,770 line:-1
以及它们如何帮助你


729
00:43:23,837 --> 00:43:26,640 line:-2
先从UIView
recursiveDescription开始


730
00:43:28,642 --> 00:43:30,811 line:-1
UIView recursiveDescription


731
00:43:31,211 --> 00:43:35,749 line:-2
将打印出接收者的视图层次结构
即子视图层次结构


732
00:43:36,049 --> 00:43:38,218 line:-1
以及一些相关的属性


733
00:43:38,285 --> 00:43:40,420 line:-1
以帮助你了解布局属性


734
00:43:41,622 --> 00:43:43,023 line:-1
让我们来看一个例子


735
00:43:43,657 --> 00:43:46,527 line:-2
我们的截屏UI中
还有另一个缺少视图的漏洞


736
00:43:47,561 --> 00:43:49,530 line:-1
我们将在viewController的视图上


737
00:43:49,596 --> 00:43:51,565 line:-1
调用recursiveDescription


738
00:43:53,767 --> 00:43:57,237 line:-2
这看起来像是一面调试文本墙
因为它的确是


739
00:43:58,972 --> 00:44:02,509 line:-2
但我们知道我们在寻找什么
我们的截屏视图就在那里


740
00:44:02,576 --> 00:44:06,547 line:-2
我们可以看到它 而在审查中
我们看到它目前是隐藏的


741
00:44:08,282 --> 00:44:11,318 line:-2
所以我们需要看看我们在这个视图上
设置隐藏属性的所有地方


742
00:44:11,385 --> 00:44:13,587 line:-1
并搞清楚为什么它没有显示


743
00:44:16,089 --> 00:44:18,125 line:-1
除了recursiveDescription


744
00:44:18,192 --> 00:44:22,496 line:-2
UIView还有parentDescription
它将向上查看父视图的视图层次结构


745
00:44:22,563 --> 00:44:27,000 line:-1
直到它到达一个值为nil的父视图


746
00:44:27,467 --> 00:44:29,670 line:-1
它将打印相同类型的调试信息


747
00:44:32,139 --> 00:44:33,173 line:-1
recursiveDescription


748
00:44:33,240 --> 00:44:36,577 line:-2
和parentDescription
非常适合处理UIView问题


749
00:44:36,643 --> 00:44:40,047 line:-2
但有时候你遇到的是
UIViewController的问题


750
00:44:40,414 --> 00:44:43,317 line:-1
为此你可以使用一个很棒的类方法


751
00:44:43,383 --> 00:44:45,752 line:-2
即UIViewController
printHierarchy


752
00:44:46,987 --> 00:44:49,756 line:-2
最近我们的截屏编辑器中
出现了一个漏洞


753
00:44:49,823 --> 00:44:52,059 line:-1
我们的一个viewController无法收到


754
00:44:52,125 --> 00:44:53,894 line:-1
viewDidAppear消息


755
00:44:54,194 --> 00:44:56,296 line:-1
所以它没有适当地设置其状态


756
00:44:57,231 --> 00:45:00,000 line:-2
通过运行UIViewController
printHierarchy


757
00:45:00,567 --> 00:45:03,670 line:-2
我们可以获得来自以下对象的输出
即所有正在呈现的viewController


758
00:45:03,904 --> 00:45:07,941 line:-2
我们提供的viewController
我们的parentViewController


759
00:45:08,008 --> 00:45:12,012 line:-2
和childViewController
甚至我们的presentationController


760
00:45:12,279 --> 00:45:13,714 line:-1
这简直是是控制器大荟萃


761
00:45:14,448 --> 00:45:17,518 line:-2
所以让我们在截屏UI中
运行printHierarchy


762
00:45:19,453 --> 00:45:22,222 line:-2
这里我们可以看到
我们的viewController层次结构


763
00:45:22,523 --> 00:45:25,459 line:-2
而当我们检查发生问题的
viewController时


764
00:45:25,926 --> 00:45:28,662 line:-2
我们可以看到
它卡在了appearing状态


765
00:45:29,263 --> 00:45:32,699 line:-2
所以我们错过了回调
因此我们需要查看app中


766
00:45:32,766 --> 00:45:36,703 line:-2
调用此回调的位置
然后我们发现了问题


767
00:45:37,504 --> 00:45:42,543 line:-2
太棒了 通过使用这些方法
你可以识别视图和视图控制器问题


768
00:45:43,210 --> 00:45:46,280 line:-1
但有时你的app存在更基本的问题


769
00:45:47,080 --> 00:45:50,083 line:-2
为此我们可以使用一些
我们为你准备的


770
00:45:50,150 --> 00:45:51,251 line:-1
很棒的状态调试技巧


771
00:45:51,919 --> 00:45:57,391 line:0
LLDB的表达式命令可以让你
在调试器中运行任意代码


772
00:45:57,958 --> 00:46:01,595 line:0
想想这点 你在代码编辑器中
可以运行的任何代码


773
00:46:01,662 --> 00:46:05,732 line:0
现在都可以在调试器中直接编写
并在程序运行时运行


774
00:46:06,466 --> 00:46:08,502 line:0
这对调试非常有用


775
00:46:09,169 --> 00:46:13,407 line:0
你可以调用结构上的函数
获取对象的属性


776
00:46:13,473 --> 00:46:16,143 line:0
并更好地诊断你的程序正在做什么


777
00:46:17,110 --> 00:46:18,745 line:0
有关调试的更多信息


778
00:46:19,079 --> 00:46:23,650 line:0
请观看2012年的精彩演讲
“如何使用LLDB进行调试”


779
00:46:23,717 --> 00:46:26,854 line:-2
以及2014年的演讲
“如何使用Swift进行调试”


780
00:46:27,821 --> 00:46:31,658 line:-1
你可以在LLDB中使用表达式命令


781
00:46:31,725 --> 00:46:34,394 line:-1
运行一些我们将教你的很棒的函数


782
00:46:34,461 --> 00:46:36,163 line:-1
第一个是dump


783
00:46:41,368 --> 00:46:47,007 line:-2
dump将打印
所有Swift对象和结构属性


784
00:46:48,208 --> 00:46:52,412 line:-2
我们来看看我们的一些自定义UI中
遇到的另一个漏洞


785
00:46:53,647 --> 00:46:58,785 line:-2
我们有包含些子视图的视图
包括标签和一个imageView


786
00:46:59,052 --> 00:47:01,188 line:-1
而现在我们的一个标签丢失了


787
00:47:02,256 --> 00:47:04,224 line:-1
因此我们将在父视图上运行dump


788
00:47:04,992 --> 00:47:06,593 line:-1
并看看这里发生了什么


789
00:47:07,761 --> 00:47:12,933 line:-2
我们发现了丢失的标签 它就在这里
但是如果我们看一下


790
00:47:13,000 --> 00:47:14,935 line:-1
位于它旁边的imageView


791
00:47:15,669 --> 00:47:19,273 line:-1
我们注意到这两者的frame属性


792
00:47:19,339 --> 00:47:21,008 line:-1
都具有相同的源


793
00:47:22,042 --> 00:47:26,313 line:-2
所以这里可能发生的是
标签被imageView阻挡了


794
00:47:27,214 --> 00:47:29,583 line:-2
因此我想我们需要再次查看
我们的布局代码


795
00:47:31,451 --> 00:47:34,555 line:-2
除了对Swift对象的
dump函数


796
00:47:35,656 --> 00:47:37,925 line:-2
如果你还有一些
Objective-C代码


797
00:47:38,492 --> 00:47:41,695 line:-2
NSObject也有
ivarDescription方法


798
00:47:42,696 --> 00:47:43,730 line:-1
这将打印出


799
00:47:43,797 --> 00:47:47,000 line:-2
Objective-C对象的
所有实例变量


800
00:47:48,435 --> 00:47:50,771 line:-1
我们的截屏代码中还有另一个漏洞


801
00:47:51,371 --> 00:47:53,740 line:-2
我们的裁剪处理功能
出于某些原因无法工作


802
00:47:55,342 --> 00:47:58,779 line:-2
如果我们在截屏的视图中调用
ivarDescription


803
00:47:59,613 --> 00:48:02,149 line:-1
我们仔细观察可以看到


804
00:48:02,216 --> 00:48:06,286 line:-2
cropEnabled ivar
目前设置为NO


805
00:48:07,721 --> 00:48:10,624 line:-1
因此我们知道从哪开始研究这个漏洞


806
00:48:11,825 --> 00:48:12,960 line:-1
这很棒


807
00:48:13,026 --> 00:48:15,762 line:-2
使用dump
和ivarDescription


808
00:48:15,829 --> 00:48:18,832 line:-1
是诊断app问题的好方法


809
00:48:20,200 --> 00:48:24,738 line:-2
我们为你准备的另一个很棒的
调试技巧和窍门是断点


810
00:48:25,606 --> 00:48:29,743 line:-2
断点可以让你在任意执行状态下
暂停程序


811
00:48:30,244 --> 00:48:31,578 line:-1
并运行命令


812
00:48:32,446 --> 00:48:36,683 line:-2
并且通过使用
LLDB命令行或Xcode UI


813
00:48:37,050 --> 00:48:40,220 line:-2
你甚至可以在运行这些断点之前
添加条件


814
00:48:40,721 --> 00:48:43,590 line:-2
并且设置每次命中断点时
所要运行的命令


815
00:48:44,558 --> 00:48:47,694 line:-1
断点是调试工作流程的重要组成部分


816
00:48:48,028 --> 00:48:52,533 line:-2
你可以在Xcode中设置的断点中
使用表达式命令


817
00:48:52,599 --> 00:48:54,568 line:-2
dump
和ivarDescription


818
00:48:54,902 --> 00:48:57,504 line:-1
我真的鼓励你下次调试app问题时


819
00:48:57,571 --> 00:48:59,940 line:-1
能够使用断点


820
00:49:01,375 --> 00:49:04,745 line:-2
但有时我们的view
或viewController没有问题


821
00:49:05,345 --> 00:49:07,347 line:-1
我们的状态也没有问题


822
00:49:08,048 --> 00:49:11,185 line:-2
我们遇到的是一个非常棘手的
内存管理问题


823
00:49:12,319 --> 00:49:14,288 line:-1
Ben 为此我们有何工具使用吗？


824
00:49:15,322 --> 00:49:16,623 line:-1
我很高兴你问这个问题 Peter


825
00:49:16,690 --> 00:49:19,960 line:-2
因为Xcode中
的确还有另一个很棒的工具


826
00:49:20,427 --> 00:49:21,862 line:-1
即Xcode内存调试器


827
00:49:23,530 --> 00:49:27,868 line:-2
此工具将帮助你可视化
app使用内存的方式


828
00:49:29,570 --> 00:49:31,405 line:-2
Peter和我
前几天在调试一个问题


829
00:49:31,471 --> 00:49:33,073 line:-2
我们有一个泄漏的
viewController


830
00:49:33,841 --> 00:49:36,610 line:-2
这里我们可以看到
它正被一个块所持有


831
00:49:37,778 --> 00:49:39,813 line:-1
通过启用Malloc堆栈日志记录


832
00:49:39,880 --> 00:49:44,151 line:-1
我们能够看到分配此块时的完整回溯


833
00:49:46,019 --> 00:49:47,754 line:-1
通过放大 我们可以看到这个块


834
00:49:47,821 --> 00:49:50,490 line:-2
实际上由该
viewController创建


835
00:49:51,358 --> 00:49:53,961 line:-2
因此那个块持有着
viewController


836
00:49:54,027 --> 00:49:56,296 line:-2
但该viewController
也持有该块


837
00:49:57,164 --> 00:49:58,432 line:-1
这就是一个持有循环


838
00:49:59,633 --> 00:50:02,469 line:-2
哇 太棒了
Xcode内存图调试器


839
00:50:02,536 --> 00:50:06,373 line:-2
是一款非常棒的工具
它可以在你的app中诊断此类问题


840
00:50:07,007 --> 00:50:11,678 line:-2
欲了解更多 查看2017年的演讲
“使用Xcode 9进行调试”


841
00:50:13,280 --> 00:50:16,350 line:-2
以上就是如何像专业人士一样
调试你的app


842
00:50:18,785 --> 00:50:21,088 line:-1
每当你遇到程序问题时


843
00:50:21,154 --> 00:50:23,824 line:-1
记住一定要像侦探一样思考


844
00:50:25,192 --> 00:50:27,561 line:-1
使用Xcode视图调试器


845
00:50:27,628 --> 00:50:32,366 line:-2
和内存图调试器深入研究
视图和内存相关的问题


846
00:50:33,066 --> 00:50:38,539 line:-2
并使用LLDB的
表达式命令与dump


847
00:50:38,605 --> 00:50:41,475 line:-2
以及我们在这里谈到的
所有其它优秀的调试方法


848
00:50:44,545 --> 00:50:45,445 line:-1
谢谢


849
00:50:52,286 --> 00:50:55,956 line:-2
今天早上我们讨论了
六个非常激动人心的话题


850
00:50:56,023 --> 00:50:57,124 line:-1
甚至今天下午


851
00:50:58,659 --> 00:51:00,561 line:-1
但这些仍只是一些皮毛


852
00:51:00,827 --> 00:51:03,363 line:-1
我们鼓励你查看我们在整个演讲中


853
00:51:03,430 --> 00:51:04,865 line:-1
所引用的那些演讲


854
00:51:04,932 --> 00:51:07,734 line:-1
并为你的app增添更多光彩


855
00:51:08,435 --> 00:51:13,140 line:-2
更多相关信息
请查看开发者门户上的页面 谢谢


856
00:51:13,207 --> 00:51:14,808 line:-1
我们希望你们享受这次大会


857
00:51:14,875 --> 00:51:15,709 line:-1
谢谢

