1
00:00:17,417 --> 00:00:22,456 line:0
（tvOS 12新特性
演讲208）


2
00:00:22,523 --> 00:00:23,457 line:0
下午好


3
00:00:25,192 --> 00:00:27,127 line:-1
欢迎参加“tvOS新特性”演讲


4
00:00:28,328 --> 00:00:29,363 line:-1
我叫Hans Kim


5
00:00:29,429 --> 00:00:31,465 line:-1
我是tvOS团队中的一名工程师


6
00:00:32,499 --> 00:00:37,004 line:-2
今天我很高兴地跟大家分享一下
tvOS 12中的新特性


7
00:00:37,704 --> 00:00:40,040 line:-1
我们将会谈到密码自动填写


8
00:00:40,974 --> 00:00:43,010 line:-1
我们还会了解一下


9
00:00:43,610 --> 00:00:45,245 line:-1
tvOS聚焦引擎的一些新改进


10
00:00:46,213 --> 00:00:52,219 line:-2
最后我们会谈到关于tvOS上
新用户界面模式的一些改动


11
00:00:53,153 --> 00:00:54,354 line:-1
我们要讲的内容太多了


12
00:00:54,421 --> 00:00:56,523 line:-2
我们还有一些很棒的演示
让我们开始吧


13
00:00:57,357 --> 00:00:58,358 line:-1
首先


14
00:00:58,425 --> 00:01:00,694 line:-2
我要邀请同事
Alex和Conrad上台


15
00:01:01,094 --> 00:01:03,797 line:-1
谈谈如何帮助你的客户登录你的app


16
00:01:11,205 --> 00:01:12,206 line:-1
谢谢Hans


17
00:01:12,639 --> 00:01:13,640 line:-1
大家好


18
00:01:13,707 --> 00:01:15,309 line:-1
我叫Alex Sanciangco


19
00:01:15,375 --> 00:01:17,678 line:-1
今天我很激动地要跟大家一起分享


20
00:01:17,744 --> 00:01:19,112 line:-1
密码自动填写的相关信息


21
00:01:20,747 --> 00:01:23,617 line:-2
登录是用户与app之间
的一个常用体验


22
00:01:23,984 --> 00:01:26,720 line:-2
比如这里有一个我一直在做的app
叫做Shiny


23
00:01:26,987 --> 00:01:29,990 line:-2
它每天会向用户展示
他们所喜欢的狗狗的可爱图片


24
00:01:30,057 --> 00:01:31,258 line:-1
当他们登录时


25
00:01:32,259 --> 00:01:34,828 line:-1
为了让登录变得尽可能地流畅


26
00:01:34,895 --> 00:01:37,798 line:-2
我们在tvOS 12中
引入了密码自动填写功能


27
00:01:37,865 --> 00:01:43,170 line:-2
这是一种与iOS上同样简单
和熟悉的密码自动填写功能


28
00:01:43,604 --> 00:01:44,872 line:-1
让我演示一下


29
00:01:53,680 --> 00:01:55,782 line:-2
首先我要给你们展示
一个连续性键盘


30
00:01:56,016 --> 00:01:57,084 line:-1
你可能会记得


31
00:01:57,150 --> 00:01:59,186 line:-1
连续性键盘是一个iOS功能


32
00:01:59,553 --> 00:02:02,089 line:-2
允许用户在Apple TV上
输入文本


33
00:02:02,155 --> 00:02:03,690 line:-1
通过他们的iOS设备


34
00:02:03,991 --> 00:02:05,025 line:-1
我们实际操作一下


35
00:02:05,926 --> 00:02:09,295 line:-2
我要导航到Shiny app
我要选择邮箱地址字段


36
00:02:11,365 --> 00:02:14,301 line:-2
正如我所期待的
屏幕上出现了连续性键盘的通知


37
00:02:14,434 --> 00:02:17,504 line:-2
我们也对这个键盘进行了改善
可以提供密码自动填写功能


38
00:02:18,071 --> 00:02:19,273 line:-1
那么现在我要打开它


39
00:02:21,241 --> 00:02:25,312 line:-2
我看到了它针对Shinyapp
给出了用户名和密码的建议


40
00:02:25,379 --> 00:02:26,880 line:-1
就在快速输入栏那里


41
00:02:26,947 --> 00:02:28,382 line:-1
我知道只需要一次轻触


42
00:02:28,448 --> 00:02:31,118 line:-2
这个信息就会自动填入TV
然后我就登录了


43
00:02:31,185 --> 00:02:32,186 line:-1
那么我现在就做


44
00:02:35,756 --> 00:02:36,990 line:-1
哇 你们大家看


45
00:02:43,830 --> 00:02:45,732 line:-1
我在iPhone上收到了一个通知


46
00:02:45,999 --> 00:02:49,102 line:-2
因为我的iPhone和Apple TV
在同一个iCloud账户上


47
00:02:49,903 --> 00:02:52,673 line:-2
并且如果你是TV Remote
和控制中心


48
00:02:52,739 --> 00:02:53,941 line:-2
或TV Remote app
的用户


49
00:02:54,007 --> 00:02:55,809 line:-1
体验也很相似


50
00:02:56,877 --> 00:02:59,713 line:-2
但我们今天要给你们展示
一些全新的功能


51
00:02:59,780 --> 00:03:02,683 line:-1
告诉你们我们把登录变得多么简单了


52
00:03:03,016 --> 00:03:06,153 line:-2
甚至对于一个可能从未使用过
Apple TV的客人来说


53
00:03:06,520 --> 00:03:09,590 line:-1
为此我要邀请Conrad上台


54
00:03:14,194 --> 00:03:15,195 line:-1
谢谢Alex


55
00:03:16,263 --> 00:03:18,732 line:-1
现在假如我是Alex的表哥


56
00:03:19,132 --> 00:03:20,167 line:-1
正在他家做客


57
00:03:20,901 --> 00:03:22,603 line:-1
他的小狗非常可爱


58
00:03:23,270 --> 00:03:28,275 line:-2
但我真的非常想登录Shiny
这样我就能看到我的狗Max照片了


59
00:03:28,675 --> 00:03:30,744 line:-1
或是Max可爱的妹妹Min


60
00:03:31,645 --> 00:03:34,715 line:-1
我从未使用过他的Apple TV


61
00:03:35,048 --> 00:03:37,851 line:-1
因此我没有任何可用的键盘选项


62
00:03:37,918 --> 00:03:39,019 line:-1
就像他刚才所说


63
00:03:39,553 --> 00:03:44,491 line:-2
此外 因我在iCloud钥匙串中
使用和保存了一个强密码


64
00:03:44,992 --> 00:03:46,226 line:-1
我并没有记住密码


65
00:03:46,727 --> 00:03:49,596 line:-1
我希望能查询一下我的密码


66
00:03:49,863 --> 00:03:54,334 line:-2
然后把它一个字母一个字母地
键入到Apple TV上


67
00:03:55,169 --> 00:03:56,336 line:-1
让我们看看会发生什么


68
00:03:58,639 --> 00:03:59,740 line:-1
我要跳过这里


69
00:04:00,741 --> 00:04:01,842 line:-1
我要拿起我的手机


70
00:04:02,910 --> 00:04:04,678 line:-1
然后让我们登录


71
00:04:05,612 --> 00:04:09,116 line:-1
甚至在我打开设置之前


72
00:04:09,483 --> 00:04:11,485 line:-1
或在请求Siri查询我的密码之前


73
00:04:11,852 --> 00:04:15,589 line:-2
我的iPhone就已经帮我
自动填写了我的密码


74
00:04:16,822 --> 00:04:19,059 line:-1
我要打开这个通知


75
00:04:20,694 --> 00:04:21,695 line:-1
好的


76
00:04:21,762 --> 00:04:23,597 line:-1
通过键入一个PIN码


77
00:04:23,664 --> 00:04:28,368 line:-2
我就了解到我正在安全连接到
这台Apple TV上


78
00:04:29,169 --> 00:04:30,270 line:-1
需要指纹识别


79
00:04:31,438 --> 00:04:34,074 line:-2
然后顶部就出现了
我的Shiny证书


80
00:04:34,508 --> 00:04:37,177 line:-1
只需要一次轻触我就登录了


81
00:04:37,778 --> 00:04:38,779 line:-1
超级简单


82
00:04:41,281 --> 00:04:44,651 line:-1
哇 抱歉 它是…它是Min 好的


83
00:04:46,353 --> 00:04:48,388 line:-1
现在你可能在思考


84
00:04:49,089 --> 00:04:50,157 line:-1
那是如何实现的


85
00:04:50,591 --> 00:04:55,429 line:-2
并不是房间里的所有iPhone
都会收到一条通知


86
00:04:56,630 --> 00:04:59,700 line:-1
我认为这非常非常酷


87
00:05:00,667 --> 00:05:01,668 line:-1
Siri Remote


88
00:05:02,135 --> 00:05:06,206 line:-2
可以定位附近提供自动填写
密码功能的iPhone


89
00:05:06,573 --> 00:05:10,444 line:-2
在本例中 只有我的iPhone
显示了一条通知


90
00:05:11,378 --> 00:05:14,114 line:-2
这就是tvOS上的
密码自动填写功能


91
00:05:14,715 --> 00:05:15,916 line:-1
现在我要感谢…抱歉


92
00:05:15,983 --> 00:05:18,252 line:-1
我要邀请Alex返回舞台


93
00:05:19,052 --> 00:05:23,624 line:-2
给大家演示把这个功能完美地嵌入
你的app是一件多么简单的事


94
00:05:24,057 --> 00:05:24,892 line:-1
Alex？


95
00:05:29,997 --> 00:05:30,998 line:-1
谢谢Conrad


96
00:05:31,598 --> 00:05:32,866 line:-1
天呐 我喜欢那个演示


97
00:05:32,933 --> 00:05:34,601 line:-1
我就是觉得那个功能太酷了


98
00:05:36,637 --> 00:05:38,305 line:-1
tvOS上的密码自动填写功能


99
00:05:38,372 --> 00:05:41,208 line:-2
是你可能在周一听到过的一个
配套功能的一部分


100
00:05:41,275 --> 00:05:43,477 line:-1
目的是简化密码体验


101
00:05:44,044 --> 00:05:46,313 line:-1
这些功能可以整合到现有app中


102
00:05:46,380 --> 00:05:48,382 line:-1
而你不需要做太大修改


103
00:05:49,149 --> 00:05:51,118 line:-1
这里有一些你们开发人员可以做的事


104
00:05:51,185 --> 00:05:53,921 line:-1
以确保密码自动填写功能尽可能很棒


105
00:05:54,288 --> 00:05:55,455 line:-1
让我们快速说明一下


106
00:05:57,724 --> 00:05:59,960 line:-1
首先你要确保快速输入栏出现


107
00:06:00,027 --> 00:06:01,495 line:-1
用于填写文本字段


108
00:06:02,729 --> 00:06:05,199 line:-1
接下来你要确保app的证书


109
00:06:05,265 --> 00:06:06,834 line:-1
由快速输入栏进行了建议


110
00:06:07,701 --> 00:06:08,535 line:-1
最后


111
00:06:09,469 --> 00:06:12,206 line:-2
你要在体验中
启用一次轻触即可登录功能


112
00:06:12,639 --> 00:06:14,875 line:-1
现在让我们更具体地看看该如何实现


113
00:06:16,476 --> 00:06:19,279 line:-2
要确保用于文本字段输入的
快速输入栏的出现


114
00:06:19,580 --> 00:06:22,216 line:-1
你要采用UITextContentTypes


115
00:06:23,217 --> 00:06:26,854 line:-2
tvOS将会自动尝试检测
用户名和密码字段


116
00:06:26,920 --> 00:06:30,424 line:-1
你可以通过明确标记文本字段来实现


117
00:06:31,325 --> 00:06:34,261 line:0
这跟在这些文本字段上
设置单一属性一样简单


118
00:06:34,695 --> 00:06:39,533 line:0
简单地设置你的用户名文本字段
把textContentType设置为.username


119
00:06:39,867 --> 00:06:41,568 line:0
密码字段也一样


120
00:06:41,635 --> 00:06:44,071 line:0
你要把textContentType
设置为.password


121
00:06:44,638 --> 00:06:47,441 line:-2
非常简单 这也可以在
Interface Builder中实现


122
00:06:48,909 --> 00:06:51,144 line:-1
采用textContentTypes之后


123
00:06:51,211 --> 00:06:54,414 line:-2
这是浏览者很可能会在那个
连续性键盘通知中看到的东西


124
00:06:54,648 --> 00:06:55,516 line:-1
这很棒


125
00:06:55,582 --> 00:06:57,985 line:-1
因为它给用户提供了他们密码的权限


126
00:06:58,552 --> 00:07:00,087 line:-1
但它却隐藏在那个钥匙图标背后


127
00:07:00,487 --> 00:07:01,688 line:-1
需要太多次轻触才能实现


128
00:07:02,089 --> 00:07:04,525 line:-1
我们真正想要用户看到的是这个：


129
00:07:05,125 --> 00:07:08,529 line:-2
快速输入栏上给出了
你app的证书的建议


130
00:07:09,630 --> 00:07:10,797 line:-1
那样就得到了这个行为


131
00:07:10,864 --> 00:07:14,101 line:-1
通过采用一种叫做关联域的技术


132
00:07:14,368 --> 00:07:16,270 line:-1
它会安全地告诉密码自动填写功能


133
00:07:16,336 --> 00:07:18,639 line:-2
在快速输入栏中
要给出哪个域名的建议


134
00:07:21,542 --> 00:07:24,211 line:-1
关联域是一个强大的技术


135
00:07:24,278 --> 00:07:27,481 line:-2
还带有其它功能 比如通用链接
和回到上次离开的地方功能


136
00:07:31,785 --> 00:07:36,023 line:-1
它会在用户权限内的域名


137
00:07:36,089 --> 00:07:37,891 line:-2
以及他们所下载的app之间
创建一个安全的关系


138
00:07:39,159 --> 00:07:41,728 line:-2
然后密码自动填写功能
就使用这个关系


139
00:07:41,795 --> 00:07:45,165 line:-2
来准确建议证书
就显示在快速输入栏的顶部


140
00:07:46,767 --> 00:07:48,635 line:-1
要了解如何采用关联域


141
00:07:48,902 --> 00:07:52,873 line:-2
我强烈推荐大家查看“在app中
引入密码自动填写功能”演讲


142
00:07:52,940 --> 00:07:54,474 line:-1
它是去年WWDC的一场演讲


143
00:07:55,108 --> 00:07:57,311 line:-1
那场演讲中有一步一步的指南


144
00:07:57,611 --> 00:08:00,380 line:-2
关于如何在iOS app中
采用关联域


145
00:08:00,514 --> 00:08:02,850 line:-2
那些步骤对于tvOS app
同样适用


146
00:08:04,751 --> 00:08:06,687 line:-1
在采用关联域之后


147
00:08:06,753 --> 00:08:09,590 line:-2
用户很可能在Shiny app上
看到这些


148
00:08:09,656 --> 00:08:11,992 line:-1
在快速输入栏上轻触你的证书之后


149
00:08:12,192 --> 00:08:13,193 line:-1
非常棒


150
00:08:13,327 --> 00:08:16,463 line:-2
用户的用户名和密码已经填写到
他们的Apple TV上了


151
00:08:16,530 --> 00:08:18,432 line:-1
而不需要键入一个字母


152
00:08:19,199 --> 00:08:22,269 line:-1
但我们真正希望用户看到的是这个


153
00:08:23,003 --> 00:08:26,006 line:-1
能自动登录并查看他们的小狗


154
00:08:26,340 --> 00:08:28,742 line:-1
因为他们已经通过一次轻触登录了


155
00:08:30,177 --> 00:08:34,381 line:-2
你可以通过实施preferredFocus
Environments API来获得这个行为


156
00:08:36,383 --> 00:08:39,586 line:-2
在填写密码之后
就发生了一次更新


157
00:08:39,785 --> 00:08:40,787 line:-1
并且密码自动填写


158
00:08:40,854 --> 00:08:43,056 line:-1
将会执行聚焦按钮的行动


159
00:08:43,123 --> 00:08:44,124 line:-1
若有按钮是聚焦状态


160
00:08:44,558 --> 00:08:48,095 line:-2
你应该实施
preferredFocusEnvironments API


161
00:08:48,161 --> 00:08:50,797 line:-1
以便你可以向聚焦引擎提供登录按钮


162
00:08:51,164 --> 00:08:53,066 line:-1
让我们看看你要如何实施


163
00:08:54,601 --> 00:08:58,405 line:-2
在这里我有一个示例是关于实施
preferredFocusEnvironments API


164
00:08:58,472 --> 00:09:01,708 line:-2
它会返回UIFocusEnvironment
对象的一个数组


165
00:09:02,976 --> 00:09:06,313 line:-2
首先我们要尝试把用户名和密码
字段的文本抓取出来


166
00:09:06,513 --> 00:09:09,716 line:-2
如果我们可以 我们只需要
向聚焦引擎返回那个登录按钮即可


167
00:09:10,384 --> 00:09:12,052 line:-1
如果我们不能抓取任何文本


168
00:09:12,119 --> 00:09:14,288 line:-1
那就意味着用户尚未键入任何文本


169
00:09:14,354 --> 00:09:17,357 line:-2
因此我们要返回用户名和密码字段
使其保持聚焦状态


170
00:09:17,991 --> 00:09:18,992 line:-1
超级简单


171
00:09:20,761 --> 00:09:22,429 line:-1
那么让我们简单说一下


172
00:09:22,496 --> 00:09:23,697 line:-1
密码自动填写功能的方便快捷性


173
00:09:25,265 --> 00:09:26,266 line:-1
对于客户来说


174
00:09:26,667 --> 00:09:29,670 line:-2
密码自动填写功能
减少了在你的app内部的摩擦


175
00:09:29,970 --> 00:09:33,073 line:-1
通过启用一次轻触即可登录体验


176
00:09:33,640 --> 00:09:36,743 line:-2
对于你们开发人员来说
如果需要采用什么技术


177
00:09:37,110 --> 00:09:38,212 line:-1
那也超级简单


178
00:09:39,313 --> 00:09:43,016 line:-1
你只需要采用UITextContentTypes


179
00:09:44,551 --> 00:09:45,919 line:-1
采用关联域


180
00:09:45,986 --> 00:09:48,822 line:-2
以便你的app证书
出现在快速输入栏中


181
00:09:50,090 --> 00:09:50,924 line:-1
最后


182
00:09:50,991 --> 00:09:55,863 line:-2
实施preferredFocusEnvironments
以启用一次轻触即可登录体验


183
00:09:56,763 --> 00:09:58,665 line:-2
这就是tvOS上的
密码自动填写功能


184
00:09:59,032 --> 00:10:01,902 line:-2
我们已经迫不及待地要看到
你的用户使用这个功能了


185
00:10:02,536 --> 00:10:05,539 line:-2
接下来我想邀请Ada上台
谈谈聚焦改进


186
00:10:13,380 --> 00:10:14,414 line:-1
谢谢Alex


187
00:10:14,781 --> 00:10:16,383 line:-2
各位
我叫Ada Turner


188
00:10:16,450 --> 00:10:18,519 line:-1
今天我要激动地跟大家一起分享


189
00:10:18,585 --> 00:10:21,889 line:-2
我们在tvOS 12中
针对聚焦所做出的改进


190
00:10:22,923 --> 00:10:27,294 line:-2
聚焦是让用户在tvOS上
与你的app进行交互的方法


191
00:10:27,694 --> 00:10:30,197 line:-1
它允许用户优雅地滚动内容


192
00:10:30,397 --> 00:10:32,332 line:-1
并提供幽默的移动暗示


193
00:10:32,566 --> 00:10:35,402 line:-2
随着他们与Siri Remote
触摸表面的交互


194
00:10:36,203 --> 00:10:37,738 line:-1
app是通过UIKit


195
00:10:37,905 --> 00:10:39,706 line:-2
SpriteKit
和SceneKit创建的


196
00:10:39,907 --> 00:10:41,808 line:-1
它们都支持聚焦


197
00:10:42,142 --> 00:10:45,846 line:-2
然而 使用了可替换方法
来渲染内容的app


198
00:10:46,079 --> 00:10:49,149 line:-1
并不能直接支持聚焦引擎


199
00:10:50,050 --> 00:10:53,187 line:-2
今天我很高兴地宣布
在tvOS 12中


200
00:10:53,387 --> 00:10:57,357 line:-2
聚焦引擎现已支持各种app了
无论它们是否被渲染过


201
00:11:03,063 --> 00:11:06,300 line:-2
意思是用框架
比如Metal写的app


202
00:11:06,567 --> 00:11:10,037 line:-2
现在也能直接在交互模式中
采用聚焦了


203
00:11:10,470 --> 00:11:11,471 line:-1
这是通过


204
00:11:11,538 --> 00:11:14,708 line:-2
允许你让你自己的类
遵循聚焦协议来实现的


205
00:11:14,942 --> 00:11:18,011 line:-1
即使它们并不是继承UIKit组件


206
00:11:18,812 --> 00:11:20,914 line:-1
现在这就意味着对于你的app来说


207
00:11:21,148 --> 00:11:23,250 line:-1
它们将获得稳定管理


208
00:11:23,383 --> 00:11:24,985 line:-1
关于当前聚焦什么


209
00:11:25,385 --> 00:11:28,956 line:-2
用几何法确定
聚焦可以和不可以移动到哪里


210
00:11:29,356 --> 00:11:31,291 line:-1
完整的权限支持


211
00:11:31,658 --> 00:11:37,698 line:-2
聚焦移动、暗示和滚动感觉就像
一个嵌入的tvOS app


212
00:11:39,066 --> 00:11:41,602 line:-1
在我们了解新的聚焦API之前


213
00:11:41,869 --> 00:11:45,506 line:-1
让我们迅速回顾一些现有聚焦组件


214
00:11:46,306 --> 00:11:48,575 line:-2
首先我们有
UIFocusEnvironments


215
00:11:48,909 --> 00:11:52,679 line:-2
这个原型管理的是
聚焦互动可以发生在哪里的状态


216
00:11:53,080 --> 00:11:57,618 line:-2
当焦点更新时 它会收到一个通知
并可以影响焦点更新行为


217
00:11:57,951 --> 00:11:58,952 line:-1
在UIKit中


218
00:11:59,019 --> 00:12:02,523 line:-2
UIViewController是一个
聚焦环境的很棒的例子


219
00:12:03,457 --> 00:12:05,726 line:-2
接下来我们有
UIFocusItem


220
00:12:06,360 --> 00:12:08,896 line:-2
这个原型继承
FocusEnvironment


221
00:12:09,162 --> 00:12:13,300 line:-2
并添加了焦点项的功能
以使其能够真正聚焦


222
00:12:13,600 --> 00:12:19,239 line:-2
UIKit的UIView和SpriteKit的
SKNode是焦点项的好例子


223
00:12:19,940 --> 00:12:22,910 line:-2
最后我们还有
UIFocusSystem


224
00:12:23,143 --> 00:12:25,445 line:-1
它提供了一个著名而又有用的功能


225
00:12:25,646 --> 00:12:30,250 line:-2
即在聚焦交互过程中
能够注册自定义语音


226
00:12:31,251 --> 00:12:34,188 line:-1
要了解更多关于如何使用这些组件


227
00:12:34,388 --> 00:12:35,656 line:-1
以及调试聚焦的信息


228
00:12:35,889 --> 00:12:37,558 line:-1
我强烈推荐你们观看


229
00:12:37,724 --> 00:12:41,261 line:-2
去年的一场演讲
“tvOS 11中的聚焦交互”


230
00:12:42,095 --> 00:12:47,167 line:-2
我要向聚焦引擎中引入一些新组件
对此我感到万分激动


231
00:12:47,734 --> 00:12:50,137 line:-1
首先从tvOS 12开始讲


232
00:12:50,571 --> 00:12:54,107 line:-2
我们扩展了
FocusSystem对象的功能


233
00:12:54,608 --> 00:12:57,644 line:-2
你可以在指定环境下
取回一个FocusSystem


234
00:12:57,911 --> 00:13:01,548 line:-2
并从FocusSystem外
获取当前的焦点项


235
00:13:02,349 --> 00:13:06,787 line:-2
接下来我们引入了一个叫做
UIFocusItemContainer的新协议


236
00:13:07,254 --> 00:13:10,224 line:-1
它向焦点项提供几何情境


237
00:13:11,225 --> 00:13:14,528 line:-2
FocusItemContainer
由FocusEnvironment所有


238
00:13:14,862 --> 00:13:18,365 line:-1
并可以在特定区域定位焦点项


239
00:13:18,432 --> 00:13:21,969 line:-1
允许聚焦引擎聚焦到最佳候选项上


240
00:13:23,537 --> 00:13:26,740 line:-2
接下来我们有
FocusItemContainer的特殊类型


241
00:13:26,807 --> 00:13:28,842 line:-1
叫做FocusItemScrollableContainer


242
00:13:29,076 --> 00:13:32,079 line:-1
它会对添加对内容的自动滚动支持


243
00:13:32,145 --> 00:13:33,547 line:-1
随着焦点的移动


244
00:13:34,481 --> 00:13:38,852 line:-2
最后我们现在提供附带移动暗示的
FocusItems


245
00:13:39,086 --> 00:13:42,856 line:-2
它包含你可以用于
创建视觉效果的原始值


246
00:13:43,090 --> 00:13:46,360 line:-1
那会建议即将向哪个方向移动焦点


247
00:13:47,261 --> 00:13:49,229 line:-1
现在让我们具体了解一下


248
00:13:49,296 --> 00:13:52,466 line:-1
我们该如何让我们的类遵循这些协议


249
00:13:53,233 --> 00:13:56,236 line:-2
让我们从实施自定义
FocusEnvironment开始


250
00:13:56,803 --> 00:13:59,840 line:-1
为了让聚焦引擎找到你的环境


251
00:14:00,073 --> 00:14:02,442 line:-1
及其子环境或项


252
00:14:02,743 --> 00:14:05,345 line:-1
你必须app一个父聚焦环境


253
00:14:05,546 --> 00:14:07,047 line:-1
和一个FocusItemContainer


254
00:14:07,447 --> 00:14:08,448 line:-1
比如


255
00:14:08,515 --> 00:14:11,451 line:-2
UIViewController
可能会把它的父viewController


256
00:14:11,518 --> 00:14:13,053 line:-1
提供为它的parentFocusEnvironment


257
00:14:13,420 --> 00:14:16,223 line:-2
并把它的视图
提供为它的FocusItemContainer


258
00:14:17,524 --> 00:14:20,127 line:-2
FocusEnvironment提供了
一系列的方法 你可以用于


259
00:14:20,194 --> 00:14:22,696 line:-1
控制和应对焦点更新


260
00:14:22,963 --> 00:14:23,964 line:-1
比如


261
00:14:24,031 --> 00:14:27,734 line:-2
preferredFocusEnvironments
允许你引导聚焦系统


262
00:14:27,935 --> 00:14:31,471 line:-2
在视图初始化之后
选择要聚焦哪一项


263
00:14:31,839 --> 00:14:33,841 line:-1
或是一个程序性的焦点更新


264
00:14:34,775 --> 00:14:37,711 line:-1
我在这里要提醒你们注意两个方法


265
00:14:37,778 --> 00:14:39,146 line:-1
在FocusEnvironment上


266
00:14:39,646 --> 00:14:42,883 line:-2
SetNeedsFocusUpdate
和updateFocusIfNeeded


267
00:14:43,283 --> 00:14:45,385 line:-1
你对这些方法的实施


268
00:14:45,452 --> 00:14:49,857 line:-2
必须在FocusSystem上
调用指定方法


269
00:14:51,425 --> 00:14:55,062 line:-2
接下来让我们实施一个自定义
FocusItemContainer


270
00:14:57,164 --> 00:14:59,766 line:-2
首先你要提供一个
coordinateSpace


271
00:15:00,133 --> 00:15:02,569 line:-2
UIView会把它自己提供为一个
coordinateSpace


272
00:15:03,003 --> 00:15:04,938 line:-1
如果你的容器更抽象


273
00:15:05,005 --> 00:15:08,675 line:-2
你可能会返回一个现有的coordinateSpace
或实施你自己的coordinateSpace


274
00:15:09,910 --> 00:15:12,746 line:-2
接下来你需要在方框中
实施FocusItems


275
00:15:13,113 --> 00:15:16,016 line:-2
这个方法必须返回任意一个
所包含的FocusItems


276
00:15:16,283 --> 00:15:18,685 line:-1
它的框架贯穿所提供的方框


277
00:15:19,152 --> 00:15:21,321 line:-1
请注意传递到这个方法中的方框


278
00:15:21,388 --> 00:15:23,891 line:-1
是在容器的coordinateSpace中表达的


279
00:15:24,224 --> 00:15:27,928 line:-2
并且你从这个方法中所返回的每一个
focusItem的框架


280
00:15:28,295 --> 00:15:30,998 line:-2
必须也在那个coordinateSpace中
进行了表达


281
00:15:33,200 --> 00:15:35,869 line:-2
接下来让我们实施一个
自定义FocusItem


282
00:15:36,904 --> 00:15:39,740 line:-2
请记住这个协议继承
FocusEnvironment


283
00:15:39,973 --> 00:15:42,476 line:-1
因此你也需要实施全部方法


284
00:15:43,510 --> 00:15:46,747 line:-1
为了让聚焦引擎聚焦到你的项


285
00:15:47,014 --> 00:15:49,850 line:-2
它必须从canBecomeFocused中
返回“真”


286
00:15:51,084 --> 00:15:53,987 line:-2
DidHintFocusMovement
是一个可选方法


287
00:15:54,054 --> 00:15:56,390 line:-2
无论何时当用户移动他们的手指时
就会调用它


288
00:15:56,456 --> 00:15:58,392 line:-1
在Siri Remote触摸表面


289
00:15:58,926 --> 00:16:02,262 line:-2
它向FocusItem
提供了一个移动暗示


290
00:16:02,329 --> 00:16:05,265 line:-2
包含你可以用于创建
某个效果的原始值


291
00:16:05,566 --> 00:16:08,735 line:-2
是指能暗示焦点
即将向哪个方向移动的效果


292
00:16:09,736 --> 00:16:11,905 line:-1
最后你需要提供一个框架


293
00:16:12,239 --> 00:16:15,008 line:-1
正如我之前所说 这个框架必须


294
00:16:15,075 --> 00:16:18,579 line:-2
在包含FocusItemContainer的
coordinateSpace中表达过


295
00:16:18,846 --> 00:16:24,718 line:-2
比如UIView在它的超级试图的
coordinateSpace中表达了它的框架


296
00:16:25,018 --> 00:16:28,055 line:-1
那也是它的FocusItemContainer


297
00:16:29,289 --> 00:16:33,160 line:-2
现在让我们具体了解一下
FocusMovementHint对象


298
00:16:34,194 --> 00:16:35,929 line:-1
移动方向是一个矢量


299
00:16:36,196 --> 00:16:40,300 line:-1
它的值在-1、-1和1、1之间


300
00:16:40,601 --> 00:16:44,671 line:-2
代表焦点的移动
距某一特定方向有多近


301
00:16:45,439 --> 00:16:47,541 line:-1
这个值被绑定为


302
00:16:47,608 --> 00:16:51,111 line:-2
在Siri Remote触摸表面
用户的手指所创建的路径


303
00:16:52,579 --> 00:16:55,349 line:-1
说得透彻一点 旋转和转换


304
00:16:55,616 --> 00:17:00,153 line:-2
是你可以用来匹配
tvOS的嵌入交互暗示的值


305
00:17:01,021 --> 00:17:02,556 line:-1
并且interactionTransform


306
00:17:02,623 --> 00:17:06,359 line:-2
把这三个值结合到了
一个单一的3D变换中


307
00:17:08,262 --> 00:17:10,897 line:-2
接下来让我们看看如何实施
自定义


308
00:17:10,964 --> 00:17:13,367 line:-1
FocusItemScrollableContainer


309
00:17:13,767 --> 00:17:16,470 line:-2
这是FocusItemContainer的一个
特殊类型


310
00:17:16,770 --> 00:17:18,605 line:-1
通过变换为这个协议


311
00:17:18,839 --> 00:17:22,509 line:-2
你的容器会向聚焦引擎
表明它支持滚动


312
00:17:22,809 --> 00:17:26,079 line:-2
比如UIScrollView
变换为这个协议


313
00:17:26,980 --> 00:17:29,449 line:-1
它提供三种额外的属性


314
00:17:29,750 --> 00:17:33,053 line:-1
可以让聚焦引擎管理它的滚动行为


315
00:17:33,420 --> 00:17:36,190 line:-2
首先我们有
contentOffset


316
00:17:36,456 --> 00:17:38,458 line:-1
它是一个读/写属性


317
00:17:38,525 --> 00:17:41,195 line:-1
表示容器已经滚动了多远


318
00:17:41,595 --> 00:17:46,733 line:-2
聚焦引擎会随着焦点的移动
自动设置这个属性


319
00:17:46,800 --> 00:17:50,070 line:-1
以便在屏幕上显示当前焦点项


320
00:17:51,071 --> 00:17:53,140 line:-1
其次我们有contentSize


321
00:17:53,273 --> 00:17:57,911 line:-1
表示可滚动内容的完整尺寸


322
00:17:58,345 --> 00:18:01,081 line:-1
第三我们有visibleSize


323
00:18:01,148 --> 00:18:04,051 line:-1
表示你的容器在屏幕上的尺寸


324
00:18:04,384 --> 00:18:08,388 line:-2
这个属性类似于UIScrollView上的
bounds.size


325
00:18:09,857 --> 00:18:14,061 line:-2
重要的是要谨记
contentOffset会被自动设置


326
00:18:14,361 --> 00:18:16,396 line:-1
而你要负责


327
00:18:16,463 --> 00:18:19,066 line:-1
适时更新你的渲染内容


328
00:18:19,132 --> 00:18:21,001 line:-1
无论何时当这个属性被设置


329
00:18:24,137 --> 00:18:28,342 line:-2
现在让我们谈谈如何
向自定义渲染app中添加权限


330
00:18:28,909 --> 00:18:30,944 line:-1
它实际上非常简单


331
00:18:31,411 --> 00:18:35,849 line:-2
通过实施FocusItemContainers
FocusItems方法


332
00:18:36,149 --> 00:18:39,152 line:-1
你会向聚焦引擎提供足够的信息


333
00:18:39,419 --> 00:18:42,823 line:-2
从而允许旁白在导航上
辅助你的用户


334
00:18:43,490 --> 00:18:47,794 line:-1
请一定记得设置权限标签和权限暗示


335
00:18:47,861 --> 00:18:48,896 line:-1
在你的FocusItems上


336
00:18:49,196 --> 00:18:53,100 line:-1
以便旁白给你的用户提供最佳体验


337
00:18:53,767 --> 00:18:55,435 line:-1
我强烈建议你们观看


338
00:18:55,669 --> 00:18:59,907 line:-2
2016年WWDC的
“权限新特性”演讲


339
00:19:00,207 --> 00:19:01,608 line:-1
以便深入了解


340
00:19:01,875 --> 00:19:06,446 line:-2
在tvOS中聚焦和旁白
是如何协同合作的


341
00:19:08,248 --> 00:19:11,285 line:-1
现在我要邀请同事Paul


342
00:19:11,552 --> 00:19:14,955 line:-2
给大家演示如何创建
聚焦Metal app


343
00:19:21,995 --> 00:19:22,996 line:-1
谢谢Ada


344
00:19:23,764 --> 00:19:26,466 line:-2
那么我正在设置屏幕上
处理一个基于Metal的游戏


345
00:19:26,867 --> 00:19:29,903 line:-2
在屏幕底部有一些
标准的用户界面按钮


346
00:19:30,637 --> 00:19:33,540 line:0
顶部是一些方格用于选择等级


347
00:19:34,074 --> 00:19:36,743 line:0
这些方格实际上是由
游戏引擎自身来进行渲染的


348
00:19:36,877 --> 00:19:37,911 line:0
你们一定能看出


349
00:19:37,978 --> 00:19:39,913 line:0
通过你在那儿看到的
很绚丽的3D图形


350
00:19:40,781 --> 00:19:43,450 line:0
我希望能通过遥控选择方格


351
00:19:44,251 --> 00:19:47,321 line:0
在此之前
我得自己处理遥控上的事件


352
00:19:47,721 --> 00:19:49,323 line:0
并实施我自己的导航


353
00:19:49,656 --> 00:19:51,992 line:0
尽可能匹配聚焦引擎的外观


354
00:19:52,292 --> 00:19:55,996 line:0
在tvOS 12中 我能直接
把这些方格连接到聚焦引擎上


355
00:19:56,630 --> 00:19:57,731 line:0
让我们实际操作一下


356
00:20:01,468 --> 00:20:02,836 line:-1
我首先要做的是


357
00:20:02,903 --> 00:20:05,906 line:-2
扩展LevelTile类
以便实施UIFocusItem


358
00:20:06,673 --> 00:20:08,675 line:-1
这就是允许它变得可聚焦的东西


359
00:20:09,943 --> 00:20:10,978 line:-1
这里有一些方法


360
00:20:11,245 --> 00:20:13,347 line:-2
我只想让你们注意一下
顶部的几个方法


361
00:20:14,214 --> 00:20:16,583 line:-2
对于canBecomeFocused
我要键入“真”


362
00:20:16,817 --> 00:20:17,885 line:-1
就是这么直截了当


363
00:20:18,652 --> 00:20:19,920 line:-1
对于parentFocusEnvironment


364
00:20:20,220 --> 00:20:22,589 line:-2
我要返回渲染这些项的
MetalView


365
00:20:23,524 --> 00:20:25,759 line:-2
最后
在didUpdateFocus中


366
00:20:26,126 --> 00:20:28,929 line:-2
我要把方格设置为
把自己设定为活动状态


367
00:20:29,196 --> 00:20:30,397 line:-1
当它变为焦点时


368
00:20:31,665 --> 00:20:34,768 line:-2
接下来我要告诉聚焦引擎
如何处理这些新项


369
00:20:35,469 --> 00:20:36,470 line:-1
为此


370
00:20:36,537 --> 00:20:39,306 line:-2
我要扩展渲染
它们的MetalView


371
00:20:40,307 --> 00:20:42,209 line:-1
这个视图已经在视图等级之中了


372
00:20:42,276 --> 00:20:44,211 line:-1
并且聚焦引擎也已知道了它的存在


373
00:20:44,278 --> 00:20:45,612 line:-1
这是一个钩入的绝佳位置


374
00:20:46,480 --> 00:20:47,915 line:-1
因为这是一个UIView


375
00:20:48,182 --> 00:20:50,584 line:-2
它已变换为
UIFocusItemContainer


376
00:20:50,884 --> 00:20:53,620 line:-1
并且它把自己作为了一个坐标空间


377
00:20:54,321 --> 00:20:55,589 line:-1
我唯一要做的是


378
00:20:55,656 --> 00:20:59,593 line:-2
覆盖FocusItem方框
以返回我的等级方格


379
00:20:59,826 --> 00:21:01,929 line:-2
当然
它现在是UIFocusItems


380
00:21:03,163 --> 00:21:04,731 line:-1
并且我在此能得到一个性能提升


381
00:21:04,998 --> 00:21:06,266 line:-1
仅仅通过返回方格


382
00:21:06,333 --> 00:21:08,669 line:-1
在搜索框内这些框架贯穿路径


383
00:21:10,304 --> 00:21:11,138 line:-1
呀


384
00:21:11,405 --> 00:21:13,073 line:-1
让我们看看是如何实现的


385
00:21:18,045 --> 00:21:20,113 line:0
现在你可以看到方格是可聚焦的


386
00:21:20,480 --> 00:21:23,951 line:0
并且系统甚至在它们成为焦点时
播放了一个标准音


387
00:21:24,451 --> 00:21:26,920 line:0
我甚至可以在我的自定义方格


388
00:21:26,987 --> 00:21:29,089 line:0
和底部的标准用户界面按钮之间
移动焦点


389
00:21:30,357 --> 00:21:31,491 line:0
但是这里有一个问题


390
00:21:31,992 --> 00:21:33,527 line:0
方格延伸到屏幕外了


391
00:21:34,127 --> 00:21:37,297 line:0
如果我把焦点移动到了屏幕以外
我就看不到我正和什么进行交互


392
00:21:38,131 --> 00:21:39,132 line:0
当然我希望的是


393
00:21:39,199 --> 00:21:41,735 line:0
当方格变成焦点时
让方格在屏幕上移动


394
00:21:42,336 --> 00:21:43,470 line:0
让我们来实施一下


395
00:21:46,373 --> 00:21:48,575 line:-1
我要再次扩展RenderView


396
00:21:49,209 --> 00:21:52,346 line:-2
这次是为了实施
UIFocusItemScrollableContainer


397
00:21:53,080 --> 00:21:54,381 line:-1
现在这里的重点是


398
00:21:54,581 --> 00:21:56,917 line:-2
通过contentOffset
调整我的渲染


399
00:21:57,518 --> 00:22:01,154 line:-2
聚焦引擎会随焦点移动
设置contentOffset


400
00:22:01,421 --> 00:22:03,390 line:-1
以便保证当前的焦点项显示在屏幕上


401
00:22:04,291 --> 00:22:05,692 line:-1
因为这是一个UIView


402
00:22:05,993 --> 00:22:08,328 line:-2
我还要通过
bounds.origin更新


403
00:22:08,562 --> 00:22:11,498 line:-2
以便coordinateSpace
转换继续准确无误地工作


404
00:22:15,035 --> 00:22:16,069 line:-1
看到它是如何实现的了吧？


405
00:22:18,639 --> 00:22:21,942 line:0
那么你可以看到当我聚焦某方格时
它会在屏幕上移动


406
00:22:22,543 --> 00:22:23,544 line:0
如果我继续


407
00:22:23,944 --> 00:22:26,914 line:0
我会得到一个漂亮、流畅的滚动
并拥有同样的动量…


408
00:22:27,214 --> 00:22:28,048 line:0
谢谢


409
00:22:28,282 --> 00:22:30,984 line:0
带有同样动量和动画的
漂亮、流畅的滚动


410
00:22:31,251 --> 00:22:32,619 line:0
就好像这是一个
UIScrollView


411
00:22:34,154 --> 00:22:36,790 line:-2
看起来非常棒
但我认为我们可以做得更好


412
00:22:37,291 --> 00:22:40,527 line:-2
我真正想要的是当这些方格
成为焦点时 它们会活跃起来


413
00:22:40,827 --> 00:22:42,162 line:-1
就像系统元素一样


414
00:22:43,630 --> 00:22:44,831 line:-1
让我们实际操作一下


415
00:22:46,333 --> 00:22:47,835 line:-1
我要返回到LevelTile


416
00:22:48,435 --> 00:22:50,737 line:-1
我要试试一个可选方法


417
00:22:51,271 --> 00:22:52,506 line:-1
didHintFocusMovement


418
00:22:53,941 --> 00:22:56,476 line:-1
我要把建议的视角、旋转


419
00:22:56,677 --> 00:22:59,346 line:-2
和转换值
从UIFocusMovementHint中取出来


420
00:22:59,680 --> 00:23:01,849 line:-2
并在我渲染FocusTile时
app它们


421
00:23:03,317 --> 00:23:04,318 line:-1
我们了解一下看起来如何


422
00:23:10,324 --> 00:23:12,092 line:-1
随着我的手指在轨迹板上的移动


423
00:23:12,359 --> 00:23:15,262 line:-1
方格正如我所期待的那样交互


424
00:23:16,230 --> 00:23:19,566 line:-2
现在我已在自定义
Metal对象中添加了聚焦支持


425
00:23:19,900 --> 00:23:22,736 line:-2
并且感觉就像
它们是用ULikeIT写的一样


426
00:23:23,437 --> 00:23:24,438 line:-1
舞台交还给你Ada


427
00:23:28,775 --> 00:23:29,776 line:-1
谢谢Paul


428
00:23:30,711 --> 00:23:32,946 line:-1
哇 真是一个很棒的Metal演示


429
00:23:33,213 --> 00:23:35,182 line:-1
只需要几行代码


430
00:23:35,382 --> 00:23:38,051 line:-1
我们就能给Metal用户界面


431
00:23:38,318 --> 00:23:41,455 line:-2
提供漂亮、流畅
聚焦的移动和滚动


432
00:23:41,722 --> 00:23:46,393 line:-2
还有令人赏心悦目的交互暗示
就像嵌入的tvOS app一样


433
00:23:47,528 --> 00:23:48,762 line:-1
现在让我们回顾一下


434
00:23:48,829 --> 00:23:51,298 line:-1
我们今天学到的全部聚焦新特性


435
00:23:52,099 --> 00:23:56,603 line:-2
首先 我们了解了如何实施自定义
FocusEnvironments和FocusItems


436
00:23:57,137 --> 00:24:00,007 line:-1
即使它们并不继承UIKit组件


437
00:24:00,774 --> 00:24:03,877 line:-2
其次 我们了解了如何使用
FocusItemContainer


438
00:24:04,244 --> 00:24:06,813 line:-1
从而当用户在你的app中移动焦点时


439
00:24:06,880 --> 00:24:09,216 line:-1
感觉像是tvOS中嵌入的app一样


440
00:24:10,083 --> 00:24:12,586 line:-2
第三 我们了解了如何使用
FocusMovementHint


441
00:24:12,819 --> 00:24:16,924 line:-2
当人们与Siri Remote交互时
让我们的界面变得活跃


442
00:24:17,724 --> 00:24:21,261 line:-2
第四 我们了解了如何使用
FocusItemScrollableContainer


443
00:24:21,562 --> 00:24:23,997 line:-1
允许人们在app的内容之间滚动


444
00:24:24,198 --> 00:24:26,466 line:-2
并拥有一个流畅
熟悉和嵌入式的体验


445
00:24:27,000 --> 00:24:28,001 line:-1
最后


446
00:24:28,135 --> 00:24:32,439 line:-2
我们了解了如何给app提供
完整的权限支持


447
00:24:32,739 --> 00:24:34,942 line:-1
仅仅通过采用这些协议即可实现


448
00:24:35,242 --> 00:24:37,578 line:-1
以及如何提供权限标签和暗示


449
00:24:37,811 --> 00:24:40,180 line:-2
以便每个人都可以
使用并享受我们的app


450
00:24:41,114 --> 00:24:44,751 line:-2
全部这些很棒的新特性
今天在Developer Beta中可用了


451
00:24:44,818 --> 00:24:46,787 line:-1
并且我强烈建议你下载它


452
00:24:46,854 --> 00:24:48,889 line:-1
并发现它是如何简单地


453
00:24:48,956 --> 00:24:51,625 line:-1
向你的自定义渲染app添加聚焦支持


454
00:24:52,259 --> 00:24:55,362 line:-1
现在我要邀请Hans返回舞台


455
00:24:55,429 --> 00:24:58,565 line:-2
跟我们分享一些tvOS上
很棒的用户界面模式


456
00:25:01,235 --> 00:25:02,236 line:-1
谢谢Ada


457
00:25:04,771 --> 00:25:07,641 line:-2
在我们感觉如何连接到
房间内的屏幕方面


458
00:25:07,708 --> 00:25:09,076 line:-1
聚焦交互是完整的


459
00:25:09,676 --> 00:25:13,480 line:-2
并且tvOS
有许多通用的用户界面模式


460
00:25:14,448 --> 00:25:15,449 line:-1
有这样一个例子


461
00:25:16,517 --> 00:25:19,620 line:-2
一个标签会在成为焦点时
动态显示它的文本


462
00:25:21,588 --> 00:25:24,925 line:-1
内部滚动文本或字幕动画


463
00:25:25,292 --> 00:25:28,428 line:-2
都是有用的技巧
在表达可变长度的字符串方面


464
00:25:28,662 --> 00:25:31,064 line:-1
而不需要替换标签的外部图形


465
00:25:32,566 --> 00:25:33,734 line:-1
它也非常有效


466
00:25:34,234 --> 00:25:37,538 line:-1
可以从视觉上突出你当前的焦点所在


467
00:25:39,039 --> 00:25:41,942 line:-2
这个行为在tvOS上的
使用非常广泛


468
00:25:42,376 --> 00:25:44,645 line:-1
但它的实现并没有那么简单


469
00:25:45,145 --> 00:25:46,647 line:-1
我说的是现在


470
00:25:47,614 --> 00:25:49,650 line:-1
但tvOS把它变得非常简单了


471
00:25:50,017 --> 00:25:50,984 line:-1
你所需要做的就是


472
00:25:52,252 --> 00:25:54,054 line:-1
在你的标签上设置一个新属性


473
00:25:54,888 --> 00:25:58,192 line:-2
把MarqueeWhenAncestorFocused
设置为“真”


474
00:26:02,329 --> 00:26:05,566 line:-2
然后当包含那个标签的视图
成为焦点时


475
00:26:05,933 --> 00:26:09,036 line:-2
标签包含一个字符串
它的长度远远超过了视图的宽度


476
00:26:11,972 --> 00:26:15,576 line:-2
它就会动态显示字符串
水平循环显示


477
00:26:17,211 --> 00:26:18,946 line:-1
我们都实际使用过这个API


478
00:26:19,012 --> 00:26:22,282 line:-2
我们认为你们一定会非常喜欢它
因为你可以简单地采用这个行为


479
00:26:23,450 --> 00:26:25,352 line:-1
这是用户界面标签中的文本滚动


480
00:26:27,254 --> 00:26:31,024 line:-1
但tvOS还有很多惯用法和模式


481
00:26:31,091 --> 00:26:35,462 line:-2
比如当图片和标签
成为焦点时会变得活跃


482
00:26:38,198 --> 00:26:41,301 line:-1
任意视图等级浮动作为一个固定单元


483
00:26:44,671 --> 00:26:47,908 line:-1
按钮有可自定义的聚焦移动和内容


484
00:26:50,944 --> 00:26:52,746 line:-1
并且还有代表用户的小工具


485
00:26:54,014 --> 00:26:55,015 line:-1
正如你所看到的


486
00:26:55,315 --> 00:26:58,785 line:-2
这些模式在tvOS
和Apple自己的app中无所不在


487
00:26:59,186 --> 00:27:02,389 line:-1
因为它们已在TVMLKit中可用


488
00:27:02,456 --> 00:27:04,958 line:-1
我们也看到你们的app中采用了它们


489
00:27:06,193 --> 00:27:08,095 line:-2
但若你的app基于UIKit之上
会如何？


490
00:27:09,363 --> 00:27:10,230 line:-1
嗯


491
00:27:10,497 --> 00:27:13,667 line:-2
我们真的非常激动地要跟你们
分享tvOS 12


492
00:27:14,701 --> 00:27:18,272 line:-2
将把其中一些变得适用于
基于UIKit的app


493
00:27:23,243 --> 00:27:27,014 line:-2
我们通过一个新的轻量级框架
TVUIKit来实现


494
00:27:29,316 --> 00:27:31,718 line:-1
TVUIKit中的前四个元素是


495
00:27:32,486 --> 00:27:38,091 line:-1
海报、字幕按钮、卡片和交织字母


496
00:27:39,293 --> 00:27:40,527 line:-1
让我们分别了解一下


497
00:27:41,795 --> 00:27:43,363 line:-1
海报视图是关于图片的


498
00:27:44,331 --> 00:27:46,500 line:-2
TVPosterView
是一个组合视图


499
00:27:46,567 --> 00:27:48,669 line:-1
主要表示一张图片


500
00:27:49,436 --> 00:27:52,739 line:-1
而页脚自己由至多两个标签组成


501
00:27:53,807 --> 00:27:57,110 line:-2
当海报视图成为焦点时
图片的尺寸就会变大


502
00:27:57,244 --> 00:27:59,546 line:-1
而且标签会移走以便提供空间


503
00:28:00,881 --> 00:28:02,416 line:-1
当它不是焦点时


504
00:28:02,883 --> 00:28:05,285 line:-1
图片和标签又重新组成普通布局


505
00:28:07,020 --> 00:28:09,022 line:-2
当你在TVPosterView中
编码某个图片时


506
00:28:09,523 --> 00:28:12,726 line:-1
它会算出图片尺寸增长的精确值


507
00:28:14,461 --> 00:28:18,498 line:-2
且TVPosterView是创建
诸如此类的用户界面的理想API


508
00:28:18,999 --> 00:28:20,000 line:-1
非常简单


509
00:28:21,902 --> 00:28:23,370 line:-1
这就是TVPosterView


510
00:28:24,771 --> 00:28:26,173 line:-1
接下来是字幕按钮


511
00:28:27,341 --> 00:28:29,409 line:-1
字幕按钮是关于行动召唤


512
00:28:32,179 --> 00:28:33,647 line:-1
TVCaptionButtonView


513
00:28:33,947 --> 00:28:34,948 line:-1
是一个组合视图


514
00:28:35,015 --> 00:28:37,851 line:-1
主要表达按钮式的内容


515
00:28:39,319 --> 00:28:42,289 line:-1
而页脚自己由至多两个标签组成


516
00:28:43,924 --> 00:28:45,859 line:-1
内容视图有一个模糊背景


517
00:28:46,493 --> 00:28:49,329 line:-1
可以是图片或文本


518
00:28:51,064 --> 00:28:52,866 line:-2
当CaptionButtonView
成为焦点时


519
00:28:53,634 --> 00:28:57,771 line:-2
它会浮动
但与PosterView不同


520
00:28:58,372 --> 00:29:03,177 line:-1
它只增加页眉、顶部和背向的尺寸


521
00:29:04,912 --> 00:29:06,914 line:-1
你还可以限制浮动运动


522
00:29:07,814 --> 00:29:11,084 line:-1
为仅水平浮动或仅垂直浮动


523
00:29:12,886 --> 00:29:14,821 line:-2
且当你使用多个
TVCaptionButtons


524
00:29:14,888 --> 00:29:17,324 line:-1
并给予它们一个恒定的运动方向时


525
00:29:17,925 --> 00:29:19,493 line:-1
你可以创建一种群组的感觉


526
00:29:20,727 --> 00:29:23,130 line:-2
TVCaptionButton
让这个过程变得非常简单


527
00:29:25,332 --> 00:29:26,867 line:-1
接下来是CardView


528
00:29:28,902 --> 00:29:30,704 line:-1
CardView是关于自定义视图


529
00:29:32,306 --> 00:29:37,177 line:-2
TVCardView主要是表示
任意组合的视图等级


530
00:29:39,646 --> 00:29:41,048 line:-1
CardView为焦点时


531
00:29:42,416 --> 00:29:46,253 line:-2
它是内容视图的浮动
并且它全部子视图的移动都很一致


532
00:29:46,320 --> 00:29:48,388 line:-1
作为浮动内容视图的一部分


533
00:29:51,558 --> 00:29:56,463 line:-2
TVCardView是创建
类似这样的用户界面的好方法


534
00:29:59,299 --> 00:30:00,434 line:-1
非常直截了当


535
00:30:02,236 --> 00:30:04,872 line:-1
接下来是交织字母


536
00:30:06,807 --> 00:30:09,042 line:-2
MonogramView
用于表达人


537
00:30:10,978 --> 00:30:14,915 line:-2
TVMonogramView
有一个循环的内容图片


538
00:30:15,716 --> 00:30:18,919 line:-1
而页脚自己由至多两个标签组成


539
00:30:20,454 --> 00:30:23,824 line:-1
当你不提供人的名字或图片时


540
00:30:24,424 --> 00:30:27,327 line:-2
TVMonogramView
会提供一个通用的剪影


541
00:30:29,129 --> 00:30:30,697 line:-1
如果你提供了人的名字


542
00:30:31,398 --> 00:30:34,368 line:-2
TVMonogramView
会根据初始内容创建一个交织字母


543
00:30:37,037 --> 00:30:39,206 line:-1
当然如果你提供了图片


544
00:30:39,673 --> 00:30:41,608 line:-2
它就不会提出任何质疑
我们会直接使用它


545
00:30:44,077 --> 00:30:46,246 line:-2
TVMonogramView
成为焦点时


546
00:30:47,381 --> 00:30:50,617 line:-2
标签会移开以便给图片
提供尺寸增长的空间


547
00:30:53,120 --> 00:30:54,955 line:-2
当你使用
TVMonogramView时


548
00:30:55,956 --> 00:30:58,892 line:-2
创建一个类似这样的用户界面
就变得非常直截了当了


549
00:30:59,893 --> 00:31:02,963 line:-2
现在你可能已经注意到
那儿有一个一致性模式


550
00:31:03,197 --> 00:31:04,698 line:-1
在这四个元素之间


551
00:31:05,699 --> 00:31:08,135 line:-1
也就是有主内容


552
00:31:09,203 --> 00:31:10,871 line:-1
可选页眉和页脚


553
00:31:11,839 --> 00:31:13,740 line:-1
当这个组合成为焦点时


554
00:31:14,241 --> 00:31:15,843 line:-1
页眉和页脚就会移开


555
00:31:16,176 --> 00:31:18,378 line:-1
以便给内容提供空间


556
00:31:20,547 --> 00:31:23,684 line:-2
这个常用的行为
在基础类中是封装入内的


557
00:31:24,117 --> 00:31:25,219 line:-1
TVLockupView


558
00:31:27,387 --> 00:31:29,790 line:-2
TVLockupView中
你能自定义的东西


559
00:31:30,657 --> 00:31:33,560 line:-1
很明显是内容的尺寸


560
00:31:34,561 --> 00:31:35,562 line:-1
这真的很有帮助


561
00:31:35,629 --> 00:31:37,531 line:-2
当布局多个
LockupViews时


562
00:31:40,100 --> 00:31:41,401 line:-1
另一个是内容…


563
00:31:41,768 --> 00:31:44,238 line:-2
当内容处于焦点状态时
它的尺寸会变大


564
00:31:45,806 --> 00:31:47,140 line:-1
这些是定向插图


565
00:31:47,608 --> 00:31:50,911 line:-2
因此你甚至可以指定
全部四个方向的不同增长量


566
00:31:52,613 --> 00:31:55,549 line:-2
你可以回调使用此功能的
CaptionButtonView


567
00:31:59,286 --> 00:32:02,656 line:-2
当你把自己的内容
作为TVLockupView时


568
00:32:03,257 --> 00:32:07,327 line:-2
你可以利用
TVLockupViewComponent协议


569
00:32:08,662 --> 00:32:10,731 line:-2
无论何时TVLockupView
状态发生变更时


570
00:32:11,131 --> 00:32:15,035 line:-2
它会调用updateAppearance
forLockupViewState方法


571
00:32:15,102 --> 00:32:17,070 line:-1
在实施了它的全部子视图上


572
00:32:18,405 --> 00:32:21,608 line:-1
这是更新子视图行为的好机会


573
00:32:21,942 --> 00:32:24,811 line:-1
或根据状态自定义是否显示


574
00:32:28,282 --> 00:32:29,850 line:-1
你可使用TVLockupView


575
00:32:30,083 --> 00:32:33,120 line:-1
创建你自己的小工具 响应聚焦交互


576
00:32:33,720 --> 00:32:37,724 line:-1
或进一步自定义四个特定目的子类


577
00:32:37,791 --> 00:32:38,792 line:-1
我们刚刚讨论过的


578
00:32:40,894 --> 00:32:43,130 line:-2
这就是TVLockupView
及其子类


579
00:32:45,165 --> 00:32:48,268 line:-2
最后你可能会回调
并看到诸如这样的东西


580
00:32:49,937 --> 00:32:51,004 line:-1
很简单


581
00:32:51,071 --> 00:32:54,408 line:-1
但它的简单恰恰伪装了


582
00:32:54,474 --> 00:32:55,509 line:-1
在屏幕上实施何等困难


583
00:32:57,778 --> 00:33:00,147 line:-1
TVUIKit把这个过程变简单了


584
00:33:00,480 --> 00:33:03,350 line:-2
那就是通过
TVDigitEntryViewController


585
00:33:05,519 --> 00:33:09,022 line:-2
TVDigitEntryViewController
管理全屏视图


586
00:33:09,523 --> 00:33:12,860 line:-1
表达标题标签、提示标签


587
00:33:14,027 --> 00:33:17,030 line:-1
数位视图和数字键盘


588
00:33:19,533 --> 00:33:22,736 line:-2
在TVDigitEntryViewController
可自定义的元素中


589
00:33:23,637 --> 00:33:29,676 line:-1
有数位的数量以及键入是否安全


590
00:33:32,279 --> 00:33:35,582 line:-2
完成处理器允许你处理
所键入的数位


591
00:33:36,917 --> 00:33:38,151 line:-1
我们别只会嘴上说说


592
00:33:38,418 --> 00:33:41,555 line:-2
我要邀请同事Marshall上台
给大家做一个演示


593
00:33:48,395 --> 00:33:51,164 line:-2
谢谢Hans 我叫Marshall
今天我们要看看


594
00:33:51,231 --> 00:33:53,534 line:-2
你要如何使用
TVDigitEntryViewController


595
00:33:53,934 --> 00:33:56,537 line:-1
从你的用户那儿收集数字数据


596
00:33:57,171 --> 00:33:59,206 line:-2
我有一个app叫做
Top Movies


597
00:33:59,273 --> 00:34:01,141 line:-1
可以让我观看我喜欢的内容


598
00:34:01,642 --> 00:34:03,977 line:-1
但并不是所有内容都适用于


599
00:34:04,044 --> 00:34:05,179 line:-1
房子里的每一个人


600
00:34:05,245 --> 00:34:08,215 line:-2
因此我希望用一个PIN码
对它进行保护


601
00:34:08,581 --> 00:34:10,317 line:-1
以便我可以限制谁能观看它


602
00:34:11,118 --> 00:34:12,953 line:-1
我们这里有一个收集视图


603
00:34:13,187 --> 00:34:15,755 line:-2
里面都是Hans刚介绍过的
TVPosterViews


604
00:34:17,024 --> 00:34:19,760 line:-1
如果我们深入到收集视图内：


605
00:34:19,860 --> 00:34:21,328 line:-2
didSelectItemAt
indexPath


606
00:34:22,029 --> 00:34:23,063 line:-1
我们首先要做的是


607
00:34:23,463 --> 00:34:25,532 line:-2
公布一个
TVDigitEntryViewController


608
00:34:26,033 --> 00:34:27,935 line:-1
并发送相应的标题和提示文本


609
00:34:28,001 --> 00:34:31,338 line:-2
让用户知道
他们应该输入一个五位密码


610
00:34:32,105 --> 00:34:33,607 line:-1
我们把数位的数量设置为五


611
00:34:34,107 --> 00:34:38,344 line:-2
把isSecure entry设为“真”
因为我们正在收集密码


612
00:34:40,246 --> 00:34:43,317 line:-2
接下来我们要实施
entryCompletionHandler


613
00:34:44,184 --> 00:34:45,686 line:-1
它会返回一个字符串


614
00:34:46,119 --> 00:34:49,121 line:-1
一旦用户填写完全部数位


615
00:34:49,188 --> 00:34:50,190 line:-1
在数位视图中


616
00:34:50,891 --> 00:34:52,993 line:-1
因为我正在app中


617
00:34:53,126 --> 00:34:54,795 line:-1
我们只需查看每一个数位是否正确


618
00:34:54,862 --> 00:34:57,130 line:-1
如果是 我们就丢弃视图控制器


619
00:34:57,197 --> 00:34:58,265 line:-1
并显示内容


620
00:34:58,565 --> 00:35:00,367 line:-1
否则我们就会更新提示文本


621
00:35:00,434 --> 00:35:02,669 line:-1
让用户知道密码无效


622
00:35:02,736 --> 00:35:05,439 line:-2
我们调用clearEntry
animated为真


623
00:35:05,873 --> 00:35:08,675 line:-1
这将清除所填写的全部数位


624
00:35:08,976 --> 00:35:11,645 line:-2
并晃动数位视图
让用户知道出错了


625
00:35:12,479 --> 00:35:14,715 line:-2
最后我们显示
viewController


626
00:35:14,781 --> 00:35:18,886 line:-2
由于这只是一个viewController
我们可以使用自定义显示样式


627
00:35:19,286 --> 00:35:21,722 line:-2
我们使用
blurOverFullScreen


628
00:35:22,089 --> 00:35:24,091 line:-2
这是我们去年在tvOS中
引入的功能


629
00:35:25,559 --> 00:35:26,860 line:-1
运行它 看看该如何实现


630
00:35:28,228 --> 00:35:29,930 line:-1
我要选择我的电影


631
00:35:30,364 --> 00:35:33,033 line:-2
我们得到了一个
blurOverFullScreen动画


632
00:35:33,100 --> 00:35:35,068 line:-1
我们得到提示说要输入密码


633
00:35:35,402 --> 00:35:37,204 line:-1
现在我们知道目前是五位密码


634
00:35:37,271 --> 00:35:39,806 line:-2
那么让我们看看
如果我输入两个数位会怎样


635
00:35:40,574 --> 00:35:43,277 line:-2
我们看到有一个漂亮的晃动动画
并且更新了文本


636
00:35:44,211 --> 00:35:46,180 line:-1
现在我要输入全部五位密码


637
00:35:47,014 --> 00:35:48,315 line:-1
我们知道这是正确的密码


638
00:35:48,382 --> 00:35:50,784 line:-2
所以我们丢弃viewController
并可以播放内容了


639
00:35:52,586 --> 00:35:54,688 line:-1
现在如果用户希望使用…


640
00:35:54,755 --> 00:35:57,291 line:-1
他们很可能希望使用他们自己的密码


641
00:35:57,357 --> 00:36:00,093 line:-2
我们要做的就是
获取这里的设置按钮


642
00:36:00,160 --> 00:36:02,696 line:-1
并允许用户设置他们自己的密码


643
00:36:03,530 --> 00:36:05,299 line:-1
那么我已经获得了我的IB行动


644
00:36:06,033 --> 00:36:09,503 line:-2
我们公布
TVDigitEntryViewController


645
00:36:10,003 --> 00:36:11,305 line:-1
并设置标题文本


646
00:36:11,371 --> 00:36:13,807 line:-1
让他们知道我们正在收集密码


647
00:36:13,874 --> 00:36:15,809 line:-1
那会限制可以观看的内容


648
00:36:15,876 --> 00:36:18,245 line:-1
把数位数量设置为五


649
00:36:19,446 --> 00:36:22,850 line:-2
接下来我们要再次实施
entryCompletionHandler


650
00:36:23,483 --> 00:36:25,853 line:-1
现在这里出现了一个额外的变量


651
00:36:25,919 --> 00:36:28,288 line:-2
一个叫做passcodeToVerify的
可选字符串


652
00:36:28,388 --> 00:36:29,389 line:-1
它会在用户


653
00:36:29,590 --> 00:36:33,360 line:-1
第一次输入密码时保存下来


654
00:36:33,427 --> 00:36:36,864 line:-2
因此我们可以验证它
以确保他们真的输入了正确的密码


655
00:36:37,497 --> 00:36:39,933 line:-2
我们看到 当调用
completionHandler时


656
00:36:40,634 --> 00:36:42,769 line:-2
我们可以查看以便了解
passcodeToVerify是否为空


657
00:36:42,836 --> 00:36:44,338 line:-1
如果是并且这是第一次


658
00:36:44,404 --> 00:36:48,342 line:-1
我们就会要求他们验证密码


659
00:36:48,408 --> 00:36:52,079 line:-2
我们调用clearEntry动画
除非这一次为假


660
00:36:52,312 --> 00:36:54,615 line:-2
我们不希望晃动它
因为他们并没有做错任何事


661
00:36:54,681 --> 00:36:56,750 line:-2
但我们希望清除它
以便他们可以再次输入


662
00:36:57,284 --> 00:37:00,254 line:-2
否则 如果在passcodeToVerify中
有一个存储的值


663
00:37:00,320 --> 00:37:03,123 line:-2
我们就知道他们正在验证它
我们需检验以确保值是相同的


664
00:37:03,290 --> 00:37:07,227 line:-2
如果是 我们就保存新密码
丢弃viewController


665
00:37:07,594 --> 00:37:11,031 line:-2
否则我们就把提示文本
重新设置为我们最开始的内容


666
00:37:11,465 --> 00:37:12,466 line:-1
清除输入


667
00:37:12,666 --> 00:37:15,569 line:-2
然后把passcodeToVerify设置为空
以便他们可以再次输入


668
00:37:16,036 --> 00:37:17,938 line:-1
最后我们要显示viewController


669
00:37:21,909 --> 00:37:23,510 line:-1
现在我们要进行设置


670
00:37:23,777 --> 00:37:25,646 line:-1
它会要求我们设置密码


671
00:37:25,712 --> 00:37:27,848 line:-1
让我们继续并先设置密码


672
00:37:28,282 --> 00:37:29,550 line:-1
现在它要求我们进行验证


673
00:37:29,917 --> 00:37:31,418 line:-1
但这一次我要输入两个数位


674
00:37:32,119 --> 00:37:33,487 line:-1
因为我们知道那是不对的


675
00:37:33,921 --> 00:37:35,589 line:-1
那么现在让我们输入正确的密码


676
00:37:36,390 --> 00:37:38,792 line:-2
我们输入了五位密码
我们要验证PIN码


677
00:37:39,493 --> 00:37:42,329 line:-2
并且保存PIN码
以便用户需要时可以使用它


678
00:37:43,497 --> 00:37:46,800 line:-2
这就是如何实施
TVDigitEntryViewController


679
00:37:46,867 --> 00:37:47,801 line:-1
在你的app中


680
00:37:48,101 --> 00:37:49,736 line:-1
我要邀请Hans返回舞台


681
00:37:52,940 --> 00:37:54,041 line:-1
谢谢Marshall


682
00:37:55,442 --> 00:37:57,644 line:-1
这是一个很棒的演示


683
00:37:57,711 --> 00:38:00,447 line:-2
展示了通过TVUIKit用
通用用户界面模式很简单


684
00:38:02,716 --> 00:38:06,787 line:-2
此外TVUIKit还有一个
用于定位的内置支持


685
00:38:06,854 --> 00:38:10,591 line:-2
包括右到左的语言支持
当然了 还有权限


686
00:38:11,325 --> 00:38:13,727 line:-1
TVUIKit在Developer Beta中可用


687
00:38:13,794 --> 00:38:15,495 line:-1
因此请下载并查看一下标题


688
00:38:16,029 --> 00:38:17,731 line:-1
随着你在app中的使用


689
00:38:18,599 --> 00:38:21,535 line:-2
我们认为它会节省你的时间和资源
因此你可以


690
00:38:21,802 --> 00:38:23,871 line:-1
关注让你的app真正出彩的东西


691
00:38:25,939 --> 00:38:27,040 line:-1
这就是TVUIKit


692
00:38:29,309 --> 00:38:31,645 line:-1
今天下午我们了解了其中一些区域


693
00:38:31,712 --> 00:38:35,849 line:-2
tvOS 12可以改善
app用户的体验和性能


694
00:38:37,451 --> 00:38:39,319 line:-1
我们了解了密码自动填充


695
00:38:39,486 --> 00:38:42,990 line:-2
可以让客户登录app的过程
变得非常简单


696
00:38:44,057 --> 00:38:47,494 line:-1
如果他们有强密码 会更有帮助


697
00:38:49,396 --> 00:38:54,434 line:-2
我们还了解了如何把tvOS的
聚焦引擎扩展到支持所有app


698
00:38:54,835 --> 00:38:56,670 line:-1
无论app是否被渲染


699
00:38:57,538 --> 00:38:58,839 line:-1
这真的是一个大变更


700
00:39:00,841 --> 00:39:03,110 line:-1
最后我们了解了TVUIKit


701
00:39:03,544 --> 00:39:07,514 line:-2
它使得在tvOS上采用
通用用户界面模式变得非常简单


702
00:39:09,783 --> 00:39:12,419 line:0
我们有一个演讲页面
包括全部这些信息以及更多信息


703
00:39:12,719 --> 00:39:15,756 line:0
并且你们在tvOS实验室
也可以见到我们


704
00:39:15,856 --> 00:39:18,992 line:0
而这一周都会有
Safari WebKit实验室


705
00:39:19,626 --> 00:39:22,029 line:-2
我们邀请你们参加
带上你们的问题和代码


706
00:39:22,696 --> 00:39:24,131 line:-1
谢谢参加今天下午的演讲


707
00:39:24,831 --> 00:39:26,300 line:-1
祝你们度过一个美好的WWDC

