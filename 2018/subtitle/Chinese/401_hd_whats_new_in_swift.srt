1
00:00:07,016 --> 00:00:15,500
[ 音乐 ]


2
00:00:25,516 --> 00:00:28,586
[ 掌声 ]


3
00:00:29,086 --> 00:00:31,526
>> 上午好 欢迎参加


4
00:00:31,526 --> 00:00:32,836
Swift 新功能介绍会议


5
00:00:33,546 --> 00:00:36,986
今年对于 Swift 和 Swift 社区来说


6
00:00:37,046 --> 00:00:37,596
发生了许多激动人心的事


7
00:00:37,966 --> 00:00:39,076
接下来的 40 分钟里


8
00:00:39,136 --> 00:00:40,606
Slava 和我将很荣幸


9
00:00:40,606 --> 00:00:42,526
向大家介绍一系列最新进展


10
00:00:43,696 --> 00:00:44,956
本会议大致


11
00:00:44,956 --> 00:00:45,346
分为两部分


12
00:00:46,126 --> 00:00:47,296
首先 我会介绍


13
00:00:47,296 --> 00:00:48,606
Swift 开源计划


14
00:00:48,646 --> 00:00:51,126
以及整个社区的新情况


15
00:00:51,606 --> 00:00:52,796
接下来 我们会探讨 Swift 4.2 


16
00:00:52,796 --> 00:00:54,666
Swift 4.2 将从今天起


17
00:00:54,666 --> 00:00:58,206
在 Xcode 10 测试版中提供预览


18
00:00:58,756 --> 00:01:00,786
2015 年年底开始


19
00:01:00,786 --> 00:01:02,946
Swift 作为开源项目登陆 GitHub


20
00:01:04,546 --> 00:01:06,476
用户社区十分活跃


21
00:01:06,476 --> 00:01:10,226
大家展开讨论 提交新功能


22
00:01:10,226 --> 00:01:11,556
审核后将新功能


23
00:01:11,556 --> 00:01:13,366
加入语言和标准库中


24
00:01:15,726 --> 00:01:17,476
在此期间 有 600 人


25
00:01:17,476 --> 00:01:18,776
向 GitHub 上的


26
00:01:18,776 --> 00:01:20,926
Swift 开源项目


27
00:01:20,926 --> 00:01:21,706
贡献了代码


28
00:01:22,576 --> 00:01:23,686
总共合并了


29
00:01:23,686 --> 00:01:26,046
18000 多项合并请求


30
00:01:27,316 --> 00:01:29,386
自从 Swift.org 上线以来


31
00:01:29,386 --> 00:01:31,326
Swift 便可以在


32
00:01:31,326 --> 00:01:33,966
Swift.org 上下载


33
00:01:33,966 --> 00:01:36,956
作为可下载工具链用于 Xcode


34
00:01:36,996 --> 00:01:38,216
以及多个版本的 Ubuntu


35
00:01:38,646 --> 00:01:43,536
其中既包括开发快照 也包括正式版本


36
00:01:45,016 --> 00:01:46,106
我们希望 Swift


37
00:01:46,106 --> 00:01:48,646
得到所有平台的支持


38
00:01:48,796 --> 00:01:50,396
方便大家使用


39
00:01:50,396 --> 00:01:53,086
重要工作之一


40
00:01:53,086 --> 00:01:54,766
就是拓展社区的


41
00:01:55,116 --> 00:01:56,586
测试支持


42
00:01:57,046 --> 00:01:58,476
许多开源项目用户


43
00:01:58,506 --> 00:02:01,506
也在努力让 Swift 支持


44
00:02:01,506 --> 00:02:02,106
其他平台


45
00:02:02,476 --> 00:02:04,166
我们也想要助一臂之力


46
00:02:05,396 --> 00:02:07,726
大约一个月前 我们


47
00:02:07,726 --> 00:02:08,545
扩展了公共持续集成系统


48
00:02:08,545 --> 00:02:10,006
以支持社区设立的


49
00:02:10,006 --> 00:02:12,066
持续集成节点


50
00:02:12,566 --> 00:02:13,576
如果你是社区的一员


51
00:02:13,576 --> 00:02:14,796
想要让 Swift


52
00:02:14,796 --> 00:02:16,386
得到其他平台的支持


53
00:02:16,436 --> 00:02:18,046
你现在可以


54
00:02:18,046 --> 00:02:19,266
直接接入你的硬件支持


55
00:02:19,266 --> 00:02:20,726
并开始测试


56
00:02:21,146 --> 00:02:22,776
这一前提可以帮助


57
00:02:22,776 --> 00:02:23,956
Swift 得到


58
00:02:23,956 --> 00:02:24,566
其他平台的支持


59
00:02:26,826 --> 00:02:28,816
我们还投入了很多


60
00:02:29,056 --> 00:02:31,056
建立了 Swift 开源项目的


61
00:02:31,106 --> 00:02:32,716
周边社区 在这里


62
00:02:33,056 --> 00:02:35,966
社区成员可以讨论语言中的所有变化


63
00:02:36,966 --> 00:02:38,936
大约六个月前 我们


64
00:02:38,936 --> 00:02:40,196
不再使用邮件列表


65
00:02:40,196 --> 00:02:42,556
因为信息量太大 而改用论坛


66
00:02:42,986 --> 00:02:44,746
这是当时社区的呼声


67
00:02:45,366 --> 00:02:48,776
起初有很多人想要以适合


68
00:02:48,776 --> 00:02:50,446
自己的方式真正


69
00:02:50,446 --> 00:02:54,126
参与项目 但发现困难重重


70
00:02:54,666 --> 00:02:55,586
有了论坛 你们就可以


71
00:02:55,586 --> 00:02:57,656
以适合自己的


72
00:02:57,656 --> 00:03:00,926
方式参与项目 论坛非常成功


73
00:03:00,926 --> 00:03:02,476
我们也想拓展


74
00:03:02,476 --> 00:03:04,586
它的用途 支持


75
00:03:04,586 --> 00:03:06,746
整个开源项目


76
00:03:07,476 --> 00:03:10,196
如果你在维护


77
00:03:10,196 --> 00:03:11,696
一个开源项目 例如


78
00:03:11,696 --> 00:03:13,526
很受欢迎的 Swift 库


79
00:03:13,526 --> 00:03:14,906
你就可以用论坛


80
00:03:15,186 --> 00:03:16,436
来讨论项目内容


81
00:03:16,436 --> 00:03:18,506
例如与用户沟通


82
00:03:18,506 --> 00:03:19,286
或讨论开发进度


83
00:03:20,986 --> 00:03:22,376
我们还想


84
00:03:22,376 --> 00:03:24,386
拓展 Swift.org 的作用


85
00:03:24,426 --> 00:03:26,016
让它能为整个社区所用


86
00:03:26,566 --> 00:03:28,936
本周 我们将把 Swift 编程语言手册


87
00:03:29,006 --> 00:03:30,486
迁移到 Swift.org


88
00:03:31,486 --> 00:03:33,706
地址为 docs.swift.org


89
00:03:33,706 --> 00:03:35,146
我们今后也会在这里


90
00:03:35,186 --> 00:03:37,716
公布更多文档


91
00:03:37,716 --> 00:03:39,026
供社区使用


92
00:03:39,606 --> 00:03:42,876
关于 Swift


93
00:03:42,876 --> 00:03:45,006
最激动人心的是


94
00:03:45,006 --> 00:03:46,776
人们很喜欢使用 Swift


95
00:03:46,776 --> 00:03:48,406
并且在很多场合


96
00:03:48,406 --> 00:03:49,376
讨论 Swift


97
00:03:49,606 --> 00:03:51,246
例如博客 聚会


98
00:03:51,696 --> 00:03:52,556
还有会议


99
00:03:53,126 --> 00:03:54,916
而 Apple 认为


100
00:03:54,916 --> 00:03:56,726
我们很有必要


101
00:03:56,996 --> 00:03:59,966
参与其中 因为讨论就是在这些地方发生


102
00:04:00,736 --> 00:04:02,696
过去一年间


103
00:04:02,696 --> 00:04:04,116
我们格外重视


104
00:04:04,116 --> 00:04:06,046
参与这些会议


105
00:04:06,046 --> 00:04:09,016
并且进行了技术展示


106
00:04:09,406 --> 00:04:10,826
包括我们在 Swift 上的


107
00:04:10,826 --> 00:04:13,026
工作 Swift 的工作原理


108
00:04:13,026 --> 00:04:14,386
还有你们参与


109
00:04:14,386 --> 00:04:15,376
开源项目的方式


110
00:04:16,375 --> 00:04:17,576
这些我们在今后


111
00:04:17,576 --> 00:04:19,616
也会致力于向前推进


112
00:04:21,466 --> 00:04:22,466
其中一项重要努力


113
00:04:22,466 --> 00:04:25,096
是周五在 WWDC


114
00:04:25,166 --> 00:04:27,266
场地附近举办的 try Swift


115
00:04:27,336 --> 00:04:29,226
圣何塞会议


116
00:04:29,866 --> 00:04:31,596
届时会有工作坊


117
00:04:31,836 --> 00:04:33,256
成员来自社区


118
00:04:33,256 --> 00:04:34,806
帮助有兴趣


119
00:04:34,806 --> 00:04:36,326
为 Swift 开源项目做贡献的


120
00:04:36,326 --> 00:04:38,196
与会人员


121
00:04:38,626 --> 00:04:39,916
届时 Apple 的


122
00:04:39,916 --> 00:04:41,836
编译器团队也会出席


123
00:04:42,046 --> 00:04:44,416
帮助大家进行交流


124
00:04:45,146 --> 00:04:48,446
以上就是关于社区的新进展


125
00:04:49,066 --> 00:04:50,166
我们来谈谈 Swift 4.2


126
00:04:50,166 --> 00:04:53,346
我认为 首先应当谈谈 这个版本的


127
00:04:53,346 --> 00:04:55,466
内容 以及在整体发展过程中的地位


128
00:04:58,276 --> 00:05:01,906
Swift 更新 特别是大版本更新 大约


129
00:05:01,906 --> 00:05:02,386
两年一次


130
00:05:02,996 --> 00:05:04,926
Swift 4.2 是继 Swift 4.1


131
00:05:04,956 --> 00:05:07,026
和 4.0 之后的大版本更新


132
00:05:08,246 --> 00:05:10,116
总体而言 这个版本


133
00:05:10,216 --> 00:05:11,736
有两大要点


134
00:05:12,316 --> 00:05:14,686
第一是进一步关注


135
00:05:14,686 --> 00:05:15,386
开发者效率


136
00:05:15,826 --> 00:05:16,946
你们可以在很多方面


137
00:05:16,946 --> 00:05:17,136
感受到


138
00:05:17,686 --> 00:05:19,186
项目构建速度更快


139
00:05:19,546 --> 00:05:20,826
但整体而言


140
00:05:20,826 --> 00:05:22,876
核心工具的体验


141
00:05:22,876 --> 00:05:24,676
也大幅改善


142
00:05:24,676 --> 00:05:26,106
例如调试器（Debugger）和编辑器（Editor）


143
00:05:26,186 --> 00:05:28,306
Swift 社区也


144
00:05:28,306 --> 00:05:30,216
也不断重视改进语言


145
00:05:30,616 --> 00:05:32,206
从而改善一般的


146
00:05:32,206 --> 00:05:33,796
开发者工作流


147
00:05:33,796 --> 00:05:34,386
去除鸡肋代码


148
00:05:34,926 --> 00:05:36,936
Apple 也一直在


149
00:05:36,936 --> 00:05:39,406
改进 SDK 从而


150
00:05:39,406 --> 00:05:41,646
让 Objective-C API 更好地


151
00:05:41,686 --> 00:05:44,226
映射到 Swift 中


152
00:05:44,386 --> 00:05:45,456
改善对语言


153
00:05:45,456 --> 00:05:47,006
和 API 的运用


154
00:05:48,266 --> 00:05:49,626
另一方面


155
00:05:49,626 --> 00:05:51,766
语言底层得到


156
00:05:51,846 --> 00:05:53,736
大幅改善 


157
00:05:53,736 --> 00:05:55,636
运行时间也有很多变化


158
00:05:55,636 --> 00:05:58,156
以实现二进制兼容性


159
00:05:58,156 --> 00:06:01,946
这一功能将在 Swift 5 中推出


160
00:06:01,946 --> 00:06:04,916
预计于 2019 年早些时候发布


161
00:06:05,926 --> 00:06:07,486
什么是二进制兼容性


162
00:06:08,406 --> 00:06:09,806
二进制兼容性指


163
00:06:09,806 --> 00:06:11,536
构建 Swift 代码时


164
00:06:11,576 --> 00:06:13,286
你可以使用 Swift 5 的编译器和层


165
00:06:13,286 --> 00:06:15,036
而在二进制层面


166
00:06:15,036 --> 00:06:16,626
代码可以与


167
00:06:16,696 --> 00:06:17,866
同一编译器或其他编译器层


168
00:06:17,866 --> 00:06:19,686
构建的代码


169
00:06:19,686 --> 00:06:20,016
相互操作


170
00:06:20,496 --> 00:06:22,266
这一点十分重要


171
00:06:22,266 --> 00:06:23,966
标志着这门语言


172
00:06:23,966 --> 00:06:24,506
走向成熟


173
00:06:25,146 --> 00:06:26,606
有了这一功能


174
00:06:26,606 --> 00:06:28,436
Apple 就可以将 Swift 运行时


175
00:06:28,586 --> 00:06:30,746
移入操作系统


176
00:06:30,746 --> 00:06:32,156
App 可以直接使用它


177
00:06:32,576 --> 00:06:33,496
而不再需要


178
00:06:33,496 --> 00:06:34,976
将其放入 App 包中


179
00:06:35,346 --> 00:06:37,446
这样可以缩减代码体积


180
00:06:37,446 --> 00:06:38,966
但同样重要的是


181
00:06:38,966 --> 00:06:40,146
启动时间和


182
00:06:40,146 --> 00:06:42,286
内存使用也能得到优化


183
00:06:42,286 --> 00:06:44,056
对社区而言帮助很大


184
00:06:44,056 --> 00:06:46,876
我们也会


185
00:06:46,876 --> 00:06:48,046
公布实现


186
00:06:48,286 --> 00:06:50,196
ABI 稳定性或二进制兼容性的


187
00:06:50,196 --> 00:06:50,906
相关进展


188
00:06:51,286 --> 00:06:52,826
可以访问 Swift.org 的


189
00:06:52,826 --> 00:06:54,366
ABI 稳定性总览页面


190
00:06:54,406 --> 00:06:55,806
跟踪进展


191
00:06:57,696 --> 00:07:00,186
今天的重点是 Swift 4.2


192
00:07:00,186 --> 00:07:01,596
这是实现 Swift 5 的


193
00:07:01,916 --> 00:07:02,696
重要一步


194
00:07:03,426 --> 00:07:05,446
我们来谈谈


195
00:07:05,446 --> 00:07:06,166
源兼容性


196
00:07:07,526 --> 00:07:10,106
像 Xcode 9 一样


197
00:07:10,166 --> 00:07:12,696
Xcode 10 只搭载一种 Swift 编译器


198
00:07:13,686 --> 00:07:15,086
如果你使用 Xcode 10


199
00:07:15,086 --> 00:07:16,256
你就在使用 Swift 4.2


200
00:07:17,226 --> 00:07:19,716
但就像 Xcode 9 一样


201
00:07:20,276 --> 00:07:21,746
这一编译器也支持


202
00:07:22,236 --> 00:07:23,896
多种语言


203
00:07:23,896 --> 00:07:24,366
兼容性模式


204
00:07:25,256 --> 00:07:27,906
在所有模式中 你都可以使用新 API


205
00:07:28,676 --> 00:07:30,476
可以使用全部新特性


206
00:07:30,856 --> 00:07:31,676
这足以带来


207
00:07:31,676 --> 00:07:33,476
影响代码源的变化


208
00:07:34,036 --> 00:07:37,286
前两个模式


209
00:07:37,286 --> 00:07:39,026
在 Xcode 9 中就已存在


210
00:07:39,426 --> 00:07:40,676
保留它们是为了提供


211
00:07:40,676 --> 00:07:41,776
开箱即用式的体验


212
00:07:41,776 --> 00:07:43,046
你可以直接构建 Swift 3 


213
00:07:43,046 --> 00:07:44,926
和 Swift 4 代码 不需修改


214
00:07:45,656 --> 00:07:47,206
Swift 4.2 模式与


215
00:07:47,206 --> 00:07:49,586
Swift 4 模式基本相同


216
00:07:49,586 --> 00:07:51,216
但包含刚才提到的


217
00:07:51,476 --> 00:07:52,266
SDK 改进


218
00:07:53,426 --> 00:07:54,346
就这样


219
00:07:54,976 --> 00:07:57,026
如果使用之前版本的 Xcode


220
00:07:57,086 --> 00:07:58,526
可以使用迁移帮助（Migrator Support）


221
00:07:58,526 --> 00:07:59,436
该功能位于编辑（Edit）菜单


222
00:07:59,436 --> 00:08:01,556
用来自动进行大部分修改


223
00:08:02,806 --> 00:08:03,876
我想先做一项


224
00:08:03,876 --> 00:08:06,166
关于 Swift 4.2 SDK 变化的


225
00:08:06,306 --> 00:08:07,146
免责声明


226
00:08:07,496 --> 00:08:09,436
后期的 Xcode 10 测试版可能


227
00:08:09,436 --> 00:08:11,036
会进一步改进 SDK


228
00:08:11,416 --> 00:08:13,206
这是为了能够


229
00:08:13,206 --> 00:08:14,916
整合大家


230
00:08:14,916 --> 00:08:16,976
关于 API 改进方向


231
00:08:16,976 --> 00:08:18,676
和改进如何反映在 Swift 中


232
00:08:18,676 --> 00:08:19,626
等反馈意见


233
00:08:20,236 --> 00:08:22,246
这意味着 如果你提前


234
00:08:22,416 --> 00:08:23,926
迁移到 Swift 4.2


235
00:08:23,926 --> 00:08:25,096
就要注意后续可能出现的变化


236
00:08:25,576 --> 00:08:27,446
你也可以先不迁移 之后再选择迁移


237
00:08:27,836 --> 00:08:28,816
完全取决于你


238
00:08:30,616 --> 00:08:32,176
Swift 4.2 中


239
00:08:32,176 --> 00:08:34,126
我们在加速让


240
00:08:34,166 --> 00:08:35,476
Swift 代码成型


241
00:08:35,876 --> 00:08:36,635
并面向未来


242
00:08:36,666 --> 00:08:40,716
这是语言成熟的重要阶段


243
00:08:41,506 --> 00:08:43,046
因此 我们认为


244
00:08:43,046 --> 00:08:44,596
大家都有必要


245
00:08:44,596 --> 00:08:47,486
从 Swift 3 迁移到


246
00:08:47,486 --> 00:08:48,086
Swift 4.2


247
00:08:48,086 --> 00:08:50,456
代码体积得到了重要改善


248
00:08:50,456 --> 00:08:51,396
语言整体也


249
00:08:51,396 --> 00:08:52,006
有所改进


250
00:08:52,836 --> 00:08:54,106
Xcode 10 将会是


251
00:08:54,156 --> 00:08:55,636
最后一个支持


252
00:08:55,636 --> 00:08:58,916
Swift 3 兼容模式的版本


253
00:08:59,586 --> 00:09:00,506
我们来谈谈工具


254
00:09:00,506 --> 00:09:01,446
方面的改进


255
00:09:02,536 --> 00:09:04,076
在 Platform State of the Union 会议中


256
00:09:04,076 --> 00:09:05,006
我们提到


257
00:09:05,106 --> 00:09:06,206
Xcode 9 中的


258
00:09:06,206 --> 00:09:07,416
Swift 项目构建


259
00:09:07,416 --> 00:09:09,366
也得到了显著改善


260
00:09:10,176 --> 00:09:12,176
这些结果是在一台配备


261
00:09:12,176 --> 00:09:13,516
四核 i7 处理器的 MacBook Pro 上得到的


262
00:09:13,516 --> 00:09:17,416
我们来仔细看看其中之一


263
00:09:18,896 --> 00:09:20,456
这个项目混合了


264
00:09:20,456 --> 00:09:21,776
Objective-C 和 Swift 代码


265
00:09:22,066 --> 00:09:24,666
它最初是一个 Objective-C 项目 随后


266
00:09:24,666 --> 00:09:25,526
开始采用 Swift


267
00:09:26,216 --> 00:09:27,786
这种情况很常见


268
00:09:28,756 --> 00:09:29,576
屏幕上的构建时间


269
00:09:29,576 --> 00:09:32,156
提升无法反映


270
00:09:32,156 --> 00:09:33,826
构建这段 Swift 代码


271
00:09:33,876 --> 00:09:35,536
到底比之前快了多少


272
00:09:36,356 --> 00:09:37,526
如果我们只关注


273
00:09:37,526 --> 00:09:39,826
Swift 构建速度的提升


274
00:09:39,826 --> 00:09:42,896
构建速度实际上快了三倍


275
00:09:43,386 --> 00:09:44,776
这就是为什么


276
00:09:45,046 --> 00:09:47,536
项目速度提升只有 1.6 倍


277
00:09:49,656 --> 00:09:51,096
可以看到


278
00:09:51,096 --> 00:09:52,216
构建速度提升


279
00:09:52,216 --> 00:09:53,706
整体取决于


280
00:09:53,706 --> 00:09:54,766
项目性质 使用多少


281
00:09:54,766 --> 00:09:56,816
Swift 代码 以及处理器的


282
00:09:56,816 --> 00:09:58,606
核数 但实际情况中


283
00:09:58,766 --> 00:10:01,476
许多项目都提速多达两倍


284
00:10:02,416 --> 00:10:04,366
提升主要由于


285
00:10:04,366 --> 00:10:06,326
Swift 目标


286
00:10:06,326 --> 00:10:08,286
具有跨文件


287
00:10:08,286 --> 00:10:10,896
可见性 这是 Swift 的优异特性之一


288
00:10:10,896 --> 00:10:11,946
不需要头文件


289
00:10:12,606 --> 00:10:13,976
过去编译器会执行


290
00:10:13,976 --> 00:10:15,586
许多冗余工作


291
00:10:15,586 --> 00:10:17,056
于是 我们就


292
00:10:17,056 --> 00:10:18,346
重新设计了编译


293
00:10:18,346 --> 00:10:20,136
流程 大幅减少了


294
00:10:20,136 --> 00:10:21,626
冗余 并且更好的利用处理器


295
00:10:21,626 --> 00:10:22,936
你机器上的核


296
00:10:23,096 --> 00:10:24,466
因此才会有这样的速度提升


297
00:10:25,206 --> 00:10:27,616
欲知更多细节 本周晚些时候


298
00:10:27,616 --> 00:10:28,886
会有两场讲座


299
00:10:28,886 --> 00:10:30,346
深入分析构建过程


300
00:10:30,396 --> 00:10:31,846
背后的工作原理 会提到


301
00:10:31,846 --> 00:10:32,906
更多细节 解释


302
00:10:32,946 --> 00:10:34,146
为何会有如此性能提升


303
00:10:36,356 --> 00:10:37,906
性能大幅提升是由于


304
00:10:38,606 --> 00:10:40,526
调试版本构建的改进


305
00:10:41,566 --> 00:10:44,776
我想重点讲这一功能


306
00:10:44,776 --> 00:10:47,846
为何出现在 Xcode 的构建选项中


307
00:10:48,746 --> 00:10:49,926
最近我们将


308
00:10:49,926 --> 00:10:51,386
编译模式（Compilation Mode）从


309
00:10:51,386 --> 00:10:52,506
优化水平（Optimization Level）中分离出来


310
00:10:53,206 --> 00:10:55,286
编译模式决定


311
00:10:55,286 --> 00:10:56,726
项目构建的方式


312
00:10:57,256 --> 00:10:58,566
如果是构建发行版本（Release）


313
00:10:58,566 --> 00:10:59,566
默认设置是全模组


314
00:10:59,566 --> 00:11:01,446
编译（Whole Module Compilation）


315
00:11:01,446 --> 00:11:02,906
目标中全部文件


316
00:11:02,906 --> 00:11:04,226
总是一起构建


317
00:11:04,386 --> 00:11:05,836
进行优化的


318
00:11:05,836 --> 00:11:07,326
可能性最高


319
00:11:07,326 --> 00:11:09,756
重点不是优化的数量 而是


320
00:11:09,756 --> 00:11:11,366
进行优化的可能性


321
00:11:12,166 --> 00:11:14,146
而如果是调试版本（Debug）


322
00:11:14,146 --> 00:11:15,176
则是增量（Incremental）构建


323
00:11:15,386 --> 00:11:16,486
并非所有文件


324
00:11:16,486 --> 00:11:18,626
都会构建 或者再构建


325
00:11:19,616 --> 00:11:20,506
这是性能表现


326
00:11:20,506 --> 00:11:22,536
和构建时间权衡的结果


327
00:11:23,516 --> 00:11:24,826
调试版本构建的


328
00:11:24,826 --> 00:11:25,746
优化水平默认仍然是


329
00:11:25,746 --> 00:11:26,966
无优化（No optimization）


330
00:11:26,966 --> 00:11:27,946
这样构建速度更快


331
00:11:27,946 --> 00:11:29,806
调试信息更全


332
00:11:29,806 --> 00:11:32,096
发行版本构建则着重优化速度


333
00:11:32,636 --> 00:11:35,306
我们稍后会再提到优化水平


334
00:11:38,436 --> 00:11:42,696
好的 分离编译模式和


335
00:11:42,696 --> 00:11:45,296
优化水平


336
00:11:45,356 --> 00:11:46,516
反映了一个非常有趣的权宜之计


337
00:11:46,516 --> 00:11:48,096
有人发现有时候


338
00:11:48,096 --> 00:11:50,176
如果


339
00:11:50,176 --> 00:11:51,126
结合全模组


340
00:11:51,126 --> 00:11:53,946
编译并且无优化时


341
00:11:53,946 --> 00:11:54,876
可以更快的


342
00:11:55,036 --> 00:11:56,026
构建调试版本


343
00:11:56,966 --> 00:11:58,786
这是因为


344
00:11:58,786 --> 00:12:02,246
这一组合显著减少了


345
00:12:02,246 --> 00:12:04,136
我们现在努力


346
00:12:04,136 --> 00:12:08,666
消除或大幅减少的冗余工作


347
00:12:10,036 --> 00:12:12,496
而这样组合的问题在于 它会减慢


348
00:12:12,496 --> 00:12:13,296
增量构建的速度


349
00:12:13,506 --> 00:12:14,716
只要你修改了目标中的


350
00:12:14,716 --> 00:12:16,806
一个文件 整个目标就要重新构建


351
00:12:17,496 --> 00:12:18,836
而 Xcode 10 改进了


352
00:12:18,836 --> 00:12:20,406
调试版本构建 我们认为


353
00:12:20,406 --> 00:12:21,936
你们不再需要


354
00:12:21,986 --> 00:12:24,416
使用这种权宜之计 我们也


355
00:12:24,416 --> 00:12:25,626
发现 默认的


356
00:12:25,626 --> 00:12:27,316
增量构建 表现


357
00:12:27,316 --> 00:12:29,356
同这种组合相当 甚至更好


358
00:12:29,356 --> 00:12:30,976
特别是现在 增量构建得到了正式支持


359
00:12:34,696 --> 00:12:35,826
我们来谈谈


360
00:12:35,826 --> 00:12:37,006
运行时得到的


361
00:12:37,006 --> 00:12:38,256
底层优化 这也是


362
00:12:38,256 --> 00:12:39,356
实现二进制兼容的


363
00:12:39,406 --> 00:12:40,586
环节之一


364
00:12:43,436 --> 00:12:45,126
Swift 使用自动内存


365
00:12:45,126 --> 00:12:47,726
管理 并且像 Objective-C 一样


366
00:12:47,726 --> 00:12:49,236
使用引用计数（reference counting）


367
00:12:49,386 --> 00:12:51,026
管理对象实例


368
00:12:51,916 --> 00:12:53,526
这张幻灯片上 用备注


369
00:12:53,526 --> 00:12:54,786
显示出编译器在哪里


370
00:12:54,786 --> 00:12:56,426
插入（insert） 保留（retain） 释放（release）


371
00:12:57,516 --> 00:13:02,116
这是 Swift 4.1 中的运行方式


372
00:13:02,316 --> 00:13:03,276
对象创建时


373
00:13:03,276 --> 00:13:04,716
会关联一个 +1


374
00:13:04,716 --> 00:13:05,896
引用计数


375
00:13:05,896 --> 00:13:08,176
惯例是 如果


376
00:13:08,176 --> 00:13:09,596
对象作为一个参数


377
00:13:09,596 --> 00:13:10,806
传递到另一个函数中


378
00:13:11,286 --> 00:13:12,406
那个函数的调用


379
00:13:12,466 --> 00:13:14,526
就应该释放对象


380
00:13:14,986 --> 00:13:16,626
这基本上就是让


381
00:13:16,626 --> 00:13:18,036
函数调用


382
00:13:18,036 --> 00:13:19,406
释放对象


383
00:13:20,376 --> 00:13:21,556
这样一来 就有


384
00:13:21,556 --> 00:13:22,926
机会改进性能 缩减


385
00:13:22,926 --> 00:13:25,156
一些对象的生命周期


386
00:13:25,156 --> 00:13:26,936
限制到最小范围


387
00:13:27,806 --> 00:13:29,976
但是 如果你的代码


388
00:13:30,056 --> 00:13:32,076
将对象传递到


389
00:13:32,076 --> 00:13:33,886
不同 API 的话


390
00:13:34,276 --> 00:13:35,236
可能会是这样


391
00:13:35,906 --> 00:13:37,096
由于存在这种


392
00:13:37,136 --> 00:13:38,856
调用惯例 就依然存在


393
00:13:38,856 --> 00:13:40,226
这种往复操作


394
00:13:40,226 --> 00:13:41,316
最初的引用计数


395
00:13:41,366 --> 00:13:42,466
在最后的调用中


396
00:13:42,516 --> 00:13:43,066
抵消


397
00:13:43,466 --> 00:13:44,666
但中间的步骤


398
00:13:44,666 --> 00:13:45,776
又应当有额外的


399
00:13:45,776 --> 00:13:48,246
保留和释放过程 因为


400
00:13:48,246 --> 00:13:49,956
这是惯例


401
00:13:50,876 --> 00:13:52,406
这样会造成浪费 因为


402
00:13:52,626 --> 00:13:53,886
对象在函数


403
00:13:53,886 --> 00:13:55,156
执行期间


404
00:13:55,156 --> 00:13:57,106
始终存活（alive）


405
00:13:57,816 --> 00:13:59,876
所以 Swift 4.2 中 我们改变了


406
00:13:59,876 --> 00:14:01,396
调用惯例 这样一来


407
00:14:01,396 --> 00:14:02,606
就不再由被调用的


408
00:14:02,606 --> 00:14:04,806
一方来释放对象


409
00:14:05,206 --> 00:14:06,526
这样一来 所有的保留


410
00:14:06,526 --> 00:14:10,366
和释放都不复存在


411
00:14:10,606 --> 00:14:12,066
可以显著减少


412
00:14:12,066 --> 00:14:13,016
保留和释放的数据量


413
00:14:13,936 --> 00:14:15,076
这有两重意义


414
00:14:15,546 --> 00:14:16,916
一 可以缩减代码体积


415
00:14:16,986 --> 00:14:19,026
因为这些调用不复存在


416
00:14:19,026 --> 00:14:20,336
二 可以改善运行时


417
00:14:21,776 --> 00:14:24,746
另一项重要的优化


418
00:14:24,746 --> 00:14:25,746
针对字符串


419
00:14:26,186 --> 00:14:28,506
Swift 4.2 的字符串为 16 个


420
00:14:28,506 --> 00:14:30,316
字节长 此前长度为 24


421
00:14:30,756 --> 00:14:31,976
这也是我们 


422
00:14:31,976 --> 00:14:33,266
权衡内存使用和


423
00:14:33,266 --> 00:14:33,936
性能的结果


424
00:14:35,346 --> 00:14:37,356
但同时 这一长度


425
00:14:37,356 --> 00:14:38,936
也足以对小字符串


426
00:14:38,936 --> 00:14:40,026
进行优化


427
00:14:40,706 --> 00:14:42,746
如果字符串不足 15


428
00:14:42,746 --> 00:14:45,226
字节长 实际的字符串


429
00:14:45,226 --> 00:14:46,636
就可以直接用


430
00:14:46,636 --> 00:14:48,246
字符串类型表示 而不用


431
00:14:48,246 --> 00:14:49,306
分配单独的


432
00:14:49,306 --> 00:14:50,806
缓冲区来表示字符串


433
00:14:51,436 --> 00:14:53,456
这显然既有利于内存


434
00:14:53,456 --> 00:14:55,066
也有利于性能


435
00:14:55,716 --> 00:14:56,546
这很像我们在


436
00:14:56,546 --> 00:14:57,866
NSString 中


437
00:14:57,866 --> 00:14:58,286
所做的优化


438
00:14:58,586 --> 00:15:00,516
但我们可以存储更大的字符串


439
00:15:03,396 --> 00:15:05,096
最后 在我把舞台交给


440
00:15:05,156 --> 00:15:06,126
Slava 之前 我们来谈谈


441
00:15:06,126 --> 00:15:07,086
语言本身的改进


442
00:15:07,086 --> 00:15:08,576
我想多谈一下


443
00:15:08,576 --> 00:15:10,636
缩减代码体积方面的努力


444
00:15:12,176 --> 00:15:13,146
我之前在谈到


445
00:15:13,146 --> 00:15:14,586
调用惯例改变的时候 提到了


446
00:15:14,586 --> 00:15:15,826
缩减代码体积


447
00:15:15,826 --> 00:15:17,546
我们还推出了一个新的


448
00:15:17,546 --> 00:15:19,936
优化水平选项 即优化


449
00:15:19,936 --> 00:15:20,256
体积（Optimize for Size [-Osize]）


450
00:15:21,466 --> 00:15:22,366
这一点很有用


451
00:15:22,366 --> 00:15:23,986
尤其是当 App 非常


452
00:15:24,056 --> 00:15:25,966
关心体积限制的时候 例如


453
00:15:25,966 --> 00:15:27,216
使用蜂窝网络进行


454
00:15:27,216 --> 00:15:28,056
下载的限制


455
00:15:29,146 --> 00:15:30,626
Swift 是一门强大的


456
00:15:30,696 --> 00:15:33,656
静态语言 以静态的方式


457
00:15:33,656 --> 00:15:34,846
理解程序行为


458
00:15:35,306 --> 00:15:36,306
因此 编译器有很多


459
00:15:36,306 --> 00:15:38,626
优化性能的


460
00:15:38,626 --> 00:15:40,016
机会 例如


461
00:15:40,016 --> 00:15:41,596
将函数调用内联（function call inlining）


462
00:15:41,596 --> 00:15:43,126
以及推测性去虚化（speculative 


463
00:15:43,126 --> 00:15:44,326
devirtualization） 这些方法牺牲代码体积


464
00:15:44,326 --> 00:15:45,846
以换取性能 然而


465
00:15:45,846 --> 00:15:46,936
有时候 这部分性能


466
00:15:47,226 --> 00:15:49,346
并非实际需要


467
00:15:49,956 --> 00:15:51,726
这是对 Swift 源编译套件


468
00:15:51,786 --> 00:15:54,466
实行 Osize 优化的结果 其中


469
00:15:54,466 --> 00:15:55,546
包括一系列


470
00:15:55,546 --> 00:15:58,266
GitHub 项目 如框架和 App


471
00:15:59,156 --> 00:16:00,176
可以看到 优化范围


472
00:16:00,176 --> 00:16:01,626
取决于使用了


473
00:16:01,626 --> 00:16:03,456
哪些语言特性 代码体积


474
00:16:03,456 --> 00:16:05,136
缩减了 10% 到 30%


475
00:16:05,826 --> 00:16:07,896
这里所说的代码体积指的是编译


476
00:16:07,896 --> 00:16:09,636
Swift 代码过程中


477
00:16:09,636 --> 00:16:11,046
构建的机器码


478
00:16:11,046 --> 00:16:12,676
不是 App 的整体体积


479
00:16:12,906 --> 00:16:14,206
App 整体体积取决于


480
00:16:14,206 --> 00:16:15,766
应用素材等多重因素


481
00:16:17,576 --> 00:16:19,416
现实中 我们发现


482
00:16:19,416 --> 00:16:21,836
运行时性能会下降大约 5%


483
00:16:21,836 --> 00:16:23,776
这需要牺牲一小部分性能


484
00:16:24,336 --> 00:16:25,766
对很多 App 而言 这一点


485
00:16:25,766 --> 00:16:26,496
无伤大雅


486
00:16:26,926 --> 00:16:28,716
所以确实取决于实际用例


487
00:16:29,216 --> 00:16:30,096
但如果你对此


488
00:16:30,096 --> 00:16:31,516
感兴趣 我们也鼓励你


489
00:16:31,516 --> 00:16:33,956
进行尝试


490
00:16:34,456 --> 00:16:35,476
现在 我要把舞台


491
00:16:35,476 --> 00:16:36,916
交给 Slava  他会谈到


492
00:16:36,916 --> 00:16:37,806
Swift 4.2 中


493
00:16:37,806 --> 00:16:39,826
语言方面的重大改进


494
00:16:40,516 --> 00:16:45,546
[ 掌声 ]


495
00:16:46,046 --> 00:16:47,856
>> 大家好 我是 Slava Pestov


496
00:16:47,896 --> 00:16:49,586
我负责 Swift 编译器


497
00:16:49,586 --> 00:16:50,886
今天 我想谈谈


498
00:16:50,886 --> 00:16:52,366
Swift 4.2 中的新语言特性


499
00:16:52,366 --> 00:16:54,216
可以如何帮助你


500
00:16:54,216 --> 00:16:55,956
写出更简单 更易维护的代码


501
00:16:57,556 --> 00:16:59,156
在讲到语言的


502
00:16:59,196 --> 00:17:00,766
新变化之前 先来


503
00:17:00,766 --> 00:17:02,576
回顾一下改进


504
00:17:02,576 --> 00:17:03,886
语言的过程


505
00:17:04,516 --> 00:17:06,506
如同 Ted 所说 Swift 是一个


506
00:17:06,506 --> 00:17:08,506
开源项目 也具备


507
00:17:08,506 --> 00:17:09,556
开放式设计


508
00:17:10,165 --> 00:17:11,435
也就是说 如果你有


509
00:17:11,435 --> 00:17:13,066
改进语言的想法


510
00:17:13,386 --> 00:17:14,636
你可以在论坛上


511
00:17:14,715 --> 00:17:16,826
提出来 如果想法


512
00:17:16,826 --> 00:17:18,536
得到足够认可 并列入


513
00:17:18,606 --> 00:17:20,465
提议案 你就可以


514
00:17:20,465 --> 00:17:21,606
把想法和


515
00:17:21,606 --> 00:17:23,435
实现提交给核心团队


516
00:17:23,506 --> 00:17:24,286
以供审核


517
00:17:24,626 --> 00:17:26,165
此时 会有正式审核期


518
00:17:26,165 --> 00:17:27,596
社区成员


519
00:17:27,626 --> 00:17:28,946
可以提供额外反馈


520
00:17:29,016 --> 00:17:30,726
之后 核心团队


521
00:17:30,726 --> 00:17:32,486
就会决定是否


522
00:17:32,486 --> 00:17:33,606
接受提议


523
00:17:34,796 --> 00:17:36,196
如果访问 Swift Evolution


524
00:17:36,196 --> 00:17:38,346
网站 就能看到一系列


525
00:17:38,346 --> 00:17:39,596
提议 这些提议均得到了


526
00:17:39,596 --> 00:17:42,406
接受 并将在 Swift 4.2 中实现


527
00:17:43,396 --> 00:17:44,976
列表中包含的提议


528
00:17:44,976 --> 00:17:46,646
数量很多


529
00:17:46,646 --> 00:17:47,946
我今天无法涉及


530
00:17:47,946 --> 00:17:48,316
所有提议


531
00:17:48,776 --> 00:17:50,046
但有一点我想要


532
00:17:50,046 --> 00:17:51,776
强调 那就是


533
00:17:51,776 --> 00:17:53,086
有很多提议是


534
00:17:53,086 --> 00:17:55,476
由社区设计并


535
00:17:55,476 --> 00:17:56,136
实现的


536
00:17:56,566 --> 00:17:58,066
这表明 这些


537
00:17:58,066 --> 00:17:59,626
提议针对


538
00:17:59,666 --> 00:18:01,406
你们遇到的


539
00:18:01,406 --> 00:18:03,276
各类常见问题


540
00:18:03,276 --> 00:18:05,756
也是你们想出了


541
00:18:05,756 --> 00:18:07,636
解决方案


542
00:18:07,636 --> 00:18:09,246
并向 Swift 贡献了


543
00:18:09,286 --> 00:18:11,766
解决方案 使人人收益


544
00:18:12,166 --> 00:18:12,516
谢谢大家


545
00:18:14,516 --> 00:18:19,016
[ 掌声 ]


546
00:18:19,516 --> 00:18:20,936
第一项改进


547
00:18:21,126 --> 00:18:22,226
我们来看看


548
00:18:22,226 --> 00:18:23,636
如何在使用枚举时


549
00:18:23,636 --> 00:18:25,486
去除鸡肋代码


550
00:18:26,566 --> 00:18:28,196
比如说 我要获得一个枚举


551
00:18:28,616 --> 00:18:30,486
我想要打印出


552
00:18:30,486 --> 00:18:32,846
这个枚举包含的所有值


553
00:18:33,376 --> 00:18:36,286
在 Swift 4 中 我需要定义


554
00:18:36,286 --> 00:18:38,636
一个属性 例如包括所有


555
00:18:39,026 --> 00:18:40,386
可能样例的列表


556
00:18:41,056 --> 00:18:44,656
如果我要添加新的样例


557
00:18:44,656 --> 00:18:46,016
我要记得更新


558
00:18:46,086 --> 00:18:48,376
属性 否则就会呈现


559
00:18:48,376 --> 00:18:49,706
行为或运行时错误


560
00:18:50,976 --> 00:18:53,536
这种做法并不好


561
00:18:53,536 --> 00:18:54,936
因为你在向编译器


562
00:18:54,936 --> 00:18:56,406
重复自己的工作


563
00:18:56,986 --> 00:18:59,296
所以在 Swift 4.2 中 我们添加了


564
00:18:59,296 --> 00:19:01,966
新的 CaseIterable 协议


565
00:19:01,966 --> 00:19:03,346
如果你表示遵从（conformance）


566
00:19:03,406 --> 00:19:04,726
这一协议 编译器就会


567
00:19:04,726 --> 00:19:06,676
将包含所有样例的属性


568
00:19:06,676 --> 00:19:07,096
同步


569
00:19:07,096 --> 00:19:08,976
简短而有效


570
00:19:09,516 --> 00:19:12,546
[ 鼓掌 ]


571
00:19:13,046 --> 00:19:15,216
下一项改进 我们


572
00:19:15,216 --> 00:19:16,476
要去除另一个


573
00:19:16,476 --> 00:19:17,806
鸡肋代码的根源


574
00:19:18,016 --> 00:19:19,216
这种情况下


575
00:19:19,306 --> 00:19:20,436
你的代码往往


576
00:19:20,626 --> 00:19:21,786
不够泛型（generic）


577
00:19:22,726 --> 00:19:24,916
Swift 4 中 我们为序列


578
00:19:24,956 --> 00:19:26,596
引入了 contains() 方法


579
00:19:27,006 --> 00:19:28,506
这就要求


580
00:19:28,506 --> 00:19:30,106
序列的元素类型


581
00:19:30,106 --> 00:19:32,186
为 Equatable


582
00:19:32,186 --> 00:19:33,666
才能找出所需的元素


583
00:19:34,636 --> 00:19:36,736
当然 我可以对


584
00:19:36,736 --> 00:19:37,966
字符串组成的数组调用


585
00:19:38,236 --> 00:19:39,616
因为字符串是 Equatable 类型


586
00:19:39,616 --> 00:19:41,516
但如果对数组组成的数组


587
00:19:41,516 --> 00:19:42,346
调用呢


588
00:19:43,226 --> 00:19:45,736
如果子数组包含整型（integer）


589
00:19:45,736 --> 00:19:47,756
类型就不为 Equatable


590
00:19:48,126 --> 00:19:49,486
也就是说


591
00:19:49,486 --> 00:19:50,596
编译时间错误


592
00:19:51,796 --> 00:19:53,796
你可能会问 为什么


593
00:19:53,796 --> 00:19:55,106
标准库不让


594
00:19:55,196 --> 00:19:56,796
所有数列为 Equatable 呢


595
00:19:57,136 --> 00:19:58,316
但那样不合逻辑


596
00:19:58,316 --> 00:20:00,666
因为如果数列的


597
00:20:00,666 --> 00:20:01,836
元素类型不为


598
00:20:01,836 --> 00:20:03,366
Equatable 例如函数


599
00:20:03,396 --> 00:20:06,566
你也不能让数列为 Equatable


600
00:20:07,956 --> 00:20:09,286
但显然 如果数列的


601
00:20:09,326 --> 00:20:10,846
元素类型为 Equatable


602
00:20:10,846 --> 00:20:12,726
我就可以为数组


603
00:20:12,726 --> 00:20:14,516
定义等值运算


604
00:20:14,516 --> 00:20:16,376
以比较数组中的元素对


605
00:20:17,116 --> 00:20:18,516
而这就是条件一致性


606
00:20:18,516 --> 00:20:20,116
（conditional conformance）对标准库


607
00:20:20,116 --> 00:20:21,286
发挥的作用


608
00:20:21,376 --> 00:20:23,076
现在 如果数组元素


609
00:20:23,076 --> 00:20:24,916
类型为 Equatable


610
00:20:24,916 --> 00:20:26,246
那么数组样例也可以


611
00:20:26,246 --> 00:20:27,056
实现 Equatable


612
00:20:27,416 --> 00:20:29,776
Swift 4.2 中 之前展示的


613
00:20:29,776 --> 00:20:31,366
例子可以运行


614
00:20:31,856 --> 00:20:34,776
除了数组为 Equatable 外


615
00:20:34,776 --> 00:20:37,636
标准库还定义了其他一些


616
00:20:37,636 --> 00:20:38,896
条件一致性


617
00:20:39,436 --> 00:20:41,026
例如 选项（options）


618
00:20:41,026 --> 00:20:42,726
和字典（dictionaries）也是 Equatable


619
00:20:42,726 --> 00:20:44,126
前提是它们的


620
00:20:44,126 --> 00:20:46,486
元素类型为 Equatable


621
00:20:46,536 --> 00:20:49,576
Hashable Encodable 和


622
00:20:49,576 --> 00:20:51,306
Decodable 同理


623
00:20:52,516 --> 00:20:57,576
[ 掌声 ]


624
00:20:58,076 --> 00:20:59,746
这样一来 你就可以


625
00:20:59,746 --> 00:21:01,156
用全新的方法


626
00:21:01,156 --> 00:21:02,256
构建集合（collections）


627
00:21:02,986 --> 00:21:05,886
这里 有一些由


628
00:21:05,886 --> 00:21:08,166
整数构成的数组


629
00:21:09,176 --> 00:21:10,366
一切运行正常


630
00:21:10,916 --> 00:21:13,416
欲知更多细节


631
00:21:13,416 --> 00:21:14,656
本周晚些时候有一场会议


632
00:21:14,656 --> 00:21:17,026
可以进一步了解


633
00:21:17,026 --> 00:21:18,476
条件一致性


634
00:21:18,476 --> 00:21:19,946
以及 Swift 4.2 中


635
00:21:19,946 --> 00:21:21,256
今天无法提及的


636
00:21:21,256 --> 00:21:22,536
泛型改进


637
00:21:23,896 --> 00:21:25,756
如果要定义自己的


638
00:21:25,756 --> 00:21:26,776
Equatable 和 Hashable


639
00:21:26,776 --> 00:21:27,606
成员（conformances）呢


640
00:21:28,596 --> 00:21:30,376
Swift 中的通用做法是


641
00:21:30,446 --> 00:21:32,446
用包含许多存储属性（stored properties）的


642
00:21:32,446 --> 00:21:34,516
结构体来实现


643
00:21:34,516 --> 00:21:36,006
而这些存储属性


644
00:21:36,006 --> 00:21:37,096
应为 Equatable


645
00:21:37,436 --> 00:21:38,546
接下来 要想让


646
00:21:38,546 --> 00:21:40,656
结构体 Equatable


647
00:21:40,656 --> 00:21:42,156
只需比较两个值的


648
00:21:42,156 --> 00:21:43,056
属性即可


649
00:21:43,516 --> 00:21:45,616
此前在 Swift 4 中 你需要


650
00:21:45,616 --> 00:21:46,726
亲手写出这些内容


651
00:21:47,166 --> 00:21:48,486
这就是鸡肋代码


652
00:21:48,706 --> 00:21:50,276
如果添加一个新的


653
00:21:50,276 --> 00:21:51,836
存储属性 就要记得


654
00:21:51,836 --> 00:21:53,286
更新 Equatable


655
00:21:53,286 --> 00:21:54,926
实现 很容易在


656
00:21:54,926 --> 00:21:57,166
拷贝粘贴等过程中出错


657
00:21:57,796 --> 00:21:59,676
Swift 4.1 中 我们可以


658
00:21:59,676 --> 00:22:01,536
合成 equality（相等性）


659
00:22:01,536 --> 00:22:02,926
的使用


660
00:22:03,386 --> 00:22:04,966
如果忘记了实现部分


661
00:22:05,186 --> 00:22:06,326
编译器会为你


662
00:22:06,326 --> 00:22:08,046
补上 前提是


663
00:22:08,046 --> 00:22:10,036
存储属性本身为 Equatable


664
00:22:11,076 --> 00:22:12,626
这也适用于 Hashable


665
00:22:13,996 --> 00:22:15,726
那么如果是泛型呢


666
00:22:16,266 --> 00:22:17,986
这个数据类型中


667
00:22:17,986 --> 00:22:19,556
值可能是


668
00:22:19,556 --> 00:22:22,316
左类型的实例 或者是右类型的实例


669
00:22:22,936 --> 00:22:26,216
我想让左右类型都为


670
00:22:26,216 --> 00:22:28,876
Equatable  因为我想令这两个类型


671
00:22:28,876 --> 00:22:31,046
为函数 错误（errors）


672
00:22:31,046 --> 00:22:32,446
或其他不为 Equatable 的类型


673
00:22:32,916 --> 00:22:34,326
但显然 我可以定义


674
00:22:34,326 --> 00:22:36,226
条件一致性 这样


675
00:22:36,226 --> 00:22:37,506
如果左右类型都为


676
00:22:37,506 --> 00:22:39,726
Equatable  二者之一即为 Equatable


677
00:22:40,116 --> 00:22:41,696
但还可以进一步改进


678
00:22:42,166 --> 00:22:43,666
注意此处的可等性


679
00:22:43,666 --> 00:22:45,576
实现 只有一种


680
00:22:45,576 --> 00:22:47,616
显然正确的实现方式


681
00:22:47,946 --> 00:22:49,186
需要确保两个值


682
00:22:49,186 --> 00:22:51,416
包含相同的样例


683
00:22:51,416 --> 00:22:53,286
如果确实如此 则需要检查载体（payloads）


684
00:22:53,286 --> 00:22:53,996
以确保可等性


685
00:22:54,776 --> 00:22:56,396
你可能会想 


686
00:22:56,396 --> 00:22:57,426
编译器应该能够


687
00:22:57,426 --> 00:22:58,926
替你进行合成


688
00:22:58,926 --> 00:23:00,256
Swift 4.2 中确实可以


689
00:23:01,176 --> 00:23:02,666
该功能也可用于


690
00:23:02,666 --> 00:23:03,186
Hashable


691
00:23:04,676 --> 00:23:07,166
比方说 现在就可以创建


692
00:23:07,356 --> 00:23:09,786
元素为整型或字符串的集合了


693
00:23:11,546 --> 00:23:11,656
好的


694
00:23:12,516 --> 00:23:15,676
[ 掌声 ]


695
00:23:16,176 --> 00:23:18,146
有时 你确实需要


696
00:23:18,146 --> 00:23:19,526
手动实现


697
00:23:19,586 --> 00:23:22,766
可等性和哈希值（Hashing）


698
00:23:23,436 --> 00:23:25,456
我们来看一个例子


699
00:23:26,616 --> 00:23:27,866
假如说 有一个数据类型


700
00:23:28,006 --> 00:23:30,796
表示一座城市 其中


701
00:23:30,796 --> 00:23:32,166
包括城市名 包括所在的


702
00:23:32,166 --> 00:23:34,296
州 还包括城市的人口


703
00:23:34,706 --> 00:23:35,556
在这个例子中


704
00:23:35,556 --> 00:23:38,006
我只需要


705
00:23:38,006 --> 00:23:39,536
比较城市名和州


706
00:23:39,536 --> 00:23:41,456
以确保可等性


707
00:23:41,456 --> 00:23:42,826
如果数值相等 就不需要


708
00:23:42,826 --> 00:23:43,926
对比人口了


709
00:23:44,616 --> 00:23:46,446
如果我让编译器


710
00:23:46,446 --> 00:23:48,056
合成可等性的


711
00:23:48,056 --> 00:23:49,706
实现 就会产生


712
00:23:49,706 --> 00:23:52,006
冗余 因为它还比较了


713
00:23:52,006 --> 00:23:53,046
人口信息


714
00:23:53,776 --> 00:23:55,436
我当然可以把这部分


715
00:23:55,436 --> 00:23:56,976
写成代码 或许此时


716
00:23:56,976 --> 00:23:57,636
这样还可以


717
00:23:58,556 --> 00:23:59,796
但 Hashable 呢


718
00:24:01,286 --> 00:24:02,796
如果我想计算


719
00:24:02,836 --> 00:24:04,566
城市对象的哈希值


720
00:24:05,066 --> 00:24:06,986
我就要算出


721
00:24:07,016 --> 00:24:08,336
城市名的哈希值和


722
00:24:08,336 --> 00:24:09,636
州的哈希值


723
00:24:09,636 --> 00:24:11,086
再想办法结合二者


724
00:24:11,646 --> 00:24:12,686
但该怎么做呢


725
00:24:13,296 --> 00:24:15,286
可以用异或运算


726
00:24:15,286 --> 00:24:18,246
也可以用


727
00:24:18,246 --> 00:24:20,196
网上随便找的


728
00:24:20,196 --> 00:24:21,866
或者自己编的


729
00:24:21,866 --> 00:24:22,656
运算方式


730
00:24:23,246 --> 00:24:24,976
但这两种办法


731
00:24:24,976 --> 00:24:27,306
都不够好 好像


732
00:24:27,306 --> 00:24:28,896
结合哈希值的函数


733
00:24:29,176 --> 00:24:30,556
是一种魔法似的


734
00:24:30,876 --> 00:24:32,336
而出错的成本


735
00:24:32,336 --> 00:24:34,376
也相当高 因为


736
00:24:34,376 --> 00:24:35,846
字典和集合


737
00:24:35,846 --> 00:24:37,526
要想具备良好性能


738
00:24:37,526 --> 00:24:39,716
确实需要依赖


739
00:24:39,716 --> 00:24:41,416
高质量的哈希函数


740
00:24:42,146 --> 00:24:44,266
同时也有安全考量


741
00:24:44,636 --> 00:24:46,966
如果攻击者


742
00:24:46,966 --> 00:24:49,336
打造的输入能生成


743
00:24:49,336 --> 00:24:51,086
相同的哈希值


744
00:24:51,086 --> 00:24:52,336
并通过互联网发给你的 App 


745
00:24:52,396 --> 00:24:54,286
就可能降低 App


746
00:24:54,286 --> 00:24:55,466
运行速度 以致


747
00:24:55,466 --> 00:24:56,906
无法使用 即发起


748
00:24:56,906 --> 00:24:58,056
阻断服务攻击（denial-of-service attack）


749
00:24:58,536 --> 00:25:01,066
所以 在 Swift 4.2 中 我们添加了


750
00:25:01,066 --> 00:25:02,476
更好的 API 实现该功能


751
00:25:03,316 --> 00:25:05,396
可以回想一下 Swift 4


752
00:25:05,396 --> 00:25:06,896
和 4.1 中的 Hashable 协议


753
00:25:07,486 --> 00:25:09,076
其中一个 hashValue


754
00:25:09,076 --> 00:25:10,446
要求（requirement） 返回一个


755
00:25:10,446 --> 00:25:11,696
整型值


756
00:25:12,446 --> 00:25:14,676
Swift 4.2 中 我们重新设计了


757
00:25:14,676 --> 00:25:16,936
Hashable 协议 现在


758
00:25:17,296 --> 00:25:19,746
有了新的 Hash into 要求


759
00:25:20,126 --> 00:25:21,346
Hash into 不产生


760
00:25:21,346 --> 00:25:23,466
单一哈希值


761
00:25:23,466 --> 00:25:26,146
而是选用一个 Hasher 实例


762
00:25:26,146 --> 00:25:27,636
之后可以将


763
00:25:27,636 --> 00:25:29,616
多个值传入 Hasher


764
00:25:29,616 --> 00:25:31,376
Hasher 会结合传入值 生成一个哈希值


765
00:25:32,306 --> 00:25:34,096
回到城市数据类型的


766
00:25:34,096 --> 00:25:36,076
例子 我们只需要 


767
00:25:36,076 --> 00:25:38,226
对我们给出的 Hasher 对象实例中


768
00:25:38,226 --> 00:25:42,576
传入的城市名和州


769
00:25:42,576 --> 00:25:44,596
进行递归的


770
00:25:44,596 --> 00:25:45,316
Hash into 调用


771
00:25:46,486 --> 00:25:49,786
Hasher 中的


772
00:25:49,786 --> 00:25:51,726
哈希合并算法


773
00:25:51,726 --> 00:25:53,526
可以有效平衡


774
00:25:53,526 --> 00:25:55,146
哈希值质量和性能


775
00:25:55,476 --> 00:25:56,556
还可以作为额外保护


776
00:25:56,606 --> 00:25:57,816
抵御阻断服务攻击


777
00:25:57,816 --> 00:25:59,686
为此 它使用了


778
00:25:59,686 --> 00:26:01,616
App 启动时生成的


779
00:26:01,616 --> 00:26:03,346
随机预处理种子


780
00:26:05,136 --> 00:26:07,236
我们认为 你可以


781
00:26:07,316 --> 00:26:09,136
很轻松地迁移代码


782
00:26:09,136 --> 00:26:10,746
来使用新的 Hashable


783
00:26:10,746 --> 00:26:12,756
协议 我们也鼓励你这样做


784
00:26:13,206 --> 00:26:15,016
有一条警告


785
00:26:15,016 --> 00:26:16,936
你可能原本


786
00:26:16,936 --> 00:26:18,746
希望哈希值


787
00:26:18,746 --> 00:26:20,426
能够在多次运行 App 中


788
00:26:20,426 --> 00:26:22,296
保持不变 或者


789
00:26:22,296 --> 00:26:23,566
在遍历字典


790
00:26:23,566 --> 00:26:25,416
或集合的时候


791
00:26:25,416 --> 00:26:26,976
希望以同一顺序获取元素


792
00:26:27,256 --> 00:26:28,726
这些已经不再可行


793
00:26:28,726 --> 00:26:29,656
因为使用了随机


794
00:26:29,656 --> 00:26:30,676
预处理种子


795
00:26:30,746 --> 00:26:32,116
你可能需要调整代码


796
00:26:32,916 --> 00:26:35,096
为了简化工作 我们


797
00:26:35,096 --> 00:26:37,336
添加了一项构建设置 即 


798
00:26:37,336 --> 00:26:38,426
SWIFT_DETERMINISTIC_HASHING


799
00:26:38,426 --> 00:26:39,996
环境变量 你可以


800
00:26:39,996 --> 00:26:41,666
在方案编辑器（Scheme Editor）中激活


801
00:26:42,246 --> 00:26:43,736
以暂时停用


802
00:26:43,786 --> 00:26:45,256
随机预处理种子


803
00:26:45,796 --> 00:26:49,466
接下来 来谈谈


804
00:26:49,606 --> 00:26:51,096
随机数生成


805
00:26:52,396 --> 00:26:53,656
现在 你们在 Swift 中


806
00:26:53,656 --> 00:26:54,706
如何生成随机数


807
00:26:55,356 --> 00:26:58,376
你需要导入 C 语言的 API


808
00:26:58,446 --> 00:26:59,876
这确实不够理想


809
00:26:59,876 --> 00:27:01,446
因为 API 


810
00:27:01,446 --> 00:27:03,866
因平台而异


811
00:27:03,866 --> 00:27:04,876
名字不同


812
00:27:04,876 --> 00:27:06,586
行为不同


813
00:27:06,666 --> 00:27:08,156
需要检查构建配置


814
00:27:08,566 --> 00:27:10,486
此外 这些 API 位于底层


815
00:27:10,486 --> 00:27:12,806
还会用到一些


816
00:27:12,806 --> 00:27:14,566
不太直观的常见运算


817
00:27:15,316 --> 00:27:16,886
例如 如果我想得到


818
00:27:16,886 --> 00:27:19,016
1 到 6 之间的随机数


819
00:27:19,406 --> 00:27:21,446
我需要调用


820
00:27:21,446 --> 00:27:23,716
Darwin 中的 arc4random 函数


821
00:27:23,826 --> 00:27:25,366
再除以 6


822
00:27:25,366 --> 00:27:26,556
来求余


823
00:27:26,836 --> 00:27:27,916
但这样的结果


824
00:27:27,916 --> 00:27:29,476
往往并非均匀


825
00:27:29,476 --> 00:27:31,566
分布在 1 到 6 之间


826
00:27:32,346 --> 00:27:35,386
Swift 4.2 中 我们添加了


827
00:27:35,386 --> 00:27:37,236
一组新的 API


828
00:27:37,236 --> 00:27:38,086
以简化操作


829
00:27:39,146 --> 00:27:41,186
首先 我们为所有数字类型


830
00:27:41,186 --> 00:27:43,296
定义了 random 方法


831
00:27:43,486 --> 00:27:45,576
可以获取一个范围 返回


832
00:27:45,576 --> 00:27:47,986
平均分布在范围中的数字


833
00:27:48,196 --> 00:27:49,816
这种方法使用了正确算法


834
00:27:49,816 --> 00:27:51,316
也适用于浮点型（floats）


835
00:27:52,516 --> 00:27:58,596
[ 掌声 ]


836
00:27:59,096 --> 00:28:00,676
对于顶层代码 我们


837
00:28:00,676 --> 00:28:03,076
为集合协议添加了


838
00:28:03,076 --> 00:28:04,196
randomElement 方法


839
00:28:04,786 --> 00:28:07,026
可以像 min 和 max 方法一样


840
00:28:07,026 --> 00:28:08,636
返回选项


841
00:28:08,636 --> 00:28:10,376
如果传入空集合


842
00:28:10,526 --> 00:28:11,506
会返回空


843
00:28:12,596 --> 00:28:14,326
最后 我们为集合添加了


844
00:28:14,326 --> 00:28:17,116
shuffle 方法


845
00:28:17,116 --> 00:28:18,926
可以生成一个


846
00:28:18,926 --> 00:28:21,616
该集合元素的随机排列组合的数组


847
00:28:22,146 --> 00:28:25,216
我们认为 默认的随机数


848
00:28:25,216 --> 00:28:26,636
生成器（Random Number Generator）


849
00:28:26,636 --> 00:28:27,996
适合大多数 App


850
00:28:28,296 --> 00:28:29,883
但你也可以采用自己的算法


851
00:28:30,676 --> 00:28:31,836
现在 有了新的


852
00:28:31,836 --> 00:28:34,206
RandomNumberGenerator 协议


853
00:28:34,206 --> 00:28:35,606
一旦你创建一个符合


854
00:28:35,606 --> 00:28:37,826
该协议的类型 就可以将它


855
00:28:37,826 --> 00:28:39,326
传递给我提到的 API


856
00:28:39,326 --> 00:28:40,846
API 拥有一个使用 using 参数的


857
00:28:40,846 --> 00:28:43,416
额外重载（additional overload）


858
00:28:43,576 --> 00:28:44,706
可以接收 RandomNumberGenerator


859
00:28:44,706 --> 00:28:45,236
作为输入


860
00:28:46,746 --> 00:28:49,456
好的 之前我们看到了


861
00:28:49,456 --> 00:28:51,446
构建配置检查


862
00:28:51,526 --> 00:28:54,346
我们再多了解一些


863
00:28:54,566 --> 00:28:56,806
这是 Swift 中常见的情况


864
00:28:57,026 --> 00:28:58,356
有一小段代码


865
00:28:58,356 --> 00:29:00,796
在 iOS 和 macOS 间共用


866
00:29:00,796 --> 00:29:03,836
在 iOS 上 你应该


867
00:29:03,836 --> 00:29:05,206
使用 UIKit


868
00:29:05,586 --> 00:29:06,776
在 macOS 上 你应该


869
00:29:06,776 --> 00:29:08,156
使用 AppKit


870
00:29:08,896 --> 00:29:10,466
现在要做到这一点


871
00:29:10,466 --> 00:29:11,816
你要写一段 #if 代码


872
00:29:12,236 --> 00:29:14,186
来进行编译时间检查


873
00:29:14,186 --> 00:29:15,386
之后需要列出


874
00:29:15,386 --> 00:29:17,736
支持 UIKit 的操作系统


875
00:29:18,566 --> 00:29:20,046
但你真正关心的


876
00:29:20,046 --> 00:29:21,836
不是你在运行


877
00:29:21,836 --> 00:29:23,016
什么操作系统


878
00:29:23,016 --> 00:29:25,096
而是导入 UIKit


879
00:29:25,626 --> 00:29:27,956
Swift 4.2 中 我们添加了


880
00:29:27,956 --> 00:29:30,086
canImport() 构建配置指令


881
00:29:30,086 --> 00:29:32,486
（Build Configuration Directive）


882
00:29:32,486 --> 00:29:33,476
帮助你表达本意


883
00:29:34,171 --> 00:29:36,171
[ 掌声 ]


884
00:29:36,326 --> 00:29:38,026
而利用 Swift 4.2 的新特性


885
00:29:38,026 --> 00:29:39,686
我还可以进一步


886
00:29:39,686 --> 00:29:40,766
完善代码


887
00:29:41,246 --> 00:29:43,326
比方说 我还要


888
00:29:43,326 --> 00:29:44,966
专门检查 AppKit


889
00:29:45,306 --> 00:29:47,036
如果 UIKit 和


890
00:29:47,036 --> 00:29:48,866
AppKit 都不可用


891
00:29:48,866 --> 00:29:50,576
例如我在 Linux 上构建


892
00:29:50,576 --> 00:29:52,356
我就可以使用新的 #error


893
00:29:52,546 --> 00:29:53,916
构建指令来生成


894
00:29:53,916 --> 00:29:55,796
编译时间错误信息


895
00:29:57,206 --> 00:29:59,376
好的 还有一种类似的


896
00:29:59,376 --> 00:30:00,416
鸡肋代码


897
00:30:01,616 --> 00:30:03,126
如果我想在


898
00:30:03,126 --> 00:30:05,066
模拟器环境中


899
00:30:05,066 --> 00:30:06,476
编译代码


900
00:30:06,776 --> 00:30:09,266
在 Swift 4 中 我需要


901
00:30:09,266 --> 00:30:11,546
把这一段东西


902
00:30:11,546 --> 00:30:12,686
拷贝 粘贴到所有我想要进行检查的地方 才能


903
00:30:12,686 --> 00:30:13,176
进行检测


904
00:30:14,056 --> 00:30:16,456
Swift 4.2 中 你可以使用新的


905
00:30:16,456 --> 00:30:18,596
hasTargetEnvironment() 环境判断


906
00:30:18,906 --> 00:30:21,216
来更好地表达本意


907
00:30:21,216 --> 00:30:23,006
还可以直接询问


908
00:30:23,006 --> 00:30:25,026
编译器 我是不是在


909
00:30:25,026 --> 00:30:26,106
为模拟器编译


910
00:30:26,876 --> 00:30:28,826
说到这里


911
00:30:28,826 --> 00:30:30,566
我们再把 FIXME 换成


912
00:30:30,656 --> 00:30:32,036
#warning 构建指令


913
00:30:32,076 --> 00:30:33,986
来生成信息


914
00:30:34,046 --> 00:30:35,856
或运行时间 提醒我别忘了


915
00:30:35,856 --> 00:30:38,126
修复 FIXME


916
00:30:38,126 --> 00:30:40,916
好的 这差不多就是


917
00:30:40,916 --> 00:30:42,306
我今天要讲的


918
00:30:42,306 --> 00:30:43,516
全部特性


919
00:30:43,516 --> 00:30:44,936
但我还有几项要提一下


920
00:30:46,026 --> 00:30:47,646
我们来解析一下


921
00:30:47,646 --> 00:30:48,586
隐式解析选项（Implicitly Unwrapped 


922
00:30:48,806 --> 00:30:49,646
Optionals） 这个梗没效果啊


923
00:30:50,296 --> 00:30:52,986
好吧 隐式解析选项


924
00:30:52,986 --> 00:30:54,326
可能会有点


925
00:30:54,326 --> 00:30:57,686
让人疑惑 我们先来


926
00:30:57,686 --> 00:31:00,196
看看它的思维模型


927
00:31:00,196 --> 00:31:01,266
应该如何理解它


928
00:31:01,966 --> 00:31:04,426
从 Swift 3 开始


929
00:31:04,426 --> 00:31:06,326
不是表达式的一种类型


930
00:31:06,816 --> 00:31:08,006
不要认为它是一种类型


931
00:31:08,446 --> 00:31:09,856
而要认为


932
00:31:09,856 --> 00:31:11,256
它是声明的


933
00:31:11,256 --> 00:31:13,096
特性之一


934
00:31:13,996 --> 00:31:15,756
当你引用这种声明是


935
00:31:15,756 --> 00:31:17,526
编译器会首先


936
00:31:17,846 --> 00:31:19,186
检查它的类型


937
00:31:19,186 --> 00:31:21,536
看它是不是普通的选项


938
00:31:21,536 --> 00:31:23,006
如果在它的使用场景中


939
00:31:23,006 --> 00:31:24,556
它不合理


940
00:31:24,746 --> 00:31:26,916
编译器就会将其解析


941
00:31:26,916 --> 00:31:28,096
进行类型检查 将其标记为


942
00:31:28,096 --> 00:31:28,876
下划线类型（underlined type）


943
00:31:30,296 --> 00:31:31,746
我们来看看第一种


944
00:31:31,746 --> 00:31:32,506
情况的例子


945
00:31:33,236 --> 00:31:34,886
这里有两个函数


946
00:31:34,966 --> 00:31:36,596
第一个会生成


947
00:31:36,596 --> 00:31:37,906
整型的隐式解析选项


948
00:31:37,906 --> 00:31:39,656
第二个则会接受


949
00:31:39,656 --> 00:31:41,226
任何类型的传入值


950
00:31:41,836 --> 00:31:43,306
我要用第一个函数的


951
00:31:43,306 --> 00:31:45,256
结果 来调用第二个函数


952
00:31:45,916 --> 00:31:47,966
这个例子中 我可以


953
00:31:47,966 --> 00:31:50,506
在任意（Any）类型中存入整型选项


954
00:31:50,856 --> 00:31:53,206
不会进行强制解析


955
00:31:53,466 --> 00:31:55,896
值会变成一个普通的选项


956
00:31:55,896 --> 00:31:59,966
我们再看看第二种情况的例子


957
00:32:00,876 --> 00:32:02,856
现在 第一个函数生成


958
00:32:02,856 --> 00:32:05,486
对不起 第二个函数


959
00:32:05,486 --> 00:32:07,086
现在接受整型


960
00:32:07,516 --> 00:32:09,066
如果我使用第一个函数的


961
00:32:09,066 --> 00:32:10,646
结果 调用第二个


962
00:32:10,706 --> 00:32:13,006
函数 我就不能


963
00:32:13,086 --> 00:32:14,986
传递整型选项 因为


964
00:32:14,986 --> 00:32:16,126
函数需要整型


965
00:32:16,596 --> 00:32:18,246
所以 编译器必须进行


966
00:32:18,246 --> 00:32:21,296
强制解析 之后


967
00:32:21,296 --> 00:32:22,656
代码运行正常 因为这里需要整型


968
00:32:22,836 --> 00:32:26,266
也传入了整型 这个思维模型


969
00:32:26,346 --> 00:32:27,626
可以很好地


970
00:32:27,626 --> 00:32:29,506
帮助理解隐式解析选项


971
00:32:30,206 --> 00:32:32,566
但直到最近 编译器


972
00:32:32,776 --> 00:32:34,166
还是会遇到一些不遵从


973
00:32:34,166 --> 00:32:35,636
此模型的极端案例


974
00:32:36,316 --> 00:32:38,956
所以记住 隐式解析选项


975
00:32:38,956 --> 00:32:41,696
不能是其他类型的一部分


976
00:32:42,416 --> 00:32:43,706
Swift 4.2 中


977
00:32:43,706 --> 00:32:44,646
依然如此


978
00:32:44,816 --> 00:32:46,616
数组不能包含


979
00:32:46,676 --> 00:32:48,296
隐式解析整型


980
00:32:49,136 --> 00:32:51,566
但在 Swift 4 中


981
00:32:51,876 --> 00:32:53,536
有一些像这样的极端案例


982
00:32:53,536 --> 00:32:55,606
我可以定义一个 typealias


983
00:32:55,796 --> 00:32:57,596
它的实际类型可以是


984
00:32:57,776 --> 00:32:59,606
隐式解析整型


985
00:32:59,606 --> 00:33:00,956
接下来 我就可以用这个


986
00:33:01,016 --> 00:33:03,166
typealias 创建数组


987
00:33:03,166 --> 00:33:04,756
从而使编译器的行为


988
00:33:04,756 --> 00:33:06,906
匪夷所思 令代码难以理解


989
00:33:07,596 --> 00:33:09,516
因此 在 Swift 4.2 中 我们


990
00:33:09,516 --> 00:33:10,816
重新采用了


991
00:33:10,816 --> 00:33:12,556
隐式解析选项


992
00:33:12,666 --> 00:33:14,736
完美契合我之前


993
00:33:14,736 --> 00:33:17,186
提到的思维模型


994
00:33:17,386 --> 00:33:19,226
这一段匪夷所思的代码


995
00:33:19,226 --> 00:33:20,986
现在会生成编译时间错误


996
00:33:21,306 --> 00:33:23,586
编译器也会将其


997
00:33:23,946 --> 00:33:25,816
按照普通整型数组


998
00:33:25,816 --> 00:33:27,576
或整型选项数组来解析


999
00:33:28,546 --> 00:33:30,836
大多数代码不会


1000
00:33:30,836 --> 00:33:32,266
因隐式解析选项的


1001
00:33:32,266 --> 00:33:33,626
这一变化而受影响


1002
00:33:34,036 --> 00:33:35,436
但如果你碰巧


1003
00:33:35,436 --> 00:33:37,426
用到了这些极端案例


1004
00:33:37,426 --> 00:33:38,696
我建议你看一看


1005
00:33:38,746 --> 00:33:41,096
Swift.org 上的这篇博客文章


1006
00:33:41,096 --> 00:33:42,486
这篇文章包含更多细节


1007
00:33:42,486 --> 00:33:44,736
举了很多例子 来说明


1008
00:33:44,736 --> 00:33:47,136
变化的种类和方式


1009
00:33:47,376 --> 00:33:50,566
好的 还有最后一项


1010
00:33:50,986 --> 00:33:52,566
我们来谈谈内存


1011
00:33:52,566 --> 00:33:53,866
独占性检查（memory exclusivity checking）


1012
00:33:55,196 --> 00:33:57,946
大家还记得 在 Swift 4 中 我们


1013
00:33:57,946 --> 00:33:59,896
带来了所谓的


1014
00:33:59,896 --> 00:34:01,386
内存独占性检查


1015
00:34:01,646 --> 00:34:02,896
该功能结合了


1016
00:34:02,956 --> 00:34:05,186
运行时检查


1017
00:34:05,436 --> 00:34:06,696
和编译时检查


1018
00:34:06,696 --> 00:34:08,856
但一些功能受限


1019
00:34:09,315 --> 00:34:10,976
我们专门限制了


1020
00:34:11,286 --> 00:34:13,376
对同一内存区域的


1021
00:34:13,376 --> 00:34:14,356
重复访问


1022
00:34:14,856 --> 00:34:15,656
这意味着什么


1023
00:34:15,815 --> 00:34:17,096
我们来看个例子


1024
00:34:17,666 --> 00:34:20,085
这一段代码


1025
00:34:20,085 --> 00:34:21,706
为操作系统路径


1026
00:34:21,896 --> 00:34:23,246
实现了一个数据类型


1027
00:34:23,766 --> 00:34:25,446
表现为包含路径元素的


1028
00:34:25,565 --> 00:34:27,005
一个数组


1029
00:34:27,576 --> 00:34:29,206
还使用了 withAppended 方法


1030
00:34:30,216 --> 00:34:31,946
这个方法可以向数组中


1031
00:34:31,946 --> 00:34:33,735
添加元素 再调用 closure()


1032
00:34:33,735 --> 00:34:35,806
作用于你传入的元素


1033
00:34:35,806 --> 00:34:37,626
再将它从数组中移出


1034
00:34:38,295 --> 00:34:40,036
这段代码没有问题


1035
00:34:40,036 --> 00:34:41,726
在 Swift 4 中运行无误


1036
00:34:42,755 --> 00:34:44,505
但我们来看一下


1037
00:34:44,505 --> 00:34:45,536
Path 数据类型的使用


1038
00:34:46,545 --> 00:34:47,976
这个 path 变量


1039
00:34:47,976 --> 00:34:49,746
存储在局部变量中


1040
00:34:50,056 --> 00:34:51,806
我对它调用 withAppended 方法


1041
00:34:52,295 --> 00:34:54,856
在 closure 中 我再访问


1042
00:34:54,856 --> 00:34:56,306
这个局部变量


1043
00:34:56,536 --> 00:34:57,056
并将它打印出来


1044
00:34:57,556 --> 00:34:58,696
问题出在哪儿


1045
00:34:59,436 --> 00:35:01,076
事实上 这段代码


1046
00:35:01,076 --> 00:35:03,756
有歧义 因为


1047
00:35:03,756 --> 00:35:05,866
当我访问 closure 中的


1048
00:35:06,136 --> 00:35:08,436
局部变量时 它已经被


1049
00:35:08,436 --> 00:35:10,086
withAppended


1050
00:35:10,086 --> 00:35:11,686
这一可变方法（mutating method）


1051
00:35:11,686 --> 00:35:12,586
修改过了


1052
00:35:13,306 --> 00:35:16,136
歧义之处在于


1053
00:35:16,136 --> 00:35:18,466
我所指的是 path


1054
00:35:18,806 --> 00:35:20,556
在调用 withAppended 之前的


1055
00:35:20,556 --> 00:35:22,706
原始值 还是


1056
00:35:22,706 --> 00:35:24,106
修改之后的


1057
00:35:24,106 --> 00:35:25,926
当前值


1058
00:35:26,756 --> 00:35:28,636
Swift 4 中 这是一处


1059
00:35:28,636 --> 00:35:30,396
编译时错误 因为


1060
00:35:30,396 --> 00:35:32,226
它违反了独占性


1061
00:35:32,756 --> 00:35:34,716
要解决这一问题


1062
00:35:34,716 --> 00:35:35,976
消除歧义 办法之一


1063
00:35:35,976 --> 00:35:37,926
是告诉编译器


1064
00:35:37,926 --> 00:35:40,496
我想要获得当前值 所以


1065
00:35:40,496 --> 00:35:41,766
我只将其作为参数


1066
00:35:41,766 --> 00:35:44,986
传入 closure 而不去捕获它


1067
00:35:45,586 --> 00:35:47,936
可以 但再看看这个例子


1068
00:35:48,266 --> 00:35:49,586
这个函数和刚才的


1069
00:35:49,586 --> 00:35:51,376
几乎相同 除了这是一个泛型


1070
00:35:51,376 --> 00:35:53,326
函数 参数由


1071
00:35:53,326 --> 00:35:54,646
closure 返回值的类型决定


1072
00:35:55,306 --> 00:35:57,436
这个例子中 我们会遇到


1073
00:35:57,436 --> 00:35:59,286
类似的歧义 因为


1074
00:35:59,286 --> 00:36:01,246
要从闭包内部获得


1075
00:36:01,246 --> 00:36:02,166
path 的值


1076
00:36:02,496 --> 00:36:04,766
但 Swift 4 无法在


1077
00:36:04,766 --> 00:36:06,866
编译时捕获到这个错误


1078
00:36:08,286 --> 00:36:10,436
Swift 4.2 中 我们改进了


1079
00:36:10,436 --> 00:36:12,526
静态独占性检查（static exclusivity 


1080
00:36:12,526 --> 00:36:15,256
checking） 可以在更多情况下 指出这样的歧义


1081
00:36:16,386 --> 00:36:18,546
除了改进


1082
00:36:19,146 --> 00:36:20,526
好吧 你还可以用类似方法


1083
00:36:20,526 --> 00:36:22,236
将变量值作为


1084
00:36:22,236 --> 00:36:23,566
closure 的参数传入


1085
00:36:23,566 --> 00:36:24,026
来消除歧义


1086
00:36:24,576 --> 00:36:26,876
除了改进


1087
00:36:26,876 --> 00:36:28,986
静态检查 我们还新增了


1088
00:36:28,986 --> 00:36:30,796
使用运行时独占性检查


1089
00:36:30,796 --> 00:36:32,906
和释放构造的功能


1090
00:36:33,336 --> 00:36:35,166
这会牺牲一些性能


1091
00:36:35,166 --> 00:36:36,606
但如果你的 App 不注重


1092
00:36:36,606 --> 00:36:38,096
性能 我们鼓励你尝试一下


1093
00:36:38,096 --> 00:36:39,746
并且始终开启


1094
00:36:39,746 --> 00:36:40,216
这一功能


1095
00:36:40,686 --> 00:36:42,386
未来 我们会将


1096
00:36:42,386 --> 00:36:44,236
动态检查的性能损耗


1097
00:36:44,306 --> 00:36:46,276
大幅降低 这样就可以


1098
00:36:46,276 --> 00:36:48,126
始终开启这一功能


1099
00:36:48,186 --> 00:36:49,226
这一功能还能带来


1100
00:36:49,226 --> 00:36:50,846
额外保护 就像


1101
00:36:50,896 --> 00:36:53,296
数组边界检查（array bounds checking）


1102
00:36:53,296 --> 00:36:54,596
或整型溢出检查（integer overflow checking）


1103
00:36:55,166 --> 00:36:58,316
一样 Swift 4.2 中还有


1104
00:36:58,316 --> 00:37:01,576
很多我没有涉及的特性


1105
00:37:02,096 --> 00:37:03,716
我们鼓励大家


1106
00:37:03,716 --> 00:37:05,496
在现有 App 中尝试


1107
00:37:05,546 --> 00:37:06,776
我们希望大家多尝试


1108
00:37:06,776 --> 00:37:08,536
新特性 如果有


1109
00:37:08,536 --> 00:37:10,056
任何问题 欢迎来到


1110
00:37:10,056 --> 00:37:11,966
实验室 咨询我们


1111
00:37:12,556 --> 00:37:12,956
谢谢


1112
00:37:14,516 --> 00:37:19,500
[ 掌声 ]

