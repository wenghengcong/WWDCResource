1
00:00:16,750 --> 00:00:21,755 line:0
（自动化App Store Connect演讲303）


2
00:00:34,701 --> 00:00:38,405 line:-2
下午好 我是Geoff Coffey
App Store Connect的工程师


3
00:00:38,805 --> 00:00:41,742 line:-2
我今天要跟大家谈谈自动化
App Store Connect


4
00:00:42,276 --> 00:00:44,278 line:-1
老实说我现在非常激动


5
00:00:44,344 --> 00:00:45,779 line:-2
想到今天要跟大家分享的内容
就无比激动


6
00:00:46,947 --> 00:00:48,348 line:-1
让我们首先谈谈


7
00:00:48,415 --> 00:00:51,118 line:-1
我们在自动App Store Connect的进度


8
00:00:51,685 --> 00:00:53,987 line:-2
我知道你们都了解
也都能使用Xcode


9
00:00:54,054 --> 00:00:56,156 line:-2
把你所创建的app上传到
App Store Connect中


10
00:00:56,490 --> 00:00:58,158 line:-1
并下载崩溃报告


11
00:00:58,725 --> 00:01:00,160 line:-1
我们有一个 Transporter 工具


12
00:01:00,227 --> 00:01:03,430 line:-2
可以帮助你自动上传
metadata.xml文件


13
00:01:03,664 --> 00:01:05,566 line:-1
也会自动上传你所创建的构建版本


14
00:01:06,133 --> 00:01:07,201 line:-1
我们还有Reporter


15
00:01:07,267 --> 00:01:10,838 line:-2
它是一个命令行工具
可以下载你的销售和财务报告


16
00:01:11,605 --> 00:01:14,007 line:-2
这些工具都很棒
你们中一定有很多人都使用它们


17
00:01:14,241 --> 00:01:16,210 line:-1
但我听你们说你们想要更多功能


18
00:01:16,376 --> 00:01:19,513 line:-1
你希望能查看App Store Connect中的更多区域


19
00:01:19,746 --> 00:01:22,182 line:-1
并希望集成更多不同的工作流程


20
00:01:22,883 --> 00:01:26,620 line:-2
我们真的非常高兴引入了一个新的
App Store Connect API


21
00:01:33,961 --> 00:01:35,062 line:-1
我们自己也感到非常激动


22
00:01:35,128 --> 00:01:39,700 line:-2
这是一个App Store
Connect的标准REST API


23
00:01:40,300 --> 00:01:42,536 line:-1
如果你问我 这是它最棒的一点


24
00:01:42,603 --> 00:01:46,139 line:-2
它是一个库存标准的
REST API附带JSON响应


25
00:01:46,206 --> 00:01:48,909 line:-2
所以你们一定会感到很熟悉
可以立即上手使用它


26
00:01:49,476 --> 00:01:52,379 line:-2
那也意味着
你可以从任意平台使用这个API


27
00:01:52,446 --> 00:01:54,147 line:-1
它几乎支持任何一种编码语言


28
00:01:54,214 --> 00:01:57,050 line:-2
你可以使用
你当前很可能正在使用的工具


29
00:01:58,352 --> 00:02:00,254 line:-1
当然了 这个API需要保持安全


30
00:02:00,320 --> 00:02:04,691 line:-2
因此我们使用了工业级的JSON
网络令牌进行验证


31
00:02:05,125 --> 00:02:08,095 line:-2
那仅仅意味着
你不需要传递用户名和密码


32
00:02:08,562 --> 00:02:12,499 line:-2
而且你不需要把代码
绑定到你团队中的任意人员身上


33
00:02:12,866 --> 00:02:16,503 line:-2
但你仍然可以控制谁可以获取
你的数据以及他们能做什么


34
00:02:18,639 --> 00:02:19,740 line:-1
从简单易用方面考虑


35
00:02:19,806 --> 00:02:22,943 line:-1
我们十分关注这个API的一致性


36
00:02:23,243 --> 00:02:27,080 line:-2
我们有一个独立、统一
的REST源模型 那就意味着


37
00:02:27,281 --> 00:02:29,983 line:-2
你可以把你所了解到的东西
放到API中的任意一部分


38
00:02:30,217 --> 00:02:31,785 line:-1
并把它用到其它部分中去


39
00:02:32,286 --> 00:02:35,455 line:-1
我们还以一种简单的方式


40
00:02:35,923 --> 00:02:38,659 line:-2
在API自身嵌入了可暴露性
比如当我们给你返回JSON数据时


41
00:02:38,725 --> 00:02:40,494 line:-1
它的格式和缩进会非常整齐


42
00:02:40,561 --> 00:02:42,930 line:-2
所以如果需要
你可以把它嵌入控制台


43
00:02:42,996 --> 00:02:44,498 line:-1
并在屏幕上读取它


44
00:02:44,765 --> 00:02:48,035 line:-2
并且我们在那些响应中
包含了相关信息的链接


45
00:02:48,101 --> 00:02:50,337 line:-2
用于帮助你们了解
各部分之间的协调性


46
00:02:51,738 --> 00:02:54,274 line:-2
当然了
这个API配备你所需要的全部文档


47
00:02:54,508 --> 00:02:57,077 line:-2
如果你还没有看到文档
你现已使用的文档平台


48
00:02:57,144 --> 00:03:00,747 line:-2
developer.apple.com中的
Xcode部分


49
00:03:00,814 --> 00:03:04,284 line:-2
今年进行了扩展 其中就包含了
Apple的REST API


50
00:03:04,551 --> 00:03:08,255 line:-1
因此与你所熟悉的框架文档格式相同


51
00:03:08,322 --> 00:03:10,290 line:-1
同样适用于App Store Connect API


52
00:03:12,326 --> 00:03:15,796 line:-1
我们开始关注App Store Connect中


53
00:03:16,096 --> 00:03:19,066 line:-1
还没有自动化的区域


54
00:03:19,233 --> 00:03:21,201 line:-1
你得时不时地关注一下


55
00:03:21,268 --> 00:03:24,471 line:-2
尤其是我们已经开始进行
你在这里看到的这四个区域了


56
00:03:24,538 --> 00:03:26,473 line:-1
让我们看看都包含什么


57
00:03:27,174 --> 00:03:29,276 line:-2
首先我们有TestFlight的
全部功能


58
00:03:29,610 --> 00:03:33,180 line:-2
你可以管理测试人员和团队
你可以提交代码用于审阅


59
00:03:33,580 --> 00:03:34,882 line:-1
并且如果你观看了昨天的演讲


60
00:03:34,948 --> 00:03:36,617 line:-1
“App Store Connect新特性”演讲


61
00:03:36,683 --> 00:03:39,119 line:-2
你就知道我们刚发布了
一个新的公共链接功能


62
00:03:39,186 --> 00:03:40,521 line:-1
有助于收集测试人员


63
00:03:40,854 --> 00:03:42,923 line:-1
这个功能要和API一起使用


64
00:03:43,323 --> 00:03:45,859 line:-1
你可以用API来管理你的公共链接


65
00:03:46,093 --> 00:03:49,062 line:-2
你可以同时使用公共连接和API
运行你的beta测试程序


66
00:03:49,129 --> 00:03:51,198 line:-1
你可以随心所欲选择一种方式


67
00:03:52,966 --> 00:03:55,602 line:-2
在用户和职能方面
你可以添加和移除用户


68
00:03:55,669 --> 00:03:59,506 line:-2
并保持你用户的权限
与实际团队中的权限同步


69
00:04:00,073 --> 00:04:01,375 line:-1
正如我们昨天所发布的那样


70
00:04:01,441 --> 00:04:03,877 line:-1
这包括完整、统一的用户基础


71
00:04:04,044 --> 00:04:06,947 line:-2
在开发者网站上
和App Store Connect中


72
00:04:07,014 --> 00:04:09,883 line:-1
所以你拥有一套用户和一套职能


73
00:04:16,055 --> 00:04:19,125 line:-2
我们有配置API
你可以添加开发设备


74
00:04:19,192 --> 00:04:22,863 line:-2
和批量注册ID
并管理你的证书和档案


75
00:04:23,597 --> 00:04:25,065 line:-1
然后我们还有报告API


76
00:04:25,132 --> 00:04:27,935 line:-1
你可以下载销售和财务报告文件


77
00:04:28,268 --> 00:04:30,137 line:-1
如果你用过Reporter


78
00:04:30,204 --> 00:04:32,206 line:-1
那么你一定会对这个API感到熟悉


79
00:04:32,272 --> 00:04:35,676 line:-2
因为你发送给Reporter的参数
与你发送给API的参数非常相似


80
00:04:35,742 --> 00:04:37,544 line:-2
因此在这两者之间切换
就很容易


81
00:04:38,879 --> 00:04:41,048 line:-1
我说过一共有四件事 那么最后一件


82
00:04:41,114 --> 00:04:43,717 line:-2
其实并不是API自身的一部分
但我想把它提出来


83
00:04:43,784 --> 00:04:46,086 line:-2
因为它对于我们的自动化来说
非常重要


84
00:04:46,486 --> 00:04:48,088 line:-2
我们已在 Transporter 工具中
做了重要修改


85
00:04:48,155 --> 00:04:50,390 line:-1
用于帮助你们更好地使用它


86
00:04:50,858 --> 00:04:53,794 line:-2
首先 Linux将开始支持
Transporter 工具


87
00:04:54,461 --> 00:04:56,663 line:-2
同时你能把在新API上
使用的API令牌


88
00:04:56,864 --> 00:05:00,234 line:-1
发送给 Transporter 工具


89
00:05:00,300 --> 00:05:02,402 line:-1
那么 Transporter 工具可以用它们进行认证


90
00:05:02,636 --> 00:05:04,972 line:-2
它只是把进程变得更简单了
便于你进行管理


91
00:05:07,107 --> 00:05:08,442 line:-1
我们还有很多内容要讲


92
00:05:08,509 --> 00:05:10,043 line:-1
今天我们要加快进度了


93
00:05:10,110 --> 00:05:12,045 line:-1
我很抱歉 但我们还有很多内容要讲


94
00:05:12,112 --> 00:05:15,148 line:-2
我们要谈谈
用API获取数据和修改数据


95
00:05:15,349 --> 00:05:17,551 line:-2
我们要谈谈关系
就是API的不同部分


96
00:05:17,618 --> 00:05:20,387 line:-2
是如何协同合作的
以及你要如何使用它们


97
00:05:20,721 --> 00:05:22,289 line:-1
我们要谈谈如何处理报错


98
00:05:22,356 --> 00:05:24,958 line:-1
如何获取API并验证请求


99
00:05:25,192 --> 00:05:27,261 line:-1
然后我们会展示一些最佳范例


100
00:05:28,695 --> 00:05:29,696 line:-1
你们准备好了吗？


101
00:05:34,001 --> 00:05:36,470 line:-2
正如我所说的
我们要从获取数据开始讲


102
00:05:36,537 --> 00:05:41,041 line:-2
那意味着我们要从这里开始
api.appstoreconnect.apple.com


103
00:05:41,275 --> 00:05:45,679 line:-2
这是API的大本营
从这里我们想要构建一个URL


104
00:05:46,313 --> 00:05:48,182 line:-1
首先我们要添加一个版本号


105
00:05:48,882 --> 00:05:52,519 line:-2
现在所有API终端都有一个版本号
目前它一直是v1


106
00:05:52,986 --> 00:05:56,290 line:-2
但不可避免 随App Store
Connect的扩张和变更


107
00:05:56,557 --> 00:05:58,125 line:-1
我们要对API进行修改


108
00:05:58,192 --> 00:06:00,127 line:-1
那可能会导致你的代码停止运行


109
00:06:00,561 --> 00:06:01,762 line:-1
如果发生了这种情况


110
00:06:01,828 --> 00:06:04,698 line:-2
我们会修改这个版本号
老版本仍然继续工作一段时间


111
00:06:04,765 --> 00:06:07,968 line:-2
因此你就有时间进行调整
从而适应我们的修改


112
00:06:08,735 --> 00:06:12,973 line:-2
在这个版本之后 我们会添加
一个叫做源类型名称的东西


113
00:06:13,340 --> 00:06:15,576 line:-1
这在API中是一个极其重要的概念


114
00:06:15,809 --> 00:06:19,446 line:-1
源就像是API的基本单位


115
00:06:19,813 --> 00:06:21,582 line:-2
从概念上讲
你几乎可以把API看作


116
00:06:21,648 --> 00:06:24,852 line:-1
你正在操作的源的一个大集合


117
00:06:25,552 --> 00:06:27,855 line:-1
在API中我们有一大群源


118
00:06:28,255 --> 00:06:30,791 line:-2
其中大部分都映射为你在
App Store Connect中所熟悉的元素


119
00:06:30,858 --> 00:06:32,860 line:-1
今天我们不会都谈到


120
00:06:32,926 --> 00:06:36,363 line:-2
我们只重点谈其中一些
我们从用户开始讲


121
00:06:37,030 --> 00:06:39,666 line:-1
我们有一个完整的API URL：


122
00:06:39,733 --> 00:06:44,972 line:-2
api.appstoreconnect.apple.com
/v1/users


123
00:06:45,038 --> 00:06:47,941 line:-1
这个URL代表你团队中的全部用户


124
00:06:48,575 --> 00:06:52,913 line:-2
当然 你可以获取这个URL
并返回一个JSON对象


125
00:06:53,547 --> 00:06:57,284 line:-2
对此你首先要注意到的是
它有一个数据属性


126
00:06:57,784 --> 00:07:00,521 line:-2
任何时候当我们成功发送给你一个
带有数据的响应时


127
00:07:00,888 --> 00:07:02,356 line:-1
都包含这个数据属性


128
00:07:02,856 --> 00:07:06,159 line:-1
在本例中 它是一个用户源的数组


129
00:07:06,693 --> 00:07:08,829 line:-1
现在你在屏幕上只能看到一个用户


130
00:07:08,896 --> 00:07:10,697 line:-1
但如果屏幕再高点


131
00:07:10,764 --> 00:07:13,433 line:-2
你就可以在这个数组中看到
你团队中的全部用户


132
00:07:14,468 --> 00:07:17,337 line:-2
现在我想谈谈
我们返回给你的某些数据


133
00:07:17,404 --> 00:07:19,540 line:-1
带有每一个这样的源响应


134
00:07:20,073 --> 00:07:22,910 line:-2
每个源都有一个类型
我只想告诉你类型是什么


135
00:07:23,243 --> 00:07:26,113 line:-1
并且一个ID会唯一识别这个源


136
00:07:26,213 --> 00:07:27,981 line:-1
在整个App Store Connect中


137
00:07:28,849 --> 00:07:30,150 line:-1
然后我们有属性


138
00:07:30,517 --> 00:07:32,686 line:-1
这很可能是你最感兴趣的地方


139
00:07:32,920 --> 00:07:35,556 line:-1
对于用户 它就是像姓、名


140
00:07:35,756 --> 00:07:36,823 line:-1
和邮箱地址一样


141
00:07:37,591 --> 00:07:41,862 line:-2
这些参数的值通常是简单的类型
比如字符串、数字


142
00:07:42,029 --> 00:07:43,397 line:-1
日期和时间或布尔值


143
00:07:43,764 --> 00:07:47,034 line:-2
但有时它们也可以是复杂的类型
比如数组和对象


144
00:07:48,068 --> 00:07:50,170 line:-1
参数之后 我们有关系


145
00:07:50,704 --> 00:07:53,140 line:-2
现在我们先跳过这个话题
我们稍后再返回来谈


146
00:07:53,674 --> 00:07:58,145 line:-2
然后我们有链接
特别是一个我们叫做源自链接的链接


147
00:07:58,612 --> 00:08:01,982 line:-2
现在这个URL唯一识别
这个特定的源


148
00:08:02,182 --> 00:08:04,818 line:-2
在这种情况下
第一个用户在这个结果中


149
00:08:04,885 --> 00:08:08,488 line:-2
我们返回给你的每一个源
都包含这个源自链接


150
00:08:09,723 --> 00:08:13,493 line:-2
它看起来总是这个样子的：
api.appstoreconnect.apple.com


151
00:08:13,727 --> 00:08:15,495 line:-1
然后版本号是v1


152
00:08:15,562 --> 00:08:19,867 line:-2
然后源类型是用户
然后是那个源的标识符


153
00:08:20,234 --> 00:08:21,368 line:-1
你可以获取它


154
00:08:21,735 --> 00:08:24,872 line:-2
并获得返回的数据
跟我们刚才所看到的几乎一模一样


155
00:08:25,038 --> 00:08:28,242 line:-2
这里的唯一不同点就是
我们刚才只看到了这个用户


156
00:08:28,308 --> 00:08:30,310 line:-1
而不是你团队中的全部用户


157
00:08:32,613 --> 00:08:34,280 line:-1
所以这是获取数据的两种方式


158
00:08:34,748 --> 00:08:37,551 line:-1
你可以获取源列表或某一个源


159
00:08:37,683 --> 00:08:40,354 line:-1
但当然了 你也希望能修改数据


160
00:08:40,554 --> 00:08:43,823 line:-1
为此我们要使用通用的REST惯例


161
00:08:43,890 --> 00:08:46,226 line:-2
那么你们中的很多人
对这个也会感到很熟悉


162
00:08:46,860 --> 00:08:48,695 line:-1
你们已经了解如何获取源


163
00:08:49,062 --> 00:08:52,833 line:-2
要创建一个新的源
你要使用http POST方法


164
00:08:53,267 --> 00:08:55,702 line:-1
要修改源 你要使用PATCH


165
00:08:55,769 --> 00:08:58,805 line:-2
要删除一个源
你要使用DELETE方法


166
00:08:59,273 --> 00:09:00,340 line:-1
那么让我们来试试


167
00:09:00,407 --> 00:09:03,076 line:-2
假如我们想向你的团队中
添加一个新用户


168
00:09:03,810 --> 00:09:06,513 line:-1
现在我们不能直接添加用户


169
00:09:06,780 --> 00:09:08,749 line:-1
就像App Store Connect自身


170
00:09:08,815 --> 00:09:13,020 line:-2
你必须邀请用户到你的团队
然后他们可以接受那个邀请


171
00:09:13,220 --> 00:09:17,124 line:-1
那么我们要创建一个用户邀请源


172
00:09:17,658 --> 00:09:20,694 line:-2
看似如此 我们用一个POST
因为我们正在创建


173
00:09:21,228 --> 00:09:24,631 line:-1
而URL是用户邀请源URL


174
00:09:25,032 --> 00:09:27,968 line:-1
然后我们需要发送这个用户的数据


175
00:09:28,569 --> 00:09:30,604 line:-2
现在这个数据看来
跟你刚才看到的很相似


176
00:09:30,671 --> 00:09:32,639 line:-1
就是我们之前获取用户时的数据


177
00:09:32,706 --> 00:09:34,808 line:-1
但我想指出其中一个重要的不同点


178
00:09:35,275 --> 00:09:39,213 line:-2
我们有一个类型是用户邀请
但我们没有ID


179
00:09:39,913 --> 00:09:43,083 line:-2
Apple会给你所创建的每一个源
分配一个ID


180
00:09:43,150 --> 00:09:45,419 line:-1
因此你不需要在POST中包含它


181
00:09:45,853 --> 00:09:48,856 line:-2
我们还丢掉了链接
因为创建过程不需要它


182
00:09:49,089 --> 00:09:50,257 line:-1
并且我们还丢掉了关系


183
00:09:50,324 --> 00:09:52,693 line:-1
因为它在本例中并不相关


184
00:09:53,227 --> 00:09:55,562 line:0
如果我们运行这个请求
我们就会得到一个响应


185
00:09:56,063 --> 00:09:59,800 line:0
特别是这是一个
201 CREATED响应


186
00:10:00,067 --> 00:10:01,635 line:0
这只是一个标准的REST行为


187
00:10:01,702 --> 00:10:04,137 line:0
用于告诉你们源已成功创建


188
00:10:05,272 --> 00:10:08,141 line:0
我们还包含了完整的源信息


189
00:10:08,208 --> 00:10:11,478 line:0
在响应数据中 这个信息很重要
有两点原因


190
00:10:11,612 --> 00:10:15,382 line:0
第一 它给你提供了
所创建的源ID和源自链接


191
00:10:15,449 --> 00:10:18,218 line:0
你很可能稍后会用到它们


192
00:10:18,285 --> 00:10:21,755 line:0
因此你可以再返回来操作这个源


193
00:10:22,356 --> 00:10:24,725 line:0
同时如果你看一下属性


194
00:10:24,791 --> 00:10:28,829 line:0
你可能看到这个响应中的属性
是你并没有包含在你的POST中的


195
00:10:29,630 --> 00:10:33,100 line:0
比如 对于用户邀请来说
Apple会给你


196
00:10:33,400 --> 00:10:35,302 line:0
创建的每一个用户邀请
分配一个到期日


197
00:10:35,502 --> 00:10:38,438 line:0
现在你没有设置它
因此在POST中就不会包含它


198
00:10:38,672 --> 00:10:41,175 line:0
这就是为什么这个响应数据
对你来说非常重要


199
00:10:41,341 --> 00:10:45,445 line:0
它给你展示了
源被创建以后的所有相关信息


200
00:10:45,512 --> 00:10:47,648 line:0
以及适用于这个源的全部规则


201
00:10:49,183 --> 00:10:52,186 line:0
现在如果这个用户接受
那么他将成为我们团队中的一个用户


202
00:10:52,486 --> 00:10:55,956 line:0
假如我们稍后要返回
并以某种方式进行修改


203
00:10:56,323 --> 00:10:58,292 line:0
比如 你可以从这里的属性中看到


204
00:10:58,358 --> 00:10:59,993 line:0
这个用户有开发者职能


205
00:11:00,661 --> 00:11:03,597 line:-2
那么让我们修改一下
让他有开发者和营销人员职能


206
00:11:04,598 --> 00:11:07,868 line:-2
我们正在修改一个现有的源
所以我们要执行PATCH请求


207
00:11:08,335 --> 00:11:13,040 line:-2
这次的URL是
我们要修改用户的源自链接


208
00:11:13,774 --> 00:11:17,744 line:-2
如果你看一下属性
我们只包含了职能属性


209
00:11:17,811 --> 00:11:19,780 line:-1
这个请求的意思是修改这个用户


210
00:11:19,847 --> 00:11:22,850 line:-1
这样他就有开发者和营销人员的职能


211
00:11:23,050 --> 00:11:25,652 line:-1
我们并不想修改这个用户的其它信息


212
00:11:25,719 --> 00:11:27,888 line:-1
所以我们就不需要包含其它属性


213
00:11:28,789 --> 00:11:31,658 line:0
如果我们运行这个请求
我们再次获得了一个成功响应


214
00:11:32,426 --> 00:11:34,561 line:0
并且我们获得了完整的源陈述


215
00:11:34,795 --> 00:11:37,064 line:0
该源包含我们所进行的修改


216
00:11:38,699 --> 00:11:41,235 line:-2
对于源来说 你最不想做的事
很可能就是删除它


217
00:11:41,301 --> 00:11:43,303 line:-1
这是其中最简单的操作了


218
00:11:43,370 --> 00:11:46,507 line:-2
我们只需要对源自链接执行
DELETE请求即可


219
00:11:46,840 --> 00:11:49,343 line:-2
然后就会获得
204 NO CONTENT响应


220
00:11:49,810 --> 00:11:50,911 line:-1
如果你熟悉REST


221
00:11:50,978 --> 00:11:54,648 line:-2
你就会知道编号200系列的
任意状态代码都意味着成功


222
00:11:54,882 --> 00:11:56,216 line:-1
所以API就是在告诉你


223
00:11:56,283 --> 00:11:58,619 line:-1
用户已经被成功删除了


224
00:11:58,919 --> 00:12:01,588 line:-1
这次我们不需要包含任意额外数据


225
00:12:01,655 --> 00:12:04,691 line:-2
所以我们使用成功响应的
NO CONTENT版本


226
00:12:07,060 --> 00:12:09,429 line:-2
在我们进入下一章节之前
我想邀请我的同事


227
00:12:09,496 --> 00:12:11,765 line:-2
Sehoon Shon上台
给大家演示


228
00:12:11,832 --> 00:12:15,068 line:-2
如何在现实场景中使用
这些源的一些示例 Sehoon


229
00:12:21,909 --> 00:12:22,910 line:-1
大家好 谢谢Geoff


230
00:12:24,278 --> 00:12:25,946 line:-2
大家好
我叫Sehoon Shon


231
00:12:26,013 --> 00:12:28,882 line:-2
我是TestFlight团队的
软件工程师 今天我来此


232
00:12:28,949 --> 00:12:32,019 line:-2
给大家做一个
App Store Connect API的现场演示


233
00:12:33,287 --> 00:12:37,357 line:-2
我们会用一个实例来了解
我们如何在用户源中实施这个API


234
00:12:38,292 --> 00:12:40,794 line:-2
假如我们团队中的某个人
离开了我们公司


235
00:12:40,861 --> 00:12:42,362 line:-1
我想找到这个用户


236
00:12:42,429 --> 00:12:44,965 line:-2
并把这个用户
从 App Store Connect 团队中删除


237
00:12:45,599 --> 00:12:46,633 line:-1
让我们看一个演示


238
00:13:02,216 --> 00:13:05,285 line:-1
我们首先要获取团队的全部用户列表


239
00:13:05,352 --> 00:13:08,188 line:-1
通过向用户源发送GET请求实现


240
00:13:08,255 --> 00:13:10,190 line:-1
即GET v1/users


241
00:13:10,991 --> 00:13:14,027 line:-1
这将返回我们团队中全部可用的用户


242
00:13:15,162 --> 00:13:17,297 line:-1
现在让我们尝试查找我们要找的用户


243
00:13:17,364 --> 00:13:20,934 line:-2
我们可以通过使用筛选参数
来搜索用户的邮箱地址


244
00:13:21,235 --> 00:13:24,771 line:-2
那么这个邮箱地址的筛选参数
需要指定我们要查找


245
00:13:24,838 --> 00:13:28,175 line:-1
匹配JohnAppleseed@mac.com的用户


246
00:13:28,375 --> 00:13:29,643 line:-1
那么让我们发送这个请求


247
00:13:30,944 --> 00:13:34,448 line:-2
我们获得了一个响应 其中是邮箱为
John Appleseed用户


248
00:13:36,149 --> 00:13:41,488 line:-2
现在让我们使用这个用户的ID
获取这个用户的实例


249
00:13:42,456 --> 00:13:45,459 line:-1
即users/ID


250
00:13:46,326 --> 00:13:49,796 line:-2
这应该会返回用户的实例
并附带匹配ID


251
00:13:51,498 --> 00:13:54,601 line:-2
我们获得了一个用户名为
John Appleseed响应


252
00:13:55,502 --> 00:13:57,237 line:-1
因此我们找到了想要查找的用户


253
00:13:57,504 --> 00:13:59,139 line:-1
让我们尝试移除这个用户


254
00:13:59,206 --> 00:14:02,409 line:-2
通过向这个用户的自链接
发送DELETE请求实现


255
00:14:03,410 --> 00:14:05,946 line:-1
我们会用DELETE替换GET


256
00:14:07,114 --> 00:14:09,483 line:-1
这应该会移除所匹配ID的用户


257
00:14:13,120 --> 00:14:17,090 line:-2
我们就得到了204 意味着
删除成功并且NO CONTENT


258
00:14:17,157 --> 00:14:19,393 line:-1
因为用户的相关内容已经不存在了


259
00:14:20,294 --> 00:14:24,398 line:-2
最后 让我们确认一下
用户确实被删除了


260
00:14:24,464 --> 00:14:25,999 line:-2
通过向自链接
再次发送GET请求实现


261
00:14:27,267 --> 00:14:29,136 line:-1
得到了404 NOT FOUND


262
00:14:29,203 --> 00:14:31,371 line:-1
看来用户确实被移除了


263
00:14:34,575 --> 00:14:37,311 line:-2
在这个演示中
我们了解了如何获取用户集合


264
00:14:37,377 --> 00:14:41,949 line:-2
如何查找用户实例
如何通过使用筛选器搜索用户


265
00:14:42,416 --> 00:14:45,118 line:-2
以及如何通过发送
DELETE请求移除用户


266
00:14:45,786 --> 00:14:48,755 line:-2
这也就总结了
如何结合用户源


267
00:14:49,022 --> 00:14:50,057 line:-1
使用app源连接API


268
00:14:50,457 --> 00:14:52,626 line:-2
我把舞台交还给Geoff
谢谢大家


269
00:14:59,499 --> 00:15:00,334 line:-1
谢谢Sehoon


270
00:15:02,436 --> 00:15:06,773 line:-2
现在你们了解了如何创建
读取、更新和删除


271
00:15:06,840 --> 00:15:09,076 line:-1
全部这些不同的源了 感觉像是


272
00:15:09,142 --> 00:15:11,645 line:-2
全部内容就这些了
这是你能实现的所有功能


273
00:15:11,912 --> 00:15:15,649 line:-2
但这并不是全部
我们还要提一下关系


274
00:15:16,049 --> 00:15:18,051 line:-1
有时候你并不是对单一源


275
00:15:18,118 --> 00:15:19,453 line:-1
最感兴趣


276
00:15:19,520 --> 00:15:21,288 line:-1
而是对它们之间的连接感兴趣


277
00:15:21,889 --> 00:15:25,626 line:-2
给大家个例子 一定会有帮助
一个叫Beta小组的源


278
00:15:25,726 --> 00:15:27,928 line:-2
表示你在TestFlight中的
全部组


279
00:15:28,428 --> 00:15:30,163 line:-2
我们还有一个源
叫做Beta测试人员


280
00:15:30,230 --> 00:15:33,467 line:-2
它表示可以测试
你的app的所有人


281
00:15:33,934 --> 00:15:37,037 line:-2
正如你所了解的
你可以把这些测试人员放到小组中去


282
00:15:37,671 --> 00:15:40,641 line:-2
我们如何在API中
实现这样的操作呢？


283
00:15:41,441 --> 00:15:43,010 line:-2
我们首先要从获取
Beta小组开始


284
00:15:43,410 --> 00:15:47,614 line:-2
执行一个GET v1/beta Groups
然后会返回一个数组


285
00:15:48,015 --> 00:15:49,183 line:-1
若我们看下第一个小组


286
00:15:49,683 --> 00:15:51,852 line:-1
特别是关系部分


287
00:15:52,252 --> 00:15:54,488 line:-1
我们可以看到这个小组有三个关系：


288
00:15:54,555 --> 00:15:57,124 line:-1
app、beta测试人员和构建版本


289
00:15:57,558 --> 00:15:59,493 line:-1
今天只谈Beta测试人员


290
00:15:59,726 --> 00:16:00,928 line:-1
所以我们要打开它


291
00:16:01,728 --> 00:16:03,931 line:-1
我们再次看到了另一个链接部分


292
00:16:04,531 --> 00:16:07,768 line:-2
这些是与这个beta测试人员关系
相关联的链接


293
00:16:07,835 --> 00:16:09,803 line:-1
在列表中的第一个小组


294
00:16:09,970 --> 00:16:12,773 line:-2
数组中的每一个小组
都会有这样的一个部分


295
00:16:13,574 --> 00:16:17,778 line:-2
这里有两个链接
第一个我们叫做关系自链接


296
00:16:18,078 --> 00:16:21,548 line:-1
它是一个URL 表示关系自身


297
00:16:22,649 --> 00:16:26,854 line:-1
我们用这个URL来操作这个关系


298
00:16:27,754 --> 00:16:28,789 line:-1
现在让我来解释一下


299
00:16:29,089 --> 00:16:31,658 line:-2
我们刚才说想在这个小组中
添加测试人员


300
00:16:32,092 --> 00:16:34,494 line:-2
明确下 测试人员
已在TestFlight中


301
00:16:34,862 --> 00:16:36,630 line:-1
该组已在TestFlight中


302
00:16:36,864 --> 00:16:41,034 line:-2
我们希望把这些现有测试人员
放到这个现有小组中


303
00:16:41,535 --> 00:16:44,271 line:-2
这个操作以我们现在所掌握的技术
是不可能实现的


304
00:16:44,338 --> 00:16:46,406 line:-1
如果你仔细想一下的话 对吧


305
00:16:46,473 --> 00:16:49,009 line:-2
就像我们并不创建或编辑
或删除测试人员


306
00:16:49,076 --> 00:16:51,512 line:-1
并且我们也不会真正编辑这个小组


307
00:16:51,578 --> 00:16:53,514 line:-1
至少不会编辑小组的属性


308
00:16:53,947 --> 00:16:57,217 line:-2
那么从概念上说
你可能会说我们要创建新连接


309
00:16:57,284 --> 00:17:00,087 line:-2
在这个小组及其相关
beta测试人员之间


310
00:17:00,287 --> 00:17:02,823 line:-1
这就需要用到关系自链接


311
00:17:03,457 --> 00:17:04,290 line:-1
看起来是这样的


312
00:17:04,358 --> 00:17:07,294 line:-2
我们对关系自链接
执行一个POST请求


313
00:17:08,161 --> 00:17:11,365 line:-2
若你看一下我们所发送的数据
它是两名测试人员的类型和ID对


314
00:17:11,531 --> 00:17:14,501 line:-2
在本例中是指我们要添加到
这个小组中的两名测试人员


315
00:17:15,068 --> 00:17:18,271 line:-2
那么这个请求的意思是
把这两名测试人员放到这个小组中


316
00:17:18,338 --> 00:17:20,007 line:-1
我们无需包含更多测试人员的信息


317
00:17:20,073 --> 00:17:22,009 line:-2
因为测试人员已存在于
TestFlight中


318
00:17:22,476 --> 00:17:26,313 line:-2
如果我们运行它 我们就再次获得
204 NO CONTENT响应


319
00:17:26,480 --> 00:17:29,383 line:-2
也就是API在告诉你
测试人员已经被添加到小组中


320
00:17:30,217 --> 00:17:31,418 line:-1
你们中有些人会想


321
00:17:31,485 --> 00:17:33,887 line:-2
“如果我想把测试人员
从小组中移出来要怎么做呢？”


322
00:17:33,954 --> 00:17:35,822 line:-1
答案是以完全相同的方式来实现


323
00:17:35,889 --> 00:17:38,525 line:-2
要用到同一个URL
要用到同样的数据格式


324
00:17:38,759 --> 00:17:41,461 line:-2
你只需要用DELETE方法
替换POST方法即可


325
00:17:43,564 --> 00:17:47,067 line:-2
再看一下Beta小组
看第二个链接


326
00:17:47,734 --> 00:17:51,104 line:-1
我们把它叫做相关链接


327
00:17:51,505 --> 00:17:54,174 line:-1
这个URL表示实际的相关数据


328
00:17:54,241 --> 00:17:56,176 line:-1
在本例中是指这个小组中的测试人员


329
00:17:56,476 --> 00:17:59,913 line:-2
如果我们执行并获取这个数据
就会获得一个beta测试人员数组


330
00:18:00,180 --> 00:18:01,481 line:0
这里的格式


331
00:18:01,548 --> 00:18:05,752 line:0
与对v1/betaTesters
执行Get时所得到的格式一样


332
00:18:05,886 --> 00:18:08,222 line:0
唯一不同是我们获得的是
这个小组中的测试人员


333
00:18:08,655 --> 00:18:10,891 line:0
而非TestFlight中的
全部测试人员


334
00:18:12,359 --> 00:18:14,795 line:0
我想在这里暂停一下
确保我的意思表达清楚了


335
00:18:15,229 --> 00:18:16,730 line:-1
我们得到了该小组的测试人员


336
00:18:16,797 --> 00:18:20,801 line:-2
当我说“该小组”时 我是指标识符
包含在那个URL中的小组


337
00:18:21,235 --> 00:18:23,303 line:-2
这个URL会获取
一个小组中的测试人员


338
00:18:23,604 --> 00:18:25,973 line:-2
如果我想批量获取
不同小组中的测试人员


339
00:18:26,039 --> 00:18:29,042 line:-2
可以使用这个机制
我得批量执行不同请求


340
00:18:29,376 --> 00:18:31,011 line:-1
有时候会有些不方便


341
00:18:31,478 --> 00:18:33,614 line:-1
所以我们还有一种方式获得相关数据


342
00:18:33,680 --> 00:18:36,283 line:-2
这种方式叫做包含参数
看起来是这样的


343
00:18:36,350 --> 00:18:39,119 line:-2
我们对v1/betaGroups
执行GET方法


344
00:18:39,520 --> 00:18:43,490 line:-2
然后我们添加这个查询参数：
include=betaTesters


345
00:18:43,724 --> 00:18:46,193 line:-2
这就告诉API
当返回beta小组时


346
00:18:46,260 --> 00:18:50,964 line:-2
同时也包含每个小组中
相关测试人员的信息


347
00:18:53,200 --> 00:18:54,101 line:0
它看起来是这样的


348
00:18:54,735 --> 00:18:57,771 line:0
我们获得了beta测试人员数组…
抱歉 应该是beta小组的数组


349
00:18:58,038 --> 00:19:00,307 line:0
如果你查看一下第一个小组中
beta测试人员的关系


350
00:19:00,374 --> 00:19:03,610 line:0
你就会看到一个叫做数据的新部分


351
00:19:04,611 --> 00:19:08,549 line:0
包含这个小组中
所有测试人员的类型和ID对


352
00:19:08,615 --> 00:19:10,217 line:0
现在如果你可以看到这里的整个响应


353
00:19:10,284 --> 00:19:14,087 line:0
你会在每一个beta测试人员
关系内部看到一个这样的数据部分


354
00:19:14,354 --> 00:19:17,624 line:0
在这个数组中的每个小组的内部
对吧


355
00:19:18,192 --> 00:19:19,726 line:-1
这只是包含类型和ID


356
00:19:19,793 --> 00:19:22,095 line:-2
我相信你一定在想
实际的测试人员信息在哪儿


357
00:19:22,362 --> 00:19:25,232 line:0
如果我们一直向下
滚动到这个响应的最后


358
00:19:25,499 --> 00:19:27,568 line:0
我们还会看到一个叫做包含的新部分


359
00:19:28,135 --> 00:19:31,705 line:0
这是一个beta测试人员的数组
附带完整的测试人员信息


360
00:19:32,072 --> 00:19:36,610 line:0
再通俗一点说
包含部分拥有完整的源呈现


361
00:19:36,677 --> 00:19:40,514 line:0
你通过关系所包含的
每一个源的完整呈现


362
00:19:41,081 --> 00:19:43,183 line:0
然后我们按照类型和ID进行匹配


363
00:19:43,417 --> 00:19:46,186 line:0
从而了解哪个测试人员
属于哪个小组


364
00:19:48,021 --> 00:19:49,523 line:-1
你可能在想我们为何要这么做


365
00:19:49,590 --> 00:19:52,025 line:-2
我们有数据部分
其中包括我们的全部小组


366
00:19:52,092 --> 00:19:54,895 line:-2
我们还有包含部分
其中包括包含在内的全部测试人员


367
00:19:55,162 --> 00:19:57,464 line:-2
这么做是出于很重要的原因
屏幕上有这个测试人员


368
00:19:57,531 --> 00:20:01,134 line:-2
John Appleseed
可能属于多个小组 对吧


369
00:20:01,368 --> 00:20:04,037 line:-2
我们构建这个的方式是让
John Appleseed数据


370
00:20:04,104 --> 00:20:05,873 line:-1
在每次响应中只出现一次


371
00:20:05,939 --> 00:20:09,376 line:-2
无论他出现在多少个小组中
明白了吗？


372
00:20:11,311 --> 00:20:13,614 line:-1
好的 Sehoon现在要回到台上


373
00:20:13,680 --> 00:20:16,717 line:-2
给大家演示一些
与关系相关的现实示例


374
00:20:16,783 --> 00:20:17,618 line:-1
Sehoon


375
00:20:23,457 --> 00:20:24,291 line:-1
谢谢Geoff


376
00:20:26,627 --> 00:20:29,296 line:-2
对于这部分的演示
让我们看看TestFlight


377
00:20:29,363 --> 00:20:32,866 line:-2
了解如何创建新的beta小组
和添加外部测试人员


378
00:20:32,933 --> 00:20:35,636 line:-2
并了解一下测试人员
和小组之间的关系


379
00:20:35,903 --> 00:20:37,137 line:-1
让我们看演示吧


380
00:20:46,446 --> 00:20:50,817 line:-2
我们从创建新的beta小组开始
通过公布到beta小组终端实现


381
00:20:50,884 --> 00:20:53,587 line:-1
即v1/betaGroups


382
00:20:54,254 --> 00:20:55,489 line:-1
当我们创建源时


383
00:20:55,556 --> 00:20:58,125 line:-2
我们还需要提供有效负载
看起来是这样的


384
00:20:58,358 --> 00:21:00,260 line:-1
我们的数据包含beta小组的类型


385
00:21:00,327 --> 00:21:01,595 line:-1
和一系列属性


386
00:21:01,995 --> 00:21:03,931 line:-1
因为名称是唯一需要填写的字段


387
00:21:03,997 --> 00:21:05,032 line:-1
当我们创建小组时


388
00:21:05,899 --> 00:21:09,770 line:-2
让我们给它取个名字
我们就叫它测试小组


389
00:21:10,604 --> 00:21:11,772 line:-1
我现在要发送请求了


390
00:21:13,574 --> 00:21:17,244 line:-2
我们得到409 CONFLICT
响应 让我们看看详细信息


391
00:21:18,579 --> 00:21:22,449 line:-2
“在本次请求中
你必须给关联app提供一个值”


392
00:21:22,716 --> 00:21:23,617 line:-1
在TestFlight中


393
00:21:23,684 --> 00:21:27,421 line:-2
你不能创建
不属于任何app的beta小组


394
00:21:27,487 --> 00:21:30,524 line:-2
因此当我们创建beta小组时
必须关联某一个app


395
00:21:31,091 --> 00:21:32,125 line:-1
我们该如何做呢？


396
00:21:32,192 --> 00:21:34,428 line:-1
我们可以在有效负载中包含关系…


397
00:21:36,997 --> 00:21:38,732 line:-2
就像这样 我们现在某个app中的
有效负载中有了关系


398
00:21:38,799 --> 00:21:42,102 line:-1
附带app的数据类型


399
00:21:42,369 --> 00:21:46,206 line:-2
并且ID识别了beta小组
应该链接到哪个app


400
00:21:46,707 --> 00:21:49,343 line:-2
这就会创建名为
测试小组的beta小组


401
00:21:49,409 --> 00:21:51,011 line:-1
并按照ID链接到某app


402
00:21:52,613 --> 00:21:53,981 line:-1
让我们重新发送这个请求


403
00:21:54,948 --> 00:21:56,984 line:-1
得到了201 CREATED响应


404
00:21:57,351 --> 00:21:59,720 line:-1
在响应中 我们有所生成的ID


405
00:21:59,786 --> 00:22:00,988 line:-1
让我们复制这个ID


406
00:22:04,157 --> 00:22:05,993 line:-1
我们刚创建了名为测试小组的小组


407
00:22:06,159 --> 00:22:08,695 line:-2
但若你不喜欢我们刚创建的小组
的名称怎么办呢？


408
00:22:09,463 --> 00:22:11,098 line:-1
我们可以修改现有小组


409
00:22:11,164 --> 00:22:13,867 line:-2
通过向这个小组的自链接
发送PATCH请求实现


410
00:22:15,502 --> 00:22:19,540 line:-2
我们要发送PATCH
然后beta小组/ID


411
00:22:21,909 --> 00:22:25,412 line:-2
我们还需提供有效负载
看起来是这样的


412
00:22:25,846 --> 00:22:30,184 line:-2
看来更像posting的有效负载
但我们还需要提供ID


413
00:22:30,651 --> 00:22:32,653 line:-1
以确保我们修改的是正确数据


414
00:22:34,221 --> 00:22:36,290 line:-1
让我们粘贴beta小组的ID


415
00:22:36,990 --> 00:22:39,526 line:-1
我们唯一需要修改的信息就是名称


416
00:22:39,893 --> 00:22:42,262 line:-1
让我们把它重命名为WWDC小组


417
00:22:44,498 --> 00:22:46,366 line:-1
我要发送请求


418
00:22:46,433 --> 00:22:49,469 line:-2
现在我们得到了一个200响应
看来名称已经更新了


419
00:22:50,737 --> 00:22:54,608 line:-2
现在我们有了想要的小组
让我们开始添加一些外部测试人员


420
00:22:55,242 --> 00:22:59,146 line:-2
要创建测试人员 得向beta
测试人员终端发送POST请求


421
00:23:00,747 --> 00:23:03,684 line:-1
即v1/betaTesters


422
00:23:05,285 --> 00:23:08,488 line:-1
我们还需要提供这样的有效负载


423
00:23:09,256 --> 00:23:12,259 line:-2
它的类型是beta测试人员
它还有一系列的属性


424
00:23:12,326 --> 00:23:14,862 line:-2
我们要创建一名为
Kate Bell的测试人员


425
00:23:15,762 --> 00:23:19,099 line:-1
同时有一个关系是属于beta小组


426
00:23:19,166 --> 00:23:20,901 line:-1
这将创建beta测试人员


427
00:23:20,968 --> 00:23:23,270 line:-1
同时也会分配到beta小组中


428
00:23:24,104 --> 00:23:26,640 line:-2
那么如果你粘贴
我们刚创建的beta小组的ID


429
00:23:27,174 --> 00:23:30,043 line:-2
这会把测试人员分配到
WWDC小组中


430
00:23:32,346 --> 00:23:36,116 line:-2
得到201 CREATED响应
看来测试人员已被创建


431
00:23:36,183 --> 00:23:38,118 line:-1
同时也被分配到了小组中


432
00:23:39,119 --> 00:23:41,288 line:-2
既然我们已在此
让我们再添加一名测试人员


433
00:23:41,688 --> 00:23:44,758 line:-1
我们需要做的是替换这个属性部分


434
00:23:45,425 --> 00:23:46,660 line:-1
替换为另一个人的名字


435
00:23:48,061 --> 00:23:51,265 line:-2
这将会在同一个小组中创建
名为John Appleseed的测试人员


436
00:23:54,601 --> 00:23:57,504 line:-2
我们再次获得了
201 CREATED响应


437
00:23:58,238 --> 00:24:00,207 line:-1
我们刚向小组中添加了两名测试人员


438
00:24:00,807 --> 00:24:04,344 line:-2
现在让我们确认这两名测试人员
确实添加到了小组内


439
00:24:04,411 --> 00:24:05,812 line:-1
通过发送GET请求实现


440
00:24:07,047 --> 00:24:10,584 line:-2
我们要发送到beta小组
和beta测试人员之间的相关链接


441
00:24:11,852 --> 00:24:16,423 line:-1
这个链接/小组ID/betaTesters


442
00:24:17,457 --> 00:24:21,195 line:-2
这将返回分配给beta小组
的全部beta测试人员


443
00:24:21,261 --> 00:24:22,863 line:-1
并附带指定ID


444
00:24:24,865 --> 00:24:28,135 line:-2
你可以看到我们刚才添加的
John Appleseed


445
00:24:29,236 --> 00:24:31,405 line:-1
这个响应包含许多信息


446
00:24:31,471 --> 00:24:34,541 line:-1
包括属性列表以及关系列表


447
00:24:34,875 --> 00:24:37,911 line:-2
但如果你只关心 比如
测试人员的邮箱地址应该怎么办呢？


448
00:24:38,912 --> 00:24:42,649 line:-2
我们可以通过使用一个叫做
字段的特殊参数来削减响应内容


449
00:24:42,916 --> 00:24:45,018 line:-1
这将允许我们削减内容主体


450
00:24:45,085 --> 00:24:47,421 line:-1
我们可以只查看我们想要看到的内容


451
00:24:48,322 --> 00:24:53,293 line:-2
如果你执行beta测试人员的
字段等于邮箱地址…


452
00:24:55,028 --> 00:24:58,565 line:-2
正如你所看到的
现在响应中只包含用户的邮箱地址


453
00:24:58,632 --> 00:24:59,533 line:-1
没有其它内容


454
00:25:00,300 --> 00:25:03,437 line:-2
我们在这个beta小组中
添加了两名测试人员


455
00:25:10,010 --> 00:25:14,181 line:-2
在这个演示中 我们了解了如何创建
beta小组和beta测试人员


456
00:25:14,248 --> 00:25:16,783 line:-1
也了解了测试人员和小组间的关系


457
00:25:17,251 --> 00:25:18,385 line:-1
这就总结了演示


458
00:25:18,452 --> 00:25:21,088 line:-2
如何通过TestFlight
使用App Store Connect API


459
00:25:21,154 --> 00:25:23,257 line:-1
我要把舞台交还给Geoff 谢谢


460
00:25:29,897 --> 00:25:31,732 line:-1
再次感谢Sehoon 非常棒


461
00:25:32,633 --> 00:25:33,467 line:-1
那么…


462
00:25:34,902 --> 00:25:37,905 line:-1
这就是获取数据、修改数据和关系


463
00:25:37,971 --> 00:25:40,174 line:-1
这就是API的基本功能


464
00:25:40,507 --> 00:25:42,509 line:-2
但正如你在Sehoon的
演示中所见


465
00:25:42,876 --> 00:25:46,013 line:-2
有时候你会犯错误
导致我们不能处理你的请求


466
00:25:46,213 --> 00:25:47,281 line:-1
我们现在要谈点别的


467
00:25:47,347 --> 00:25:51,084 line:-1
谈谈API如何把这些报错传回给你


468
00:25:52,152 --> 00:25:55,222 line:-2
任何时候当请求失败时
你都会得到一个这样的响应


469
00:25:56,523 --> 00:25:57,958 line:-1
现在要注意的第一件事


470
00:25:58,358 --> 00:26:01,595 line:-2
就是我们会发送一个
适当的HTTP响应状态


471
00:26:01,895 --> 00:26:05,065 line:-2
表明发生了什么错误
通常是400系列


472
00:26:05,132 --> 00:26:06,500 line:-1
一般来说你只需要得到这个


473
00:26:06,567 --> 00:26:10,771 line:-2
大部分REST客户端函数库都有
Did Succeed或It Is Success函数


474
00:26:10,838 --> 00:26:11,805 line:-1
你可以调用它


475
00:26:11,872 --> 00:26:15,242 line:-1
它会准确地告诉你请求是否成功


476
00:26:15,909 --> 00:26:17,644 line:-1
但若你想了解更多关于报错的信息


477
00:26:17,711 --> 00:26:19,813 line:-1
你可以分析一下响应


478
00:26:19,880 --> 00:26:22,382 line:-2
请求失败后 不会看到那个
总能看到的数据属性


479
00:26:22,449 --> 00:26:25,452 line:-1
而会看到一个报错的属性


480
00:26:25,519 --> 00:26:29,323 line:-2
它是报错对象的一个数组
因此可能会有多个报错对象


481
00:26:29,389 --> 00:26:32,526 line:-2
每一个都代表
你所发送请求的某个问题


482
00:26:33,427 --> 00:26:35,662 line:-2
每个报错对象
都有一个ID 可以唯一识别


483
00:26:35,729 --> 00:26:38,632 line:-2
这个特定的报错
在这个特定的响应中


484
00:26:38,699 --> 00:26:41,668 line:-2
你可能会把它存起来
如果你认为这是我们这端的问题


485
00:26:41,735 --> 00:26:43,737 line:-2
请把它发送给我们
它会帮助我们进行追踪


486
00:26:44,438 --> 00:26:47,074 line:-1
对你来说更有用的是标题和详情


487
00:26:47,474 --> 00:26:50,310 line:-1
这两者给你提供了一个英文语言解释


488
00:26:50,377 --> 00:26:53,347 line:-2
关于发生了什么错误
从这个标题中 我可以看到


489
00:26:53,413 --> 00:26:54,515 line:-1
参数出了一些问题


490
00:26:54,948 --> 00:26:58,485 line:-2
从详情中我了解到
我通过邮箱地址进行筛选


491
00:26:58,552 --> 00:27:00,787 line:-2
然后立即看到了
邮箱地址拼写不正确


492
00:27:01,255 --> 00:27:04,691 line:-2
这些都是很棒的值
你可以记录下来并在解决问题


493
00:27:04,758 --> 00:27:05,993 line:-1
和学习API过程中使用


494
00:27:06,994 --> 00:27:08,896 line:-1
但你一定不想在代码中用到它们


495
00:27:08,962 --> 00:27:10,898 line:-1
你不想用这些来中断你的编码


496
00:27:11,164 --> 00:27:13,200 line:-1
我并不能做出任何承诺说未经允许


497
00:27:13,267 --> 00:27:15,736 line:-1
我们不会修改这些信息中的文字


498
00:27:17,037 --> 00:27:21,008 line:-2
对于程序性报错处理
你得使用代码属性


499
00:27:21,341 --> 00:27:24,978 line:-2
这是一个稳定的机器可读字符串
表示发生了哪些错误


500
00:27:25,345 --> 00:27:29,550 line:-2
它有一个分层的值
在特定等级之间用点隔开


501
00:27:29,616 --> 00:27:32,753 line:-2
那么在本例中
我可以看到我有一个参数报错


502
00:27:32,819 --> 00:27:35,822 line:-2
通常更具体地说
其中一个参数是无效的


503
00:27:36,557 --> 00:27:39,059 line:-1
现在这些代码可以变得很长、很精确


504
00:27:39,593 --> 00:27:41,929 line:-1
有时候你并不关心精确度


505
00:27:41,995 --> 00:27:44,598 line:-2
事实上你通常不会这样做
所以我们这样构建它们


506
00:27:44,665 --> 00:27:47,668 line:-2
从而你可以在代码中执行前缀匹配
可以是模糊匹配


507
00:27:47,734 --> 00:27:51,205 line:-1
或是精确匹配 取决于你自己的用例


508
00:27:51,772 --> 00:27:53,106 line:-1
但如果你需要精确匹配


509
00:27:53,173 --> 00:27:55,375 line:-1
比如 你可以报告返回你自己的用户


510
00:27:55,442 --> 00:27:57,010 line:-1
并附带发生了哪些错误的清晰说明


511
00:27:57,077 --> 00:27:59,346 line:-1
我们尽量给你们足够的信息


512
00:28:00,013 --> 00:28:02,950 line:-1
我们还通过源参数来提供帮助


513
00:28:03,884 --> 00:28:07,087 line:-2
无论何时只要可能
我们都会在请求中追踪


514
00:28:07,154 --> 00:28:08,555 line:-1
导致问题发生的报错所在的位置


515
00:28:08,622 --> 00:28:11,325 line:-2
在这里我可以看到
筛选器括号邮箱地址参数


516
00:28:11,391 --> 00:28:13,460 line:-1
就是它产生了这个报错


517
00:28:13,994 --> 00:28:17,364 line:-2
源可以是这样的一个参数
或者也可以是一个JSON指针


518
00:28:17,431 --> 00:28:21,702 line:-2
在你发送给我们的JSON数据中
指出问题所发生的位置


519
00:28:23,403 --> 00:28:25,472 line:-1
这就是你所要了解的


520
00:28:25,539 --> 00:28:29,209 line:-2
关于App Store Connect API
除了如何获取App Store Connect API


521
00:28:29,276 --> 00:28:30,777 line:-1
和成功发送请求外的全部信息


522
00:28:30,844 --> 00:28:34,715 line:-2
Julie Richards
将上台帮助你们了解这两块内容


523
00:28:35,749 --> 00:28:36,583 line:-1
Julie


524
00:28:42,089 --> 00:28:42,923 line:-1
谢谢


525
00:28:45,425 --> 00:28:47,127 line:-1
大家好 我是Julie


526
00:28:47,194 --> 00:28:49,630 line:-2
我是App Store Connect团队
的工程师


527
00:28:50,197 --> 00:28:53,534 line:-2
今天我在这里要跟大家谈谈
权限和验证


528
00:28:54,501 --> 00:28:59,006 line:-1
在这点上 你们已经看到了许多


529
00:28:59,072 --> 00:29:00,140 line:-1
可用的终端的例子


530
00:29:00,674 --> 00:29:03,844 line:-1
当你准备好测试你的某些新功能时


531
00:29:04,344 --> 00:29:07,881 line:-2
你首先可能会发送一个
这样的简单GET请求：


532
00:29:08,882 --> 00:29:12,085 line:-2
然而 如果你只是要
curl这个终端


533
00:29:12,152 --> 00:29:13,954 line:-1
或把它键入到你的浏览器中


534
00:29:14,354 --> 00:29:17,124 line:-1
你最终将得到一个这样的响应


535
00:29:18,425 --> 00:29:22,863 line:-2
正如Geoff所提到的
我们仍缺少一个非常重要的步骤


536
00:29:23,197 --> 00:29:25,933 line:-1
那就是验证证书


537
00:29:27,568 --> 00:29:30,737 line:-1
现在这个步骤很有必要 原因有两点


538
00:29:31,505 --> 00:29:36,009 line:-2
第一 验证证书
可以给你的请求提供情境


539
00:29:36,143 --> 00:29:39,947 line:-2
毕竟你并不想要全部app
你只想要你的app


540
00:29:40,514 --> 00:29:44,718 line:-2
最重要的是这些证书
可以保证API的安全


541
00:29:45,185 --> 00:29:48,822 line:-2
并确保除你之外
没有别人能获取你的数据


542
00:29:50,924 --> 00:29:54,127 line:-1
要在你的请求中添加这些证书


543
00:29:54,194 --> 00:29:57,231 line:-1
你首先需要创建一个API钥匙


544
00:29:57,731 --> 00:29:59,733 line:-1
然后你要使用那个钥匙


545
00:29:59,800 --> 00:30:05,138 line:-2
生成令牌
然后在每次请求时都要发送那些令牌


546
00:30:05,873 --> 00:30:08,008 line:-1
让我们从API钥匙开始说


547
00:30:09,943 --> 00:30:13,447 line:-2
每个钥匙实际上是一个
公共钥匙和私人密钥对


548
00:30:14,982 --> 00:30:17,084 line:-1
私人密钥属于你


549
00:30:17,150 --> 00:30:20,287 line:-1
用于向令牌中添加唯一署名


550
00:30:22,256 --> 00:30:27,461 line:-2
公共钥匙将用于
由Apple认证署名并确保


551
00:30:27,528 --> 00:30:30,964 line:-1
它是由相关联的私人密钥所签署


552
00:30:33,567 --> 00:30:37,971 line:-2
要创建一个钥匙 你需登录
App Store Connect


553
00:30:38,038 --> 00:30:41,742 line:-1
并导航到一个新的API钥匙标签


554
00:30:42,809 --> 00:30:47,514 line:-2
你的管理员用户
可以管理你团队中的API钥匙


555
00:30:47,915 --> 00:30:51,919 line:-2
你可以创建新钥匙 若有些钥匙
不再需要你可以撤销它


556
00:30:53,720 --> 00:30:58,959 line:-2
每个钥匙都需要被分配
一个权限等级 这将决定


557
00:30:59,026 --> 00:31:01,828 line:-1
钥匙可以用于哪种API服务


558
00:31:03,697 --> 00:31:08,769 line:-2
一旦创建 新钥匙会出现在此列表中
并且私人密钥文件


559
00:31:08,836 --> 00:31:12,406 line:-1
这是属于你的部分 也可以下载了


560
00:31:13,674 --> 00:31:15,342 line:-1
有一个重点需要注意


561
00:31:15,409 --> 00:31:19,046 line:-1
每个私人密钥只能下载一次


562
00:31:19,980 --> 00:31:22,850 line:-1
因为Apple不会存储这些钥匙


563
00:31:23,317 --> 00:31:26,253 line:-1
事实上 你的钥匙


564
00:31:26,320 --> 00:31:29,122 line:-1
甚至在你决定下载它之前还没有生成


565
00:31:30,190 --> 00:31:32,960 line:-2
因此你可以认为
这些钥匙跟真正的钥匙一样


566
00:31:33,460 --> 00:31:37,731 line:-2
它们属于你
而且你必须管理和保护它们


567
00:31:39,366 --> 00:31:41,468 line:-1
同样跟实际的钥匙一样


568
00:31:42,536 --> 00:31:44,338 line:-1
这些钥匙不会过期


569
00:31:44,771 --> 00:31:48,709 line:-2
因此如果钥匙丢了或被盗了
它将继续拥有


570
00:31:48,775 --> 00:31:52,913 line:-2
对数据的权限 除非通过
App Store Connect撤销钥匙


571
00:31:53,480 --> 00:31:57,784 line:-2
为此 保证钥匙的安全
和稳妥非常重要


572
00:31:59,186 --> 00:32:01,522 line:-1
一旦你获得了私人密钥文件


573
00:32:02,089 --> 00:32:04,992 line:-2
你就可以立即开始生成
JSON网络令牌了


574
00:32:05,893 --> 00:32:09,730 line:-1
现在每一个令牌都需要包含一些信息


575
00:32:10,898 --> 00:32:15,669 line:-2
首先 你需要添加发行者ID
也就是你的账户标识符


576
00:32:15,969 --> 00:32:19,473 line:-1
你可以从新页面的顶部找到这个ID


577
00:32:21,241 --> 00:32:25,145 line:-1
你还需要添加钥匙的ID


578
00:32:25,746 --> 00:32:29,850 line:-2
你也可以从这个新页面上
找到这个ID


579
00:32:30,350 --> 00:32:33,320 line:-1
它只针对你所使用的钥匙


580
00:32:36,256 --> 00:32:39,259 line:-1
每个令牌还将需要一个到期时间戳


581
00:32:39,493 --> 00:32:40,961 line:-1
正如我之前所提到的那样


582
00:32:41,028 --> 00:32:46,366 line:-2
你的钥匙不会过期
但这些令牌至多只能使用20分钟


583
00:32:47,334 --> 00:32:51,405 line:-1
最后这两个信息都是常量


584
00:32:52,105 --> 00:32:55,843 line:-2
我的意思是在全部令牌
和全部App Store Connect API中


585
00:32:55,909 --> 00:32:58,846 line:-1
它们会保持一样的值


586
00:32:59,146 --> 00:33:03,951 line:-2
第一个是令牌的观众
永远是App Store Connect


587
00:33:05,419 --> 00:33:11,058 line:-1
最后 你需要分配或添加算法


588
00:33:11,124 --> 00:33:12,793 line:-1
用于签署令牌


589
00:33:13,126 --> 00:33:16,563 line:-1
为此我们选择使用ES256


590
00:33:17,431 --> 00:33:21,301 line:-2
现在这个算法相对应的是一个
由JWT支持的算法


591
00:33:21,602 --> 00:33:23,604 line:-1
这是我们选择让你们使用的一个算法


592
00:33:23,904 --> 00:33:27,508 line:-1
但不用担心 你不需要实施这个算法


593
00:33:28,242 --> 00:33:31,945 line:-1
很幸运的是 JWT提供多个函数库


594
00:33:32,012 --> 00:33:34,281 line:-1
事实上涵盖了任何一种语言


595
00:33:34,348 --> 00:33:37,885 line:-2
使得创建和签署这些令牌
变得尽可能简单


596
00:33:39,319 --> 00:33:44,057 line:-2
我后面的这个例子是用Ruby写的
正如你所看到的


597
00:33:44,124 --> 00:33:48,662 line:-2
我要做的就是传递私人密钥的同时
也传递这些信息


598
00:33:48,729 --> 00:33:52,533 line:-2
这个编码方法会返回给我
一个完整的、已签署的令牌


599
00:33:53,967 --> 00:33:57,504 line:-2
然后你就可以把那个令牌
添加到我的请求中


600
00:33:57,571 --> 00:34:01,074 line:-1
只需要把它放在一个验证标题内即可


601
00:34:03,911 --> 00:34:09,149 line:-2
现在我们了解了如何创建这些钥匙
以及如何使用这些钥匙


602
00:34:09,216 --> 00:34:13,654 line:-2
向我们的请求中添加令牌
让我们继续 尝试一下


603
00:34:23,130 --> 00:34:25,831 line:-1
好的 这是那个新API钥匙的页面


604
00:34:26,266 --> 00:34:28,034 line:-1
我还没有钥匙


605
00:34:28,534 --> 00:34:30,103 line:-1
那么我要继续并创建一个钥匙


606
00:34:31,471 --> 00:34:34,908 line:-2
我把它命名为演示
并且我得分配一个权限等级


607
00:34:35,576 --> 00:34:38,045 line:-1
在这里 如果我要选择 比如财务


608
00:34:38,679 --> 00:34:43,116 line:-2
我就会得到拥有诸如财务报告
或销售报告这样权限的钥匙


609
00:34:43,183 --> 00:34:47,754 line:-2
但它不会有诸如beta测试人员
或创建者这样的权限


610
00:34:48,155 --> 00:34:52,391 line:-1
我可以添加权限等级或选择管理员


611
00:34:52,525 --> 00:34:55,161 line:-2
那样我就得到一个
能获取全部API权限的钥匙


612
00:34:55,629 --> 00:34:58,665 line:-2
所以我坚持分配给它一个管理员权限
当我生成我的钥匙时


613
00:34:59,566 --> 00:35:03,136 line:-2
我可以看到
我的私人密钥已经可以下载了


614
00:35:04,271 --> 00:35:08,509 line:-2
正如我刚才提到的那样
我的私人密钥只能下载一次


615
00:35:09,109 --> 00:35:11,345 line:-1
如果我丢了钥匙或意外删除了它


616
00:35:11,411 --> 00:35:13,480 line:-1
我不能再从这里重新下载它


617
00:35:13,947 --> 00:35:15,015 line:-1
那么为此


618
00:35:15,082 --> 00:35:18,318 line:-2
我一定要确保
我现已准备好下载它了


619
00:35:19,253 --> 00:35:21,488 line:-1
我准备好了 那么让我们继续并下载


620
00:35:23,223 --> 00:35:26,059 line:-2
现在我的下载文件夹中已经有了
我的私人密钥


621
00:35:26,827 --> 00:35:29,029 line:-1
我可以拉动我们刚才看到的那个脚本


622
00:35:29,863 --> 00:35:33,166 line:-1
我需要复制发行者ID


623
00:35:37,871 --> 00:35:40,674 line:-2
这是在你的API钥匙中
共享的一个ID


624
00:35:41,041 --> 00:35:45,679 line:-2
并且我还需要复制
我刚才下载的私人密钥ID


625
00:35:49,816 --> 00:35:51,685 line:-1
一旦搞好这些ID


626
00:35:51,752 --> 00:35:55,422 line:-2
就会从我的下载文件夹中
加载我的私人密钥


627
00:35:55,489 --> 00:35:57,124 line:-1
我要生成一个新令牌


628
00:35:58,458 --> 00:36:01,361 line:-1
如果我拉起终端


629
00:36:02,296 --> 00:36:04,331 line:-1
我可以curl那个app终端


630
00:36:06,133 --> 00:36:09,603 line:-2
正如我们预计的那样
我们得到了那个401响应


631
00:36:10,237 --> 00:36:12,139 line:-1
因此让我们调用我的脚本


632
00:36:18,078 --> 00:36:19,379 line:-1
我得到了一个新令牌


633
00:36:20,113 --> 00:36:25,419 line:-2
因此我可以把那个令牌
添加到我的请求中…


634
00:36:29,256 --> 00:36:33,727 line:-2
通过把它放在一个验证标题中
确定我拼写无误


635
00:36:38,332 --> 00:36:40,200 line:-1
然后我得到了app列表


636
00:36:45,672 --> 00:36:49,042 line:-2
正如你所看到的
仅仅通过几个简单的步骤


637
00:36:49,109 --> 00:36:53,447 line:-2
我就能获取API的权限
并开始返回真实数据


638
00:36:54,047 --> 00:36:55,482 line:-1
谢谢 舞台交给Geoff


639
00:37:02,589 --> 00:37:03,590 line:-1
好的 谢谢Julie


640
00:37:04,591 --> 00:37:05,492 line:-1
很酷 对吗？


641
00:37:06,460 --> 00:37:08,729 line:-1
这就是权限和验证


642
00:37:08,996 --> 00:37:10,631 line:-1
现在还剩下几分钟时间


643
00:37:10,697 --> 00:37:13,367 line:-1
我想谈谈API的一些最佳使用范例


644
00:37:14,368 --> 00:37:17,237 line:-2
我们要从那些钥匙说起
正如Julie所说的


645
00:37:17,304 --> 00:37:20,474 line:-2
那些钥匙属于你
保护它们是你的职责


646
00:37:20,541 --> 00:37:23,143 line:-2
无论是谁 只要拥有钥匙
就能获取你的数据


647
00:37:23,477 --> 00:37:27,314 line:-2
因此理想地说 你要把钥匙
放在一个安全的钥匙商店中


648
00:37:27,381 --> 00:37:29,116 line:-1
你的代码要在外面进行查看


649
00:37:29,183 --> 00:37:33,320 line:-2
并在存储器中使用 永远不要把它们
存在任何地方 如数据库或磁盘


650
00:37:33,654 --> 00:37:35,455 line:-1
如果你必须把钥匙存储在磁盘上


651
00:37:35,789 --> 00:37:38,559 line:-2
请确保你非常认真地检查了
文件系统的权限


652
00:37:39,026 --> 00:37:41,929 line:-2
当然 如果你有任何理由认为
钥匙被盗用了


653
00:37:41,995 --> 00:37:46,033 line:-2
请立即登录App Store Connect
并撤销那个钥匙


654
00:37:47,467 --> 00:37:50,904 line:-1
我还想谈谈你从钥匙中创建的令牌


655
00:37:50,971 --> 00:37:53,073 line:-1
现在没有任何理由


656
00:37:53,140 --> 00:37:54,308 line:-2
要求你在每次请求时
发送一个不同的令牌


657
00:37:54,374 --> 00:37:57,578 line:-2
事实上 你会在代码中和我们这端
获得更好的性能


658
00:37:57,644 --> 00:38:00,113 line:-1
如果你不断重复使用那些令牌


659
00:38:00,514 --> 00:38:02,182 line:-1
通常这是一件很简单的事 对吧


660
00:38:02,249 --> 00:38:04,718 line:-1
你只需要在脚本顶部生成一个令牌


661
00:38:04,785 --> 00:38:06,954 line:-1
在每次请求时发送令牌 直到完成


662
00:38:07,287 --> 00:38:11,258 line:-2
我们可以让你控制到期时间
因为你是最了解


663
00:38:11,325 --> 00:38:14,294 line:-2
它应该持续多久的人
这些时间足够完成那个进程


664
00:38:14,361 --> 00:38:16,530 line:-1
并且不会比所需要的时间长太多


665
00:38:17,865 --> 00:38:20,667 line:-2
当然 有些进程的执行
可能会超过20分钟


666
00:38:20,734 --> 00:38:22,736 line:-2
或需要连续不断地运行
如果是这种情况


667
00:38:22,803 --> 00:38:24,638 line:-1
你在编码结构上要有一点不一样了


668
00:38:25,205 --> 00:38:28,509 line:-2
也许你会生成一个20分钟的令牌
并根据需要使用它


669
00:38:28,942 --> 00:38:31,912 line:-2
然后把它丢掉并在旧令牌到期之前
分配一个新令牌


670
00:38:31,979 --> 00:38:33,247 line:-1
比如 每18分钟换一次


671
00:38:33,547 --> 00:38:35,382 line:-1
那样你会最大程度上重复使用令牌


672
00:38:35,449 --> 00:38:38,685 line:-2
从而获得最佳性能
并且你永远不会发送过期令牌


673
00:38:40,721 --> 00:38:41,989 line:-1
接下来我要谈的是


674
00:38:42,055 --> 00:38:43,824 line:-1
响应中所包含的链接


675
00:38:44,224 --> 00:38:45,559 line:-1
今天我们谈到了这些


676
00:38:45,626 --> 00:38:48,128 line:-1
作为自文档的一种漂亮的形式


677
00:38:48,195 --> 00:38:51,231 line:-2
一种可以让你查看数据并了解
还有什么其它可用东西的方法


678
00:38:51,298 --> 00:38:52,799 line:-1
但这并不是唯一原因


679
00:38:52,933 --> 00:38:55,903 line:-1
实际上你的代码可以使用它们


680
00:38:56,303 --> 00:38:59,540 line:-2
当你执行多步骤进程时
无论何时只要有可能


681
00:38:59,606 --> 00:39:01,675 line:-1
请把我提供的链接从响应中拿出来


682
00:39:01,742 --> 00:39:04,011 line:-1
并把它用在进程的下一个部分


683
00:39:04,244 --> 00:39:06,980 line:-1
这有两个好处 一是它会让你的代码


684
00:39:07,047 --> 00:39:10,117 line:-1
对于API的不同部分变得更加通用


685
00:39:10,350 --> 00:39:13,453 line:-2
二是当v2 API
不可避免地出现时


686
00:39:13,520 --> 00:39:17,224 line:-1
会减少你调整和修改代码的工作量


687
00:39:18,392 --> 00:39:20,694 line:-1
最后我想谈谈文档


688
00:39:22,029 --> 00:39:24,631 line:-1
我们今天提到过这个API的一致性


689
00:39:24,698 --> 00:39:27,134 line:-2
我们非常关心这个问题
因此任何时候如果一个源


690
00:39:27,201 --> 00:39:31,104 line:-2
可以做些什么
它将会以与其它源同样的方式来做


691
00:39:31,505 --> 00:39:34,241 line:-2
但是 当然了
并不是每个源都能实现一切


692
00:39:34,575 --> 00:39:36,310 line:-2
你已看到一个例子
就是用户的例子


693
00:39:36,376 --> 00:39:39,479 line:-2
我们必须创建一个邀请
没有API能创建用户


694
00:39:39,847 --> 00:39:41,782 line:-1
因此文档是你了解这些信息的资源


695
00:39:41,849 --> 00:39:44,084 line:-1
它会告诉你源可以做什么


696
00:39:44,151 --> 00:39:47,654 line:-2
有哪些可用的操作
它支持哪些参数等等


697
00:39:49,256 --> 00:39:50,924 line:-1
这就是App Store Connect API


698
00:39:51,325 --> 00:39:53,727 line:-1
它是一致的标准REST API


699
00:39:54,027 --> 00:39:58,031 line:-2
我们对此感到非常激动
关于这个API我很喜欢的一件事


700
00:39:58,098 --> 00:40:00,267 line:-1
就是我们对它的设计非常灵活


701
00:40:00,334 --> 00:40:04,271 line:-2
你可以把App Store Connect
以你需要的方式


702
00:40:04,338 --> 00:40:07,641 line:-2
放到你的工作流程中
并使用你最喜欢的工具


703
00:40:07,875 --> 00:40:09,743 line:-1
我们真的非常期待你们的成果


704
00:40:10,143 --> 00:40:12,579 line:-1
这个夏天所有app开发者都能用到它


705
00:40:13,747 --> 00:40:15,716 line:0
我知道你们大家一定会有问题


706
00:40:15,782 --> 00:40:18,252 line:0
请到我们的App Store Connect
实验室面谈 现在就可以来


707
00:40:18,318 --> 00:40:20,220 line:0
演讲结束后 我就会去那里


708
00:40:20,287 --> 00:40:21,522 line:0
我们可以回答你们的问题


709
00:40:21,588 --> 00:40:23,891 line:0
我们明天下午1点也有一个实验室


710
00:40:24,258 --> 00:40:26,593 line:0
请大家同时了解一下
“App Store Connect新特性”的演讲


711
00:40:26,660 --> 00:40:27,694 line:0
如果你昨天没去参加


712
00:40:28,095 --> 00:40:31,465 line:0
它讲了更多关于API
和App Store Connect的相关信息


713
00:40:31,932 --> 00:40:34,635 line:0
请收藏这个链接
我们很快


714
00:40:34,701 --> 00:40:35,903 line:0
会在这里发布文档


715
00:40:36,436 --> 00:40:38,305 line:0
谢谢大家 稍后在实验室见

