1
00:00:07,516 --> 00:00:16,500
[ 音乐 ]


2
00:00:19,296 --> 00:00:20,086
>> 大家好


3
00:00:20,226 --> 00:00:21,616
我叫 Jeremy 是


4
00:00:21,616 --> 00:00:23,366
tvOS 团队的一名工程师


5
00:00:23,866 --> 00:00:25,066
今天 我很高兴


6
00:00:25,066 --> 00:00:26,586
能与大家分享


7
00:00:26,586 --> 00:00:29,236
tvOS 12 中 TVMLKit 的新内容


8
00:00:29,776 --> 00:00:32,706
如果你不熟悉 TVMLKit


9
00:00:32,706 --> 00:00:34,366
这是 Apple 的一个高级框架 


10
00:00:34,366 --> 00:00:37,506
可以快速构建基于内容的 tvOS App


11
00:00:38,016 --> 00:00:39,826
它无需额外设置 就已经


12
00:00:39,826 --> 00:00:41,416
符合我们的 Human Interface Guidelines


13
00:00:41,766 --> 00:00:42,996
让你的 App 外表


14
00:00:42,996 --> 00:00:44,776
美观 体验合理


15
00:00:45,536 --> 00:00:47,406
TVMLKit 使用 JavaScript 来驱动


16
00:00:47,406 --> 00:00:49,526
App 逻辑 还使用了一种


17
00:00:49,526 --> 00:00:51,226
基于 XML 的标记（markup）语言


18
00:00:51,226 --> 00:00:53,876
按照你的规定 渲染成


19
00:00:53,876 --> 00:00:55,326
屏幕上的用户界面（UI）


20
00:00:57,226 --> 00:00:59,346
其实 大家熟知的


21
00:00:59,346 --> 00:01:01,996
一些常用 App 就是


22
00:01:01,996 --> 00:01:03,216
用 TVMLKit 构建的


23
00:01:04,146 --> 00:01:06,336
此外 还有数千款 App Store 中的 App


24
00:01:06,336 --> 00:01:07,046
也是如此


25
00:01:09,006 --> 00:01:10,706
我们先来谈谈


26
00:01:10,706 --> 00:01:12,006
我们为 TVMLKit


27
00:01:12,006 --> 00:01:14,046
进行的改进 我今天


28
00:01:14,306 --> 00:01:15,606
想先谈谈其中的三点


29
00:01:16,336 --> 00:01:18,176
首先 我们改进了


30
00:01:18,176 --> 00:01:20,006
网页检查器（Web Inspector） 


31
00:01:20,006 --> 00:01:22,816
方便你更好地找出 App 中的错误 并深入


32
00:01:23,116 --> 00:01:24,446
地进行分析


33
00:01:26,056 --> 00:01:28,716
去年以来 我们添加了许多新特性 并做了许多改进


34
00:01:28,716 --> 00:01:29,986
以改善 TVMLKit 的框架


35
00:01:30,196 --> 00:01:32,676
今天 我会讲到其中三点


36
00:01:32,676 --> 00:01:34,936
我们会提到


37
00:01:34,936 --> 00:01:37,006
全新的网页检查器


38
00:01:37,006 --> 00:01:39,506
它改进了调试过程


39
00:01:39,506 --> 00:01:41,176
更新了功能更为强大的


40
00:01:41,176 --> 00:01:42,416
数据绑定构建


41
00:01:43,026 --> 00:01:45,716
并添加了全新的自定义 TVMLKit 上播放


42
00:01:45,716 --> 00:01:47,196
体验的方法


43
00:01:47,786 --> 00:01:50,446
我们先来谈谈网页检查器


44
00:01:50,876 --> 00:01:53,156
tvOS 11 加强了对


45
00:01:53,156 --> 00:01:54,466
网页检查器的支持 能够


46
00:01:54,466 --> 00:01:56,156
让你进一步分析


47
00:01:56,156 --> 00:01:57,236
使用 TVMLKit 的 App


48
00:01:57,966 --> 00:01:59,506
自此 我们进一步增强了


49
00:01:59,506 --> 00:02:01,976
这方面的支持


50
00:02:02,476 --> 00:02:05,596
tvOS 11.3 中 除了可以


51
00:02:05,596 --> 00:02:06,996
在元素中显示注册


52
00:02:06,996 --> 00:02:08,616
事件监听器 现在你也可以


53
00:02:08,616 --> 00:02:09,886
暂时将其禁用


54
00:02:10,985 --> 00:02:13,166
这对调试很有帮助


55
00:02:13,166 --> 00:02:14,456
因为现在你可以随意启用


56
00:02:14,456 --> 00:02:16,166
或禁用事件处理器了


57
00:02:20,436 --> 00:02:22,476
在网络标签页下


58
00:02:22,476 --> 00:02:23,516
XHR 中除了文稿资源


59
00:02:23,516 --> 00:02:25,416
还有图像资源


60
00:02:25,806 --> 00:02:27,206
这样 你就可以看到


61
00:02:27,206 --> 00:02:29,336
正在加载的图像


62
00:02:29,336 --> 00:02:30,576
以及其他信息 例如


63
00:02:30,576 --> 00:02:32,436
加载耗时 以及时间分配的情况


64
00:02:32,946 --> 00:02:35,806
如果你想看到


65
00:02:35,806 --> 00:02:37,076
实际传输的


66
00:02:37,076 --> 00:02:40,236
图像 你可以使用这一功能


67
00:02:40,746 --> 00:02:42,206
但请注意


68
00:02:42,206 --> 00:02:43,386
你必须先


69
00:02:43,386 --> 00:02:45,206
打开网页检查器


70
00:02:45,806 --> 00:02:47,026
因为它不能显示


71
00:02:47,026 --> 00:02:47,876
已加载的图像


72
00:02:49,636 --> 00:02:51,496
最后 也是我


73
00:02:51,496 --> 00:02:53,086
最喜欢的特性 就是


74
00:02:53,086 --> 00:02:53,396
检查按钮


75
00:02:54,176 --> 00:02:55,596
点击之后 就会显示


76
00:02:55,596 --> 00:02:56,916
当前关注的视图中


77
00:02:56,916 --> 00:02:59,186
所包含的临近元素


78
00:03:00,946 --> 00:03:02,576
如果你的元素树为收起状态


79
00:03:03,036 --> 00:03:05,156
网页检查器会将其展开


80
00:03:05,156 --> 00:03:07,016
找出具体元素 并高亮显示


81
00:03:09,596 --> 00:03:11,966
要使用网页检查器 你可以


82
00:03:11,966 --> 00:03:13,636
下载并安装 macOS 的


83
00:03:13,636 --> 00:03:15,616
最新版本 或安装


84
00:03:15,616 --> 00:03:16,966
Safari 技术预览版


85
00:03:17,796 --> 00:03:19,176
欲知更多关于使用


86
00:03:19,176 --> 00:03:21,406
网页检查器的信息 可以


87
00:03:21,406 --> 00:03:23,296
观看我们去年的关于


88
00:03:23,296 --> 00:03:24,876
通过 tvOS App 来使用网页检查器的演讲


89
00:03:28,516 --> 00:03:30,636
接下来 我们谈谈数据绑定


90
00:03:33,696 --> 00:03:35,176
在我们谈到


91
00:03:35,176 --> 00:03:36,646
具体的新特性之前


92
00:03:36,766 --> 00:03:38,566
我先来大概介绍一下数据绑定


93
00:03:39,236 --> 00:03:40,576
数据绑定借助


94
00:03:40,576 --> 00:03:42,746
模板标记文件中的


95
00:03:42,746 --> 00:03:44,346
表达式 帮你将


96
00:03:44,346 --> 00:03:46,166
数据轻松转化为 UI 元素


97
00:03:47,356 --> 00:03:48,876
这很重要 因为


98
00:03:48,876 --> 00:03:50,706
这可以让数据


99
00:03:50,906 --> 00:03:52,066
与布局逻辑


100
00:03:52,066 --> 00:03:53,796
和 App


101
00:03:53,796 --> 00:03:55,116
逻辑相分离


102
00:03:57,526 --> 00:03:58,776
因此 数据绑定


103
00:03:58,776 --> 00:04:00,126
模板可以减少


104
00:04:00,126 --> 00:04:02,566
将数据转换为 TVML 文稿时


105
00:04:02,566 --> 00:04:04,556
所需的 JavaScript 代码量


106
00:04:04,556 --> 00:04:06,116
因为框架可以替你


107
00:04:06,776 --> 00:04:07,016
完成这项工作


108
00:04:07,016 --> 00:04:10,646
事实上 这种替你编写文稿的方式


109
00:04:10,646 --> 00:04:13,236
能够确保最佳性能 你也不必


110
00:04:13,236 --> 00:04:15,076
担心该用什么 API


111
00:04:16,456 --> 00:04:17,926
我们来看一个


112
00:04:17,926 --> 00:04:19,266
具体的例子


113
00:04:19,856 --> 00:04:21,026
假如你想生成一个


114
00:04:21,026 --> 00:04:23,596
横幅 其中包括标题和描述


115
00:04:24,136 --> 00:04:26,706
这是不使用数据绑定的


116
00:04:26,706 --> 00:04:28,546
通常做法


117
00:04:30,996 --> 00:04:32,386
首先 要获取


118
00:04:32,386 --> 00:04:33,666
显示给用户的


119
00:04:33,666 --> 00:04:35,146
相关数据 本例中


120
00:04:35,146 --> 00:04:36,856
就是标题和描述


121
00:04:38,656 --> 00:04:40,596
获取之后 要将数据


122
00:04:40,596 --> 00:04:42,406
传递给一段写好的


123
00:04:42,406 --> 00:04:43,666
JavaScript 代码


124
00:04:43,666 --> 00:04:45,126
让代码来处理数据


125
00:04:45,126 --> 00:04:47,766
并生成最终的文稿


126
00:04:49,306 --> 00:04:52,336
借助数据绑定


127
00:04:52,336 --> 00:04:53,666
就可以去掉 JavaScript 处理


128
00:04:53,666 --> 00:04:55,526
这一步 并在模板中


129
00:04:55,526 --> 00:04:57,206
设置绑定参数


130
00:04:57,206 --> 00:04:58,956
TVMLKit 可以


131
00:04:58,956 --> 00:05:00,556
按照设置 替你填入数据


132
00:05:00,556 --> 00:05:01,876
并生成文稿


133
00:05:02,786 --> 00:05:04,616
实际上 你的 App


134
00:05:04,616 --> 00:05:05,676
只需要负责


135
00:05:05,676 --> 00:05:08,186
获取和交换数据


136
00:05:08,186 --> 00:05:09,866
完全不需要考虑编辑 DOM


137
00:05:11,076 --> 00:05:13,936
简而言之 这就是数据绑定如何工作


138
00:05:13,936 --> 00:05:14,906
以及它如何帮助你减少代码量


139
00:05:17,516 --> 00:05:20,626
去年 我们引入了数据绑定的概念


140
00:05:20,626 --> 00:05:22,356
以及其他核心概念 例如


141
00:05:22,636 --> 00:05:23,896
绑定元素属性


142
00:05:23,896 --> 00:05:25,896
绑定元素的


143
00:05:25,896 --> 00:05:28,146
文本内容 当然


144
00:05:28,146 --> 00:05:29,516
还有将区块（section）中的


145
00:05:29,516 --> 00:05:31,546
条目（items）绑定在搁架（shelf）网格


146
00:05:31,816 --> 00:05:32,456
或列表中


147
00:05:33,266 --> 00:05:35,016
我们再用一个例子来


148
00:05:35,016 --> 00:05:36,796
快速回顾这些概念


149
00:05:39,756 --> 00:05:40,946
这个数据绑定模板


150
00:05:40,946 --> 00:05:42,316
对应一个


151
00:05:42,316 --> 00:05:43,666
图像元素 其中的


152
00:05:43,666 --> 00:05:45,046
绑定表达式


153
00:05:45,046 --> 00:05:47,796
以 @ 开头 后面是属性名


154
00:05:47,796 --> 00:05:49,806
和想要绑定的特性


155
00:05:50,236 --> 00:05:52,466
接下来 我们来看看


156
00:05:52,466 --> 00:05:54,456
生成元素文本内容的例子


157
00:05:55,946 --> 00:05:57,406
这个例子中 标题元素


158
00:05:57,406 --> 00:05:58,856
有对应的数据


159
00:05:58,856 --> 00:06:01,126
应当填充在元素中


160
00:06:03,356 --> 00:06:05,976
标题元素的数据绑定模板


161
00:06:05,976 --> 00:06:07,386
包含文本内容绑定


162
00:06:07,386 --> 00:06:09,836
以及这一绑定所映射的特性


163
00:06:13,186 --> 00:06:15,376
最后我们来谈谈条目绑定


164
00:06:15,836 --> 00:06:17,356
这种绑定方式


165
00:06:17,356 --> 00:06:19,256
稍有不同 它涉及到


166
00:06:19,256 --> 00:06:20,886
一组想要展示的数据


167
00:06:21,586 --> 00:06:23,156
它仅适用于搁架 列表


168
00:06:23,156 --> 00:06:24,696
或网格中的区块


169
00:06:26,656 --> 00:06:27,796
这个例子中 有一个数组


170
00:06:27,796 --> 00:06:30,736
数据以树形列表条目的形式存在


171
00:06:31,236 --> 00:06:32,636
最后的结果


172
00:06:32,636 --> 00:06:34,836
应当是一个由


173
00:06:34,836 --> 00:06:35,656
锁定的列表条目（listItemLockup）组成的区块


174
00:06:37,246 --> 00:06:39,586
区块对应的数据绑定模板


175
00:06:39,586 --> 00:06:41,696
应包括两项 分别是


176
00:06:41,696 --> 00:06:43,366
条目的绑定及其所映射的特性


177
00:06:43,366 --> 00:06:46,336
以及一个原型


178
00:06:46,336 --> 00:06:48,016
用来转化数组中的


179
00:06:48,136 --> 00:06:49,006
数据对象


180
00:06:49,636 --> 00:06:51,296
这里 数据


181
00:06:51,296 --> 00:06:52,826
绑定模板对应的


182
00:06:52,826 --> 00:06:53,836
是锁定的列表条目


183
00:06:55,976 --> 00:06:57,236
这就是我们在


184
00:06:57,236 --> 00:06:59,556
tvOS 11 中引入的树状绑定结构体


185
00:06:59,736 --> 00:07:01,366
欲知更多信息


186
00:07:01,366 --> 00:07:02,736
请观看我们去年 WWDC 上名为


187
00:07:02,736 --> 00:07:05,116
Advances in TVMLKit 的会议


188
00:07:08,246 --> 00:07:11,436
今年 我们进一步扩充了功能


189
00:07:11,996 --> 00:07:13,366
首先 我们添加了


190
00:07:13,366 --> 00:07:14,896
子元素绑定（children binding）


191
00:07:14,896 --> 00:07:17,076
以更接近原生的方式


192
00:07:17,076 --> 00:07:17,876
绑定元素的子元素


193
00:07:19,406 --> 00:07:20,986
为方便你管理


194
00:07:20,986 --> 00:07:22,526
DOM 我们添加了一些


195
00:07:22,526 --> 00:07:25,276
特殊元素 即片段和规则


196
00:07:25,836 --> 00:07:27,446
这些我们会深入探讨


197
00:07:27,446 --> 00:07:29,076
让我们首先谈谈子元素绑定


198
00:07:32,246 --> 00:07:33,526
子元素绑定是一种


199
00:07:33,526 --> 00:07:35,106
更为原生的条目绑定


200
00:07:35,996 --> 00:07:37,966
条目绑定为一些


201
00:07:37,966 --> 00:07:39,936
特殊情境进行了优化 例如


202
00:07:39,936 --> 00:07:42,046
包含搁板 框架或列表的区块


203
00:07:42,276 --> 00:07:44,316
以更高效地


204
00:07:44,316 --> 00:07:45,836
处理大数据的集合


205
00:07:46,826 --> 00:07:48,706
它们可以在这些元素之外使用


206
00:07:49,686 --> 00:07:51,766
其他情况下 使用子元素绑定


207
00:07:54,116 --> 00:07:56,136
背后的原因很简单


208
00:07:56,206 --> 00:07:57,976
子元素绑定能生成


209
00:07:57,976 --> 00:07:59,736
目标元素的子元素


210
00:08:02,356 --> 00:08:04,986
运作方式与条目绑定相同


211
00:08:05,566 --> 00:08:09,086
你需要使用原型 来定义


212
00:08:09,186 --> 00:08:13,526
数据转换成的元素 该元素将


213
00:08:13,526 --> 00:08:15,536
作为模板


214
00:08:15,536 --> 00:08:16,976
以生成最终的 DOM


215
00:08:20,346 --> 00:08:22,286
让我们举个例子 来解释工作原理


216
00:08:23,256 --> 00:08:24,766
让我回到之前


217
00:08:24,766 --> 00:08:26,916
数组中树状条目的例子


218
00:08:27,536 --> 00:08:32,546
数据与原来相同 但这次是三个


219
00:08:32,546 --> 00:08:33,655
不同的菜单条目


220
00:08:34,346 --> 00:08:36,326
这些条目将用在菜单栏中


221
00:08:37,676 --> 00:08:40,466
这是我们预期的最终结果


222
00:08:40,836 --> 00:08:42,796
大致是一个包含菜单栏树条目的


223
00:08:42,796 --> 00:08:43,635
菜单栏


224
00:08:46,026 --> 00:08:47,846
这是构建模板的


225
00:08:47,846 --> 00:08:50,876
非常简便的方式


226
00:08:50,876 --> 00:08:52,686
可以看到


227
00:08:52,686 --> 00:08:54,236
与条目绑定类似


228
00:08:54,756 --> 00:08:56,196
这里也使用了原型


229
00:08:56,196 --> 00:08:58,386
将数据映射到元素 这里也有


230
00:08:58,386 --> 00:08:59,516
绑定表达式


231
00:09:00,526 --> 00:09:03,186
唯一的区别在于 这里的元素


232
00:09:03,416 --> 00:09:04,416
不是区块


233
00:09:05,036 --> 00:09:07,066
子元素绑定 可以用于任何元素


234
00:09:10,166 --> 00:09:11,636
只要你希望自动生成


235
00:09:11,636 --> 00:09:13,196
全部子元素 这种解决方案


236
00:09:13,196 --> 00:09:14,716
就很好


237
00:09:15,456 --> 00:09:16,656
但有时 你可能


238
00:09:16,656 --> 00:09:18,326
只想生成部分的


239
00:09:18,326 --> 00:09:19,016
子元素


240
00:09:19,146 --> 00:09:20,996
例如 这个自动


241
00:09:20,996 --> 00:09:22,886
流传输 App 包含一个正在播放的


242
00:09:22,886 --> 00:09:23,476
菜单条目（nowPlayingMenuItem）


243
00:09:24,186 --> 00:09:25,406
这是一个


244
00:09:25,406 --> 00:09:27,386
特殊菜单条目 应该


245
00:09:27,386 --> 00:09:29,686
常驻菜单栏 但是


246
00:09:29,686 --> 00:09:32,016
仅在后台有音频


247
00:09:32,016 --> 00:09:33,896
播放时才显示


248
00:09:36,716 --> 00:09:38,376
但这里 我们还是


249
00:09:38,376 --> 00:09:39,556
希望菜单栏条目都能


250
00:09:39,556 --> 00:09:40,186
绑定数据


251
00:09:40,986 --> 00:09:42,996
为此 我们需要


252
00:09:42,996 --> 00:09:44,386
将菜单栏划分为


253
00:09:44,386 --> 00:09:46,326
依赖数据与不依赖数据


254
00:09:46,326 --> 00:09:47,006
两部分


255
00:09:47,626 --> 00:09:51,776
这里 我们就要运用片段


256
00:09:51,966 --> 00:09:52,946
那么 什么是片段呢


257
00:09:54,376 --> 00:09:56,066
片段是渲染器


258
00:09:56,216 --> 00:09:57,436
不可见的隐形元素


259
00:09:58,216 --> 00:10:00,056
它可以帮助你管理 DOM


260
00:10:01,366 --> 00:10:02,796
但片段的特殊之处


261
00:10:02,796 --> 00:10:05,346
就在于 它的子元素是可见的


262
00:10:08,176 --> 00:10:10,586
又因为片段是元素


263
00:10:10,586 --> 00:10:12,086
而子元素绑定可以应用于任何


264
00:10:12,086 --> 00:10:14,526
元素 因此片段可以


265
00:10:14,526 --> 00:10:15,816
应用子元素绑定


266
00:10:18,576 --> 00:10:19,926
我们再回到我们想要的


267
00:10:19,926 --> 00:10:21,486
数据最终形态 以及


268
00:10:21,486 --> 00:10:22,696
数据的初始状态


269
00:10:23,126 --> 00:10:24,626
这里有菜单栏条目


270
00:10:25,436 --> 00:10:27,046
很适合放在


271
00:10:27,046 --> 00:10:29,336
片段中 这一点很棒


272
00:10:29,336 --> 00:10:31,676
因为这样 我们就可以应用子元素绑定了


273
00:10:34,806 --> 00:10:36,896
现在 我们将


274
00:10:36,896 --> 00:10:38,456
绑定数据的部分放在


275
00:10:38,456 --> 00:10:41,766
片段中 菜单栏仍然保留正在播放


276
00:10:41,766 --> 00:10:42,356
菜单条目


277
00:10:42,656 --> 00:10:44,336
因为渲染器只能看到


278
00:10:44,336 --> 00:10:45,756
片段的子元素


279
00:10:45,756 --> 00:10:48,076
这段代码仍能渲染成


280
00:10:48,076 --> 00:10:49,536
格式正确的菜单栏


281
00:10:52,576 --> 00:10:53,946
对于用来


282
00:10:53,946 --> 00:10:56,416
映射到 UI


283
00:10:56,536 --> 00:10:58,496
元素的数据本身


284
00:10:58,496 --> 00:11:00,376
可能的情况是


285
00:11:00,376 --> 00:11:02,406
有些数据保持不变


286
00:11:02,406 --> 00:11:04,516
有些则始终变化


287
00:11:05,606 --> 00:11:07,296
比方说


288
00:11:07,296 --> 00:11:10,186
这段代码 对应


289
00:11:10,186 --> 00:11:12,366
一个有封面图像


290
00:11:12,496 --> 00:11:15,496
有标题 还有播放进度的视频


291
00:11:17,726 --> 00:11:19,316
有时候 我们想


292
00:11:19,316 --> 00:11:21,236
基于这些信息


293
00:11:21,236 --> 00:11:22,716
来显示不同的 UI


294
00:11:23,176 --> 00:11:25,576
如果还没有


295
00:11:25,576 --> 00:11:27,596
开始播放 进度


296
00:11:27,596 --> 00:11:29,796
自然为零 只显示


297
00:11:29,796 --> 00:11:31,596
视频的封面图像


298
00:11:31,596 --> 00:11:34,576
和视频的标题就可以了


299
00:11:36,086 --> 00:11:37,766
但如果我们开始看


300
00:11:37,766 --> 00:11:39,326
视频 播放进度自然


301
00:11:39,326 --> 00:11:40,226
会大于零


302
00:11:41,126 --> 00:11:43,606
为此 我们既要显示不变的元素


303
00:11:44,526 --> 00:11:45,836
即封面图像和标题


304
00:11:47,076 --> 00:11:48,586
还要凸显出


305
00:11:48,586 --> 00:11:50,736
视频正在播放


306
00:11:51,376 --> 00:11:53,506
也就是要显示进度条 随着播放进度的


307
00:11:53,506 --> 00:11:55,646
百分比进展 而逐渐填满


308
00:11:57,546 --> 00:12:00,526
同样地 我们现在有两种使用情景 它们的数据


309
00:12:00,526 --> 00:12:02,556
不同 同时我们也想


310
00:12:02,556 --> 00:12:04,416
显示不同的外观


311
00:12:05,146 --> 00:12:06,756
第一种情境中


312
00:12:06,756 --> 00:12:08,816
我们有锁定的图像和标题


313
00:12:09,926 --> 00:12:11,556
第二种情境中


314
00:12:11,556 --> 00:12:13,896
我们添加了额外的一个叠层和进度条


315
00:12:17,046 --> 00:12:17,916
一般来说


316
00:12:17,916 --> 00:12:19,456
App 逻辑会根据


317
00:12:19,496 --> 00:12:21,126
数据 生成不同的


318
00:12:21,126 --> 00:12:24,016
x 值 但借助规则


319
00:12:24,016 --> 00:12:25,356
你可以用一个


320
00:12:25,356 --> 00:12:27,076
静态模板 生成


321
00:12:27,076 --> 00:12:28,606
任何一种


322
00:12:28,636 --> 00:12:29,526
最终文稿


323
00:12:31,126 --> 00:12:32,096
那么 什么是规则


324
00:12:32,446 --> 00:12:35,236
规则使用数据状态


325
00:12:35,236 --> 00:12:38,186
来重新生成最终文档


326
00:12:38,416 --> 00:12:40,756
从而改善 UI


327
00:12:41,806 --> 00:12:43,296
规则是不可见元素


328
00:12:43,516 --> 00:12:44,746
渲染器看不到规则


329
00:12:45,246 --> 00:12:47,236
但规则却可以影响正在生成的文稿


330
00:12:49,296 --> 00:12:50,716
规则内的任何操作


331
00:12:50,716 --> 00:12:53,616
都会应用于


332
00:12:53,726 --> 00:12:55,476
规则所在的姊妹元素


333
00:12:56,476 --> 00:12:57,756
要展示这一点


334
00:12:57,756 --> 00:12:59,396
最好的办法是举例


335
00:12:59,396 --> 00:13:00,286
展示设置过程


336
00:13:02,836 --> 00:13:04,286
我们来看看 需要


337
00:13:04,476 --> 00:13:06,756
什么样的规则 才能


338
00:13:06,756 --> 00:13:08,106
构建我们想要的原型


339
00:13:08,106 --> 00:13:10,036
实现刚才例子中的效果


340
00:13:10,536 --> 00:13:11,976
首先 我们将原型


341
00:13:11,976 --> 00:13:13,386
定义为 UI 预期外观的


342
00:13:13,386 --> 00:13:15,116
最小公约数


343
00:13:15,116 --> 00:13:16,446
也就是最基本单位


344
00:13:17,276 --> 00:13:18,916
这里就包括


345
00:13:18,916 --> 00:13:20,016
图像和标题


346
00:13:21,716 --> 00:13:23,196
但你可能还注意到


347
00:13:23,196 --> 00:13:25,216
我们还为进度条


348
00:13:25,216 --> 00:13:25,896
准备了占位符


349
00:13:26,566 --> 00:13:28,056
占位符也是一种


350
00:13:28,056 --> 00:13:29,426
特殊元素 它对渲染器


351
00:13:29,426 --> 00:13:31,096
不可见 这个例子中


352
00:13:31,366 --> 00:13:32,876
规则会将占位符


353
00:13:32,876 --> 00:13:35,426
作为数据状态符合时的替换目标


354
00:13:36,886 --> 00:13:39,026
现在 我们将规则加入


355
00:13:40,136 --> 00:13:42,466
这组规则应用于姊妹元素


356
00:13:42,466 --> 00:13:43,976
包裹在 rules 标签中


357
00:13:47,606 --> 00:13:48,926
匹配数据状态的


358
00:13:48,926 --> 00:13:51,426
单个规则会封装成


359
00:13:51,516 --> 00:13:54,186
特定元素


360
00:13:54,606 --> 00:13:56,776
一旦匹配特定数据状态


361
00:13:56,806 --> 00:13:59,166
特定元素就会生效


362
00:14:00,396 --> 00:14:01,696
而匹配的方式


363
00:14:01,826 --> 00:14:03,766
则是利用状态属性的


364
00:14:03,766 --> 00:14:04,526
查询指令


365
00:14:07,266 --> 00:14:09,186
如果数据状态匹配


366
00:14:09,186 --> 00:14:10,876
那么特定元素的


367
00:14:10,876 --> 00:14:12,696
子元素便成为


368
00:14:12,696 --> 00:14:14,346
应用于规则姊妹元素的


369
00:14:14,346 --> 00:14:16,146
一系列操作


370
00:14:16,556 --> 00:14:18,606
这里 我们希望


371
00:14:18,606 --> 00:14:19,996
占位符能够被


372
00:14:19,996 --> 00:14:21,846
叠层元素及其子元素取代


373
00:14:25,956 --> 00:14:27,666
TVMLKit 分析元素的	


374
00:14:27,666 --> 00:14:29,106
标签属性 从而


375
00:14:29,106 --> 00:14:30,936
匹配被取代的元素


376
00:14:31,676 --> 00:14:33,456
实际取代过程中


377
00:14:33,676 --> 00:14:35,356
首先会匹配标签


378
00:14:35,776 --> 00:14:37,256
之后会比较元素的名称


379
00:14:38,146 --> 00:14:40,726
如果元素名不同 它便会将元素


380
00:14:40,726 --> 00:14:42,786
完全取代 这里


381
00:14:43,086 --> 00:14:44,776
占位符变成了叠层


382
00:14:45,736 --> 00:14:47,236
但如果元素名


383
00:14:47,236 --> 00:14:49,046
匹配 新内容


384
00:14:49,386 --> 00:14:51,476
就会添加到已有内容之后


385
00:14:53,426 --> 00:14:55,586
现在 我们就有了一个简单的


386
00:14:55,586 --> 00:14:56,986
规则模板 可以根据


387
00:14:56,986 --> 00:14:58,806
提供的数据状态 生成


388
00:14:58,806 --> 00:15:00,416
两种不同的输出


389
00:15:02,136 --> 00:15:04,016
实际上 你可以调用


390
00:15:04,016 --> 00:15:05,606
App 逻辑 来决定


391
00:15:05,606 --> 00:15:07,276
元素如何显示 并生成


392
00:15:07,276 --> 00:15:08,916
专门的静态模板


393
00:15:09,596 --> 00:15:11,216
应用于将要


394
00:15:11,586 --> 00:15:14,196
转化为 UI 的各种元素


395
00:15:15,556 --> 00:15:16,846
接下来换个话题 我们来


396
00:15:16,876 --> 00:15:18,506
谈谈 TVMLKit 中的播放


397
00:15:19,296 --> 00:15:20,896
TVMLKit 早就提供了


398
00:15:20,966 --> 00:15:22,486
扩展接口 方便你


399
00:15:22,486 --> 00:15:24,226
自定义 UI


400
00:15:24,226 --> 00:15:26,326
包括个别界面


401
00:15:26,326 --> 00:15:28,226
和整套模板


402
00:15:29,126 --> 00:15:31,276
tvOS 12 中 我们将这一功能


403
00:15:31,276 --> 00:15:32,586
扩展到回放流程


404
00:15:32,976 --> 00:15:34,586
让你完全控制播放体验


405
00:15:34,726 --> 00:15:37,416
以及相关的其他用户体验


406
00:15:41,046 --> 00:15:43,976
这些功能适用于


407
00:15:44,046 --> 00:15:45,176
现有的不同播放风格


408
00:15:45,176 --> 00:15:47,786
既包括嵌入式播放


409
00:15:47,866 --> 00:15:48,656
也包括全屏播放


410
00:15:51,676 --> 00:15:53,106
为此 你需要提供


411
00:15:53,106 --> 00:15:55,006
TVPlayer 对象 以及与其


412
00:15:55,006 --> 00:15:57,916
相关的 UI  作为 UIViewController


413
00:16:01,156 --> 00:16:03,016
这很类似


414
00:16:03,016 --> 00:16:04,486
JavaScript 的 API


415
00:16:04,626 --> 00:16:06,256
与你们的 JavaScript


416
00:16:06,406 --> 00:16:08,276
开发者沟通时 能省去不少麻烦


417
00:16:09,556 --> 00:16:11,856
最后 我们还提供了


418
00:16:11,856 --> 00:16:13,066
有限 JavaScript 桥


419
00:16:13,066 --> 00:16:13,736
（Limited JavaScript Bridge）


420
00:16:13,736 --> 00:16:15,206
该功能可以连通


421
00:16:15,336 --> 00:16:17,866
原生代码和 JavaScript 代码


422
00:16:20,536 --> 00:16:23,916
我们来谈谈 TVPlayer


423
00:16:23,916 --> 00:16:25,736
这是自定义


424
00:16:25,736 --> 00:16:27,766
播放体验的基础


425
00:16:28,996 --> 00:16:32,466
TVPlayer 是一个 AVPlayer


426
00:16:32,466 --> 00:16:33,886
公共适配器 适配于回放


427
00:16:33,886 --> 00:16:34,336
流程（Playback Pipeline）


428
00:16:35,396 --> 00:16:36,916
这意味着 TVPlayer


429
00:16:36,916 --> 00:16:38,506
可以转换一般的


430
00:16:38,506 --> 00:16:40,506
AVPlayer 回调


431
00:16:40,506 --> 00:16:41,746
并由 JavaScript 接收


432
00:16:45,316 --> 00:16:47,306
TVPlayer 还可以


433
00:16:47,306 --> 00:16:48,726
将自定义事件


434
00:16:48,726 --> 00:16:51,276
发送给 JavaScript


435
00:16:51,276 --> 00:16:52,526
默认情况下 它可以


436
00:16:52,576 --> 00:16:54,806
将 AVPlayer 的事件作为


437
00:16:54,806 --> 00:16:55,536
播放事件处理


438
00:16:55,656 --> 00:16:57,976
其他事件都由你来发送


439
00:17:02,046 --> 00:17:03,616
JavaScript 为播放器


440
00:17:03,616 --> 00:17:05,306
作出的改动均为 KVO 可观察


441
00:17:05,496 --> 00:17:06,656
你可以知道


442
00:17:06,656 --> 00:17:08,306
你的 JavaScript 开发者 进行了哪些改动


443
00:17:09,705 --> 00:17:11,526
最后 TVPlayer 对象


444
00:17:11,806 --> 00:17:13,506
播放媒体时会按照


445
00:17:13,506 --> 00:17:15,546
顺序 从第一个媒体


446
00:17:15,546 --> 00:17:16,746
一直播放到


447
00:17:16,746 --> 00:17:17,976
播放列表中最后一个媒体


448
00:17:20,945 --> 00:17:22,175
无论是否需要播放器


449
00:17:22,576 --> 00:17:24,256
TV Application Controller Delegate


450
00:17:24,256 --> 00:17:25,945
都会要求 TVPlayer


451
00:17:25,945 --> 00:17:27,506
你需要返回一个实例


452
00:17:27,566 --> 00:17:29,646
才能参与


453
00:17:29,646 --> 00:17:30,496
回放流程


454
00:17:34,076 --> 00:17:35,066
回放流程的下一步


455
00:17:35,066 --> 00:17:36,406
就是要将回放


456
00:17:36,406 --> 00:17:37,826
以 UI 的形式


457
00:17:37,826 --> 00:17:39,236
显示在屏幕上


458
00:17:39,736 --> 00:17:42,066
这随时可能发生


459
00:17:42,066 --> 00:17:44,936
可以是全屏回放 也可以是嵌入式回放


460
00:17:45,426 --> 00:17:47,016
你完全可以


461
00:17:47,016 --> 00:17:48,406
创建自己的 UI


462
00:17:49,186 --> 00:17:51,826
如果 TVMLKit 需要


463
00:17:51,826 --> 00:17:53,646
UI 那么 TVInterfaceCreating


464
00:17:53,646 --> 00:17:54,316
就会要求获得


465
00:17:54,316 --> 00:17:55,616
一个视图控制器（view controller）


466
00:17:56,246 --> 00:17:58,046
TVInterfaceCreating 还会向视图控制器


467
00:17:58,046 --> 00:18:00,336
传递对 TVPlayer 的引用 负责


468
00:18:00,336 --> 00:18:01,806
在视图中播放媒体


469
00:18:04,726 --> 00:18:05,476
接下来 使用 TVPlayer


470
00:18:05,476 --> 00:18:07,226
及与其相关的 UI 时


471
00:18:07,666 --> 00:18:10,596
有一些事情需要注意


472
00:18:12,266 --> 00:18:13,246
首先 你应当


473
00:18:13,246 --> 00:18:15,266
亲自处理所有 'should' 事件


474
00:18:16,026 --> 00:18:17,156
这类事件一般


475
00:18:17,156 --> 00:18:19,246
与广告相关 基本是一个


476
00:18:19,246 --> 00:18:20,786
UI 方面的问题


477
00:18:20,786 --> 00:18:22,656
应当由你的


478
00:18:22,656 --> 00:18:23,446
原生代码处理


479
00:18:25,676 --> 00:18:27,266
如果你使用 FairPlay 加密


480
00:18:27,266 --> 00:18:29,836
视频播放 


481
00:18:29,836 --> 00:18:32,456
你需要使用 AVContentKeySession


482
00:18:32,456 --> 00:18:33,486
来加载密钥


483
00:18:34,006 --> 00:18:36,326
欲知更多关于


484
00:18:36,326 --> 00:18:38,406
AVContentKeySession 的信息 请观看


485
00:18:38,406 --> 00:18:39,866
我们去年的讲座


486
00:18:39,866 --> 00:18:42,166
Advances in HTTP Live Streaming 以及


487
00:18:42,166 --> 00:18:43,086
今年的一场关于


488
00:18:43,086 --> 00:18:44,646
AVContentKeySession 最佳


489
00:18:44,646 --> 00:18:45,206
实践的讲座


490
00:18:47,456 --> 00:18:49,826
最后 如果你的 JavaScript


491
00:18:49,826 --> 00:18:51,586
开发者使用叠层和


492
00:18:51,586 --> 00:18:53,526
互动叠层 这些必须要


493
00:18:53,526 --> 00:18:54,856
进行设置


494
00:18:55,556 --> 00:18:56,896
这些属于 UI 既然


495
00:18:56,896 --> 00:18:57,856
你要构建自己的 UI


496
00:18:57,856 --> 00:18:59,896
就需要亲自处理


497
00:19:04,206 --> 00:19:06,166
总之 我们为


498
00:19:06,166 --> 00:19:09,746
TVMLKit 和 tvOS 12 做出了


499
00:19:10,176 --> 00:19:11,876
如下改动 首先


500
00:19:11,876 --> 00:19:13,256
数据绑定更为


501
00:19:13,256 --> 00:19:15,406
强大 你可以借此构建


502
00:19:15,406 --> 00:19:17,676
任何依赖数据的模板


503
00:19:18,316 --> 00:19:19,936
我们鼓励大家 一定要试一试


504
00:19:21,376 --> 00:19:22,986
其次 如果你一直希望


505
00:19:22,986 --> 00:19:24,716
能够自定义


506
00:19:24,716 --> 00:19:26,146
回放体验


507
00:19:26,146 --> 00:19:27,886
现在你就可以通过实现


508
00:19:27,886 --> 00:19:29,356
自己的原生回放来体验了


509
00:19:31,246 --> 00:19:32,566
欲知更多关于本会议的信息


510
00:19:32,566 --> 00:19:35,226
请访问屏幕上的网站


511
00:19:37,286 --> 00:19:40,326
谢谢大家参加 2018 年 WWDC


512
00:19:41,166 --> 00:19:41,506
谢谢

