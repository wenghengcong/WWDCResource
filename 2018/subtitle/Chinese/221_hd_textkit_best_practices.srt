1
00:00:06,516 --> 00:00:15,500
[ 音乐 ]


2
00:00:20,516 --> 00:00:25,176
[ 掌声 ]


3
00:00:25,676 --> 00:00:26,356
>> 大家好


4
00:00:27,316 --> 00:00:29,336
欢迎来到 221 号讨论会 


5
00:00:29,336 --> 00:00:29,906
“TextKit Best Practices（最佳实践）”


6
00:00:29,906 --> 00:00:31,086
我是 Donna Tom


7
00:00:31,086 --> 00:00:32,826
一名 TextKit 工程师


8
00:00:32,826 --> 00:00:35,076
我的同事 Emily Van Haren


9
00:00:35,076 --> 00:00:36,116
今天也会和我一起介绍


10
00:00:36,116 --> 00:00:36,806
她来自创作工具组


11
00:00:37,036 --> 00:00:38,796
我们非常激动能够


12
00:00:38,796 --> 00:00:39,756
和大家分享


13
00:00:39,756 --> 00:00:41,286
运用 TextKit 的一些最佳实践


14
00:00:41,676 --> 00:00:42,746
让我们开始吧


15
00:00:43,416 --> 00:00:45,786
首先 我们将回顾一下


16
00:00:45,786 --> 00:00:47,616
运用 TextKit 的一些关键概念


17
00:00:48,466 --> 00:00:49,916
然后 我们会通过一些


18
00:00:49,916 --> 00:00:51,316
例子来说明如何


19
00:00:51,316 --> 00:00:52,596
把这些关键概念运用到


20
00:00:52,596 --> 00:00:52,663
你的 App 中


21
00:00:53,916 --> 00:00:55,316
最后 我们将以一些


22
00:00:55,316 --> 00:00:56,716
在正确性 性能 


23
00:00:56,716 --> 00:00:59,116
以及安全领域的最佳实践结束


24
00:01:00,496 --> 00:01:03,496
现在让我们从关键概念开始吧


25
00:01:03,496 --> 00:01:04,346
为了确保我们进度相同


26
00:01:04,385 --> 00:01:06,496
我们将从最基础的内容开始


27
00:01:07,526 --> 00:01:08,616
什么是 TextKit


28
00:01:09,126 --> 00:01:12,016
你的第一反应可能是


29
00:01:12,296 --> 00:01:13,626
去在 Xcode 中打开一个


30
00:01:13,626 --> 00:01:15,276
新的 Playground 并且输入


31
00:01:15,426 --> 00:01:17,716
“import TextKit” 


32
00:01:17,716 --> 00:01:19,116
除非你已经试过这样做


33
00:01:19,116 --> 00:01:19,796
并且发现没有用


34
00:01:20,216 --> 00:01:23,236
这是因为 TextKit


35
00:01:23,236 --> 00:01:24,456
与其他你可能已经用过的框架相比


36
00:01:24,456 --> 00:01:25,406
有些不同


37
00:01:26,306 --> 00:01:27,116
你不必导入任何东西


38
00:01:27,116 --> 00:01:28,336
就可以使用它


39
00:01:29,376 --> 00:01:30,776
UIKit 和 AppKit 中的


40
00:01:30,776 --> 00:01:32,866
文本控件都是建立在


41
00:01:32,866 --> 00:01:33,246
TextKit 上面的


42
00:01:33,806 --> 00:01:34,946
所以 如果你曾使用过


43
00:01:34,946 --> 00:01:37,026
label textField 或者 textView


44
00:01:37,066 --> 00:01:38,846
你其实已经使用过 TextKit 了


45
00:01:39,846 --> 00:01:40,796
TextKit 还集成了


46
00:01:40,796 --> 00:01:42,386
强大的底层技术


47
00:01:42,596 --> 00:01:44,146
比如 Core Text Core Graphics


48
00:01:44,296 --> 00:01:46,036
和 Foundation 来让你的 App


49
00:01:46,036 --> 00:01:47,756
能够轻松且完美地显示文本


50
00:01:49,176 --> 00:01:50,396
每次你使用这些


51
00:01:50,396 --> 00:01:51,806
内置控件之一的时候 你都是在


52
00:01:51,806 --> 00:01:53,416
使用 TextKit 的功能去


53
00:01:53,416 --> 00:01:55,156
显示或编辑文本 以一种完全 


54
00:01:55,156 --> 00:01:56,826
国际化 可本地化


55
00:01:56,826 --> 00:01:58,186
的方式 并且没有


56
00:01:58,186 --> 00:01:59,426
直接运用这些底层


57
00:01:59,426 --> 00:02:01,086
技术或者理解


58
00:02:01,086 --> 00:02:02,566
复杂的脚本


59
00:02:02,626 --> 00:02:04,356
还有很多


60
00:02:04,356 --> 00:02:05,706
你还能顺带获得很多额外的东西


61
00:02:05,706 --> 00:02:06,736
比如你在这里看到的


62
00:02:06,736 --> 00:02:07,146
这些显示特性


63
00:02:07,796 --> 00:02:10,346
至于编辑 你也会


64
00:02:10,346 --> 00:02:11,636
获得所有 OS 所支持的


65
00:02:11,636 --> 00:02:12,646
技术服务


66
00:02:12,766 --> 00:02:14,466
比如辅助功能


67
00:02:14,466 --> 00:02:15,186
拼写检查等等


68
00:02:15,886 --> 00:02:16,946
你可以充分利用


69
00:02:16,946 --> 00:02:18,276
所有这些出色的功能


70
00:02:18,406 --> 00:02:19,566
而无需编写


71
00:02:19,566 --> 00:02:21,486
一行代码 这真的很棒


72
00:02:22,486 --> 00:02:23,716
有了这么多触手可及的


73
00:02:23,716 --> 00:02:24,406
功能供你选择


74
00:02:24,406 --> 00:02:25,986
你怎么决定


75
00:02:25,986 --> 00:02:27,646
使用哪一个控件呢


76
00:02:28,196 --> 00:02:29,246
那我们就来讨论一下


77
00:02:29,756 --> 00:02:30,796
如何为你的情况选择


78
00:02:30,796 --> 00:02:31,636
合适的控件


79
00:02:31,946 --> 00:02:32,956
你可能会有


80
00:02:32,956 --> 00:02:33,926
不同的选择 取决于


81
00:02:33,926 --> 00:02:36,046
你是在使用 UIKit 还是 AppKit


82
00:02:36,436 --> 00:02:37,506
所以让我们分别讨论一下


83
00:02:37,506 --> 00:02:38,166
好的


84
00:02:38,696 --> 00:02:40,466
让我们从 UIKit 开始


85
00:02:41,006 --> 00:02:44,846
首先 你会考虑你是否需要文本输入


86
00:02:45,346 --> 00:02:47,476
如果你不需要文本输入 


87
00:02:47,476 --> 00:02:49,006
那接下来你考虑你是否


88
00:02:49,006 --> 00:02:50,406
需要选择或滚动


89
00:02:50,976 --> 00:02:53,376
如果你不需要这些


90
00:02:53,676 --> 00:02:54,916
那你应该使用 UILabel


91
00:02:55,666 --> 00:02:57,276
UILabels 适用于


92
00:02:57,276 --> 00:02:58,936
少量的文本 比如几个字


93
00:02:58,936 --> 00:02:59,656
或者几行字


94
00:03:01,136 --> 00:03:02,096
如果你有比这更多的文本


95
00:03:02,136 --> 00:03:03,696
或者你需要


96
00:03:03,826 --> 00:03:04,546
选择或者滚动的功能


97
00:03:04,546 --> 00:03:05,966
那你需要使用


98
00:03:05,966 --> 00:03:07,676
禁用编辑的 


99
00:03:07,676 --> 00:03:08,116
UITextView 


100
00:03:08,116 --> 00:03:10,286
现在我们回到顶端


101
00:03:10,286 --> 00:03:12,456
如果你需要文本输入 那么


102
00:03:12,456 --> 00:03:13,626
考虑你是否需要安全的


103
00:03:13,626 --> 00:03:14,186
文本输入


104
00:03:14,186 --> 00:03:15,336
这会像密码栏一样


105
00:03:15,336 --> 00:03:16,936
其中文本被隐藏起来


106
00:03:16,936 --> 00:03:18,666
复制被禁用


107
00:03:19,236 --> 00:03:21,806
如果你需要这样


108
00:03:21,806 --> 00:03:23,726
你就应该使用 UITextField 因为它是


109
00:03:23,726 --> 00:03:25,076
唯一支持安全文本


110
00:03:25,246 --> 00:03:26,026
输入的控件


111
00:03:26,476 --> 00:03:29,346
否则 想想你


112
00:03:29,456 --> 00:03:30,886
想输入的文本有多少


113
00:03:32,076 --> 00:03:33,016
如果你想要像表单栏输入那样


114
00:03:33,016 --> 00:03:34,466
只需要一行的


115
00:03:34,466 --> 00:03:36,076
那就使用


116
00:03:36,076 --> 00:03:36,836
UITextField


117
00:03:37,126 --> 00:03:38,686
UITextField 仅支持


118
00:03:38,766 --> 00:03:41,716
一行文本输入


119
00:03:41,936 --> 00:03:42,996
如果你需要比这更多的文本


120
00:03:43,176 --> 00:03:44,556
你可以使用 UITextView


121
00:03:45,106 --> 00:03:47,976
对于 AppKit 来说


122
00:03:47,976 --> 00:03:49,206
同样需要这样的决策过程


123
00:03:49,206 --> 00:03:51,006
这个过程和 UIKit 的很像


124
00:03:51,006 --> 00:03:52,656
但是有些小小的不同


125
00:03:53,406 --> 00:03:55,496
你也要从考虑是否


126
00:03:55,496 --> 00:03:57,036
需要文本输入开始


127
00:03:57,596 --> 00:04:00,526
AppKit 没有标签控件


128
00:04:00,716 --> 00:04:02,106
所以 如果你需要展示文本


129
00:04:03,116 --> 00:04:04,546
那就使用 NSTextField


130
00:04:04,546 --> 00:04:05,546
你可以禁用编辑和选择


131
00:04:05,546 --> 00:04:07,036
来获得和标签一样的效果


132
00:04:07,036 --> 00:04:10,566
现在回到顶端


133
00:04:10,566 --> 00:04:12,286
如果你需要文本输入 


134
00:04:12,456 --> 00:04:13,526
问问自己是否需要


135
00:04:13,526 --> 00:04:13,806
安全文本输入


136
00:04:13,806 --> 00:04:15,856
如果需要 那你可以使用


137
00:04:15,986 --> 00:04:16,766
NSSecureTextField


138
00:04:17,176 --> 00:04:19,296
否则 我们会问


139
00:04:19,296 --> 00:04:20,596
我们最喜欢的问题


140
00:04:20,596 --> 00:04:22,346
你想要多少文本


141
00:04:23,176 --> 00:04:25,116
NSTextView 对展示


142
00:04:25,116 --> 00:04:26,556
大量文本进行了优化


143
00:04:26,946 --> 00:04:28,416
所以 如果你有大量文本要处理


144
00:04:28,416 --> 00:04:30,506
你应该使用 NSTextView


145
00:04:31,126 --> 00:04:32,556
否则 你可以使用


146
00:04:32,556 --> 00:04:33,216
NSTextField


147
00:04:33,946 --> 00:04:34,986
与 UIKit 不同


148
00:04:34,986 --> 00:04:36,926
NSTextField 


149
00:04:36,976 --> 00:04:38,136
支持多行文字 


150
00:04:39,056 --> 00:04:40,086
但是它更适用于


151
00:04:40,086 --> 00:04:41,556
短一些的字符串


152
00:04:41,556 --> 00:04:43,076
因此如果你有大量的文本的话 


153
00:04:43,076 --> 00:04:45,766
仍然应该使用 NSTextView


154
00:04:45,896 --> 00:04:47,616
好 你们中的和 TextKit 打过几次交道的人


155
00:04:47,616 --> 00:04:49,336
可能已经注意到


156
00:04:49,336 --> 00:04:50,266
这个流程图缺少了一个选项


157
00:04:50,266 --> 00:04:51,896
那就是字符串绘制优化


158
00:04:53,096 --> 00:04:54,416
你可以通过在你的


159
00:04:54,416 --> 00:04:56,016
NSString 或者 NSAttributedString 下


160
00:04:56,296 --> 00:04:58,396
直接调用 draw(at: CGPoint) 


161
00:04:58,466 --> 00:04:59,296
或 draw(in: CGRect) 


162
00:04:59,296 --> 00:05:00,236
来进行字符串绘制


163
00:05:01,146 --> 00:05:02,366
你们中的一些人可能会为了


164
00:05:02,366 --> 00:05:03,696
避免在 Kit 层级上使用过多的


165
00:05:03,846 --> 00:05:05,236
视图对象所带来的性能收益


166
00:05:05,236 --> 00:05:06,276
来使用它


167
00:05:07,606 --> 00:05:08,446
因此 如果你想要用这个方法


168
00:05:08,446 --> 00:05:10,826
请务必记住下面的几点提示


169
00:05:11,696 --> 00:05:12,686
你应该用它来处理


170
00:05:12,686 --> 00:05:13,676
少量的静态文本


171
00:05:14,166 --> 00:05:14,926
并且你应该限制


172
00:05:14,926 --> 00:05:16,396
调用 draw() 方法的频率


173
00:05:17,236 --> 00:05:18,186
如果你频繁地调用字符串


174
00:05:18,186 --> 00:05:20,296
绘制方法 


175
00:05:20,296 --> 00:05:21,626
你获得的性能表现可能不如


176
00:05:21,896 --> 00:05:23,706
使用标签或文本栏


177
00:05:23,846 --> 00:05:25,006
因为这些控件能提供


178
00:05:25,006 --> 00:05:26,516
更好的缓存 特别是


179
00:05:26,516 --> 00:05:27,306
使用自动布局的情况下


180
00:05:27,306 --> 00:05:29,216
如果你正在绘制一个


181
00:05:29,216 --> 00:05:31,056
有很多自定义属性的


182
00:05:31,056 --> 00:05:33,176
属性文本字符串 这也会


183
00:05:33,176 --> 00:05:34,366
减慢你的字符串绘制


184
00:05:34,366 --> 00:05:35,756
因为文本系统


185
00:05:35,756 --> 00:05:36,936
需要在渲染之前


186
00:05:36,936 --> 00:05:38,966
验证所有的属性 


187
00:05:38,966 --> 00:05:40,386
因此 为了最佳性能表现


188
00:05:40,386 --> 00:05:41,326
你应该在绘制之前


189
00:05:41,326 --> 00:05:42,906
剥离额外的属性


190
00:05:42,906 --> 00:05:44,776
只保留那些


191
00:05:44,776 --> 00:05:46,706
需要去决定的视觉表现属性


192
00:05:46,706 --> 00:05:48,506
比如字体或颜色


193
00:05:49,076 --> 00:05:51,996
最后你要知道


194
00:05:51,996 --> 00:05:53,146
如果使用字符串绘制


195
00:05:53,146 --> 00:05:54,546
你会失去所有这些


196
00:05:54,546 --> 00:05:55,746
文本控件提供的额外功能


197
00:05:55,746 --> 00:05:57,286
因此只要可能的话


198
00:05:57,286 --> 00:05:59,166
你应该一直使用文本控件


199
00:05:59,726 --> 00:06:02,706
所以现在你知道


200
00:06:02,706 --> 00:06:03,966
仅仅通过 TextKit 的内置控件


201
00:06:03,966 --> 00:06:04,796
你可以做些什么了


202
00:06:05,596 --> 00:06:06,686
但是如果你需要的


203
00:06:06,766 --> 00:06:07,716
比这些控件所提供的更多


204
00:06:08,206 --> 00:06:08,986
你需要文本堆栈中


205
00:06:08,986 --> 00:06:11,276
找到正确的定制点


206
00:06:12,376 --> 00:06:14,036
与 Cocoa 很像 TextKit


207
00:06:14,036 --> 00:06:16,766
是基于 MVC 设计模式的


208
00:06:17,316 --> 00:06:19,356
文本系统可以


209
00:06:19,356 --> 00:06:20,946
被分为三个阶段


210
00:06:20,946 --> 00:06:22,256
直接与 MVC 对应


211
00:06:22,386 --> 00:06:25,236
分别是存储 显示和布局


212
00:06:25,996 --> 00:06:27,446
我们现在来仔细看看


213
00:06:27,446 --> 00:06:28,916
构成了各个阶段


214
00:06:28,916 --> 00:06:29,946
的 TextKit 对象


215
00:06:30,346 --> 00:06:32,176
我们从存储开始


216
00:06:32,466 --> 00:06:35,746
它对应的是 Model（模型）


217
00:06:35,746 --> 00:06:36,866
NSTextStorage 存储着你的


218
00:06:36,866 --> 00:06:38,026
字符串数据和属性


219
00:06:38,746 --> 00:06:40,166
它是 NSMutableAttributedString 的


220
00:06:40,166 --> 00:06:41,806
一个子类 因此你可以用


221
00:06:41,806 --> 00:06:43,146
你已经熟悉的


222
00:06:43,146 --> 00:06:44,046
使用 attributedString 的方式


223
00:06:44,046 --> 00:06:45,046
来使用它


224
00:06:46,036 --> 00:06:47,256
我的同事 Emily 


225
00:06:47,256 --> 00:06:48,666
将会在稍后


226
00:06:48,666 --> 00:06:49,896
展示一些强大的方法


227
00:06:49,896 --> 00:06:51,246
来自定义 NSTextStorage


228
00:06:51,246 --> 00:06:52,146
期待一下吧


229
00:06:53,706 --> 00:06:55,716
NSTextContainer 会为


230
00:06:55,716 --> 00:06:56,906
你的文本将要被展示的几何区域


231
00:06:56,906 --> 00:06:57,866
建立模型


232
00:06:58,586 --> 00:07:00,006
默认情况下 它是一个矩形


233
00:07:00,306 --> 00:07:01,596
但你也可以自定义


234
00:07:01,596 --> 00:07:02,746
文本布局的走向或者形状


235
00:07:02,876 --> 00:07:03,486
就像这里展示的一样


236
00:07:04,096 --> 00:07:06,186
要了解更多详细的


237
00:07:06,186 --> 00:07:07,216
关于存储对象的信息


238
00:07:07,266 --> 00:07:08,806
看看这些以往优秀的


239
00:07:08,806 --> 00:07:11,246
WWDC 讨论会内容和文件


240
00:07:11,246 --> 00:07:12,656
这些能在讨论会结束时的


241
00:07:12,656 --> 00:07:16,596
更多信息链接中找到


242
00:07:17,396 --> 00:07:18,676
接下来是显示阶段


243
00:07:18,966 --> 00:07:21,276
它对应着视图


244
00:07:21,276 --> 00:07:22,626
我们已经讨论了


245
00:07:22,626 --> 00:07:23,746
一些显示阶段的内容


246
00:07:23,746 --> 00:07:24,736
在我们讨论选择


247
00:07:24,736 --> 00:07:25,396
正确控件的时候


248
00:07:25,766 --> 00:07:26,436
因此为获得更多的信息


249
00:07:26,436 --> 00:07:27,876
你可以再一次查看


250
00:07:27,876 --> 00:07:29,186
这些文件和资源


251
00:07:29,186 --> 00:07:30,796
这些也可以


252
00:07:30,796 --> 00:07:31,986
在讨论会的结尾的


253
00:07:31,986 --> 00:07:35,166
更多信息链接中获得


254
00:07:35,426 --> 00:07:36,586
最后 我们讨论下布局阶段


255
00:07:36,586 --> 00:07:38,446
它对应着控件


256
00:07:39,026 --> 00:07:41,836
NSLayoutManager 是这个阶段中


257
00:07:41,836 --> 00:07:42,656
唯一的组成部分


258
00:07:42,656 --> 00:07:44,806
它是一头野兽


259
00:07:46,036 --> 00:07:47,386
这是个褒义词


260
00:07:47,726 --> 00:07:49,656
因为它的功能实在是太棒了


261
00:07:50,146 --> 00:07:52,056
因此它是整个运作的大脑


262
00:07:52,056 --> 00:07:53,296
它协调所有阶段中的


263
00:07:53,296 --> 00:07:55,996
变化 并且控制着布局过程


264
00:07:56,066 --> 00:07:59,296
所以这里简要介绍一下


265
00:07:59,296 --> 00:08:00,546
布局过程是怎样进行的


266
00:08:01,426 --> 00:08:03,166
文字布局发生在


267
00:08:03,216 --> 00:08:04,596
系统修复文本存储的属性之后


268
00:08:04,596 --> 00:08:06,006
来消除不一致


269
00:08:06,006 --> 00:08:08,206
比如确定字符串中


270
00:08:08,206 --> 00:08:09,626
所有的字符


271
00:08:09,626 --> 00:08:11,206
都使用支持


272
00:08:11,246 --> 00:08:12,626
显示该字符的字体


273
00:08:13,086 --> 00:08:14,906
所以在这个例子中


274
00:08:14,906 --> 00:08:15,996
Times New Roman 被指定到


275
00:08:16,056 --> 00:08:17,566
整个字符串


276
00:08:18,096 --> 00:08:19,486
但是这个字体并不支持


277
00:08:19,936 --> 00:08:21,906
显示日文汉字或者表情符号


278
00:08:23,136 --> 00:08:24,536
因此在属性修正后


279
00:08:24,536 --> 00:08:25,446
你的文本存储


280
00:08:25,476 --> 00:08:26,876
看起来会像这样


281
00:08:26,876 --> 00:08:28,146
日文字符被


282
00:08:28,376 --> 00:08:29,346
分配了适当的日文字体


283
00:08:29,346 --> 00:08:31,186
表情符号被


284
00:08:31,186 --> 00:08:32,476
分配了的表情符号字体


285
00:08:32,476 --> 00:08:33,145
好的


286
00:08:33,856 --> 00:08:36,006
一旦属性被修正了


287
00:08:36,006 --> 00:08:37,666
布局过程就开始了


288
00:08:37,666 --> 00:08:39,606
我们可以认为布局


289
00:08:39,666 --> 00:08:42,866
分为两步 字形生成和字形布局


290
00:08:44,256 --> 00:08:45,366
一旦它们被布局好了


291
00:08:45,646 --> 00:08:46,456
就可以显示了


292
00:08:47,086 --> 00:08:48,606
但是 等一下


293
00:08:48,946 --> 00:08:49,356
什么是字形


294
00:08:50,206 --> 00:08:51,226
让我们回顾一下


295
00:08:52,146 --> 00:08:53,296
字形是一种代表一个


296
00:08:53,296 --> 00:08:54,536
或多个字符的


297
00:08:54,536 --> 00:08:55,046
视觉符号


298
00:08:55,536 --> 00:08:56,916
正如你在这里看到的那样


299
00:08:56,916 --> 00:08:58,056
字符与字形之间的映射


300
00:08:58,056 --> 00:09:00,066
并不总是一对一的


301
00:09:01,476 --> 00:09:03,286
字符串 “ffi” 有


302
00:09:03,386 --> 00:09:04,996
三个字符 但是它可以 


303
00:09:04,996 --> 00:09:06,476
由连起来的单个


304
00:09:06,556 --> 00:09:07,096
字形表示


305
00:09:07,096 --> 00:09:09,726
其实反过来也可以


306
00:09:10,456 --> 00:09:11,626
这里有一个 “ñ”


307
00:09:11,846 --> 00:09:13,436
这是一个单独的字符


308
00:09:13,436 --> 00:09:14,436
它可以由多个字形表示


309
00:09:14,436 --> 00:09:16,786
一个 “n”


310
00:09:16,786 --> 00:09:17,226
一个波浪号


311
00:09:18,836 --> 00:09:20,416
回到我们的图中


312
00:09:20,416 --> 00:09:22,456
我们的 NSLayoutManager


313
00:09:22,456 --> 00:09:24,726
执行字形生成和字形布局


314
00:09:25,486 --> 00:09:27,036
在字形生成这一步中


315
00:09:27,036 --> 00:09:28,096
布局管理器（Layout Manager）会


316
00:09:28,096 --> 00:09:29,446
获取字符并确定


317
00:09:29,476 --> 00:09:30,396
需要绘制的字形


318
00:09:31,276 --> 00:09:32,716
在字形布局这一步


319
00:09:32,716 --> 00:09:34,056
布局管理器会定位好这些字形


320
00:09:34,056 --> 00:09:35,646
以在你的视图中显示


321
00:09:36,116 --> 00:09:38,416
从以往 WWDC 讨论会和文档中


322
00:09:38,416 --> 00:09:39,876
还可以学到很多


323
00:09:39,876 --> 00:09:42,216
关于布局管理器的知识


324
00:09:42,596 --> 00:09:45,596
你可以在 没错


325
00:09:45,596 --> 00:09:46,936
讨论会结尾的更多


326
00:09:47,596 --> 00:09:49,416
信息链接中


327
00:09:49,576 --> 00:09:51,976
好的 现在你了解了


328
00:09:51,976 --> 00:09:53,096
文本系统的阶段


329
00:09:53,466 --> 00:09:54,296
并且你知道了 TextKit


330
00:09:54,296 --> 00:09:55,666
构成每个阶段的组件


331
00:09:57,276 --> 00:09:58,796
所以现在让我们来看看


332
00:09:58,796 --> 00:10:00,336
如何为这些组件选择正确的配置


333
00:10:00,336 --> 00:10:02,876
来创造不同的效果


334
00:10:03,376 --> 00:10:05,466
这是你的标准配置


335
00:10:05,466 --> 00:10:07,666
当你从 “界面构建器（界面构建器）”


336
00:10:07,746 --> 00:10:08,816
中拖放文本视图时


337
00:10:08,816 --> 00:10:10,116
你会自动获取


338
00:10:10,116 --> 00:10:11,896
每个组件中的一个


339
00:10:11,896 --> 00:10:12,306
像这里一样


340
00:10:13,216 --> 00:10:14,416
大多数时候 


341
00:10:14,416 --> 00:10:17,286
这对你来说就足够了


342
00:10:17,566 --> 00:10:19,046
如果你想要一个多页或一个


343
00:10:19,046 --> 00:10:20,776
多栏布局 你可以


344
00:10:20,776 --> 00:10:22,426
使用多对文本容器和


345
00:10:22,426 --> 00:10:24,076
文本视图


346
00:10:24,076 --> 00:10:24,756
每页或每列一对


347
00:10:25,656 --> 00:10:26,856
你可以将所有这些都绑定到


348
00:10:26,916 --> 00:10:28,166
相同的文本存储中的


349
00:10:28,166 --> 00:10:29,526
相同的布局管理器上


350
00:10:29,526 --> 00:10:30,866
这样它们就能在


351
00:10:30,866 --> 00:10:31,856
后台存储中 共享


352
00:10:31,936 --> 00:10:32,166
布局信息了


353
00:10:32,746 --> 00:10:35,016
如果你想要让每个视图


354
00:10:35,016 --> 00:10:36,156
呈现不同的视图 你也可以做到


355
00:10:36,156 --> 00:10:37,906
只要使用多个布局管理器


356
00:10:37,906 --> 00:10:38,576
就可以了


357
00:10:39,006 --> 00:10:40,416
再次说明 因为文本


358
00:10:40,416 --> 00:10:41,726
共享相同的后台存储


359
00:10:42,246 --> 00:10:43,626
更新该文本将更新


360
00:10:43,626 --> 00:10:44,186
所有视图


361
00:10:44,886 --> 00:10:47,796
我们现在不会讨论过多


362
00:10:47,796 --> 00:10:48,636
关于这些配置的细节


363
00:10:48,636 --> 00:10:49,986
因为之前已经有一个


364
00:10:49,986 --> 00:10:50,926
讨论会介绍过了


365
00:10:50,926 --> 00:10:52,496
你可以去看看


366
00:10:52,546 --> 00:10:54,686
WWDC 2010 讨论会中的 “Advanced Cocoa


367
00:10:54,686 --> 00:10:55,996
Text Tips and Tricks”


368
00:10:55,996 --> 00:10:57,836
你可以在讨论会结尾的


369
00:10:57,836 --> 00:11:02,476
更多信息链接中找到它


370
00:11:02,626 --> 00:11:02,946
好的


371
00:11:04,036 --> 00:11:04,946
我们已经看过了内置


372
00:11:04,946 --> 00:11:05,576
文本控件


373
00:11:06,296 --> 00:11:07,236
我们已经看过了


374
00:11:07,236 --> 00:11:07,766
TextKit 的组件


375
00:11:07,976 --> 00:11:09,016
我们已经讲过了如何


376
00:11:09,016 --> 00:11:10,336
配置这些组件


377
00:11:10,336 --> 00:11:11,066
以实现不同的效果


378
00:11:11,066 --> 00:11:12,956
在你了解了这些知识以后


379
00:11:12,956 --> 00:11:14,406
现在你已经可以做很多事情了


380
00:11:14,636 --> 00:11:15,586
但是如果你想要更多


381
00:11:16,196 --> 00:11:17,056
你需要自己扩展


382
00:11:17,056 --> 00:11:18,596
并自定义 TextKit 的某些部分


383
00:11:19,766 --> 00:11:21,076
所以现在我们会谈一谈


384
00:11:21,076 --> 00:11:22,166
选择正确的方式


385
00:11:22,166 --> 00:11:23,766
来做到这一点


386
00:11:24,826 --> 00:11:26,516
选择正确的方式


387
00:11:26,556 --> 00:11:28,036
就像构建文本工具箱一样


388
00:11:28,616 --> 00:11:29,806
这就像因为需要一把锤子


389
00:11:29,806 --> 00:11:30,606
所以你去了商店一样


390
00:11:30,606 --> 00:11:32,056
当你到了商店


391
00:11:32,056 --> 00:11:34,216
你发现有大量的锤子供选择


392
00:11:34,966 --> 00:11:36,086
但你想选择


393
00:11:36,216 --> 00:11:38,206
能够完成这项工作的锤子


394
00:11:38,286 --> 00:11:39,526
最理想的是能满足你需求的


395
00:11:39,526 --> 00:11:40,346
最便宜的锤子


396
00:11:40,896 --> 00:11:43,416
这些是我们可以


397
00:11:43,566 --> 00:11:44,456
得到的锤子


398
00:11:45,396 --> 00:11:46,836
委托就是一种


399
00:11:46,836 --> 00:11:48,866
标准的羊角锤可以用来


400
00:11:48,866 --> 00:11:49,626
完成各种任务


401
00:11:50,316 --> 00:11:51,466
委托们有很多


402
00:11:51,466 --> 00:11:52,566
不同的自定义钩子


403
00:11:52,706 --> 00:11:53,766
大多数时候它


404
00:11:53,766 --> 00:11:56,206
就能帮你完成任务


405
00:11:56,426 --> 00:11:58,446
通知就像是球头锤


406
00:11:58,596 --> 00:11:59,666
它的末端是一个球


407
00:11:59,666 --> 00:12:03,196
而不是羊角 所以它更专业化


408
00:12:03,296 --> 00:12:04,866
适合某些特定的任务


409
00:12:04,866 --> 00:12:06,466
但它并不像委托那样


410
00:12:06,466 --> 00:12:07,956
是一个全能的锤子


411
00:12:08,506 --> 00:12:12,106
最后 子类是你的大锤


412
00:12:13,496 --> 00:12:14,596
大锤非常强大


413
00:12:14,596 --> 00:12:16,096
你可以将它用于


414
00:12:16,096 --> 00:12:17,596
任何你需要锤子的任务


415
00:12:17,596 --> 00:12:19,136
但在很多时候


416
00:12:19,136 --> 00:12:20,756
使用它会有些大材小用


417
00:12:21,386 --> 00:12:23,396
接下来 我想


418
00:12:23,396 --> 00:12:24,606
邀请 Emily 向我们展示如何


419
00:12:24,606 --> 00:12:25,936
使用这些不同种类的锤子


420
00:12:26,326 --> 00:12:26,656
Emily


421
00:12:27,516 --> 00:12:32,166
[ 掌声 ]


422
00:12:32,666 --> 00:12:33,216
>> 谢谢你 Donna


423
00:12:34,396 --> 00:12:36,106
因此 作为开发人员


424
00:12:36,106 --> 00:12:37,506
我们有一系列控件


425
00:12:37,566 --> 00:12:39,676
各种配置


426
00:12:40,106 --> 00:12:41,036
以及大量的自定义选项供我们选择


427
00:12:41,036 --> 00:12:42,786
以实现我们


428
00:12:42,786 --> 00:12:43,266
所需的功能


429
00:12:44,156 --> 00:12:45,406
所以我们的工具箱


430
00:12:45,496 --> 00:12:47,656
储备充足 那么我们要


431
00:12:47,656 --> 00:12:48,346
如何选择工具呢


432
00:12:49,066 --> 00:12:51,696
我们一起来看看


433
00:12:51,696 --> 00:12:52,886
一些 App 示例


434
00:12:52,886 --> 00:12:54,326
它们套用了 TextKit 的强大功能


435
00:12:55,326 --> 00:12:56,326
这样的 App 示例并不难找


436
00:12:56,326 --> 00:12:58,436
因为几乎我们使用的每个 App


437
00:12:58,496 --> 00:13:00,536
都需要显示或


438
00:13:01,436 --> 00:13:01,586
编辑文本


439
00:13:03,336 --> 00:13:04,666
我们首先看看


440
00:13:04,666 --> 00:13:05,776
两个我们都熟悉的 App 


441
00:13:05,826 --> 00:13:07,826
然后一步一步


442
00:13:07,826 --> 00:13:08,846
构建我们


443
00:13:08,846 --> 00:13:09,136
自己的 App


444
00:13:09,706 --> 00:13:12,086
我们要看的第一个 App


445
00:13:12,086 --> 00:13:13,816
是 iOS 上的 “Apple News”


446
00:13:14,576 --> 00:13:15,906
这是一个漂亮的 App


447
00:13:15,906 --> 00:13:18,926
在个性化以及甄选的


448
00:13:18,926 --> 00:13:19,936
文章中显示文本


449
00:13:20,646 --> 00:13:23,586
下面这个例子


450
00:13:23,586 --> 00:13:25,326
是在 “Spotlight” 标签页中


451
00:13:25,366 --> 00:13:26,106
“Featured” 栏目中的一篇文章


452
00:13:27,186 --> 00:13:29,616
现在 App 的顶部显示了


453
00:13:29,616 --> 00:13:31,016
关于这篇文章的一些细节


454
00:13:32,046 --> 00:13:33,846
我们如何才能用 TextKit


455
00:13:33,846 --> 00:13:34,976
重现这个外观和风格呢


456
00:13:38,176 --> 00:13:39,356
所以让我们考虑一下


457
00:13:39,356 --> 00:13:41,156
早些时候 Donna 向我们展示的流程图


458
00:13:41,156 --> 00:13:42,386
以便选择最适合


459
00:13:42,386 --> 00:13:43,416
本示例的控件


460
00:13:43,986 --> 00:13:47,186
我们有不少文本控件


461
00:13:47,186 --> 00:13:49,506
可供选择


462
00:13:49,596 --> 00:13:50,946
但由于我们想要


463
00:13:50,946 --> 00:13:52,776
显示的文本很少


464
00:13:52,876 --> 00:13:54,946
所以我们将在每一行都使用标签


465
00:13:54,946 --> 00:13:58,806
我们可以看到


466
00:13:58,806 --> 00:14:00,446
在检查器面板中


467
00:14:00,446 --> 00:14:01,256
有很多定制选项


468
00:14:01,846 --> 00:14:03,756
我们继续


469
00:14:03,756 --> 00:14:05,076
将文本更改为 “Spotlight”


470
00:14:05,716 --> 00:14:07,776
并把字体


471
00:14:08,226 --> 00:14:09,336
改为 “Body”


472
00:14:09,926 --> 00:14:12,616
我们还要勾选


473
00:14:12,616 --> 00:14:14,546
“Dynamic Type” 这可以让


474
00:14:14,546 --> 00:14:15,866
启用辅助功能设置的用户


475
00:14:15,866 --> 00:14:17,956
能以适合它们需要的


476
00:14:18,026 --> 00:14:19,236
字体大小和样式


477
00:14:19,236 --> 00:14:20,306
来查看文本


478
00:14:21,026 --> 00:14:23,266
现在我们可以在


479
00:14:23,266 --> 00:14:24,216
界面构建器中


480
00:14:24,216 --> 00:14:25,966
自定义这个标签 但我们也可以


481
00:14:25,966 --> 00:14:27,196
在 Swift 代码中


482
00:14:27,276 --> 00:14:27,596
看到所有这些属性


483
00:14:28,826 --> 00:14:30,616
我们可以在运行时


484
00:14:30,616 --> 00:14:31,626
动态设置文本和


485
00:14:31,846 --> 00:14:33,036
排版属性


486
00:14:33,036 --> 00:14:36,266
现在回到界面构建器


487
00:14:36,866 --> 00:14:38,646
我们将继续添加两个标签


488
00:14:40,206 --> 00:14:41,536
现在一切都很好


489
00:14:42,146 --> 00:14:44,786
但我们还需要做一件事


490
00:14:46,286 --> 00:14:47,586
所以回头看 Apple News


491
00:14:47,716 --> 00:14:48,876
我们可以看到右边的文字


492
00:14:48,876 --> 00:14:50,246
实际上显示


493
00:14:50,246 --> 00:14:51,416
以两种不同的颜色


494
00:14:51,516 --> 00:14:53,676
一部分是黑色的 一部分是白色的


495
00:14:55,006 --> 00:14:56,016
现在我们可以实现这一点


496
00:14:56,016 --> 00:14:57,876
用两个单独的标签 但如果我们


497
00:14:57,876 --> 00:15:00,066
只想使用一个标签


498
00:15:00,066 --> 00:15:01,486
在界面构建器中


499
00:15:01,486 --> 00:15:02,356
是无法实现的


500
00:15:02,836 --> 00:15:06,156
那么我们怎么做到这一点呢


501
00:15:06,546 --> 00:15:07,646
我们可以利用


502
00:15:07,646 --> 00:15:09,216
NSAttributedString 强大而


503
00:15:09,216 --> 00:15:10,056
灵活的功能


504
00:15:11,856 --> 00:15:13,556
attributedString 是


505
00:15:13,556 --> 00:15:15,026
一串字符 它可以将属性


506
00:15:15,026 --> 00:15:17,236
应用于一定范围内的字符


507
00:15:18,076 --> 00:15:19,246
你可以轻松地获取一些属性


508
00:15:19,246 --> 00:15:21,506
比如默认字体 


509
00:15:21,506 --> 00:15:23,766
和文本颜色一样 但我们可以


510
00:15:23,766 --> 00:15:24,796
用我们自己的值重写


511
00:15:24,796 --> 00:15:25,156
这些属性


512
00:15:25,956 --> 00:15:27,216
在这种情况下 我们将把


513
00:15:27,216 --> 00:15:28,426
字符串的部分文本颜色


514
00:15:28,426 --> 00:15:28,756
设置为白色


515
00:15:28,756 --> 00:15:32,796
要具体查看属性字符串


516
00:15:32,926 --> 00:15:34,386
我们将使用


517
00:15:34,556 --> 00:15:35,646
在 NSMutableAttributedString 中的


518
00:15:35,706 --> 00:15:37,606
addAttribute() 方法


519
00:15:37,606 --> 00:15:39,376
来讲我们想要的范围内的文本


520
00:15:39,376 --> 00:15:40,266
设置成白色


521
00:15:41,506 --> 00:15:42,816
这一次 我们将


522
00:15:42,816 --> 00:15:44,476
在我们的标签上设置


523
00:15:44,476 --> 00:15:44,796
属性文本属性


524
00:15:45,256 --> 00:15:49,586
在运行时 


525
00:15:50,066 --> 00:15:50,246
这看起来很酷


526
00:15:51,336 --> 00:15:53,516
UILabels 对这类文本来说


527
00:15:53,516 --> 00:15:55,846
是很棒的选择


528
00:15:55,846 --> 00:15:56,876
如果我们看看屏幕底部


529
00:15:56,876 --> 00:15:57,846
我们会看到


530
00:15:57,966 --> 00:15:58,366
一个标题


531
00:15:58,546 --> 00:15:59,666
这也是文本


532
00:15:59,666 --> 00:16:01,516
但它有比较大


533
00:16:01,516 --> 00:16:02,216
占了很多行


534
00:16:02,826 --> 00:16:05,956
使这个文本不同的另一点是


535
00:16:05,956 --> 00:16:06,976
它是可以


536
00:16:06,976 --> 00:16:07,616
被选中的


537
00:16:08,206 --> 00:16:10,676
那么这次我们应该使用


538
00:16:10,676 --> 00:16:11,166
哪种控件呢


539
00:16:12,376 --> 00:16:14,076
文本栏和文本视图


540
00:16:14,076 --> 00:16:16,246
都支持选择


541
00:16:16,246 --> 00:16:18,206
但文本栏通常


542
00:16:18,206 --> 00:16:18,706
仅用于一行


543
00:16:19,306 --> 00:16:21,596
因此 在这种情况下 由于我们的


544
00:16:21,596 --> 00:16:22,716
标题可以跨越多行


545
00:16:22,716 --> 00:16:25,206
因此我们将使用


546
00:16:26,386 --> 00:16:26,496
文本视图


547
00:16:26,716 --> 00:16:28,126
当我们将文本视图


548
00:16:28,126 --> 00:16:29,596
放到 Storyboard 上时 我们可以看到


549
00:16:29,596 --> 00:16:31,046
我们默认会得到


550
00:16:31,236 --> 00:16:31,706
大量的测试文本


551
00:16:32,606 --> 00:16:33,456
我们继续来


552
00:16:33,456 --> 00:16:35,286
检查器面板中


553
00:16:35,366 --> 00:16:35,626
更改文本


554
00:16:37,236 --> 00:16:38,096
我们还要改变字体


555
00:16:38,166 --> 00:16:39,396
使它看起来更


556
00:16:39,396 --> 00:16:40,166
像 “Apple News”


557
00:16:40,806 --> 00:16:43,276
我们希望禁用


558
00:16:43,276 --> 00:16:44,316
编辑功能 因为


559
00:16:44,316 --> 00:16:45,646
标题不应该被编辑


560
00:16:46,246 --> 00:16:49,386
UITextView 默认支持滚动


561
00:16:49,426 --> 00:16:51,336
因为它们是


562
00:16:51,336 --> 00:16:52,136
UIScrollView 的子类


563
00:16:53,156 --> 00:16:54,746
但是 如果我们希望我们的文本视图


564
00:16:54,746 --> 00:16:57,046
在自动布局中良好运行


565
00:16:57,046 --> 00:16:58,126
我们应该禁用滚动


566
00:16:59,066 --> 00:17:00,456
因此 这将允许


567
00:17:00,456 --> 00:17:02,466
我们的文本视图的边界调整大小


568
00:17:03,256 --> 00:17:05,296
以适应文本


569
00:17:05,455 --> 00:17:07,465
最后 这个白色背景


570
00:17:07,496 --> 00:17:09,056
真的需要删去


571
00:17:09,906 --> 00:17:10,826
所以我们要把它


572
00:17:10,826 --> 00:17:11,506
设置为透明


573
00:17:12,675 --> 00:17:13,886
界面构建器使得


574
00:17:13,886 --> 00:17:15,205
自定这个文本视图非常容易


575
00:17:15,246 --> 00:17:16,695
但是和之前的标签一样


576
00:17:16,695 --> 00:17:18,596
我们可以在代码中


577
00:17:18,596 --> 00:17:19,076
设置所有这些


578
00:17:20,026 --> 00:17:21,586
因此 在 Swift 中我们可以


579
00:17:21,586 --> 00:17:23,036
在运行时动态设置


580
00:17:23,036 --> 00:17:24,906
文本和格式属性


581
00:17:26,386 --> 00:17:27,506
我们现在看过了 Apple News


582
00:17:27,506 --> 00:17:28,546
并选择了正确的控件


583
00:17:29,396 --> 00:17:30,196
现在我们要看看另一个


584
00:17:30,196 --> 00:17:32,096
我们都熟悉的 App


585
00:17:32,096 --> 00:17:33,216
并选择正确的配置


586
00:17:33,216 --> 00:17:36,786
那就是“文本编辑”


587
00:17:37,516 --> 00:17:39,476
“文本编辑” 是 macOS 上的一个 App


588
00:17:40,286 --> 00:17:42,136
用于处理显示和编辑


589
00:17:42,196 --> 00:17:43,406
富文本内容


590
00:17:44,946 --> 00:17:46,156
但大多数人不知道


591
00:17:46,346 --> 00:17:48,396
“文本编辑” 实际上是


592
00:17:48,396 --> 00:17:50,526
NSTextView 套上了一个壳子


593
00:17:51,826 --> 00:17:52,906
我想花一点时间


594
00:17:52,906 --> 00:17:54,646
感叹一下 TextKit 给我们带来了


595
00:17:54,646 --> 00:17:56,436
多少额外的好处


596
00:17:57,006 --> 00:17:59,156
所以这是检查器栏


597
00:17:59,526 --> 00:18:00,956
我们通过勾选


598
00:18:00,986 --> 00:18:02,456
界面构建器中的复选框


599
00:18:02,456 --> 00:18:02,796
就可以轻松获得


600
00:18:03,396 --> 00:18:04,716
正下方是一个标尺视图


601
00:18:04,716 --> 00:18:06,456
我们也可以轻松获得它


602
00:18:06,696 --> 00:18:09,006
只要简单地启用它即可


603
00:18:09,006 --> 00:18:10,116
而下面的所有内容


604
00:18:10,206 --> 00:18:12,996
其实只是一个文本视图


605
00:18:13,206 --> 00:18:15,296
更准确地说 是一个文本视图


606
00:18:15,296 --> 00:18:17,346
加上文本容器 布局管理器


607
00:18:17,346 --> 00:18:18,066
还有文本存储


608
00:18:18,866 --> 00:18:19,756
这是 NSTextView 和


609
00:18:19,756 --> 00:18:21,216
UITextView 的


610
00:18:21,216 --> 00:18:24,966
标准配置


611
00:18:24,966 --> 00:18:27,056
但相似之处也就这些


612
00:18:27,646 --> 00:18:30,556
例如 表格


613
00:18:30,556 --> 00:18:31,896
只在 NSTextView 中受支持


614
00:18:32,696 --> 00:18:34,386
再次感叹一下 我们免费


615
00:18:34,636 --> 00:18:36,336
获得的强大功能


616
00:18:36,336 --> 00:18:37,576
TextKit 提供了一个表格编辑器


617
00:18:37,576 --> 00:18:38,746
为我们完成所有


618
00:18:39,556 --> 00:18:39,646
繁冗的工作


619
00:18:42,476 --> 00:18:44,026
当我们使用“文本编辑”时


620
00:18:44,026 --> 00:18:45,596
我们经常编辑大量的文本


621
00:18:46,686 --> 00:18:48,026
有时候我们会粘贴很多


622
00:18:48,026 --> 00:18:49,446
示例文本 来看看我们是否


623
00:18:49,446 --> 00:18:50,666
也免费获得了拼写检查器


624
00:18:51,396 --> 00:18:52,776
但我们真的想看到的是


625
00:18:52,936 --> 00:18:54,126
当我们使用格式菜单


626
00:18:54,126 --> 00:18:55,976
选择“按页面换行”时


627
00:18:56,466 --> 00:18:58,706
最终看起来会


628
00:18:58,706 --> 00:18:59,626
有点像一个页面


629
00:18:59,926 --> 00:19:00,716
我们可以看到文本容器


630
00:19:00,756 --> 00:19:02,956
已被调整大小


631
00:19:02,956 --> 00:19:06,056
以匹配一张纸的尺寸


632
00:19:06,176 --> 00:19:07,696
现在 如果我们向下滚动


633
00:19:07,696 --> 00:19:08,866
我们可以看到文本会


634
00:19:08,866 --> 00:19:09,946
从第一页跳到第二页


635
00:19:10,886 --> 00:19:12,116
标准配置


636
00:19:12,116 --> 00:19:13,266
并不真的支持


637
00:19:13,266 --> 00:19:13,636
这样的布局


638
00:19:15,066 --> 00:19:16,626
显然 这个布局使用了


639
00:19:16,626 --> 00:19:18,326
两个文本视图和文本容器


640
00:19:19,076 --> 00:19:20,006
但它们仍然


641
00:19:20,106 --> 00:19:21,276
由相同的布局管理器和文本存储管理


642
00:19:21,276 --> 00:19:22,626
这使得文本


643
00:19:22,626 --> 00:19:24,176
可以从一个页面跳到


644
00:19:25,016 --> 00:19:26,566
另一个页面


645
00:19:26,776 --> 00:19:27,926
现在 如果你想了解更多


646
00:19:27,926 --> 00:19:29,276
关于文本编辑是如何工作的信息


647
00:19:29,276 --> 00:19:31,136
你其实可以在指南和示例代码库中


648
00:19:31,136 --> 00:19:32,546
找到它的源代码


649
00:19:32,546 --> 00:19:36,046
所以我们选择了正确的控件


650
00:19:36,046 --> 00:19:37,666
我们选择了正确的配置


651
00:19:37,666 --> 00:19:39,716
但有时我们


652
00:19:39,716 --> 00:19:41,016
实际上需要使用锤子控件


653
00:19:41,096 --> 00:19:42,126
以达到我们想要的效果


654
00:19:43,346 --> 00:19:44,386
但是 我们如何决定


655
00:19:44,386 --> 00:19:45,076
使用哪个锤子呢


656
00:19:45,806 --> 00:19:49,006
我们将尝试为任务


657
00:19:49,006 --> 00:19:50,166
挑选合适的锤子


658
00:19:50,306 --> 00:19:51,526
在我们接下来一起


659
00:19:51,526 --> 00:19:53,146
构建一个日记 App 的过程中


660
00:19:54,516 --> 00:19:55,876
我们从把今天的日期


661
00:19:55,946 --> 00:19:57,056
放到窗口上开始


662
00:19:58,316 --> 00:19:59,546
我们在 AppKit 中没有 UILabels


663
00:19:59,546 --> 00:20:01,226
但是我们可以使文本栏


664
00:20:01,226 --> 00:20:02,476
像标签一样工作


665
00:20:03,716 --> 00:20:05,766
我们所需要做的就是禁用编辑


666
00:20:06,366 --> 00:20:09,116
现在 对于窗口的日记内容部分


667
00:20:09,116 --> 00:20:10,976
我们将使用 textView


668
00:20:12,206 --> 00:20:13,676
所以在检查器中 我们可以确保


669
00:20:13,676 --> 00:20:16,916
文本视图是可编辑和可选的


670
00:20:16,916 --> 00:20:18,596
并支持富文本和撤销


671
00:20:18,596 --> 00:20:21,916
我们还要


672
00:20:21,916 --> 00:20:23,006
在窗口底部添加几个


673
00:20:23,006 --> 00:20:24,056
文本栏 来显示


674
00:20:24,056 --> 00:20:25,566
写了多少个单词


675
00:20:26,166 --> 00:20:29,746
现在 当我们运行我们的 App 时 我们希望


676
00:20:29,746 --> 00:20:30,766
底部的字数统计随之变化


677
00:20:30,766 --> 00:20:32,836
所以让我们来为这个任务


678
00:20:32,886 --> 00:20:33,676
找到合适的锤子


679
00:20:33,676 --> 00:20:39,266
我们可以选择委托通知或子类


680
00:20:39,266 --> 00:20:41,796
但在这种情况下 我们将


681
00:20:41,796 --> 00:20:42,636
使用小锤子


682
00:20:42,916 --> 00:20:43,756
我们将监听


683
00:20:43,756 --> 00:20:45,226
来自文本存储的通知


684
00:20:46,726 --> 00:20:47,886
我们可以从文本存储中


685
00:20:47,886 --> 00:20:49,496
获取单词的数量


686
00:20:50,686 --> 00:20:51,246
当我们收到通知时


687
00:20:51,246 --> 00:20:52,886
我们可以更新


688
00:20:52,886 --> 00:20:54,556
文本栏的


689
00:20:54,556 --> 00:20:55,026
字符串值属性


690
00:20:55,586 --> 00:20:58,726
当我们开始输入时 我们可以


691
00:20:58,756 --> 00:20:59,726
看到字数改变


692
00:21:00,326 --> 00:21:03,446
如果我们想强调部分文本


693
00:21:03,446 --> 00:21:05,806
我们可以使用键盘快捷键


694
00:21:05,806 --> 00:21:07,586
或菜单来应用


695
00:21:07,586 --> 00:21:08,616
格式 比如粗体


696
00:21:09,166 --> 00:21:11,846
但是如果我们能够支持


697
00:21:11,846 --> 00:21:13,946
现代文本排版工具会更好


698
00:21:13,946 --> 00:21:15,746
比如 Markdown 


699
00:21:15,746 --> 00:21:17,346
它使用命令字符


700
00:21:17,406 --> 00:21:18,406
来指定格式


701
00:21:19,206 --> 00:21:20,566
如果我们在一段内容前后


702
00:21:20,786 --> 00:21:22,536
分别添加两个星号


703
00:21:22,536 --> 00:21:23,366
我们希望结果是粗体的


704
00:21:24,216 --> 00:21:26,426
但我们应该使用


705
00:21:27,816 --> 00:21:28,216
哪种锤子呢


706
00:21:28,336 --> 00:21:29,276
我们想知道什么时候


707
00:21:29,276 --> 00:21:31,396
发生变化 并且我们想知道


708
00:21:31,396 --> 00:21:32,586
变化发生在哪里


709
00:21:32,616 --> 00:21:33,846
但通知并没有真正


710
00:21:33,846 --> 00:21:35,286
给我们提供很多关于


711
00:21:35,286 --> 00:21:35,896
这种改变的信息


712
00:21:37,416 --> 00:21:38,456
所以我们将使用更大的锤子


713
00:21:38,456 --> 00:21:40,076
并实现 textStorage() 委托


714
00:21:40,076 --> 00:21:44,286
具体是 _ didProcessEditing: 方法


715
00:21:45,226 --> 00:21:46,786
我们可以从现有的字体中


716
00:21:47,016 --> 00:21:47,946
创建一个新的粗体字体


717
00:21:48,646 --> 00:21:50,026
而且 我们可以将该字体


718
00:21:50,026 --> 00:21:51,426
直接添加到我们的 textStorage


719
00:21:51,426 --> 00:21:52,646
用于我们想要加粗的范围


720
00:21:53,176 --> 00:21:55,586
现在 当我们插入最后一个星号时


721
00:21:55,586 --> 00:21:57,696
我们可以将其加粗


722
00:21:58,346 --> 00:22:01,126
我们现在对这个


723
00:22:01,126 --> 00:22:02,426
Markdown 功能非常满意


724
00:22:02,586 --> 00:22:04,856
那么如果我们尝试插入


725
00:22:04,856 --> 00:22:05,476
代码片段呢


726
00:22:06,756 --> 00:22:07,996
在 Markdown 中是这样的


727
00:22:09,256 --> 00:22:10,516
如果我们添加最后一个反引号


728
00:22:10,636 --> 00:22:12,766
我们希望它看起来像一个代码块


729
00:22:14,136 --> 00:22:15,156
它应该有一个背景和


730
00:22:15,156 --> 00:22:16,346
一个表示 Swift Code 的标头


731
00:22:17,716 --> 00:22:18,906
这实际上是一项复杂的任务


732
00:22:18,906 --> 00:22:22,006
所以我们需要两把大锤


733
00:22:23,386 --> 00:22:25,526
第一个是 NSTextStorage 子类


734
00:22:26,556 --> 00:22:27,946
当我们子类化 NSTextStorage 时


735
00:22:27,946 --> 00:22:30,706
我们需要实现四个必要的方法


736
00:22:31,236 --> 00:22:32,806
我们通过对一个可变字符串的


737
00:22:32,856 --> 00:22:34,946
局部实例进行操作来做到这一点


738
00:22:34,946 --> 00:22:37,996
我们需要注意


739
00:22:37,996 --> 00:22:39,056
replaceCharacters() 方法


740
00:22:39,836 --> 00:22:42,066
我们可以将 NSTextBlock 添加


741
00:22:42,066 --> 00:22:42,876
到我们的段落样式中


742
00:22:43,406 --> 00:22:46,046
然后我们将


743
00:22:46,046 --> 00:22:47,546
该段落样式添加到


744
00:22:47,546 --> 00:22:49,116
我们文本存储中


745
00:22:49,116 --> 00:22:49,496
代码块的范围内


746
00:22:50,256 --> 00:22:51,746
现在 NSTextBlock 本身


747
00:22:51,746 --> 00:22:53,906
不会自己做任何自定义绘制


748
00:22:54,596 --> 00:22:56,766
所以我们也需要对它


749
00:22:57,916 --> 00:22:57,996
进行子类化


750
00:22:58,226 --> 00:23:00,846
我们的 NSTextBlock 子类需要


751
00:23:00,846 --> 00:23:02,756
在顶部有一些


752
00:23:02,756 --> 00:23:04,626
额外的留白


753
00:23:04,626 --> 00:23:07,346
还需要一个浅灰色背景


754
00:23:07,546 --> 00:23:08,906
我们将重写 drawBackground()


755
00:23:09,566 --> 00:23:11,346
并使用字符串绘制来绘制


756
00:23:11,346 --> 00:23:12,666
标头 Swift Code


757
00:23:13,606 --> 00:23:14,836
实际上这些我们想


758
00:23:14,836 --> 00:23:16,386
让文本块看起来


759
00:23:16,386 --> 00:23:18,886
像一个代码片段所需要做的


760
00:23:18,986 --> 00:23:20,216
现在回到我们的 customTextStorage


761
00:23:20,216 --> 00:23:21,866
我们可以创建


762
00:23:21,866 --> 00:23:23,076
新代码块的实例


763
00:23:24,256 --> 00:23:27,286
而不是使用纯文本块


764
00:23:27,856 --> 00:23:31,476
最后 我们还要


765
00:23:31,476 --> 00:23:32,896
告诉我们的 textView 使用


766
00:23:32,896 --> 00:23:34,606
我们的 customTextStorage


767
00:23:34,606 --> 00:23:36,076
所以我们要在布局管理器中


768
00:23:36,116 --> 00:23:37,096
把原来的文本存储替换掉


769
00:23:37,706 --> 00:23:41,076
现在这变成了一个真正的


770
00:23:41,076 --> 00:23:42,266
所见即所得的 Markdown 编辑器了


771
00:23:43,126 --> 00:23:44,366
现在在大多数 Markdown 编辑器上


772
00:23:44,366 --> 00:23:45,556
都有的一个功能是


773
00:23:45,666 --> 00:23:47,726
并排视图


774
00:23:47,726 --> 00:23:49,046
左侧是编辑区域


775
00:23:49,046 --> 00:23:50,016
右侧是渲染版本


776
00:23:51,516 --> 00:23:52,996
我们可以通过使用


777
00:23:52,996 --> 00:23:54,426
两个文本视图来实现


778
00:23:55,936 --> 00:23:57,946
我们停用右侧视图的编辑功能


779
00:23:58,866 --> 00:24:00,376
现在我们有两个文本视图


780
00:24:00,376 --> 00:24:01,596
虽然我们希望它们显示


781
00:24:01,696 --> 00:24:03,546
相同的内容 但我们还希望


782
00:24:03,546 --> 00:24:04,286
右边视图能够看起来不太一样


783
00:24:05,916 --> 00:24:07,176
所以我们需要一个像这样的配置


784
00:24:07,176 --> 00:24:08,806
两个视图的文本存储器相同


785
00:24:08,806 --> 00:24:11,666
而所有其他都不同


786
00:24:14,096 --> 00:24:16,506
为此 我们


787
00:24:16,506 --> 00:24:17,996
将用左侧的文本存储


788
00:24:18,066 --> 00:24:19,106
把右侧的替换掉


789
00:24:20,616 --> 00:24:21,506
现在让我们看看


790
00:24:21,536 --> 00:24:21,766
这是什么样子


791
00:24:22,286 --> 00:24:25,326
现在这真的很酷


792
00:24:25,526 --> 00:24:26,626
如果我们在左侧添加任何字符


793
00:24:26,626 --> 00:24:28,826
它们将立即显示在右侧


794
00:24:29,726 --> 00:24:31,056
现在通常右手边


795
00:24:31,906 --> 00:24:33,166
并没有真正显示 Markdown 字符


796
00:24:33,166 --> 00:24:35,406
但由于这是一个


797
00:24:35,406 --> 00:24:38,036
共享文本存储 这意味着我们


798
00:24:38,036 --> 00:24:39,196
必须隐藏字符


799
00:24:39,406 --> 00:24:40,486
在布局过程中


800
00:24:40,486 --> 00:24:44,236
因为我们需要这样做


801
00:24:44,236 --> 00:24:45,846
所以我们实际上只有一个选择


802
00:24:45,916 --> 00:24:48,486
那就是实现


803
00:24:49,016 --> 00:24:50,746
NSLayoutManager 委托上的


804
00:24:51,176 --> 00:24:52,746
shouldGenerateGlyphs() 方法


805
00:24:53,796 --> 00:24:55,196
这将允许我们介入


806
00:24:55,316 --> 00:24:57,446
字形生成过程


807
00:24:58,036 --> 00:24:59,776
因此 我们可以


808
00:24:59,776 --> 00:25:01,986
获取即将布局的字形


809
00:25:01,986 --> 00:25:03,446
并且如果它们表示 Markdown


810
00:25:03,446 --> 00:25:05,446
命令字符 我们可以将


811
00:25:05,446 --> 00:25:07,356
.null 属性应用于该字形


812
00:25:08,096 --> 00:25:09,216
现在 这将让字形


813
00:25:09,216 --> 00:25:10,516
在布局过程中被


814
00:25:10,516 --> 00:25:12,526
彻底消除 而不会更改


815
00:25:12,526 --> 00:25:13,756
底层的文本存储


816
00:25:14,306 --> 00:25:19,096
然后 我们将使用新的字形


817
00:25:19,096 --> 00:25:20,686
并告诉布局管理器


818
00:25:20,686 --> 00:25:22,046
我们想要用这些新的属性


819
00:25:22,106 --> 00:25:23,116
来呈现这些字形


820
00:25:27,096 --> 00:25:29,106
这真的很酷


821
00:25:29,106 --> 00:25:30,416
所以左侧显示了


822
00:25:30,416 --> 00:25:31,436
可编辑版本


823
00:25:31,436 --> 00:25:32,626
包含所有 Markdown 字符


824
00:25:32,956 --> 00:25:34,576
而右侧没有显示


825
00:25:34,576 --> 00:25:36,306
任何 Markdown 字符


826
00:25:36,306 --> 00:25:37,686
全部使用相同的文本存储


827
00:25:38,286 --> 00:25:40,836
现在构建一个并排的


828
00:25:40,836 --> 00:25:42,046
Markdown 编辑器 并不是


829
00:25:42,096 --> 00:25:44,256
我们每天都在做的事情


830
00:25:44,256 --> 00:25:45,536
但是很开心看到


831
00:25:45,536 --> 00:25:47,856
TextKit 的可自定义度是多么高


832
00:25:47,856 --> 00:25:48,816
以及它是如何与现实的例子结合的


833
00:25:49,536 --> 00:25:51,626
如果你想了解更多


834
00:25:51,626 --> 00:25:53,026
关于如何使用和自定义


835
00:25:53,066 --> 00:25:54,816
TextKit 的信息 请查看我们出色的


836
00:25:54,816 --> 00:25:55,576
编程指南


837
00:25:56,286 --> 00:25:58,186
然后 我要把现场交给 Donna


838
00:25:59,516 --> 00:26:06,066
[ 掌声 ]


839
00:26:06,566 --> 00:26:07,236
>> 谢谢 Emily


840
00:26:08,056 --> 00:26:09,056
这些例子真的


841
00:26:09,056 --> 00:26:09,536
非常酷


842
00:26:09,666 --> 00:26:10,786
我真的希望你能够


843
00:26:10,786 --> 00:26:11,706
采用她展示的一些技术


844
00:26:11,706 --> 00:26:13,876
并在你自己的 App 中使用它们


845
00:26:14,596 --> 00:26:16,086
但现在让我们稍微转换一下


846
00:26:16,416 --> 00:26:17,226
并讨论一些


847
00:26:17,266 --> 00:26:19,766
使用文本的最佳做法


848
00:26:21,756 --> 00:26:23,196
关于正确性


849
00:26:23,796 --> 00:26:24,996
如果你的文本没有


850
00:26:24,996 --> 00:26:26,716
按照你期望的方式呈现


851
00:26:26,716 --> 00:26:28,596
它可能与属性字符串上的


852
00:26:28,596 --> 00:26:29,806
不完整或不正确的


853
00:26:29,806 --> 00:26:30,556
属性有关


854
00:26:31,946 --> 00:26:33,636
所以我们来看看一个例子


855
00:26:33,636 --> 00:26:35,066
在实践中看到这一点


856
00:26:36,116 --> 00:26:37,466
假设我们有一个 UITextView


857
00:26:37,666 --> 00:26:39,536
它带有一些属性文本


858
00:26:39,536 --> 00:26:40,846
写着 “Don't hate.”


859
00:26:40,846 --> 00:26:42,636
这段文本的格式是


860
00:26:42,706 --> 00:26:44,266
Comic Sans 字体 24 号大小


861
00:26:44,766 --> 00:26:46,746
我们希望以编程的方式


862
00:26:46,746 --> 00:26:48,946
把它设置成粗体


863
00:26:48,946 --> 00:26:50,736
因为如果有


864
00:26:50,736 --> 00:26:52,396
任何比 Comic Sans 令人讨厌的字体


865
00:26:52,396 --> 00:26:54,396
那一定是 Comic Sans Bold


866
00:26:54,776 --> 00:26:58,316
所以乍一看


867
00:26:58,316 --> 00:26:59,696
编写这样的代码似乎是合理的


868
00:27:00,716 --> 00:27:02,746
现在 我们有我们的原始字体


869
00:27:03,386 --> 00:27:05,326
我们将使用一个 fontDescriptor


870
00:27:05,326 --> 00:27:06,796
来创建原始字体


871
00:27:06,796 --> 00:27:08,376
的粗体版本


872
00:27:09,936 --> 00:27:11,796
然后 我们要


873
00:27:11,796 --> 00:27:13,196
使用原始文本


874
00:27:13,526 --> 00:27:14,526
初始化可变属性字符串


875
00:27:14,526 --> 00:27:16,866
我们要将我们的


876
00:27:16,866 --> 00:27:18,876
新字体或新的粗体字体应用于


877
00:27:18,876 --> 00:27:20,586
单词 “Don't”


878
00:27:20,586 --> 00:27:21,496
这是前五个字符


879
00:27:21,496 --> 00:27:22,986
然后我们将设置


880
00:27:22,986 --> 00:27:24,386
我们的 UITextView 的属性文本属性


881
00:27:24,386 --> 00:27:25,996
来使用这个新的


882
00:27:25,996 --> 00:27:28,566
属性字符串 但是我们这样做时


883
00:27:28,606 --> 00:27:30,096
我们会看到


884
00:27:30,096 --> 00:27:32,186
应用于该单词的新的粗体字体


885
00:27:32,186 --> 00:27:34,416
确实像我们预期的那样


886
00:27:34,416 --> 00:27:35,676
但字符串其余的部分


887
00:27:35,676 --> 00:27:36,986
不知道为什么丢失了原始字体


888
00:27:37,506 --> 00:27:39,696
现在 那些不喜欢


889
00:27:39,696 --> 00:27:40,966
Comic Sans 的人可能会为此感到高兴


890
00:27:40,966 --> 00:27:43,676
但结果是错误的


891
00:27:43,806 --> 00:27:45,296
所以这是一个悲伤的故事


892
00:27:46,456 --> 00:27:47,926
那么为什么会这样呢


893
00:27:48,506 --> 00:27:51,046
为了回答这个问题 让我们


894
00:27:51,046 --> 00:27:52,196
仔细看看我们是如何


895
00:27:52,196 --> 00:27:53,476
初始化我们的


896
00:27:53,546 --> 00:27:53,856
属性字符串的


897
00:27:55,226 --> 00:27:56,806
所以请注意 我们要使用


898
00:27:56,966 --> 00:27:58,526
纯文本字符串来初始化它


899
00:27:58,526 --> 00:27:59,616
并且我们使用的


900
00:27:59,616 --> 00:28:01,516
初始化程序没有属性信息


901
00:28:01,516 --> 00:28:04,046
当你创建一个新的


902
00:28:04,046 --> 00:28:05,646
属性字符串 并且你没有


903
00:28:05,646 --> 00:28:06,526
提供任何属性信息时


904
00:28:06,526 --> 00:28:08,626
新的属性字符串


905
00:28:08,626 --> 00:28:10,226
会使用默认的属性


906
00:28:11,026 --> 00:28:11,926
默认字体是


907
00:28:11,926 --> 00:28:13,136
Helvetica 12 号


908
00:28:13,686 --> 00:28:15,876
为了回顾发生了什么


909
00:28:16,166 --> 00:28:17,366
我们开始


910
00:28:17,366 --> 00:28:19,036
从这个原始的属性字符串


911
00:28:19,036 --> 00:28:20,566
将字体 Comic Sans 24 应用于


912
00:28:20,566 --> 00:28:21,356
整个范围


913
00:28:21,866 --> 00:28:24,986
然后我们创建了这个新的


914
00:28:24,986 --> 00:28:26,416
属性字符串


915
00:28:26,416 --> 00:28:27,506
并使用默认属性


916
00:28:27,506 --> 00:28:27,966
进行了初始化


917
00:28:28,856 --> 00:28:30,156
并且我们将粗字体应用于


918
00:28:30,156 --> 00:28:31,226
新字符串上的 “Don't”


919
00:28:31,276 --> 00:28:33,016
结果就是这里这个


920
00:28:33,016 --> 00:28:34,896
不正确的结果 其中


921
00:28:34,896 --> 00:28:36,296
“Don't” 以 Comic Sans 粗体 24 号显示


922
00:28:36,296 --> 00:28:37,886
但字符串的其余部分


923
00:28:37,886 --> 00:28:39,366
处于默认字体


924
00:28:39,366 --> 00:28:40,146
Helvetica 12


925
00:28:40,726 --> 00:28:43,916
有两种不同的方法


926
00:28:43,916 --> 00:28:44,776
可以让它们正确地显示


927
00:28:44,776 --> 00:28:46,826
一种方法是


928
00:28:46,826 --> 00:28:47,916
避免将纯文本


929
00:28:47,916 --> 00:28:49,086
和属性文本混合在一起


930
00:28:50,146 --> 00:28:51,416
因此 通过使用原始字符串


931
00:28:51,416 --> 00:28:52,446
来初始化我们的新属性字符串


932
00:28:52,446 --> 00:28:53,676
我们要把


933
00:28:53,676 --> 00:28:54,816
那些原始属性保留下来


934
00:28:55,296 --> 00:28:56,326
然后我们再应用我们的新属性


935
00:28:56,326 --> 00:28:57,606
而不会看到这个


936
00:28:57,606 --> 00:28:59,176
重设的默认效果


937
00:28:59,696 --> 00:29:03,746
但是 避免混合纯文本和属性文本


938
00:29:03,746 --> 00:29:04,256
并不总是可行的


939
00:29:04,576 --> 00:29:06,156
因此 如果你必须将其混合


940
00:29:06,736 --> 00:29:08,096
则可以在从纯文本字符串中


941
00:29:08,096 --> 00:29:09,876
创建新的属性字符串时


942
00:29:09,876 --> 00:29:11,846
明确提供属性


943
00:29:11,846 --> 00:29:13,596
如果我们确保


944
00:29:13,656 --> 00:29:14,526
从原始文本中应用相同的属性


945
00:29:14,526 --> 00:29:15,716
我们就会得到


946
00:29:15,716 --> 00:29:16,356
正确的结果


947
00:29:16,886 --> 00:29:19,816
但是你应该知道


948
00:29:19,816 --> 00:29:20,896
重设效果会发生


949
00:29:20,896 --> 00:29:22,126
在任何具有默认值


950
00:29:22,126 --> 00:29:23,736
而不仅仅是字体的属性的情况下


951
00:29:24,816 --> 00:29:26,106
如你所见


952
00:29:26,106 --> 00:29:27,676
有很多属性都具有默认值


953
00:29:27,676 --> 00:29:30,746
所以我想特别提醒一下


954
00:29:30,746 --> 00:29:31,986
这里的 “Paragraph style（段落风格）”


955
00:29:31,986 --> 00:29:33,506
因为它是一个隐蔽的


956
00:29:33,506 --> 00:29:34,096
重置点


957
00:29:35,056 --> 00:29:36,466
为了明白为什么


958
00:29:36,466 --> 00:29:37,256
我们将重新回顾一下前面的例子


959
00:29:37,406 --> 00:29:38,496
但不是改变字体


960
00:29:38,496 --> 00:29:39,826
我们将改变段落风格


961
00:29:39,826 --> 00:29:41,576
来屏蔽 “hate” 这个词


962
00:29:41,576 --> 00:29:43,746
因为没有人喜欢仇恨


963
00:29:44,376 --> 00:29:45,786
所以我们希望我们的文本看起来像这样


964
00:29:45,856 --> 00:29:47,886
但是当我们运行这段代码时


965
00:29:48,716 --> 00:29:49,836
我们将得到


966
00:29:50,686 --> 00:29:51,696
一个这样的结果


967
00:29:51,696 --> 00:29:53,526
所有文本的格式都是 Helvetica 12 


968
00:29:53,526 --> 00:29:55,136
使用默认的段落风格


969
00:29:55,136 --> 00:29:56,866
默认的换行模式 和默认的自动断词


970
00:29:57,566 --> 00:29:59,016
又一次 对于那些


971
00:29:59,016 --> 00:29:59,956
讨厌 Comic Sans 的人来说 真是太棒了


972
00:29:59,956 --> 00:30:01,056
因为它已经被完全地


973
00:30:01,056 --> 00:30:02,136
从字符串中移除了


974
00:30:02,226 --> 00:30:03,976
但它=这是错误的


975
00:30:04,086 --> 00:30:05,446
但是这次错误的原因


976
00:30:05,446 --> 00:30:06,276
与上次不同


977
00:30:06,826 --> 00:30:08,586
为了更好地理解这不同


978
00:30:08,586 --> 00:30:09,796
让我们回顾一下


979
00:30:09,796 --> 00:30:11,686
属性修复发生在


980
00:30:11,686 --> 00:30:13,296
布局之前 这时候


981
00:30:13,296 --> 00:30:15,236
系统会修复不一致的属性


982
00:30:16,216 --> 00:30:17,196
在我们的属性字符串中


983
00:30:17,286 --> 00:30:18,546
我们有一个


984
00:30:18,546 --> 00:30:19,906
包含多个段落样式的单个段落


985
00:30:19,906 --> 00:30:22,646
这显然非常不一致


986
00:30:23,496 --> 00:30:24,996
因此 当系统修复


987
00:30:24,996 --> 00:30:26,426
此字符串的属性时


988
00:30:26,426 --> 00:30:27,086
它将采用


989
00:30:27,086 --> 00:30:28,976
它找到的第一段样式


990
00:30:28,976 --> 00:30:30,206
并将其应用于整个段落


991
00:30:31,236 --> 00:30:32,296
这就会导致


992
00:30:32,296 --> 00:30:34,096
我们的属性字符串


993
00:30:34,096 --> 00:30:35,386
以默认段落样式显示


994
00:30:35,946 --> 00:30:39,906
关键是要明确你的属性


995
00:30:39,906 --> 00:30:42,216
特别是在混合纯文本和


996
00:30:42,216 --> 00:30:42,926
属性文本时


997
00:30:43,836 --> 00:30:44,916
所以通过这样做


998
00:30:44,916 --> 00:30:46,346
你就能避免它出现


999
00:30:46,346 --> 00:30:47,216
默认属性的重置效果


1000
00:30:47,826 --> 00:30:49,406
对于 AppKit 开发人员来说


1001
00:30:49,406 --> 00:30:51,126
如果你正在为 App 更新


1002
00:30:51,126 --> 00:30:52,176
深色模式


1003
00:30:52,176 --> 00:30:52,696
这一点尤其重要


1004
00:30:53,286 --> 00:30:54,526
因此通过使用


1005
00:30:54,526 --> 00:30:56,056
带有动态颜色的显式属性


1006
00:30:56,056 --> 00:30:57,886
如 NSColor.textColor


1007
00:30:57,946 --> 00:30:59,216
可以确保你的文本


1008
00:30:59,216 --> 00:31:00,146
会根据环境用正确的


1009
00:31:00,316 --> 00:31:03,116
颜色绘制


1010
00:31:03,216 --> 00:31:03,786
继续


1011
00:31:04,316 --> 00:31:05,416
下一个话题是性能


1012
00:31:06,306 --> 00:31:07,116
如果你使用大量文本


1013
00:31:07,116 --> 00:31:08,656
一个提高 App 性能的


1014
00:31:08,656 --> 00:31:10,046
好方法是


1015
00:31:10,046 --> 00:31:11,636
使用非连续布局


1016
00:31:11,636 --> 00:31:14,076
为了明白这意味着什么


1017
00:31:14,076 --> 00:31:15,276
让我们重新回顾


1018
00:31:15,336 --> 00:31:16,766
布局过程


1019
00:31:17,826 --> 00:31:18,856
我们说过布局过程


1020
00:31:18,896 --> 00:31:20,436
包括字形生成


1021
00:31:20,526 --> 00:31:21,386
和字形布局


1022
00:31:22,806 --> 00:31:24,046
所以对于连续布局


1023
00:31:24,266 --> 00:31:25,416
布局管理器


1024
00:31:25,416 --> 00:31:26,716
在文本存储开头就开始


1025
00:31:26,716 --> 00:31:27,946
执行字形生成和


1026
00:31:27,986 --> 00:31:29,496
字形布局了


1027
00:31:30,286 --> 00:31:32,426
它以从头到尾的顺序进行


1028
00:31:33,786 --> 00:31:34,986
所以如果有人使用你的 App


1029
00:31:35,026 --> 00:31:37,556
滚动到文本视图中间的某个点


1030
00:31:37,556 --> 00:31:38,966
那么布局管理器


1031
00:31:38,966 --> 00:31:41,056
必须为红色矩形


1032
00:31:41,056 --> 00:31:42,316
所指示区域之前的所有字形


1033
00:31:42,316 --> 00:31:44,596
生成并布局字形


1034
00:31:45,166 --> 00:31:46,726
并且请注意


1035
00:31:46,726 --> 00:31:47,846
这还包括你从


1036
00:31:47,846 --> 00:31:49,016
屏幕顶部滚动回到


1037
00:31:49,016 --> 00:31:50,116
文本存储起点之间


1038
00:31:50,176 --> 00:31:51,596
所有你看不见的文本


1039
00:31:52,696 --> 00:31:54,186
所以如果你有很多文本


1040
00:31:54,236 --> 00:31:56,406
那么这个可怜的用户


1041
00:31:56,406 --> 00:31:57,756
可能需要等待你的 App 一段时间


1042
00:31:57,756 --> 00:31:59,946
让它完成布局


1043
00:31:59,946 --> 00:32:01,626
但幸运的是


1044
00:32:01,626 --> 00:32:03,616
我们可以通过使用非连续布局


1045
00:32:03,616 --> 00:32:03,916
来避免这种情况


1046
00:32:04,966 --> 00:32:06,896
正如其名称所暗示的那样


1047
00:32:06,896 --> 00:32:08,286
使用非连续布局


1048
00:32:08,286 --> 00:32:10,216
布局管理器无需


1049
00:32:10,216 --> 00:32:11,656
从文本存储开始


1050
00:32:11,716 --> 00:32:12,896
顺序地进行字形


1051
00:32:12,896 --> 00:32:13,296
生成和布局


1052
00:32:14,166 --> 00:32:15,626
所以现在当这个使用你 App 的人


1053
00:32:15,626 --> 00:32:16,756
滚动到文本视图的中间时


1054
00:32:17,026 --> 00:32:18,956
布局管理器可以


1055
00:32:18,956 --> 00:32:20,016
立即为该中间部分


1056
00:32:20,016 --> 00:32:22,696
执行字形生成和布局


1057
00:32:23,346 --> 00:32:25,696
所以如果你的文本存储中


1058
00:32:25,696 --> 00:32:26,886
有很多文本


1059
00:32:26,886 --> 00:32:28,376
使用非连续布局可以


1060
00:32:28,376 --> 00:32:29,276
为你带来巨大的性能提升


1061
00:32:29,776 --> 00:32:32,476
那么你如何启用


1062
00:32:33,266 --> 00:32:33,366
这个功能呢


1063
00:32:33,836 --> 00:32:35,946
非连续布局是


1064
00:32:35,946 --> 00:32:37,366
NSLayoutManager 的一个属性


1065
00:32:37,366 --> 00:32:39,346
对于 NSTextView


1066
00:32:39,346 --> 00:32:41,346
你可以使用布局管理器


1067
00:32:41,346 --> 00:32:42,486
来访问文本


1068
00:32:42,486 --> 00:32:43,436
然后在其中设置该属性


1069
00:32:44,006 --> 00:32:46,896
对于 UITextView


1070
00:32:46,896 --> 00:32:47,786
你通常不需要做任何事情


1071
00:32:47,786 --> 00:32:48,756
因为这是默认开启的


1072
00:32:48,756 --> 00:32:51,946
但只需要记住一件重要的事情


1073
00:32:53,006 --> 00:32:54,926
由于 UITextView 是 UIScrollView 的子类


1074
00:32:55,416 --> 00:32:57,806
因此非连续布局


1075
00:32:57,846 --> 00:32:59,586
需要启用滚动


1076
00:32:59,586 --> 00:33:00,106
才能生效


1077
00:33:01,266 --> 00:33:02,776
这是因为当你禁用滚动时


1078
00:33:02,776 --> 00:33:04,366
询求你的文本视图


1079
00:33:04,366 --> 00:33:06,086
所包含的内容大小


1080
00:33:06,086 --> 00:33:07,116
需要布局


1081
00:33:07,116 --> 00:33:08,376
所有的文本


1082
00:33:08,906 --> 00:33:09,776
所以你根本


1083
00:33:09,776 --> 00:33:10,716
不会获得


1084
00:33:10,716 --> 00:33:11,726
非连续布局的


1085
00:33:11,726 --> 00:33:12,156
性能优势


1086
00:33:12,816 --> 00:33:15,636
这把我们引导了一个


1087
00:33:15,636 --> 00:33:16,376
很重要的问题上


1088
00:33:17,186 --> 00:33:18,236
当你使用非连续布局时


1089
00:33:18,236 --> 00:33:19,696
你应该避免一次


1090
00:33:19,696 --> 00:33:20,916
请求全部或者大多数文本的布局


1091
00:33:20,916 --> 00:33:23,136
因为这样做


1092
00:33:23,136 --> 00:33:24,116
从根本上就


1093
00:33:24,116 --> 00:33:25,026
违背了我们的初衷


1094
00:33:25,086 --> 00:33:27,516
所以如果你只有一个文本容器


1095
00:33:27,516 --> 00:33:28,926
不要要求


1096
00:33:28,926 --> 00:33:29,956
整个容器的布局


1097
00:33:30,796 --> 00:33:31,866
并且不要要求


1098
00:33:31,866 --> 00:33:33,196
包含文本结尾的大范围字符


1099
00:33:33,196 --> 00:33:37,106
或字形的布局


1100
00:33:37,366 --> 00:33:38,526
我们并没有深入


1101
00:33:38,526 --> 00:33:39,406
研究文本性能的主题


1102
00:33:39,406 --> 00:33:42,076
因为 我在去年的 WWDC 2017 上针对这一点


1103
00:33:42,386 --> 00:33:44,826
进行了一次非常棒的演讲


1104
00:33:44,826 --> 00:33:45,766
那就是框架效率的不完整性


1105
00:33:46,186 --> 00:33:47,226
你可以在讨论会结束时


1106
00:33:47,226 --> 00:33:48,576
通过更多信息链接


1107
00:33:48,576 --> 00:33:49,306
访问该视频


1108
00:33:49,306 --> 00:33:50,026
好的


1109
00:33:51,396 --> 00:33:53,876
现在是时候谈论


1110
00:33:53,876 --> 00:33:55,006
每个人最喜欢的话题


1111
00:33:55,206 --> 00:33:55,666
安全


1112
00:33:56,406 --> 00:33:59,486
你可能已经注意到


1113
00:33:59,486 --> 00:34:00,526
最近有一些事件发生在互联网上


1114
00:34:00,526 --> 00:34:02,456
某些人利用我们软件中的错误


1115
00:34:02,456 --> 00:34:07,346
来给使用我们产品的人们制造麻烦


1116
00:34:08,896 --> 00:34:10,016
作为回应


1117
00:34:10,016 --> 00:34:11,416
我们正在继续设计


1118
00:34:11,606 --> 00:34:12,956
抵御这类攻击的技术


1119
00:34:12,956 --> 00:34:16,036
但今天我想谈谈


1120
00:34:16,036 --> 00:34:17,326
我们如何共同努力


1121
00:34:17,326 --> 00:34:18,755
为这些攻击


1122
00:34:18,755 --> 00:34:20,025
提供更强大的防御


1123
00:34:20,815 --> 00:34:21,626
所以你可能已经听说过


1124
00:34:21,626 --> 00:34:24,126
纵深防御的概念


1125
00:34:24,706 --> 00:34:26,056
如果你不熟悉


1126
00:34:26,056 --> 00:34:27,856
这些术语的话 纵深防御


1127
00:34:27,856 --> 00:34:30,706
就是创建多层保护


1128
00:34:30,706 --> 00:34:31,226
来抵御威胁


1129
00:34:31,226 --> 00:34:33,926
这个概念已经存在了几个世纪了


1130
00:34:34,096 --> 00:34:35,556
你可以在中世纪城堡的设计中


1131
00:34:35,556 --> 00:34:36,275
看到它


1132
00:34:36,826 --> 00:34:38,056
城堡周围的地上没有树木


1133
00:34:38,085 --> 00:34:39,906
所以你可以看到袭击者来了


1134
00:34:39,906 --> 00:34:41,656
还有一个护城河


1135
00:34:41,656 --> 00:34:42,525
可以让城堡更加难以接近


1136
00:34:42,525 --> 00:34:43,545
并且可以防止敌人在


1137
00:34:43,545 --> 00:34:44,306
下面挖隧道


1138
00:34:44,306 --> 00:34:46,876
而墙壁是另一道防线


1139
00:34:47,076 --> 00:34:48,166
它们很高


1140
00:34:48,166 --> 00:34:49,096
所以很难攀爬


1141
00:34:49,956 --> 00:34:50,926
并且在墙壁和顶部


1142
00:34:50,926 --> 00:34:52,456
有很多垛口


1143
00:34:52,456 --> 00:34:54,255
让防御者能在


1144
00:34:54,255 --> 00:34:55,406
有防御的地方


1145
00:34:55,406 --> 00:34:55,886
向攻击者开火


1146
00:34:57,096 --> 00:34:58,796
这些保护中单独


1147
00:34:58,796 --> 00:35:00,176
任何一种都可能不足以


1148
00:35:00,296 --> 00:35:01,836
抵御攻击


1149
00:35:01,836 --> 00:35:03,556
但它们组合在一起


1150
00:35:03,676 --> 00:35:04,356
就提供了强有力的防御


1151
00:35:05,066 --> 00:35:07,796
就像城堡一样


1152
00:35:07,796 --> 00:35:09,246
我们在这里为攻击


1153
00:35:09,246 --> 00:35:11,126
提供了多层防御


1154
00:35:11,126 --> 00:35:12,246
但没没有人会阻止


1155
00:35:12,316 --> 00:35:13,376
你在你的 App 或框架中


1156
00:35:13,376 --> 00:35:14,636
采取自己的


1157
00:35:14,636 --> 00:35:15,106
防御措施


1158
00:35:15,776 --> 00:35:17,266
通过这样做


1159
00:35:17,266 --> 00:35:18,596
你可以添加另一层保护


1160
00:35:18,596 --> 00:35:19,936
并提高产品安全性


1161
00:35:20,406 --> 00:35:21,066
这是共赢


1162
00:35:21,646 --> 00:35:23,216
那么让我们来谈谈


1163
00:35:23,866 --> 00:35:25,466
你可以在这里做什么


1164
00:35:25,676 --> 00:35:26,556
而我希望你考虑的是


1165
00:35:26,556 --> 00:35:28,626
在你的 App 或框架中


1166
00:35:28,626 --> 00:35:30,506
设置文本输入限制


1167
00:35:31,426 --> 00:35:32,766
现在我想强调


1168
00:35:32,766 --> 00:35:33,766
这可能并不总是


1169
00:35:33,816 --> 00:35:34,456
有意义的


1170
00:35:34,756 --> 00:35:36,106
因此举例来说


1171
00:35:36,106 --> 00:35:37,606
如果你的 App 是


1172
00:35:37,606 --> 00:35:38,736
Emily 之前展示的那种


1173
00:35:38,736 --> 00:35:40,336
日记 App 的创作工具


1174
00:35:40,336 --> 00:35:42,066
那么对该文本的长度设置限制


1175
00:35:42,066 --> 00:35:42,986
并没有任何意义


1176
00:35:43,296 --> 00:35:44,276
所以如果没有意义


1177
00:35:44,516 --> 00:35:45,626
你就不应该这样做


1178
00:35:46,416 --> 00:35:47,996
但相比之下


1179
00:35:47,996 --> 00:35:49,436
如果你的手机 App 有一个


1180
00:35:49,436 --> 00:35:50,886
用于为帐户分配昵称的


1181
00:35:50,886 --> 00:35:52,676
文本域 那么你可能会想


1182
00:35:52,676 --> 00:35:53,816
在这里应该设定怎样的限制


1183
00:35:53,816 --> 00:35:54,266
才合理


1184
00:35:54,846 --> 00:35:57,456
设置这些限制是个好主意


1185
00:35:57,456 --> 00:35:58,926
因为所有文本输入


1186
00:35:58,926 --> 00:36:00,916
都有潜在的风险


1187
00:36:02,086 --> 00:36:03,926
当你允许文本输入时


1188
00:36:03,926 --> 00:36:05,906
你就允许了复制和粘贴


1189
00:36:05,906 --> 00:36:08,206
你不知道其中会被


1190
00:36:08,206 --> 00:36:08,986
粘贴哪种文本


1191
00:36:10,126 --> 00:36:10,926
它可能是任何东西


1192
00:36:10,926 --> 00:36:12,016
它可能是一个


1193
00:36:12,016 --> 00:36:12,766
带有恶意字符组合的字符串


1194
00:36:12,766 --> 00:36:14,436
或者它可能只是


1195
00:36:14,436 --> 00:36:15,816
一个非常


1196
00:36:16,126 --> 00:36:19,236
非常长的字符串


1197
00:36:20,566 --> 00:36:21,796
即使像这样的长字符串


1198
00:36:21,796 --> 00:36:23,116
本身可能不是恶意的


1199
00:36:23,116 --> 00:36:24,336
它也可能会导致你的 App


1200
00:36:24,336 --> 00:36:25,526
冻结或卡住


1201
00:36:26,296 --> 00:36:27,386
如果你有一个文本域


1202
00:36:27,676 --> 00:36:29,276
是为了一行输入设计的


1203
00:36:29,276 --> 00:36:30,816
但有人想将“战争与和平”的


1204
00:36:30,816 --> 00:36:32,126
全部内容粘贴进去


1205
00:36:32,126 --> 00:36:33,536
这大约有 310 万个


1206
00:36:33,856 --> 00:36:35,106
英文字符


1207
00:36:35,106 --> 00:36:37,576
这是否合理


1208
00:36:39,636 --> 00:36:41,226
可能并不


1209
00:36:42,316 --> 00:36:43,916
所以这是一个很好的例子


1210
00:36:43,916 --> 00:36:45,106
它可以让你能强制增加


1211
00:36:45,106 --> 00:36:46,656
你自己的限制


1212
00:36:47,926 --> 00:36:49,376
以下是


1213
00:36:49,376 --> 00:36:50,926
设定这些限制的推荐方法


1214
00:36:51,766 --> 00:36:52,856
你希望在输入字符串


1215
00:36:52,926 --> 00:36:54,756
在文本域上设置之前进行验证


1216
00:36:55,186 --> 00:36:56,846
对于 UITextFields


1217
00:36:56,846 --> 00:36:57,706
你可以通过


1218
00:36:57,986 --> 00:36:59,066
使用 UITextFieldDelegate 来完成此操作


1219
00:36:59,936 --> 00:37:01,356
对于 NSTextFields


1220
00:37:01,356 --> 00:37:03,126
你应该使用自定义的 NSFormatter


1221
00:37:03,126 --> 00:37:04,426
来实现你的验证逻辑


1222
00:37:04,426 --> 00:37:07,656
而且我们还有一些额外的


1223
00:37:07,796 --> 00:37:09,706
安全增强功能即将推出


1224
00:37:10,386 --> 00:37:11,396
因此请在发布说明中注意它们


1225
00:37:11,396 --> 00:37:12,816
如果你有任何问题


1226
00:37:12,816 --> 00:37:13,856
请在本周的实验室中


1227
00:37:13,856 --> 00:37:14,526
联系我们


1228
00:37:15,176 --> 00:37:16,666
好的


1229
00:37:16,876 --> 00:37:18,886
时间要到了


1230
00:37:18,886 --> 00:37:19,456
所以让我们回顾一下


1231
00:37:20,436 --> 00:37:21,516
你知道如何选择正确的控件


1232
00:37:21,516 --> 00:37:23,286
自定义点


1233
00:37:23,786 --> 00:37:25,466
和自定义方法


1234
00:37:25,466 --> 00:37:26,626
并了解在正确性


1235
00:37:26,626 --> 00:37:27,646
性能和安全性方面


1236
00:37:27,646 --> 00:37:29,876
遵循的最佳实践


1237
00:37:30,626 --> 00:37:32,066
使用这些知识和 TextKit


1238
00:37:32,066 --> 00:37:34,216
去创伟大的东西吧


1239
00:37:35,636 --> 00:37:36,946
等等


1240
00:37:36,946 --> 00:37:38,066
这里是超级重要的


1241
00:37:38,066 --> 00:37:39,346
更多信息链接


1242
00:37:39,346 --> 00:37:40,506
你可以在这里找到


1243
00:37:40,506 --> 00:37:41,766
我们今天引用的


1244
00:37:41,766 --> 00:37:42,596
所有过去的优秀讨论会和文档


1245
00:37:43,096 --> 00:37:44,326
请在星期四和星期五来


1246
00:37:44,326 --> 00:37:45,036
我们实验室参观


1247
00:37:45,596 --> 00:37:47,396
谢谢 希望你们可以享受讨论会的


1248
00:37:47,396 --> 00:37:47,976
其余部分


1249
00:37:48,016 --> 00:37:50,000
[ 掌声 ]

