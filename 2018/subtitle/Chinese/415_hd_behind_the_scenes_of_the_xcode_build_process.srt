1
00:00:17,284 --> 00:00:24,291 line:0
（Xcode构建过程的后台工作
演讲415）


2
00:00:36,303 --> 00:00:37,571 line:-1
大家下午好


3
00:00:38,172 --> 00:00:41,508 line:-2
欢迎来到
Xcode构建过程的后台工作


4
00:00:41,742 --> 00:00:43,243 line:-1
我是Jake Petroules


5
00:00:43,310 --> 00:00:45,612 line:-2
我是Xcode构建系统团队的
工程师


6
00:00:45,913 --> 00:00:47,548 line:-1
今天我们要讨论


7
00:00:47,915 --> 00:00:49,416 line:-1
Xcode构建过程


8
00:00:51,185 --> 00:00:54,054 line:-2
首先我要讲讲
Xcode 10的新构建系统


9
00:00:54,121 --> 00:00:55,756 line:-1
用Swift的scratch编写


10
00:00:55,822 --> 00:00:58,525 line:-1
提供更好的性能和可靠度


11
00:00:58,959 --> 00:01:00,194 line:-1
我们要解答如下问题


12
00:01:00,260 --> 00:01:02,496 line:-2
按住Command + B
会发生什么


13
00:01:02,563 --> 00:01:04,197 line:-1
如何架构构建过程


14
00:01:04,263 --> 00:01:06,900 line:-2
Xcode如何用
project文件的信息


15
00:01:06,967 --> 00:01:09,937 line:-1
决定构建过程的模型和流程


16
00:01:11,438 --> 00:01:13,907 line:-1
然后是编译器领域


17
00:01:14,541 --> 00:01:16,376 line:-1
看看Clang和Swift


18
00:01:16,443 --> 00:01:18,679 line:-1
怎样将源代码加入目标文件


19
00:01:19,179 --> 00:01:21,481 line:-2
我们会展示
头文件和模块的运行


20
00:01:21,582 --> 00:01:24,218 line:-1
编译器如何在代码中查找声明


21
00:01:24,284 --> 00:01:26,820 line:-1
以及Swift编译模型如何不同于


22
00:01:26,887 --> 00:01:29,489 line:-2
C、C++
和Objective-C


23
00:01:30,724 --> 00:01:32,593 line:-1
最后是连接器


24
00:01:32,893 --> 00:01:35,863 line:-1
构建过程的最后一步


25
00:01:36,330 --> 00:01:39,499 line:-2
我们会解释什么是符号
及其与源代码的关系


26
00:01:39,566 --> 00:01:42,536 line:-2
还有连接器如何将
编译器产生的目标文件


27
00:01:42,603 --> 00:01:44,805 line:-1
整合成最终的可执行文件


28
00:01:44,872 --> 00:01:46,607 line:-1
提供给app或框架


29
00:01:48,141 --> 00:01:49,276 line:-1
我们会使用


30
00:01:49,343 --> 00:01:51,078 line:-1
叫PetWall的小app样本


31
00:01:51,144 --> 00:01:52,980 line:-1
作为这次演讲的示例


32
00:01:53,146 --> 00:01:56,016 line:-2
它只是一个很小的iOS app
用来展示宠物图片


33
00:01:59,119 --> 00:02:02,189 line:-2
首先来了解
什么是构建过程


34
00:02:02,256 --> 00:02:05,592 line:-2
以及如何用Xcode
创建类似PetWall的app


35
00:02:06,126 --> 00:02:08,595 line:-1
这里你看到app对象、框架


36
00:02:08,662 --> 00:02:11,698 line:-2
不同的代码文件 都是Swift
和Objective-C


37
00:02:11,899 --> 00:02:14,134 line:-1
看起来可能很像你自己的项目


38
00:02:15,669 --> 00:02:18,105 line:-1
在构建app的时候


39
00:02:19,106 --> 00:02:22,009 line:-1
要经过很多步骤 从源代码


40
00:02:22,075 --> 00:02:23,610 line:-1
和项目资源开始


41
00:02:24,044 --> 00:02:25,679 line:-1
到提供给客户的打包文件


42
00:02:25,746 --> 00:02:28,248 line:-1
或上传到App Store发布


43
00:02:29,049 --> 00:02:31,785 line:-1
你要编译和连接源代码


44
00:02:31,885 --> 00:02:36,924 line:-2
复制和处理资源 比如头文件
资源目录和Storyboard


45
00:02:37,224 --> 00:02:39,927 line:-1
最后是代码签名以及自定义


46
00:02:39,993 --> 00:02:41,595 line:-1
shell脚本或make文件


47
00:02:41,662 --> 00:02:44,398 line:-1
比如给框架构建API文件


48
00:02:44,531 --> 00:02:47,267 line:-1
运行代码检查和验证工具等


49
00:02:48,402 --> 00:02:49,703 line:-1
大多数任务


50
00:02:49,770 --> 00:02:52,339 line:-2
在构建过程中
由命令行工具运行


51
00:02:52,406 --> 00:02:56,910 line:-2
比如Clang、LD、AC工具
IB工具、代码符号等


52
00:02:57,444 --> 00:02:59,112 line:-1
这些工具的执行


53
00:02:59,179 --> 00:03:00,948 line:-1
需要一组特定的实参


54
00:03:01,181 --> 00:03:02,616 line:-1
以特定的顺序


55
00:03:02,683 --> 00:03:05,018 line:-1
基于Xcode项目的配置


56
00:03:06,620 --> 00:03:08,188 line:-1
构建系统的用处


57
00:03:08,255 --> 00:03:11,258 line:-1
就是将任务的执行部署自动化


58
00:03:11,358 --> 00:03:12,926 line:-1
在每次构建的时候


59
00:03:13,460 --> 00:03:16,096 line:-1
由于任务数量成千上万


60
00:03:16,163 --> 00:03:18,232 line:-1
构建过程更是数不胜数


61
00:03:18,298 --> 00:03:20,534 line:-1
依赖关系十分复杂


62
00:03:20,701 --> 00:03:22,302 line:-1
你肯定不想手动输入


63
00:03:22,369 --> 00:03:24,304 line:-1
1天敲100遍命令


64
00:03:25,472 --> 00:03:27,508 line:-1
那就让构建系统来做


65
00:03:29,409 --> 00:03:32,079 line:-2
我说过
构建系统里的任务


66
00:03:32,145 --> 00:03:34,181 line:-1
按照特定的顺序进行


67
00:03:34,381 --> 00:03:37,718 line:-2
因此我们谈谈这个顺序
怎么决定及其重要性


68
00:03:38,785 --> 00:03:40,654 line:-1
构建任务的执行顺序


69
00:03:40,721 --> 00:03:43,223 line:-1
取决于信息的依赖关系


70
00:03:43,290 --> 00:03:44,424 line:-1
就是任务


71
00:03:44,725 --> 00:03:46,460 line:-1
任务需要的输入


72
00:03:46,693 --> 00:03:48,428 line:-1
和任务生成的输出


73
00:03:49,329 --> 00:03:51,164 line:-1
以编译任务为例


74
00:03:51,231 --> 00:03:55,402 line:-2
它需要输入源代码文件
比如PetController.m


75
00:03:55,469 --> 00:03:59,373 line:-2
然后输出目标文件
比如PetController.o


76
00:04:00,340 --> 00:04:01,942 line:-1
同样 连接器任务


77
00:04:02,009 --> 00:04:03,911 line:-1
需要几个目标文件


78
00:04:03,977 --> 00:04:06,146 line:-1
由编译器在上个任务中生成


79
00:04:06,380 --> 00:04:08,949 line:-1
再生成可执行或lib文件


80
00:04:09,016 --> 00:04:11,852 line:-2
比如PetWall运行文件
会存到.app资源文件包


81
00:04:12,219 --> 00:04:15,322 line:-1
希望大家已经看出些许端倪


82
00:04:15,989 --> 00:04:19,726 line:-2
你能看到信息的依赖关系
是顺着这个图形的走向


83
00:04:19,793 --> 00:04:22,529 line:-1
最终形成执行顺序


84
00:04:22,963 --> 00:04:25,933 line:-2
现在大家关注下
图形中的编译任务


85
00:04:25,999 --> 00:04:28,468 line:-1
很像川流不息的马路


86
00:04:28,569 --> 00:04:30,237 line:-1
你看得到编译任务


87
00:04:30,504 --> 00:04:34,474 line:-2
在各自的路上互不干涉
可以平行运行


88
00:04:35,375 --> 00:04:37,911 line:-2
因为连接器任务
需要所有其他的输入


89
00:04:38,011 --> 00:04:39,413 line:-1
它要在最后一位


90
00:04:41,348 --> 00:04:44,017 line:-1
构建系统通过依赖关系


91
00:04:44,084 --> 00:04:46,653 line:-1
决定任务执行的顺序


92
00:04:46,720 --> 00:04:49,089 line:-1
以及平行运行的任务


93
00:04:49,156 --> 00:04:51,091 line:-1
我们叫做依赖顺序


94
00:04:51,658 --> 00:04:53,861 line:-1
知道了构建过程的定义后


95
00:04:53,961 --> 00:04:57,097 line:-1
我们具体讲讲怎么操作


96
00:04:57,164 --> 00:04:59,700 line:-1
点击“构建”会发生什么？


97
00:05:00,434 --> 00:05:03,570 line:-1
构建系统的第一步是获取构建描述


98
00:05:03,637 --> 00:05:05,138 line:-1
Xcode项目文件


99
00:05:05,239 --> 00:05:08,742 line:-1
解析项目中的所有文件


100
00:05:08,809 --> 00:05:11,178 line:-1
目标app和依赖关系


101
00:05:11,245 --> 00:05:12,246 line:-1
构建设置


102
00:05:12,779 --> 00:05:15,816 line:-1
转换成一个树形结构叫做定向图


103
00:05:16,283 --> 00:05:17,985 line:-1
它显示了所有依赖关系


104
00:05:18,051 --> 00:05:20,821 line:-1
项目中的输入和输出文件


105
00:05:20,954 --> 00:05:23,957 line:-1
以及处理它们的执行任务


106
00:05:26,159 --> 00:05:29,596 line:-1
然后低级执行引擎会处理这张图


107
00:05:29,663 --> 00:05:34,368 line:-1
研究依赖关系 决定执行哪个任务


108
00:05:34,601 --> 00:05:36,770 line:-1
执行顺序是什么


109
00:05:36,837 --> 00:05:39,206 line:-1
以及哪些可以平行运行


110
00:05:39,273 --> 00:05:41,742 line:-1
然后继续执行任务


111
00:05:42,609 --> 00:05:44,711 line:-1
我说的低级执行引擎


112
00:05:44,778 --> 00:05:46,380 line:-2
是新构建系统的
叫做llbuild


113
00:05:46,446 --> 00:05:48,615 line:-1
它是开源资源 用GitHub开发


114
00:05:48,715 --> 00:05:50,517 line:-1
如果对构建系统开发感兴趣


115
00:05:50,584 --> 00:05:52,619 line:-1
请随意研究 看看它如何工作


116
00:05:52,819 --> 00:05:54,821 line:-1
它的链接和另一个关于构建系统的


117
00:05:54,888 --> 00:05:57,124 line:-1
开源模块 会在演讲最后提到


118
00:05:58,292 --> 00:06:01,161 line:-1
现在讲讲已知的依赖关系


119
00:06:01,495 --> 00:06:04,331 line:-1
由于你无法获取过多的依赖关系信息


120
00:06:04,531 --> 00:06:07,167 line:-1
构建系统可能会找到更多


121
00:06:07,234 --> 00:06:09,203 line:-1
在任务的执行过程中


122
00:06:09,703 --> 00:06:12,906 line:-2
比如Clang编译
Objective-C文件时


123
00:06:12,973 --> 00:06:15,209 line:-1
如你所料 会生成目标文件


124
00:06:15,576 --> 00:06:17,778 line:-1
但是它也会生成另一个文件


125
00:06:18,445 --> 00:06:19,646 line:-1
其中包含一个列表


126
00:06:19,713 --> 00:06:22,249 line:-1
列出源文件中的头文件


127
00:06:22,749 --> 00:06:24,351 line:-1
那么下次构建时


128
00:06:24,418 --> 00:06:27,020 line:-1
构建系统会使用这个文件中的信息


129
00:06:27,087 --> 00:06:29,323 line:-1
以保证再次编译源文件


130
00:06:29,389 --> 00:06:32,292 line:-1
如果你更改了其中任何头文件的话


131
00:06:32,559 --> 00:06:35,629 line:-2
这里的关系路径是
PetController.h


132
00:06:35,696 --> 00:06:39,066 line:-2
PetController.d
.n直到.o文件


133
00:06:40,300 --> 00:06:42,970 line:-1
我们已经讲了很多


134
00:06:43,170 --> 00:06:47,140 line:-1
构建系统的主要工作就是执行任务


135
00:06:47,908 --> 00:06:51,778 line:-1
当然项目越大 构建时间越长


136
00:06:52,012 --> 00:06:53,981 line:-1
你肯定不想把所有任务都运行一遍


137
00:06:54,047 --> 00:06:55,549 line:-1
在每次构建的时候


138
00:06:56,049 --> 00:06:58,418 line:-1
构建系统实际上可以只执行


139
00:06:58,485 --> 00:07:00,954 line:-1
定向图上的任务子集


140
00:07:02,789 --> 00:07:04,992 line:-1
基于你对项目做出的更改


141
00:07:05,192 --> 00:07:06,527 line:-1
对比上次构建过程


142
00:07:07,127 --> 00:07:09,663 line:-1
我们称之为累加构建


143
00:07:09,863 --> 00:07:12,766 line:-1
准确的依赖关系十分重要


144
00:07:12,833 --> 00:07:16,069 line:-1
这样累加构建才能正确高效地工作


145
00:07:17,971 --> 00:07:20,174 line:-2
下面看看哪些更改
会影响构建系统


146
00:07:20,240 --> 00:07:22,009 line:-1
以及与累加构建的关系


147
00:07:22,075 --> 00:07:24,778 line:-1
构建系统如何检测更改呢？


148
00:07:26,013 --> 00:07:28,949 line:-2
构建过程中的每个任务
都有相应的签名


149
00:07:29,116 --> 00:07:30,751 line:-2
类似于Hash
通过计算


150
00:07:30,817 --> 00:07:33,120 line:-1
多个任务相关信息而得出


151
00:07:34,755 --> 00:07:37,691 line:-2
这些信息包括
任务输入的统计信息


152
00:07:37,758 --> 00:07:40,327 line:-2
比如文件路径
和更改时间标签


153
00:07:40,494 --> 00:07:43,797 line:-1
运行命令的命令行指示


154
00:07:43,864 --> 00:07:45,465 line:-1
以及其他有关任务的元数据


155
00:07:45,532 --> 00:07:48,035 line:-1
比如编译器版本


156
00:07:49,503 --> 00:07:52,072 line:-1
构建系统会追踪任务签名


157
00:07:52,139 --> 00:07:54,074 line:-1
包括当前和之前的构建


158
00:07:54,141 --> 00:07:57,911 line:-2
所以它知道每次构建时
是否要重新运行任务


159
00:07:59,046 --> 00:08:00,447 line:-1
如果某个任务的签名


160
00:08:00,514 --> 00:08:03,350 line:-1
与上次构建时不同


161
00:08:03,417 --> 00:08:05,619 line:-1
它就会重新运行这个任务


162
00:08:06,019 --> 00:08:08,288 line:-1
如果相同就会跳过


163
00:08:08,922 --> 00:08:11,792 line:-1
这就是累加构建的概念


164
00:08:12,893 --> 00:08:14,595 line:-1
我们大概了解了


165
00:08:14,661 --> 00:08:17,164 line:-1
构建过程的定义和流程


166
00:08:17,431 --> 00:08:19,566 line:-1
如何利用构建系统呢？


167
00:08:21,134 --> 00:08:22,769 line:-1
先回顾下基本知识


168
00:08:23,036 --> 00:08:27,574 line:-2
构建系统按照一定顺序
执行一系列任务


169
00:08:27,641 --> 00:08:30,477 line:-2
但要记得
构建过程以定向图表示


170
00:08:31,879 --> 00:08:35,315 line:-2
我们不要担心
任务执行的顺序


171
00:08:35,381 --> 00:08:37,150 line:-1
这是构建系统的工作


172
00:08:37,717 --> 00:08:39,419 line:-1
作为开发者


173
00:08:39,486 --> 00:08:42,155 line:-2
我们要考虑的是
任务之间的依赖关系


174
00:08:42,389 --> 00:08:44,691 line:-2
让构建系统决定
最佳的执行方法


175
00:08:44,758 --> 00:08:46,360 line:-1
根据定向图结构


176
00:08:46,894 --> 00:08:49,329 line:-2
这样构建系统
可以正确地给任务排序


177
00:08:49,396 --> 00:08:50,931 line:-1
可能的时候并排运行


178
00:08:50,998 --> 00:08:53,800 line:-1
以完全利用多核硬件


179
00:08:54,968 --> 00:08:56,937 line:-1
依赖关系源自哪里呢？


180
00:08:57,271 --> 00:08:58,238 line:-1
对某些任务


181
00:08:58,305 --> 00:09:00,240 line:-1
依赖关系


182
00:09:00,307 --> 00:09:01,608 line:-1
来自构建系统自带的数据


183
00:09:01,842 --> 00:09:05,179 line:-2
构建系统自带一些规则
比如编译器、连接器


184
00:09:05,245 --> 00:09:08,315 line:-2
资源目录
Storyboard处理器等等


185
00:09:08,549 --> 00:09:11,618 line:-2
这些规则定义了
哪些是输入文件


186
00:09:11,685 --> 00:09:13,720 line:-1
和哪些是输出文件


187
00:09:15,422 --> 00:09:17,157 line:-1
还有目标依赖关系


188
00:09:17,224 --> 00:09:19,993 line:-2
大致决定了
目标构建的顺序


189
00:09:20,160 --> 00:09:21,395 line:-1
有些时候


190
00:09:21,461 --> 00:09:24,498 line:-2
构建系统可以编译
不同目标和平行文件


191
00:09:24,798 --> 00:09:27,034 line:-2
之前的Xcode
要构建一个app


192
00:09:27,100 --> 00:09:29,403 line:-1
就要完成整个app的构建


193
00:09:29,469 --> 00:09:31,605 line:-1
然后才能使用


194
00:09:32,072 --> 00:09:35,609 line:-2
Xcode X的新构建系统
就要快得多


195
00:09:35,776 --> 00:09:38,345 line:-1
编译源阶段会提前开始


196
00:09:38,412 --> 00:09:40,881 line:-1
免费提供并行


197
00:09:41,114 --> 00:09:44,117 line:-2
但是如果含有
任何运行脚本阶段


198
00:09:44,184 --> 00:09:45,686 line:-1
这些阶段完成后


199
00:09:45,752 --> 00:09:48,155 line:-1
并行才能开始


200
00:09:49,389 --> 00:09:52,826 line:-1
有关依赖的还有隐性依赖关系


201
00:09:53,293 --> 00:09:55,495 line:-2
比如在链接库里
列出一个目标


202
00:09:55,562 --> 00:09:56,864 line:-1
用二进制构建阶段


203
00:09:57,331 --> 00:10:00,033 line:-2
隐性依赖关系
由scheme编辑器生成


204
00:10:00,100 --> 00:10:01,502 line:-1
默认为开启


205
00:10:01,635 --> 00:10:04,571 line:-2
构建系统会为这个目标
建立隐性依赖关系


206
00:10:04,638 --> 00:10:06,840 line:-1
即便它不在目标依赖关系之列


207
00:10:08,442 --> 00:10:10,577 line:-1
接下来是构建阶段依赖


208
00:10:10,911 --> 00:10:11,812 line:-1
在目标编辑器里


209
00:10:11,879 --> 00:10:13,881 line:-1
你会看到几个构建阶段


210
00:10:14,014 --> 00:10:18,652 line:-2
复制头文件、编译源
复制资源包等等


211
00:10:19,086 --> 00:10:21,154 line:-1
这些任务与每个阶段相关


212
00:10:21,221 --> 00:10:22,489 line:-1
通常按组运行


213
00:10:22,556 --> 00:10:24,892 line:-1
根据阶段的排列顺序


214
00:10:25,025 --> 00:10:27,494 line:-2
构建系统也会忽略它
如果有更好的方法


215
00:10:27,561 --> 00:10:30,797 line:-1
比如第三方静态库阶段


216
00:10:30,864 --> 00:10:32,533 line:-1
在编译源之前


217
00:10:33,033 --> 00:10:35,435 line:-2
注意有的时候
构建阶段顺序不对


218
00:10:35,502 --> 00:10:37,137 line:-1
会导致问题或构建失败


219
00:10:37,204 --> 00:10:38,705 line:-1
因此为了解依赖关系


220
00:10:38,772 --> 00:10:41,575 line:-1
验证构建阶段的顺序


221
00:10:42,943 --> 00:10:45,112 line:-1
还有scheme顺序依赖


222
00:10:45,345 --> 00:10:47,347 line:-2
如果开启了
并行构建检查


223
00:10:47,414 --> 00:10:48,615 line:-1
在方案设置里


224
00:10:48,682 --> 00:10:50,250 line:-1
构建性能会更好


225
00:10:50,317 --> 00:10:52,886 line:-1
不用担心目标顺序


226
00:10:52,953 --> 00:10:55,489 line:-2
但如果关闭
并行构建


227
00:10:55,556 --> 00:10:59,026 line:-2
Xcode构建目标时
会按照你排列的


228
00:10:59,092 --> 00:11:01,461 line:-2
构建行动顺序
逐个构建


229
00:11:01,962 --> 00:11:04,131 line:-2
目标依赖关系
优先级较高


230
00:11:04,198 --> 00:11:05,866 line:-2
优先决定
第一个构建目标


231
00:11:05,933 --> 00:11:08,235 line:-1
但Xcode会遵从这个排列


232
00:11:08,569 --> 00:11:12,272 line:-2
这个让人跃跃欲试
因为它给出了可预期的构建顺序


233
00:11:12,339 --> 00:11:14,575 line:-1
即使依赖关系有误


234
00:11:14,708 --> 00:11:17,511 line:-2
但这样会牺牲
大量并行空间


235
00:11:17,711 --> 00:11:19,012 line:-1
延缓构建速度


236
00:11:19,179 --> 00:11:22,216 line:-2
所以我们推荐
开启并行构建


237
00:11:22,282 --> 00:11:25,519 line:-2
正确设置依赖关系
不要依赖排序


238
00:11:27,521 --> 00:11:30,224 line:-1
最后 依赖关系在于你自己


239
00:11:30,290 --> 00:11:31,291 line:-1
开发者


240
00:11:32,759 --> 00:11:35,863 line:-2
你可以自定义shell脚本
构建阶段或规则


241
00:11:35,929 --> 00:11:38,866 line:-2
明确告诉构建系统
输入和输入都是什么


242
00:11:39,032 --> 00:11:42,536 line:-2
以避免重复运行
不必要的脚本任务


243
00:11:42,603 --> 00:11:45,472 line:-1
保证正确执行顺序


244
00:11:45,739 --> 00:11:48,942 line:-2
你可以用运行脚本阶段编辑器
定义输入和输出


245
00:11:49,009 --> 00:11:50,077 line:-1
这些文件的路径


246
00:11:50,143 --> 00:11:53,113 line:-2
将作为环境变量
在脚本中激活


247
00:11:54,681 --> 00:11:58,252 line:-2
不要依赖项目里
目标依赖关系的自动连接


248
00:11:58,652 --> 00:12:00,687 line:-2
Clang编译器
有自动关联功能


249
00:12:00,754 --> 00:12:04,324 line:-2
在构建设置中
自动使用关联框架


250
00:12:04,525 --> 00:12:07,327 line:-1
让编译器自动连接框架


251
00:12:07,394 --> 00:12:09,329 line:-1
对应导入的模块


252
00:12:09,396 --> 00:12:13,166 line:-2
不用在连接库的
构建阶段再明确表示


253
00:12:13,333 --> 00:12:14,501 line:-1
但是要注意


254
00:12:14,568 --> 00:12:16,770 line:-2
自动关联
不会建立依赖关系


255
00:12:16,837 --> 00:12:18,805 line:-1
在构建系统层级


256
00:12:18,939 --> 00:12:20,974 line:-2
所以它不能保证
依赖的目标


257
00:12:21,041 --> 00:12:24,011 line:-1
在关联之前已经建好


258
00:12:25,312 --> 00:12:29,216 line:-1
所以它只能用于平台STK的框架


259
00:12:29,283 --> 00:12:31,084 line:-2
比如
Foundation或UIKit


260
00:12:31,151 --> 00:12:34,354 line:-2
因为我们知道
它们在构建前就已经存在


261
00:12:34,721 --> 00:12:36,256 line:-1
你自己项目里的目标


262
00:12:36,323 --> 00:12:38,559 line:-1
要保证明确的库依赖关系


263
00:12:40,460 --> 00:12:42,296 line:-1
你也许需要创建项目引用


264
00:12:42,362 --> 00:12:44,398 line:-1
将另一个Xcode项目拖放到


265
00:12:44,464 --> 00:12:46,200 line:-1
项目文件导航


266
00:12:46,700 --> 00:12:49,503 line:-2
说明与其他项目的
目标文件的依赖关系


267
00:12:51,772 --> 00:12:54,508 line:-2
总结来说
有了准确的依赖关系


268
00:12:54,575 --> 00:12:56,944 line:-2
构建系统就能
更好地并行构建任务


269
00:12:57,077 --> 00:12:59,746 line:-1
保证每次构建的结果一致


270
00:12:59,980 --> 00:13:03,450 line:-2
这样就能减少构建用时
给开发多点时间


271
00:13:04,218 --> 00:13:06,086 line:-1
想知道更多快速构建的内容


272
00:13:06,153 --> 00:13:08,922 line:-2
如何最大化利用
崭新的iMac Pro内核


273
00:13:08,989 --> 00:13:12,159 line:-2
推荐观看演讲
用Xcode加速构建过程


274
00:13:12,559 --> 00:13:14,561 line:-2
现在
我要有请Jurgen


275
00:13:14,628 --> 00:13:16,997 line:-2
他会带大家
探索编译器的世界


276
00:13:23,270 --> 00:13:24,204 line:-1
谢谢 Jake


277
00:13:26,240 --> 00:13:29,276 line:-2
现在我们要看看
后台都发生了什么


278
00:13:29,710 --> 00:13:32,846 line:-2
当Xcode构建系统
启动Clang编译器的时候


279
00:13:34,281 --> 00:13:35,148 line:-1
大家好


280
00:13:35,215 --> 00:13:36,283 line:-1
我是Jurgen


281
00:13:36,617 --> 00:13:39,253 line:-2
我是Clang前端团队的
编译器工程师


282
00:13:40,087 --> 00:13:43,690 line:-2
今天我要讲两个功能
大家可能已经知道了


283
00:13:44,291 --> 00:13:46,860 line:-1
第一个是头文件映射


284
00:13:47,427 --> 00:13:49,997 line:-1
我们用它传递信息


285
00:13:50,197 --> 00:13:52,966 line:-2
从Xcode构建系统
到Clang编译器


286
00:13:54,067 --> 00:13:56,803 line:-1
第二个是Clang模块


287
00:13:57,204 --> 00:13:59,706 line:-1
我们用它加快构建的速度


288
00:14:01,041 --> 00:14:04,144 line:-1
在坐有些人可能只用Swift


289
00:14:04,645 --> 00:14:05,812 line:-1
我想告诉你


290
00:14:06,246 --> 00:14:08,448 line:-1
Swift在后台也用Clang


291
00:14:08,849 --> 00:14:11,485 line:-1
所以你们应该也会感兴趣


292
00:14:14,621 --> 00:14:15,722 line:-1
什么Clang？


293
00:14:16,990 --> 00:14:19,560 line:-2
Clang是Apple的
官方编译器


294
00:14:20,027 --> 00:14:23,764 line:-1
用于所有C语言


295
00:14:24,264 --> 00:14:28,035 line:-2
比如C、C++
当然还有Objective-C


296
00:14:28,135 --> 00:14:30,838 line:-1
大部分框架都在用的语言


297
00:14:32,472 --> 00:14:34,107 line:-1
Jake刚才提过


298
00:14:35,342 --> 00:14:38,078 line:-2
编译器一次性
编辑所有输入文件


299
00:14:38,145 --> 00:14:40,414 line:-1
生成仅一个输出文件


300
00:14:40,581 --> 00:14:42,482 line:-1
之后被连接器使用


301
00:14:43,417 --> 00:14:47,354 line:-1
如果要从OS访问API


302
00:14:47,888 --> 00:14:53,060 line:-2
或从自己的代码
访问实现文件


303
00:14:53,427 --> 00:14:56,430 line:-2
就需要一个叫做
头文件的东西


304
00:14:57,531 --> 00:14:59,733 line:-1
头文件是一种承诺


305
00:15:00,434 --> 00:15:04,638 line:-2
承诺在其他地方
存在这个实现文件


306
00:15:04,805 --> 00:15:06,173 line:-1
它们通常可以匹配


307
00:15:07,207 --> 00:15:10,611 line:-1
如果你只更新实现文件


308
00:15:10,911 --> 00:15:13,413 line:-2
而忘记头文件
你就食言了


309
00:15:14,381 --> 00:15:17,718 line:-2
通常这个问题
不会在编译过程中出现


310
00:15:17,885 --> 00:15:19,987 line:-1
因为编译器相信你的承诺


311
00:15:20,387 --> 00:15:23,090 line:-1
问题出在链接过程


312
00:15:24,791 --> 00:15:28,095 line:-2
编译器通常包含
不止一个头文件


313
00:15:28,495 --> 00:15:31,798 line:-2
而且所有编译器
都是这样被调用


314
00:15:32,366 --> 00:15:35,769 line:-1
以样本app为例


315
00:15:35,836 --> 00:15:38,105 line:-1
看看怎么处理头文件


316
00:15:40,507 --> 00:15:41,475 line:-1
这个PetWall


317
00:15:42,242 --> 00:15:44,311 line:-1
是多语言app


318
00:15:44,945 --> 00:15:47,648 line:-2
app本身
用Swift编写


319
00:15:48,649 --> 00:15:52,553 line:-2
框架的语言是
Objective-C


320
00:15:52,953 --> 00:15:55,422 line:0
它有个兼容库
美学档案


321
00:15:55,789 --> 00:15:58,325 line:0
是C++语言


322
00:16:00,160 --> 00:16:02,896 line:-2
时间越长
app内容越多


323
00:16:02,963 --> 00:16:07,801 line:-2
所以要重新组织
方便查找文件


324
00:16:08,135 --> 00:16:09,069 line:-1
比如


325
00:16:09,336 --> 00:16:12,806 line:-2
将所有跟猫有关的文件
移动到子文件


326
00:16:16,243 --> 00:16:20,147 line:-1
不要改变任何实现文件


327
00:16:20,681 --> 00:16:22,249 line:-1
也是可以的


328
00:16:22,983 --> 00:16:25,252 line:-1
那么你想


329
00:16:26,353 --> 00:16:29,590 line:-1
Clang是如何找到头文件的


330
00:16:32,492 --> 00:16:34,094 line:-1
举个简单的例子


331
00:16:34,628 --> 00:16:36,697 line:-1
这是一个实现文件


332
00:16:37,497 --> 00:16:38,665 line:-1
在这个代码里


333
00:16:38,966 --> 00:16:41,902 line:-2
包含一个头文件
命名为cat.h


334
00:16:43,103 --> 00:16:46,306 line:-1
怎么知道Clang做了什么


335
00:16:46,874 --> 00:16:49,643 line:-1
一是查看构建日志


336
00:16:50,711 --> 00:16:56,049 line:-2
看看Xcode构建系统
在编译这个文件时做了什么


337
00:16:56,283 --> 00:16:58,252 line:-1
复制粘贴这个调用代码


338
00:16:59,119 --> 00:17:02,956 line:-2
打开命令窗口
输入-v选项


339
00:17:03,790 --> 00:17:05,492 line:-1
-v代表显示


340
00:17:05,858 --> 00:17:08,795 line:-1
然后Clang会返回很多信息


341
00:17:09,396 --> 00:17:12,165 line:-1
我们只要关注一个


342
00:17:12,598 --> 00:17:13,567 line:-1
搜索路径


343
00:17:15,202 --> 00:17:16,537 line:-1
我说搜索路径


344
00:17:17,069 --> 00:17:19,806 line:-1
大家想到的可能是


345
00:17:20,107 --> 00:17:23,710 line:-1
指向源代码的搜索路径


346
00:17:24,877 --> 00:17:26,713 line:-1
不是这样的


347
00:17:27,347 --> 00:17:28,182 line:-1
相反


348
00:17:28,615 --> 00:17:30,684 line:-2
你会看到这个
headermaps


349
00:17:30,751 --> 00:17:32,252 line:-1
（寻找猫咪）


350
00:17:32,319 --> 00:17:36,356 line:-2
Headermaps
由Xcode构建系统创建


351
00:17:36,690 --> 00:17:39,493 line:-1
说明头文件的位置


352
00:17:40,494 --> 00:17:41,595 line:-1
仔细看下


353
00:17:41,662 --> 00:17:45,599 line:-2
这是最重要的两个
headermap文件


354
00:17:47,868 --> 00:17:50,637 line:-1
前两行只是


355
00:17:51,605 --> 00:17:53,874 line:-1
插入了框架名称


356
00:17:54,808 --> 00:17:55,742 line:-1
给头文件


357
00:17:56,210 --> 00:17:59,112 line:-2
这两个头文件
原来是公共文件


358
00:18:02,349 --> 00:18:05,018 line:-2
我建议
不要依赖这个功能


359
00:18:05,385 --> 00:18:06,220 line:-1
原因是…


360
00:18:07,487 --> 00:18:10,891 line:-2
把它放在这里
是为了让现有项目持续运行


361
00:18:11,625 --> 00:18:15,095 line:-2
但之后使用Clang模块时
可能会出现问题


362
00:18:15,462 --> 00:18:20,701 line:-2
所以我们建议
自己标出框架名称


363
00:18:20,934 --> 00:18:23,871 line:-1
在将公共或私有头文件


364
00:18:23,937 --> 00:18:25,606 line:-1
从自己的框架中导入时


365
00:18:27,341 --> 00:18:29,776 line:-1
第三行是项目头文件


366
00:18:30,110 --> 00:18:32,145 line:-1
这个例子中并不需要


367
00:18:32,746 --> 00:18:33,580 line:-1
而且…


368
00:18:33,647 --> 00:18:38,519 line:-2
headermap是为了
连接回源代码


369
00:18:39,887 --> 00:18:40,754 line:-1
如你所见


370
00:18:40,821 --> 00:18:43,524 line:-1
公共和私有头文件的操作一样


371
00:18:44,224 --> 00:18:46,693 line:-1
总是回归源代码


372
00:18:46,760 --> 00:18:50,430 line:-1
这是为了让Clang生成


373
00:18:50,797 --> 00:18:52,799 line:-1
有用的报错信息


374
00:18:53,100 --> 00:18:55,536 line:-1
用于源目录文件


375
00:18:55,936 --> 00:18:58,772 line:-2
而不是从构建目录
复制过来的


376
00:18:58,839 --> 00:19:00,107 line:-1
其他内容


377
00:19:03,210 --> 00:19:06,613 line:-2
很多人不知道
头文件映射的存在


378
00:19:06,680 --> 00:19:08,182 line:-1
就会遇到某些问题


379
00:19:08,348 --> 00:19:09,683 line:-1
最常见的是


380
00:19:10,284 --> 00:19:14,221 line:-2
忘记将头文件
添加到项目


381
00:19:15,055 --> 00:19:19,059 line:-2
它在源目录
但不在项目里


382
00:19:19,259 --> 00:19:22,329 line:-2
一定保证将头文件
添加到项目


383
00:19:23,030 --> 00:19:24,865 line:-1
另一个问题是


384
00:19:26,400 --> 00:19:29,937 line:-2
如果头文件命名一样
它们会彼此重叠


385
00:19:31,138 --> 00:19:34,007 line:-2
所以头文件的名称
要有所区别


386
00:19:34,741 --> 00:19:37,377 line:-1
这对系统头文件也一样


387
00:19:37,744 --> 00:19:41,915 line:-2
如果项目里的本地头文件
与系统头文件名字一样


388
00:19:42,149 --> 00:19:43,984 line:-1
它会叠加到系统头文件上


389
00:19:44,418 --> 00:19:46,320 line:-1
要注意避免


390
00:19:47,020 --> 00:19:48,388 line:-1
提到系统头文件


391
00:19:48,622 --> 00:19:49,923 line:-1
怎么查找？


392
00:19:53,093 --> 00:19:55,062 line:0
再用PetWall演示下


393
00:19:56,029 --> 00:19:59,099 line:0
这里导入
Foundation.h头文件


394
00:19:59,166 --> 00:20:00,601 line:0
在SDK里


395
00:20:01,869 --> 00:20:03,704 line:0
我们可以像之前一样


396
00:20:04,638 --> 00:20:06,273 line:0
就像查找自己项目的头文件


397
00:20:06,340 --> 00:20:07,975 line:0
但现在是系统头文件


398
00:20:08,809 --> 00:20:13,580 line:0
我说过头文件映射
只用于私有的头文件


399
00:20:13,881 --> 00:20:15,249 line:0
所以可以忽略


400
00:20:15,983 --> 00:20:18,318 line:0
现在关注导入路径


401
00:20:18,685 --> 00:20:19,520 line:0
那么


402
00:20:19,820 --> 00:20:23,590 line:0
默认的SDK里有两个目录


403
00:20:23,891 --> 00:20:25,926 line:0
第一个是用户的


404
00:20:26,460 --> 00:20:29,329 line:0
第二个是系统库框架


405
00:20:30,297 --> 00:20:31,698 line:0
先看第一个


406
00:20:33,433 --> 00:20:35,235 line:-1
这是正常的包含目录


407
00:20:35,302 --> 00:20:38,672 line:-1
我们只要输入搜索关键词


408
00:20:38,739 --> 00:20:41,642 line:-2
这里是
Foundation/Foundation.h


409
00:20:42,276 --> 00:20:44,711 line:-2
头文件没找到
因为它不在那里


410
00:20:45,479 --> 00:20:47,614 line:-2
没关系
再试试第二个


411
00:20:48,549 --> 00:20:50,851 line:-1
系统库框架


412
00:20:52,119 --> 00:20:54,555 line:-1
这是框架目录


413
00:20:54,888 --> 00:20:57,324 line:-1
所以Clang的做法会有些不同


414
00:20:57,391 --> 00:20:58,225 line:-1
首先…


415
00:20:58,825 --> 00:21:03,730 line:-2
它要确定框架的定义
看看框架是否存在


416
00:21:05,465 --> 00:21:06,300 line:-1
然后


417
00:21:06,667 --> 00:21:10,003 line:-2
从头文件目录中
查找头文件


418
00:21:10,637 --> 00:21:12,840 line:-2
这里找到了
不错


419
00:21:13,674 --> 00:21:16,844 line:-1
但如果没找到呢？


420
00:21:17,010 --> 00:21:20,314 line:-1
比如输入不存在的假冒头文件


421
00:21:21,648 --> 00:21:24,418 line:-1
显然不会在头文件目录中找到


422
00:21:25,819 --> 00:21:28,922 line:-2
但之后它会查找
私有头文件目录


423
00:21:30,424 --> 00:21:34,428 line:-2
Apple的SDK中
不会带有任何私有头文件


424
00:21:34,962 --> 00:21:36,430 line:-1
但是你的项目


425
00:21:36,496 --> 00:21:39,366 line:-1
和框架中可能公共和私有头文件都有


426
00:21:39,733 --> 00:21:41,568 line:-1
所以也会检查


427
00:21:42,402 --> 00:21:45,005 line:-2
但这是个假的头文件
所以那里也没有


428
00:21:46,707 --> 00:21:50,010 line:-2
现在就有意思了
搜索停止了


429
00:21:50,377 --> 00:21:53,113 line:-1
我们不会再查找其他目录


430
00:21:53,413 --> 00:21:54,248 line:-1
这是因为


431
00:21:54,715 --> 00:21:58,352 line:-1
框架已经被找到了


432
00:21:59,019 --> 00:22:00,120 line:-1
一旦框架被找到


433
00:22:00,187 --> 00:22:02,956 line:-2
一般框架目录里
能找到头文件


434
00:22:03,357 --> 00:22:05,592 line:-2
如果找不到
搜索就放弃了


435
00:22:07,928 --> 00:22:11,198 line:-2
如果好奇
实现文件的模样


436
00:22:11,632 --> 00:22:14,668 line:-2
当所有头文件
都被导入和预处理之后


437
00:22:15,169 --> 00:22:16,770 line:-1
你可以让Xcode


438
00:22:17,271 --> 00:22:22,242 line:-2
创建预处理文件
给实现文件


439
00:22:24,912 --> 00:22:27,214 line:-2
这会生成一个
巨大的输出文件


440
00:22:28,582 --> 00:22:30,684 line:-1
有多大呢？


441
00:22:32,853 --> 00:22:34,888 line:-1
举个简单的例子


442
00:22:35,923 --> 00:22:37,925 line:-1
Foundation.h是…


443
00:22:38,759 --> 00:22:42,229 line:-1
系统最基本的头文件


444
00:22:43,463 --> 00:22:45,799 line:-1
这个头文件很可能被


445
00:22:45,866 --> 00:22:49,203 line:-2
直接或间接地
导入其他头文件夹


446
00:22:49,269 --> 00:22:50,103 line:-1
就是说…


447
00:22:50,437 --> 00:22:51,872 line:-1
每次调用编译器


448
00:22:51,939 --> 00:22:54,441 line:-1
都要查找这个头文件


449
00:22:55,742 --> 00:22:56,910 line:-1
一天之内


450
00:22:57,911 --> 00:23:02,049 line:-2
Clang要查找并处理
800多个头文件夹


451
00:23:02,282 --> 00:23:04,318 line:-1
只为一个导入声明


452
00:23:05,519 --> 00:23:10,891 line:-2
也就是要解析和验证
大于9兆的源代码


453
00:23:11,792 --> 00:23:15,062 line:-2
每次调用编译器
都是如此


454
00:23:15,495 --> 00:23:18,131 line:-2
这个工作量很大
很冗余


455
00:23:18,999 --> 00:23:19,833 line:-1
所以


456
00:23:20,901 --> 00:23:21,835 line:-1
怎么改善？


457
00:23:23,971 --> 00:23:27,875 line:-2
这里有个功能叫做
预编译头文件


458
00:23:27,941 --> 00:23:29,910 line:-1
这是个好办法


459
00:23:30,544 --> 00:23:31,812 line:-1
但还有更好的


460
00:23:32,145 --> 00:23:35,048 line:-2
几年前
我们发布了Clang模块


461
00:23:36,283 --> 00:23:40,020 line:-2
Clang模块只允许我们
为框架查找和解析头文件


462
00:23:40,087 --> 00:23:41,955 line:-1
一次


463
00:23:42,322 --> 00:23:47,528 line:-2
然后储存到硬盘
缓存并可以再利用


464
00:23:48,295 --> 00:23:51,031 line:-1
这可以提升构建速度


465
00:23:53,867 --> 00:23:54,801 line:-1
要实现它


466
00:23:55,369 --> 00:23:57,905 line:-2
Clang模块
要具备特定的属性


467
00:23:59,406 --> 00:24:02,943 line:-2
最重要的一点是
上下文无关


468
00:24:03,510 --> 00:24:05,045 line:-1
什么是上下文无关？


469
00:24:06,947 --> 00:24:08,982 line:-1
这有两个代码片段


470
00:24:09,216 --> 00:24:13,053 line:-1
两个都导入了PetKit模块


471
00:24:13,887 --> 00:24:18,025 line:-1
但两个宏观定义不同


472
00:24:19,693 --> 00:24:22,863 line:-2
如果用传统方法
导入头文件


473
00:24:22,930 --> 00:24:24,798 line:-1
文本也会被导入


474
00:24:25,299 --> 00:24:26,233 line:-1
预处理器…


475
00:24:26,700 --> 00:24:30,304 line:-2
会遵从这个定义
并应用到头文件夹


476
00:24:31,205 --> 00:24:32,239 line:-1
如果这样做


477
00:24:32,306 --> 00:24:34,441 line:-1
每个案例的模块


478
00:24:34,508 --> 00:24:37,044 line:-2
就不一样
不能重复使用


479
00:24:37,644 --> 00:24:38,478 line:-1
所以…


480
00:24:39,012 --> 00:24:41,481 line:-2
如果要使用模块
就不能这样做


481
00:24:41,849 --> 00:24:46,753 line:-2
模块会忽略
所有文本信息


482
00:24:47,120 --> 00:24:51,692 line:-2
这样就能被
所有实现文件重复使用了


483
00:24:54,027 --> 00:24:55,229 line:-1
另一个要求是


484
00:24:56,630 --> 00:24:58,465 line:-1
模块各自独立


485
00:24:58,932 --> 00:25:03,036 line:-2
也就是说
要明确所有依赖关系


486
00:25:04,104 --> 00:25:06,440 line:-1
这对你有好处


487
00:25:06,840 --> 00:25:09,877 line:-1
就是只要你导入一个模块


488
00:25:10,511 --> 00:25:11,478 line:-1
它就能工作


489
00:25:11,545 --> 00:25:14,314 line:-2
不用考虑还要
添加其他的头文件


490
00:25:14,381 --> 00:25:15,816 line:-1
才能运行


491
00:25:19,186 --> 00:25:22,890 line:-2
我们怎么知道
或者说Clang怎么知道


492
00:25:22,956 --> 00:25:24,791 line:-1
要不要创建模块呢？


493
00:25:25,993 --> 00:25:29,329 line:-2
看个简单的例子
NSString.h


494
00:25:30,531 --> 00:25:33,200 line:-1
首先Clang要找到框架里的


495
00:25:33,467 --> 00:25:34,735 line:-1
这个头文件


496
00:25:37,037 --> 00:25:38,472 line:-1
你们知道怎么做了


497
00:25:38,705 --> 00:25:41,275 line:-2
这是Foundation.framework
目录


498
00:25:42,109 --> 00:25:44,111 line:-1
然后Clang编译器


499
00:25:44,511 --> 00:25:46,947 line:-2
会查找模块目录
和模块映射


500
00:25:47,181 --> 00:25:48,782 line:-1
它与头文件目录相关


501
00:25:49,483 --> 00:25:50,317 line:-1
找到了


502
00:25:51,552 --> 00:25:53,086 line:-1
什么是模块映射？


503
00:25:53,420 --> 00:25:57,524 line:-2
模块映射描述了
特定的一组头文件夹


504
00:25:57,724 --> 00:25:59,760 line:-1
翻译到模块中


505
00:26:00,961 --> 00:26:01,962 line:-1
具体讲下


506
00:26:04,264 --> 00:26:06,066 line:-1
模块映射很简单


507
00:26:06,133 --> 00:26:08,502 line:-2
这是Foundation的
整个模块映射


508
00:26:08,569 --> 00:26:09,403 line:-1
就这些


509
00:26:10,437 --> 00:26:11,805 line:-1
显然它描述了


510
00:26:11,939 --> 00:26:14,074 line:-2
模块的名称
就是Foundation


511
00:26:14,875 --> 00:26:19,813 line:-2
它还说明了
哪个头文件属于该模块


512
00:26:20,614 --> 00:26:23,617 line:-1
这里只有一个头文件


513
00:26:23,684 --> 00:26:25,052 line:-1
Foundation.h


514
00:26:25,752 --> 00:26:28,922 line:-2
但这个头文件很特殊
这是umbrella header


515
00:26:28,989 --> 00:26:31,792 line:-2
用特殊关键词
umbrella标出


516
00:26:32,426 --> 00:26:33,260 line:-1
这是说…


517
00:26:33,493 --> 00:26:36,830 line:-2
Clang要查找
这个特殊的头文件


518
00:26:37,164 --> 00:26:41,034 line:-2
来确定NSString.h
是不是模块的一部分


519
00:26:42,269 --> 00:26:43,704 line:-1
耶 找到了！


520
00:26:44,271 --> 00:26:45,105 line:-1
好了


521
00:26:45,172 --> 00:26:46,940 line:-1
我们已经确定


522
00:26:47,007 --> 00:26:50,010 line:-2
NSString.h是
foundation模块的一部分


523
00:26:50,577 --> 00:26:54,181 line:-1
Clang可以升级文本输入


524
00:26:54,248 --> 00:26:55,649 line:-1
到模块输入


525
00:26:56,283 --> 00:26:59,152 line:-2
为此我们要创建
foundation模块


526
00:27:01,021 --> 00:27:03,090 line:-2
如何创建
foundation模块呢？


527
00:27:03,957 --> 00:27:04,858 line:-1
首先


528
00:27:05,292 --> 00:27:07,594 line:-1
为Clang单独创建位置


529
00:27:08,462 --> 00:27:11,698 line:-2
Clang位置里
包含的所有头文件


530
00:27:11,765 --> 00:27:13,267 line:-1
都属于foundation模块


531
00:27:15,135 --> 00:27:18,839 line:-1
我们不会转移任何现有的上下文


532
00:27:19,173 --> 00:27:21,275 line:-1
来自原始的编译器调用


533
00:27:21,508 --> 00:27:23,076 line:-1
所以说是上下文无关


534
00:27:24,044 --> 00:27:25,846 line:-1
实际上我们转移的


535
00:27:25,913 --> 00:27:28,315 line:-1
是传递给Clang的命令行实参


536
00:27:28,382 --> 00:27:29,583 line:-1
随后继续传递


537
00:27:32,152 --> 00:27:34,188 line:-1
在创建foundation模块时


538
00:27:36,023 --> 00:27:37,624 line:-1
模块本身或框架


539
00:27:37,691 --> 00:27:38,692 line:-1
框架本身…


540
00:27:39,393 --> 00:27:41,795 line:-1
会导入其他框架


541
00:27:41,995 --> 00:27:42,863 line:-1
也就是说…


542
00:27:43,130 --> 00:27:45,032 line:-1
我们也要构建那些模块


543
00:27:46,633 --> 00:27:48,001 line:-1
我们不能停顿


544
00:27:48,068 --> 00:27:51,438 line:-2
因为它可能还包含
其他框架


545
00:27:52,272 --> 00:27:54,575 line:-2
但是我们已经能看到
它的好处了


546
00:27:55,175 --> 00:27:57,344 line:-1
某些导入可能是一样的


547
00:27:57,644 --> 00:28:00,414 line:-1
所以总能重复使用那个模块


548
00:28:02,883 --> 00:28:07,054 line:-2
所有模块要序列化
存到模块缓存区


549
00:28:09,323 --> 00:28:10,224 line:-1
我说过…


550
00:28:11,391 --> 00:28:15,128 line:-2
命令行实参会向后传递
在创建模块的时候


551
00:28:15,729 --> 00:28:16,597 line:-1
就是说…


552
00:28:17,364 --> 00:28:20,133 line:-1
这些实参会影响


553
00:28:20,601 --> 00:28:22,102 line:-1
模块的内容


554
00:28:22,636 --> 00:28:24,638 line:-1
所以我们要散列


555
00:28:25,038 --> 00:28:26,139 line:-1
这些实参


556
00:28:26,607 --> 00:28:30,644 line:-2
再保存这些
为特定编译器调用而创建的模块


557
00:28:30,811 --> 00:28:32,846 line:-1
到散列匹配的目录里


558
00:28:34,548 --> 00:28:37,284 line:-1
如果修改编译器实参


559
00:28:37,351 --> 00:28:38,752 line:-1
用不同的限制文件


560
00:28:39,186 --> 00:28:41,822 line:-2
比如写入
enable cat


561
00:28:42,823 --> 00:28:44,224 line:-1
这是不同的散列


562
00:28:44,491 --> 00:28:47,494 line:-1
要求Clang重新创建


563
00:28:47,628 --> 00:28:50,597 line:0
所有模块
且输入到那个目录


564
00:28:51,164 --> 00:28:52,132 line:0
匹配那个散列


565
00:28:53,300 --> 00:28:57,304 line:0
为了更多重复利用模块缓存


566
00:28:57,638 --> 00:29:02,209 line:0
你要保证实参的一致性
如果可能的话


567
00:29:05,245 --> 00:29:09,516 line:0
以上就是如何查找
和创建系统框架模块


568
00:29:10,350 --> 00:29:12,553 line:0
但是你的框架呢？


569
00:29:12,853 --> 00:29:14,888 line:0
如何为它们创建模块？


570
00:29:16,924 --> 00:29:18,959 line:0
回到刚才猫的例子


571
00:29:19,393 --> 00:29:21,261 line:0
这时打开模块


572
00:29:23,397 --> 00:29:25,399 line:0
如果要用头文件映射


573
00:29:26,033 --> 00:29:30,070 line:0
它会映射到源目录


574
00:29:31,805 --> 00:29:34,508 line:-2
看看这个源文件
出问题了


575
00:29:35,409 --> 00:29:37,244 line:-1
这里没有模块目录


576
00:29:38,412 --> 00:29:40,013 line:-1
看上去根本不是框架


577
00:29:41,248 --> 00:29:44,852 line:-1
Clang现在不知所措


578
00:29:45,452 --> 00:29:48,455 line:-1
答案是一个新的概念


579
00:29:49,256 --> 00:29:51,825 line:-2
叫做
Clang的虚拟文件系统


580
00:29:52,526 --> 00:29:55,896 line:-2
它会创建一个
虚拟的抽象框架


581
00:29:56,830 --> 00:29:59,366 line:-1
方便Clang创建模块


582
00:29:59,933 --> 00:30:00,767 line:-1
但是…


583
00:30:01,168 --> 00:30:04,838 line:-1
抽象框架只能映射到目录文件


584
00:30:05,372 --> 00:30:06,507 line:-1
这样


585
00:30:06,740 --> 00:30:10,210 line:-1
Clang就能在源代码中报错


586
00:30:11,812 --> 00:30:13,380 line:-1
这就是创建模块的方法


587
00:30:13,881 --> 00:30:15,749 line:-1
在使用框架的情况下


588
00:30:18,352 --> 00:30:20,187 line:-2
大家记得
开始的时候我说过


589
00:30:20,721 --> 00:30:25,025 line:-2
如果不确定框架名字
会有问题


590
00:30:25,959 --> 00:30:28,562 line:-2
我们就来举个例子
看看是什么问题


591
00:30:30,564 --> 00:30:33,934 line:-2
这是很简单的代码样本
只有两个输入


592
00:30:34,001 --> 00:30:37,671 line:-2
第一个输入
PetKit模块


593
00:30:39,106 --> 00:30:40,541 line:-1
第二个输入


594
00:30:41,208 --> 00:30:44,411 line:-2
我们都知道
这是PetKit模块的一部分


595
00:30:45,012 --> 00:30:47,614 line:-1
但Clang可能不知道


596
00:30:47,981 --> 00:30:50,284 line:-2
因为你没有写明
框架的名称


597
00:30:51,785 --> 00:30:52,686 line:-1
这样一来


598
00:30:53,253 --> 00:30:57,357 line:-2
你可能会收到
重复定义的报错


599
00:30:57,925 --> 00:31:01,195 line:-2
这种情况常见于
将同一个头文件导入了两次


600
00:31:03,163 --> 00:31:05,799 line:-1
Clang在后台辛苦工作


601
00:31:05,866 --> 00:31:09,336 line:-2
就为了解决
诸如此类的常见问题


602
00:31:10,537 --> 00:31:12,339 line:-1
但它不可能全部解决


603
00:31:13,240 --> 00:31:14,842 line:-1
这只是个简单的例子


604
00:31:15,442 --> 00:31:16,777 line:-1
稍微调整一下


605
00:31:18,545 --> 00:31:20,047 line:-1
修改一下上下文


606
00:31:21,315 --> 00:31:25,419 line:-2
模块的导入
完全不受影响


607
00:31:25,485 --> 00:31:28,055 line:-2
因为我说过
上下文可以忽略


608
00:31:29,756 --> 00:31:30,724 line:-1
cat导入


609
00:31:30,924 --> 00:31:33,727 line:-1
还是头文件的文本导入


610
00:31:33,894 --> 00:31:35,729 line:-1
它会遵循这个修改


611
00:31:36,330 --> 00:31:39,867 line:-1
这时可能就不是双重定义了


612
00:31:39,933 --> 00:31:42,269 line:-1
而是矛盾定义


613
00:31:42,469 --> 00:31:44,137 line:-1
无法解决


614
00:31:44,771 --> 00:31:46,306 line:-1
Clang解决不了


615
00:31:46,974 --> 00:31:47,808 line:-1
那么…


616
00:31:47,941 --> 00:31:49,743 line:-1
记住我的建议


617
00:31:49,810 --> 00:31:52,145 line:-1
永远明确框架名称


618
00:31:52,513 --> 00:31:55,516 line:-2
无论是导入公共的
还是私有的头文件


619
00:31:56,683 --> 00:31:58,218 line:-1
现在有请Devin


620
00:31:58,285 --> 00:32:02,256 line:-2
他为大家讲解Swift和
Swift对Clang模块的使用


621
00:32:09,096 --> 00:32:09,963 line:-1
谢谢 Jurgen


622
00:32:11,331 --> 00:32:13,300 line:-1
我们现在要具体讲解


623
00:32:13,767 --> 00:32:16,770 line:-2
Swift和构建系统
如何并肩作战


624
00:32:17,037 --> 00:32:19,506 line:-1
在项目中查找声明


625
00:32:21,475 --> 00:32:23,377 line:-2
先总结下
Jurgen的演讲


626
00:32:23,844 --> 00:32:26,914 line:-2
Clang单独编译
每个Objective-C文件


627
00:32:27,781 --> 00:32:31,652 line:-2
如果你要在另一个文件夹
查找一个类


628
00:32:32,419 --> 00:32:35,789 line:-1
你要导入声明那个类的头文件


629
00:32:37,457 --> 00:32:41,061 line:-1
Swift的设计不需要写入头文件


630
00:32:41,562 --> 00:32:44,598 line:-1
为了方便初学者上手应用


631
00:32:44,865 --> 00:32:49,036 line:-2
避免了在不同文件里
重复一个声明


632
00:32:50,370 --> 00:32:52,039 line:-1
但这就意味着编译器


633
00:32:52,105 --> 00:32:54,408 line:-1
要做些额外的记录工作


634
00:32:54,975 --> 00:32:57,211 line:-2
下面就讲讲
记录工作怎么做


635
00:32:59,713 --> 00:33:01,949 line:-1
回到PetWall app


636
00:33:02,883 --> 00:33:05,919 line:-2
在界面控制器里
有个Swift的界面


637
00:33:07,020 --> 00:33:08,622 line:-2
Objective-C
app代理


638
00:33:09,022 --> 00:33:10,524 line:-1
和Swift单元测试


639
00:33:11,625 --> 00:33:12,559 line:-1
为了编译


640
00:33:12,626 --> 00:33:15,762 line:-2
哪怕只是上面这个
PetViewController


641
00:33:16,430 --> 00:33:19,266 line:-2
编译器也要
进行4个不同的运算


642
00:33:20,400 --> 00:33:22,803 line:-1
首先要找到声明


643
00:33:23,337 --> 00:33:27,641 line:-2
Swift目标里的
和来自Objective-C的


644
00:33:29,243 --> 00:33:33,180 line:-2
它还要生成接口
描述文件内容


645
00:33:33,480 --> 00:33:36,250 line:-2
以便声明可以
被找到并用于


646
00:33:36,316 --> 00:33:39,520 line:-2
Objective-C
和其他Swift目标


647
00:33:40,754 --> 00:33:42,189 line:-1
接下来的部分


648
00:33:42,256 --> 00:33:46,760 line:-2
我会演示这个例子
分别阐述这四个任务


649
00:33:47,694 --> 00:33:50,898 line:-1
首先是在Swift目标里查找声明


650
00:33:55,469 --> 00:33:58,138 line:-2
要编译
PetViewController.swift


651
00:33:58,705 --> 00:34:02,075 line:-2
编译器会查找
PetView的初始程序类型


652
00:34:02,609 --> 00:34:04,111 line:-1
以便检查调用


653
00:34:05,379 --> 00:34:06,947 line:-1
但在此之前


654
00:34:07,281 --> 00:34:09,650 line:-2
它要解析
PetView.swift


655
00:34:10,117 --> 00:34:11,217 line:-1
并验证


656
00:34:11,618 --> 00:34:14,922 line:-2
以保证初始程序的声明
是正常的


657
00:34:15,755 --> 00:34:17,824 line:-2
编译器很聪明
它知道


658
00:34:18,091 --> 00:34:21,360 line:-2
不需要检查
初始程序的主体


659
00:34:22,094 --> 00:34:23,931 line:-1
但它还要做些工作


660
00:34:23,996 --> 00:34:26,632 line:-1
处理文件的接口部分


661
00:34:29,803 --> 00:34:32,339 line:-1
这与Clang不同


662
00:34:32,840 --> 00:34:34,908 line:-1
编译一个Swift文件


663
00:34:35,576 --> 00:34:39,313 line:-2
编译器也要解析
目标中所有其他Swift文件


664
00:34:39,379 --> 00:34:42,815 line:-1
以检查与接口有关的部分


665
00:34:48,255 --> 00:34:51,190 line:0
在Xcode 9
这会导致重复工作


666
00:34:51,391 --> 00:34:53,960 line:0
在增量调试构建中


667
00:34:54,027 --> 00:34:57,564 line:0
因为编译器单独编译每个文件


668
00:34:58,332 --> 00:35:00,834 line:0
文件的编译可以并行


669
00:35:01,168 --> 00:35:04,438 line:0
但它强制编译器
重复解析每个文件


670
00:35:05,305 --> 00:35:07,875 line:0
解析一次
作为实现文件生成.o


671
00:35:08,242 --> 00:35:10,711 line:0
解析多次是作为接口


672
00:35:11,144 --> 00:35:12,646 line:0
查找声明


673
00:35:14,181 --> 00:35:16,817 line:0
Xcode 10减少了这种消耗


674
00:35:17,451 --> 00:35:20,554 line:0
通过将文件合并成组


675
00:35:20,821 --> 00:35:23,190 line:0
尽可能多得分担工作


676
00:35:24,858 --> 00:35:27,094 line:0
在依旧最大化并行的同时


677
00:35:27,861 --> 00:35:30,197 line:0
在组中重复利用解析


678
00:35:31,164 --> 00:35:33,834 line:0
只在跨组处理时重复


679
00:35:34,535 --> 00:35:37,971 line:0
由于组的数量相对较少


680
00:35:38,372 --> 00:35:42,709 line:0
就能大幅提升
增量调试构建的速度


681
00:35:46,146 --> 00:35:49,716 line:-2
Swift代码
不止调用其他Swift代码


682
00:35:50,083 --> 00:35:51,818 line:-1
还能调用Objective-C


683
00:35:53,587 --> 00:35:55,455 line:-1
回到PetWall样本app


684
00:35:55,522 --> 00:35:58,358 line:-1
我们看到它很重要


685
00:35:58,458 --> 00:35:59,993 line:-1
因为它是系统框架


686
00:36:00,227 --> 00:36:02,896 line:-2
比如 UIKit
是Objective-C语言


687
00:36:06,633 --> 00:36:10,204 line:0
Swift与其他语言不一样


688
00:36:10,270 --> 00:36:14,408 line:0
它不需要外部功能接口


689
00:36:15,809 --> 00:36:17,611 line:-2
这里你一般要
比如


690
00:36:17,678 --> 00:36:21,915 line:-2
编写Swift声明给每个
Objective-C API


691
00:36:22,983 --> 00:36:23,817 line:-1
但是


692
00:36:23,884 --> 00:36:28,055 line:-2
编译器内置了
Clang的一大部分


693
00:36:28,121 --> 00:36:29,756 line:-1
用作库


694
00:36:30,490 --> 00:36:34,361 line:-2
这就可以直接导入
Objective-C框架


695
00:36:37,164 --> 00:36:39,533 line:-2
Objective-C声明
来自哪里？


696
00:36:40,300 --> 00:36:44,071 line:-2
导入器会查看头文件
根据目标类型


697
00:36:45,806 --> 00:36:49,076 line:-2
任何目标在导入
Objective-C框架时


698
00:36:49,943 --> 00:36:52,412 line:-2
导入器在头文件中
找到声明


699
00:36:52,479 --> 00:36:55,449 line:-2
显示的是
Clang对此框架的模块映射


700
00:36:56,950 --> 00:36:59,953 line:-2
用Swift和Objective-C
代码混编的框架


701
00:37:00,454 --> 00:37:03,457 line:-2
导入器在umbrella头文件中
查找声明


702
00:37:04,591 --> 00:37:07,294 line:-1
这个头文件定义了公共接口


703
00:37:08,262 --> 00:37:10,898 line:-1
这样 框架内的Swift代码


704
00:37:10,964 --> 00:37:14,635 line:-2
就可以调用同一框架内的
公共Objective-C代码


705
00:37:16,870 --> 00:37:19,173 line:-2
最后
在app和单元测试中


706
00:37:19,473 --> 00:37:21,975 line:-1
可以导入目标的桥接头文件


707
00:37:22,176 --> 00:37:25,612 line:-2
允许其中的声明
被Swift调用


708
00:37:28,348 --> 00:37:29,183 line:-1
现在…


709
00:37:29,650 --> 00:37:31,618 line:-1
导入器找到声明后


710
00:37:31,885 --> 00:37:34,788 line:-2
通常会修改它们
让它们变得更口语化


711
00:37:35,589 --> 00:37:37,891 line:-2
比如它会导入
Objective-C函数


712
00:37:37,958 --> 00:37:39,593 line:-1
用NSError惯用语


713
00:37:40,027 --> 00:37:41,662 line:-1
作为throwing函数


714
00:37:42,062 --> 00:37:44,798 line:-2
使用Swift内置的
错误处理语言功能


715
00:37:47,835 --> 00:37:50,537 line:-2
具体来说
就是输入参数类型名称


716
00:37:50,804 --> 00:37:52,673 line:-1
后跟动词和介词


717
00:37:53,907 --> 00:37:56,443 line:-2
比如函数
drawPet atPoint


718
00:37:56,777 --> 00:37:58,045 line:-1
带有宠物这个词


719
00:37:58,579 --> 00:38:00,380 line:-2
对于参数类型
宠物


720
00:38:00,747 --> 00:38:02,149 line:-2
后跟一个动词
画


721
00:38:03,016 --> 00:38:05,853 line:-1
同样单词point


722
00:38:06,186 --> 00:38:08,388 line:-2
代表参数类型
CGPoint


723
00:38:08,722 --> 00:38:10,257 line:-1
后跟介词at


724
00:38:11,992 --> 00:38:14,094 line:-1
Swift删除了这些词


725
00:38:14,161 --> 00:38:17,664 line:-2
只导入函数
draw at


726
00:38:19,399 --> 00:38:20,567 line:-1
怎么做到的？


727
00:38:21,068 --> 00:38:23,036 line:-1
你可能不知道


728
00:38:23,804 --> 00:38:28,008 line:-2
编译器带有一组
常用英文动词和介词列表


729
00:38:29,643 --> 00:38:33,113 line:-2
因为它们很难编码
人类语言太复杂


730
00:38:33,447 --> 00:38:34,982 line:0
有时会缺词


731
00:38:35,716 --> 00:38:38,719 line:0
另外为了
匹配Swift名字转换


732
00:38:38,952 --> 00:38:41,255 line:0
导入器会重命名函数


733
00:38:41,455 --> 00:38:44,057 line:0
根据词性删除单词


734
00:38:45,192 --> 00:38:47,895 line:0
比如
动词feed不在列表上


735
00:38:47,961 --> 00:38:52,266 line:0
所以feedPet导入后
不是我们预想的feed


736
00:38:53,467 --> 00:38:54,535 line:0
这个时候


737
00:38:54,601 --> 00:38:57,104 line:0
可以用注解
NS_Swift_Name


738
00:38:57,337 --> 00:39:01,508 line:0
让编译器导入
你要的函数形式


739
00:39:05,779 --> 00:39:08,315 line:-2
如果你要看看
Objective-C头文件


740
00:39:08,382 --> 00:39:09,917 line:-1
如何导入Swift


741
00:39:10,317 --> 00:39:13,187 line:-2
你可以到
Xcode相关项目弹窗


742
00:39:13,487 --> 00:39:15,989 line:-1
它在源编辑器的左上角


743
00:39:16,523 --> 00:39:18,592 line:-1
选择生成的接口


744
00:39:18,759 --> 00:39:21,128 line:-1
就能看到接口的样子


745
00:39:21,261 --> 00:39:22,863 line:-1
和不同的Swift版本


746
00:39:25,465 --> 00:39:27,768 line:-2
以上就是用Swift
导入Objective-C


747
00:39:28,302 --> 00:39:29,803 line:-1
反过来呢？


748
00:39:30,170 --> 00:39:33,173 line:-2
Objective-C
怎么导入Swift？


749
00:39:35,309 --> 00:39:37,878 line:-2
答案是
Swift会生成一个头文件


750
00:39:37,945 --> 00:39:39,313 line:-1
可以进行导入


751
00:39:39,913 --> 00:39:44,484 line:-2
这样你可以用Swift编写类
然后用Objective-C调用它们


752
00:39:45,619 --> 00:39:46,854 line:-1
看看工作原理


753
00:39:48,355 --> 00:39:51,225 line:-2
编译器生成
Objective-C声明


754
00:39:51,291 --> 00:39:55,963 line:-2
给Swift类
NSObject和@objc函数


755
00:39:57,397 --> 00:39:58,665 line:-1
单元测试的app


756
00:39:58,899 --> 00:40:02,503 line:-2
头文件会包含
公共和内部两种声明


757
00:40:03,003 --> 00:40:07,140 line:-2
就能在app的Objective-C部分
使用内部Swift


758
00:40:08,642 --> 00:40:09,810 line:-1
但是对于框架


759
00:40:10,110 --> 00:40:13,180 line:-1
生成的头文件只包含公共声明


760
00:40:13,380 --> 00:40:15,549 line:-1
因为它包含于构建的产品


761
00:40:15,616 --> 00:40:18,085 line:-1
是框架公共接口的一部分


762
00:40:20,521 --> 00:40:21,355 line:-1
右边


763
00:40:21,421 --> 00:40:24,491 line:-2
你看到编译器
将Objective-C类连接到


764
00:40:24,892 --> 00:40:27,227 line:-1
名字变形的Swift类


765
00:40:27,728 --> 00:40:30,464 line:-2
包含模块名称
PetWall


766
00:40:31,865 --> 00:40:34,101 line:-1
现在我讲一讲模块


767
00:40:34,668 --> 00:40:36,436 line:-2
之后Louis会讲解
命名修饰


768
00:40:36,904 --> 00:40:38,305 line:-1
现在大家要知道


769
00:40:38,505 --> 00:40:41,175 line:-2
它能防止
运行时间里的冲突


770
00:40:41,375 --> 00:40:44,478 line:-2
不让两个模块定义
同名的类


771
00:40:46,180 --> 00:40:50,017 line:0
你可以让Swift重命名
Objective-C类


772
00:40:50,284 --> 00:40:53,520 line:0
通过传递识别符
到objc属性


773
00:40:54,188 --> 00:40:55,189 line:0
如果这样做


774
00:40:55,389 --> 00:40:58,692 line:0
你要保证两个名字不冲突


775
00:40:59,893 --> 00:41:04,998 line:0
我用了PWL前缀
防止冲突


776
00:41:05,632 --> 00:41:11,271 line:0
这样就能在Objective-C中
引用这个类PWLPetCollar


777
00:41:14,107 --> 00:41:15,909 line:-1
编译器用类似的方法


778
00:41:15,976 --> 00:41:19,413 line:-1
生成其他Swift目标的接口


779
00:41:21,248 --> 00:41:22,082 line:-1
为此


780
00:41:22,416 --> 00:41:25,285 line:-2
Swift基于Clang的
模块概念进行构建


781
00:41:25,352 --> 00:41:26,720 line:-1
就像Jurgen说的


782
00:41:27,321 --> 00:41:29,489 line:-1
然后更深层的融入语言


783
00:41:30,624 --> 00:41:31,458 line:-1
Swift里


784
00:41:31,525 --> 00:41:34,561 line:-1
模块是可分布的声明单元


785
00:41:34,828 --> 00:41:39,299 line:-2
为了使用这些声明
就要导入模块


786
00:41:40,334 --> 00:41:42,703 line:-2
你可以导入
Objective-C模块


787
00:41:42,936 --> 00:41:44,571 line:-1
比如XEtest


788
00:41:45,305 --> 00:41:46,440 line:-1
Xcode里


789
00:41:46,507 --> 00:41:49,610 line:-2
每个Swift目标
生成单独的模块


790
00:41:50,043 --> 00:41:51,378 line:-1
包括目标app


791
00:41:52,479 --> 00:41:55,115 line:-2
所以要导入
app的主模块


792
00:41:55,182 --> 00:41:57,551 line:-1
以便进行单元测试


793
00:42:00,621 --> 00:42:02,022 line:-1
导入模块时


794
00:42:02,089 --> 00:42:05,792 line:-2
编译器反序列化
一个特殊的Swift模块文件


795
00:42:06,360 --> 00:42:08,128 line:-2
在使用时
检查它的类型


796
00:42:09,129 --> 00:42:10,697 line:-1
例如在单元测试中


797
00:42:10,764 --> 00:42:13,333 line:-2
编译器加载
PetViewController


798
00:42:14,001 --> 00:42:15,736 line:-1
从PetWall Swift模块里


799
00:42:16,103 --> 00:42:18,672 line:-2
以保证控制器的创建
没有问题


800
00:42:19,773 --> 00:42:22,643 line:-1
这类似于编译器在目标里查找声明


801
00:42:22,843 --> 00:42:25,012 line:-1
我之前展示过的


802
00:42:25,913 --> 00:42:27,014 line:-1
除此之外


803
00:42:27,080 --> 00:42:29,917 line:-2
编译器会加载一个
总结模块的文件


804
00:42:30,384 --> 00:42:33,220 line:-1
而不是直接解析Swift文件


805
00:42:36,323 --> 00:42:38,759 line:-2
编译器生成的
Swift模块文件


806
00:42:38,959 --> 00:42:41,762 line:-2
很多就像
Objective-C头文件


807
00:42:42,296 --> 00:42:45,199 line:-2
但它不是文本模式
而是二进制形式


808
00:42:46,033 --> 00:42:48,202 line:-1
它包括内联函数的主体


809
00:42:48,535 --> 00:42:50,971 line:-2
很像Objective-C
静态内联函数


810
00:42:51,238 --> 00:42:53,974 line:-1
C++头文件实现


811
00:42:54,842 --> 00:42:55,676 line:-1
但是


812
00:42:55,742 --> 00:42:56,844 line:-1
要注意一点


813
00:42:56,910 --> 00:43:01,381 line:-2
就是它包含
私有声明的名称和类型


814
00:43:02,115 --> 00:43:04,218 line:-2
这让你可以
在调试器中引用它们


815
00:43:04,284 --> 00:43:05,619 line:-1
很方便


816
00:43:06,253 --> 00:43:07,988 line:-1
但也意味着


817
00:43:08,388 --> 00:43:12,359 line:-2
你不能用私人秘密
来命名私有变量


818
00:43:15,829 --> 00:43:16,964 line:-1
对累加构建


819
00:43:17,331 --> 00:43:19,933 line:-2
编译器生成
部分Swift模块文件


820
00:43:20,434 --> 00:43:23,270 line:-1
然后合并为一个文件


821
00:43:23,470 --> 00:43:25,939 line:-1
代表整个模块的内容


822
00:43:26,974 --> 00:43:29,443 line:-1
合并过程可能会


823
00:43:29,510 --> 00:43:32,913 line:-2
生成一个
Objective-C头文件


824
00:43:34,515 --> 00:43:35,382 line:-1
很多时候


825
00:43:35,449 --> 00:43:37,251 line:-1
这类似于连接器的操作


826
00:43:37,317 --> 00:43:39,486 line:-1
把目标文件整合成


827
00:43:39,853 --> 00:43:41,855 line:-1
一个执行文件


828
00:43:42,322 --> 00:43:43,724 line:-1
更多关于它的内容


829
00:43:43,790 --> 00:43:46,393 line:-1
有请Louis讲讲连接器


830
00:43:46,827 --> 00:43:47,694 line:-1
Louis


831
00:43:48,161 --> 00:43:49,129 line:-1
谢谢 Devin


832
00:43:54,835 --> 00:43:57,371 line:-2
我是Louis Gerbarg
工作重点就是连接器


833
00:43:57,871 --> 00:44:00,274 line:-1
这是完成Xcode构建的最后一步


834
00:44:00,607 --> 00:44:01,642 line:-1
开始吧


835
00:44:03,076 --> 00:44:06,113 line:-1
首先浏览一下我要讲的内容


836
00:44:06,680 --> 00:44:08,782 line:-1
我会讲什么是连接器


837
00:44:09,650 --> 00:44:11,251 line:-1
还有它用做输入的


838
00:44:11,318 --> 00:44:13,921 line:-1
dylibs和目标文件及其定义


839
00:44:14,688 --> 00:44:16,190 line:-1
还会讲到符号


840
00:44:16,757 --> 00:44:18,058 line:-1
及其内容


841
00:44:18,926 --> 00:44:21,061 line:-1
最后我会总结一遍


842
00:44:21,128 --> 00:44:24,298 line:-2
通过举例
因为内容比较难懂


843
00:44:25,098 --> 00:44:27,067 line:-1
如果感到疑惑


844
00:44:27,501 --> 00:44:29,169 line:-2
坚持住
希望我能讲明白


845
00:44:31,438 --> 00:44:32,272 line:-1
那么…


846
00:44:32,639 --> 00:44:33,473 line:-1
什么是连接器？


847
00:44:33,540 --> 00:44:36,009 line:-2
我说过
它是最后一个


848
00:44:36,443 --> 00:44:37,344 line:-1
构建阶段


849
00:44:38,145 --> 00:44:40,914 line:-2
我们要合并
所有的.o文件


850
00:44:41,381 --> 00:44:45,819 line:-2
是两个编译器之前生成的
合成一个可执行文件


851
00:44:47,054 --> 00:44:49,256 line:-2
全部内容就是
移动和打包代码


852
00:44:49,323 --> 00:44:51,458 line:-2
它不能生成代码
这点很重要


853
00:44:51,525 --> 00:44:54,061 line:-1
我来举例说明


854
00:44:55,629 --> 00:44:57,931 line:-1
我们有两种输入文件


855
00:44:58,265 --> 00:45:01,268 line:-2
第一种是dylibs
就是库


856
00:45:01,468 --> 00:45:02,336 line:-1
有多个…


857
00:45:03,036 --> 00:45:04,671 line:-2
第一个应该是
目标文件


858
00:45:05,539 --> 00:45:06,840 line:-1
产生于构建过程


859
00:45:06,907 --> 00:45:08,408 line:-1
第二种是库


860
00:45:08,809 --> 00:45:11,178 line:-2
由多种类型组成
包括dylibs


861
00:45:11,245 --> 00:45:14,581 line:-2
tbd
.a文件或静态库


862
00:45:15,983 --> 00:45:17,918 line:-1
符号是什么？


863
00:45:18,485 --> 00:45:22,256 line:-2
符号是名称
代表代码或数据片段


864
00:45:24,625 --> 00:45:27,528 line:-2
这些片段可能会
指向其他符号


865
00:45:28,295 --> 00:45:29,796 line:-1
当一个函数


866
00:45:29,863 --> 00:45:31,098 line:-1
调用另一个函数


867
00:45:33,634 --> 00:45:36,904 line:-2
符号具有属性
会影响连接器的行为


868
00:45:36,970 --> 00:45:38,338 line:-1
这有很多


869
00:45:38,405 --> 00:45:41,909 line:-2
我只举一个例子
弱符号


870
00:45:42,242 --> 00:45:45,145 line:-1
弱符号的注释是指


871
00:45:45,779 --> 00:45:51,552 line:-2
它可能会消失
当你在系统上运行


872
00:45:51,818 --> 00:45:52,886 line:-1
执行文件时


873
00:45:53,320 --> 00:45:58,859 line:-2
这都是可用性标记
表示这个API可用于iOS 12


874
00:45:58,926 --> 00:46:00,961 line:-1
那个API可用于iOS 11


875
00:46:01,628 --> 00:46:05,232 line:-2
这就引到了
今天的主题连接器


876
00:46:05,299 --> 00:46:07,768 line:-2
连接器决定哪些符号
必须出现


877
00:46:07,835 --> 00:46:13,006 line:-2
和哪些符号
可以在运行时间处理


878
00:46:14,975 --> 00:46:18,378 line:-2
语言可以将数据编码成符号
通过命名修饰


879
00:46:18,445 --> 00:46:19,947 line:-1
Devin已经提到过


880
00:46:21,181 --> 00:46:22,015 line:-1
而且…


881
00:46:22,583 --> 00:46:25,052 line:-2
C++和Swift中
都能见到


882
00:46:27,254 --> 00:46:28,088 line:-1
那么…


883
00:46:28,155 --> 00:46:29,623 line:-1
符号就是这些


884
00:46:30,424 --> 00:46:32,626 line:-1
代码和数据的名字


885
00:46:33,360 --> 00:46:34,194 line:-1
那么…


886
00:46:34,561 --> 00:46:35,929 line:-1
编译器生成目标文件


887
00:46:35,996 --> 00:46:38,265 line:-1
目标文件就是


888
00:46:38,732 --> 00:46:41,602 line:-1
代码和数据的集合


889
00:46:42,703 --> 00:46:43,871 line:-1
它们不可执行


890
00:46:43,937 --> 00:46:47,474 line:-2
因为是编译的代码
所以还没完成


891
00:46:47,774 --> 00:46:49,142 line:-1
还有缺失


892
00:46:49,209 --> 00:46:51,512 line:-1
就需要linke整合和修复


893
00:46:54,114 --> 00:46:57,284 line:-2
每个文件的片段
以符号表示


894
00:46:57,351 --> 00:46:58,185 line:-1
那么…


895
00:46:58,418 --> 00:47:00,654 line:-1
print f函数


896
00:47:01,321 --> 00:47:03,257 line:-1
就以符号代替代码


897
00:47:03,790 --> 00:47:06,426 line:-2
对于其他PetKit函数
一会儿会演示


898
00:47:06,827 --> 00:47:07,828 line:-1
也是一样


899
00:47:09,863 --> 00:47:12,299 line:-1
片段可能引用未定义符号


900
00:47:12,366 --> 00:47:14,701 line:-1
如果.o文件


901
00:47:15,802 --> 00:47:18,272 line:-2
引用另一个
.o文件的函数


902
00:47:18,639 --> 00:47:20,707 line:-1
这个.o文件就是未定义的


903
00:47:20,874 --> 00:47:24,144 line:-2
连接器会查找未定义符号
进行匹配


904
00:47:26,346 --> 00:47:27,181 line:-1
那么…


905
00:47:27,381 --> 00:47:30,551 line:-1
我说过目标文件是编译器的输出


906
00:47:30,617 --> 00:47:31,852 line:-1
什么是库？


907
00:47:32,486 --> 00:47:34,821 line:-1
库是定义符号的文件


908
00:47:34,888 --> 00:47:37,524 line:-1
但不属于构建的目标


909
00:47:38,392 --> 00:47:40,961 line:-1
我们有动态库


910
00:47:41,595 --> 00:47:42,496 line:-1
而且…


911
00:47:42,729 --> 00:47:46,567 line:-2
这些Mach-O文件
显示代码和数据片段


912
00:47:46,633 --> 00:47:48,702 line:-1
供可执行文件使用


913
00:47:49,536 --> 00:47:52,506 line:-1
它们是系统的一部分


914
00:47:52,573 --> 00:47:54,741 line:-2
这是我们用的框架
你们可能会用


915
00:47:54,808 --> 00:47:56,109 line:-1
自己的框架


916
00:47:58,212 --> 00:48:02,049 line:-2
还有TBD文件
基于文本的动态库文件


917
00:48:02,115 --> 00:48:03,250 line:-1
这是什么呢？


918
00:48:03,984 --> 00:48:04,818 line:-1
就是…


919
00:48:05,853 --> 00:48:09,289 line:-2
在给iOS和macOS
创建SDK的时候


920
00:48:09,623 --> 00:48:11,758 line:-1
会有所有这些动态库和函数


921
00:48:11,825 --> 00:48:14,428 line:-2
例如MapKit和WebKit
你可能会用到


922
00:48:14,728 --> 00:48:17,731 line:-2
但我们不想把
所有这些跟SDK一起加载


923
00:48:17,798 --> 00:48:19,299 line:-1
这样体积太大


924
00:48:19,900 --> 00:48:21,735 line:-2
编译器和连接器
都不需要


925
00:48:21,802 --> 00:48:23,070 line:-1
它只要运行程序


926
00:48:23,136 --> 00:48:24,905 line:-2
因此我们创建了
stub dylib


927
00:48:24,972 --> 00:48:27,307 line:-1
删除了所有符号的主体


928
00:48:27,374 --> 00:48:28,742 line:-1
只保留名字


929
00:48:29,376 --> 00:48:30,644 line:-1
完成之后


930
00:48:30,844 --> 00:48:33,814 line:-2
转用文本表示
用起来比较简单


931
00:48:33,881 --> 00:48:39,052 line:-2
目前它们只用于
分配SDK以减少体积


932
00:48:40,187 --> 00:48:43,323 line:-2
如果在项目中看见它们
不要紧张


933
00:48:43,690 --> 00:48:44,992 line:-1
它们只是符号


934
00:48:46,159 --> 00:48:48,161 line:-1
最后是静态库


935
00:48:48,428 --> 00:48:49,263 line:-1
那么…


936
00:48:50,030 --> 00:48:52,266 line:-1
静态库是…


937
00:48:52,332 --> 00:48:56,603 line:-2
之前用AR工具创建的
.o文件的集合


938
00:48:56,670 --> 00:49:00,541 line:-2
也可能是lib
这是它的包装工具


939
00:49:00,941 --> 00:49:02,910 line:-1
根据AR操作文档


940
00:49:03,410 --> 00:49:06,680 line:-1
AR创建并维护文件组


941
00:49:06,747 --> 00:49:08,382 line:-1
将它们合并为一个库


942
00:49:09,316 --> 00:49:12,853 line:-2
听上去像是
TAR或ZIP文件


943
00:49:12,920 --> 00:49:13,954 line:-1
的确是这样


944
00:49:14,021 --> 00:49:14,855 line:-1
事实上…


945
00:49:14,922 --> 00:49:17,024 line:-1
.a格式是原始的库格式


946
00:49:17,090 --> 00:49:20,327 line:-2
在更好的工具产生之前
为UNIX所用


947
00:49:21,795 --> 00:49:24,364 line:-1
但现在的编译器和连接器


948
00:49:24,431 --> 00:49:26,567 line:-2
可以完全理解它们
所以继续使用


949
00:49:26,934 --> 00:49:28,936 line:-1
它就只是个档案文件


950
00:49:31,872 --> 00:49:35,209 line:-2
值得注意的是
它们孕育了动态链接


951
00:49:35,275 --> 00:49:36,143 line:-1
在过去


952
00:49:36,210 --> 00:49:39,313 line:-1
所有代码都被存档


953
00:49:39,780 --> 00:49:40,881 line:-1
因此


954
00:49:41,181 --> 00:49:44,184 line:-1
不能涵盖所有C库


955
00:49:44,251 --> 00:49:45,786 line:-1
只用一个函数


956
00:49:46,019 --> 00:49:47,421 line:-1
因此 行为是…


957
00:49:48,388 --> 00:49:50,591 line:-1
如果.o文件含有符号


958
00:49:50,657 --> 00:49:53,026 line:-2
我们会把整个.o文件
从库中提出来


959
00:49:53,093 --> 00:49:55,429 line:-1
但不会带入其他.o文件


960
00:49:56,230 --> 00:49:57,965 line:-1
如果在之间引用符号


961
00:49:58,031 --> 00:49:59,800 line:-1
只要带入即可


962
00:49:59,867 --> 00:50:01,935 line:-1
如果是非符号行为


963
00:50:02,002 --> 00:50:03,837 line:-1
比如静态初始程序


964
00:50:04,004 --> 00:50:06,006 line:-2
或将它们以你个人
dylib的形式重新导入


965
00:50:06,073 --> 00:50:08,408 line:-1
你要明确地用到


966
00:50:09,076 --> 00:50:13,146 line:-2
强制加载或制定加载
让连接器提取所有


967
00:50:13,213 --> 00:50:15,115 line:-2
或这些文件
即便之间没有关联


968
00:50:17,284 --> 00:50:20,954 line:-2
我们通过一个例子
串联起这些内容


969
00:50:23,457 --> 00:50:27,961 line:-1
台上是playSound函数样本


970
00:50:28,028 --> 00:50:30,797 line:-2
只看宠物不听声音
有何乐趣呢？


971
00:50:32,199 --> 00:50:33,066 line:-1
那么…


972
00:50:33,767 --> 00:50:35,636 line:-1
调用playSound


973
00:50:35,702 --> 00:50:37,804 line:-2
这个Cat函数
调用playSound


974
00:50:37,871 --> 00:50:39,173 line:-1
很简单吧


975
00:50:39,573 --> 00:50:41,575 line:-1
来看看生成的程序集


976
00:50:42,876 --> 00:50:43,810 line:-1
那么…


977
00:50:44,144 --> 00:50:46,146 line:-1
输出文件是cat.o


978
00:50:46,813 --> 00:50:47,648 line:-1
现在…


979
00:50:48,315 --> 00:50:50,150 line:-1
我们可以看到


980
00:50:51,218 --> 00:50:55,155 line:-2
字符串purr.aac
就是AAC声音文件


981
00:50:55,656 --> 00:50:57,257 line:-1
它被复制到cat.o


982
00:50:57,324 --> 00:51:00,794 line:-2
你会看到
名字为purr的文件不见了


983
00:51:01,094 --> 00:51:03,030 line:-1
因为它是静态的


984
00:51:03,096 --> 00:51:06,033 line:-2
如果你熟悉C语言
这是非导出命名


985
00:51:06,099 --> 00:51:07,534 line:-1
没有人能引用它


986
00:51:07,768 --> 00:51:09,837 line:-2
既然如此
我们不需要它了


987
00:51:09,903 --> 00:51:10,938 line:-1
排除掉


988
00:51:14,208 --> 00:51:15,275 line:-1
然后可以看到


989
00:51:15,976 --> 00:51:18,212 line:-1
Cat purr变成了符号


990
00:51:18,579 --> 00:51:21,481 line:-1
-[Cat purr]


991
00:51:23,550 --> 00:51:24,952 line:-1
跟预想的差不多


992
00:51:26,253 --> 00:51:28,989 line:-1
然后我们要把这个变量


993
00:51:29,056 --> 00:51:30,858 line:-1
传递到playSound


994
00:51:31,291 --> 00:51:33,794 line:-1
这里出现了两个指令


995
00:51:33,861 --> 00:51:34,862 line:-1
这是因为…


996
00:51:35,362 --> 00:51:38,298 line:-2
我们不知道
这个字符串最后在


997
00:51:38,365 --> 00:51:39,266 line:-1
执行文件的位置


998
00:51:39,333 --> 00:51:41,301 line:-1
没有具体的位置


999
00:51:41,602 --> 00:51:44,838 line:-2
但我们知道RM64
就是这个程序集


1000
00:51:45,506 --> 00:51:46,807 line:-1
它最多接收两个指令


1001
00:51:46,874 --> 00:51:49,076 line:-1
编译器留下两个指令


1002
00:51:49,343 --> 00:51:53,146 line:-2
留下了符号偏离
值为PAGE和PAGEOFF


1003
00:51:53,213 --> 00:51:55,349 line:-1
连接器之后回来修复


1004
00:51:56,149 --> 00:52:00,687 line:-2
既然已经
将字符串加载到x0


1005
00:52:01,855 --> 00:52:05,692 line:-2
就可以调用playSound
不用写入playSound


1006
00:52:05,759 --> 00:52:10,430 line:-2
我们写入
__z9playSoundPKc


1007
00:52:11,498 --> 00:52:12,599 line:-1
这是什么？


1008
00:52:12,666 --> 00:52:13,734 line:-1
这是变形的符号


1009
00:52:13,800 --> 00:52:16,136 line:-2
如果仔细看
会看到cat.mm


1010
00:52:16,203 --> 00:52:17,804 line:-1
这是Objective-C++


1011
00:52:18,405 --> 00:52:21,542 line:-2
playSound实际是
C++函数


1012
00:52:22,042 --> 00:52:22,876 line:-1
那么…


1013
00:52:22,943 --> 00:52:24,344 line:-1
如果你不熟悉


1014
00:52:25,979 --> 00:52:28,715 line:-2
可以在命令窗口
输入命令


1015
00:52:28,782 --> 00:52:31,151 line:-2
如果运行
Swift-demangle


1016
00:52:31,385 --> 00:52:33,554 line:-2
传递符号
然后反修饰


1017
00:52:33,720 --> 00:52:35,856 line:-2
没有用
它不是Swift符号


1018
00:52:36,456 --> 00:52:39,092 line:-2
但C++filt
C++反修饰器


1019
00:52:39,226 --> 00:52:40,427 line:-1
告诉我们它实际上是


1020
00:52:41,328 --> 00:52:42,529 line:-1
playSound的符号


1021
00:52:42,596 --> 00:52:44,932 line:-2
除了playSound
它还有一个实参


1022
00:52:44,998 --> 00:52:47,534 line:-1
就是const char*


1023
00:52:47,601 --> 00:52:52,139 line:-2
因为C++会将更多信息
编入修饰符号


1024
00:52:53,640 --> 00:52:55,108 line:-1
现在有了.o文件


1025
00:52:55,509 --> 00:52:57,811 line:-1
实际构建中会有更多


1026
00:52:58,946 --> 00:53:01,048 line:-1
那怎么办呢？


1027
00:53:02,082 --> 00:53:03,717 line:-2
首先
构建系统


1028
00:53:03,784 --> 00:53:06,653 line:-2
会将所有的.o
输入到连接器


1029
00:53:06,720 --> 00:53:09,323 line:-2
连接器会创建文件夹
放置这些文件


1030
00:53:09,756 --> 00:53:11,058 line:-1
这里构建的PetKit


1031
00:53:11,124 --> 00:53:13,360 line:-1
是PetWall的内嵌框架


1032
00:53:14,962 --> 00:53:16,463 line:-1
所以我们只要复制


1033
00:53:16,530 --> 00:53:18,665 line:-1
创建一个文本片段


1034
00:53:19,299 --> 00:53:22,069 line:-2
用来保存
app相关的所有代码


1035
00:53:22,703 --> 00:53:24,905 line:-1
然后复制cat.o到这里


1036
00:53:24,972 --> 00:53:26,673 line:-1
但是要分成两个部分


1037
00:53:26,907 --> 00:53:29,443 line:-2
一个给字符串
一个给执行代码


1038
00:53:30,410 --> 00:53:33,514 line:-1
现在已知它们的文件位置


1039
00:53:33,580 --> 00:53:36,984 line:-1
连接器就能复写cat.o


1040
00:53:37,584 --> 00:53:40,287 line:-1
基于特定的偏移值


1041
00:53:40,754 --> 00:53:43,624 line:-1
你看到第二个指令消失了


1042
00:53:43,690 --> 00:53:47,361 line:-2
它被一个null指令代替
没有任何行动


1043
00:53:47,961 --> 00:53:52,666 line:-2
但是它不能被删除
因为我们无法创建或删除代码


1044
00:53:52,733 --> 00:53:56,370 line:-1
这会打乱所有已经完成的工作


1045
00:53:56,503 --> 00:53:58,739 line:-1
所以与其删除


1046
00:53:59,273 --> 00:54:02,142 line:-1
不如用零行动替代


1047
00:54:02,609 --> 00:54:03,777 line:-1
最后是分支


1048
00:54:04,845 --> 00:54:06,246 line:-1
那么分支指令…


1049
00:54:07,581 --> 00:54:08,415 line:-1
然后…


1050
00:54:09,850 --> 00:54:11,218 line:-1
要怎么做？


1051
00:54:11,285 --> 00:54:12,886 line:-1
因为这个未定义符号？


1052
00:54:13,120 --> 00:54:14,855 line:-1
我们要继续浏览


1053
00:54:14,922 --> 00:54:17,124 line:-1
所有已经导入的.o文件


1054
00:54:18,325 --> 00:54:20,127 line:-1
首先是过去的静态库


1055
00:54:20,194 --> 00:54:22,496 line:-1
这是PetSupport.a


1056
00:54:22,963 --> 00:54:24,865 line:-1
PetSupport.a里面


1057
00:54:25,566 --> 00:54:28,468 line:-2
有一些文件
包括PetSounds.o


1058
00:54:29,503 --> 00:54:33,574 line:-2
大家能看到
playSound对应的符号


1059
00:54:34,741 --> 00:54:35,642 line:-1
把它拉入


1060
00:54:38,378 --> 00:54:41,048 line:-2
PetCare.o
不能被拉入


1061
00:54:41,381 --> 00:54:43,851 line:-1
因为这个.o文件没有符号


1062
00:54:43,917 --> 00:54:45,953 line:-1
能被app的其他部分


1063
00:54:46,019 --> 00:54:46,987 line:-1
引用


1064
00:54:48,555 --> 00:54:50,624 line:-2
所有我们把它拉入
现在需要


1065
00:54:51,859 --> 00:54:53,193 line:-2
_open
但没有定义


1066
00:54:53,260 --> 00:54:54,895 line:-1
你看到


1067
00:54:56,096 --> 00:54:57,664 line:-1
拉入的对话已变成


1068
00:54:57,731 --> 00:54:59,466 line:-1
open$stub


1069
00:54:59,766 --> 00:55:01,001 line:-1
为什么呢？


1070
00:55:01,768 --> 00:55:04,638 line:-1
因为我们发现open的复制


1071
00:55:05,806 --> 00:55:09,877 line:-2
在lib系统的
TBD文件里


1072
00:55:11,178 --> 00:55:14,281 line:-2
我知道
这不属于系统库


1073
00:55:14,348 --> 00:55:16,016 line:-2
我不会复制到
我的app


1074
00:55:16,083 --> 00:55:17,217 line:-1
但我需要…


1075
00:55:17,784 --> 00:55:21,255 line:-2
在app里放入足够的信息
以方便调用


1076
00:55:21,455 --> 00:55:24,858 line:-2
所以我们创建假函数
只是个模板


1077
00:55:25,259 --> 00:55:26,426 line:-1
用来代替


1078
00:55:26,493 --> 00:55:27,928 line:-2
从lib系统
拿走的函数


1079
00:55:27,995 --> 00:55:29,196 line:-1
这里就是open


1080
00:55:29,630 --> 00:55:31,064 line:-1
观察这个函数


1081
00:55:31,665 --> 00:55:35,269 line:-2
它实际是来自指针
open$pointer


1082
00:55:36,103 --> 00:55:37,137 line:-1
然后跳过来


1083
00:55:37,304 --> 00:55:40,774 line:-2
这需要一个函数指针
任何正常的C语言函数指针


1084
00:55:42,609 --> 00:55:43,877 line:-1
然后创建它


1085
00:55:44,144 --> 00:55:45,212 line:-1
在数据片段中


1086
00:55:45,579 --> 00:55:48,549 line:-2
如果有全局变量
就会出现在这里


1087
00:55:49,349 --> 00:55:51,084 line:-1
但这里是0


1088
00:55:51,351 --> 00:55:54,721 line:-1
如果空引用就会导致崩溃


1089
00:55:55,956 --> 00:55:58,458 line:-2
所以添加一个
LINKEDIT部分


1090
00:55:58,525 --> 00:56:00,294 line:-1
LINKEDIT是元数据


1091
00:56:00,661 --> 00:56:03,263 line:-1
连接器会用它


1092
00:56:03,764 --> 00:56:06,433 line:-1
给操作系统留下信息


1093
00:56:06,500 --> 00:56:09,870 line:-2
这就是动态连接器
在运行时间解决问题


1094
00:56:10,103 --> 00:56:11,538 line:-1
了解更多信息


1095
00:56:12,105 --> 00:56:16,443 line:-2
请观看2016年的演讲
优化app启动时间


1096
00:56:19,246 --> 00:56:20,080 line:-1
那么…


1097
00:56:21,048 --> 00:56:23,417 line:-1
简单回顾下今天的内容


1098
00:56:23,483 --> 00:56:27,287 line:-2
Jake讲述了构建系统
如何用依赖关系


1099
00:56:27,688 --> 00:56:30,624 line:-1
优化多核构建过程


1100
00:56:33,026 --> 00:56:36,763 line:-2
Jurgen展示了Clang
和如何查找头文件


1101
00:56:36,830 --> 00:56:39,299 line:-1
以及如何优化模块构建


1102
00:56:41,001 --> 00:56:42,135 line:-1
Devin简述了


1103
00:56:42,436 --> 00:56:44,872 line:-1
Swift对模块的扩展


1104
00:56:45,005 --> 00:56:46,840 line:-1
所有这些今年的新实施


1105
00:56:46,907 --> 00:56:49,443 line:-2
比如BF处理
都是为了提升构建速度


1106
00:56:49,810 --> 00:56:51,645 line:-1
最后连接器接收


1107
00:56:51,712 --> 00:56:52,913 line:-1
两个编译器的输出


1108
00:56:53,146 --> 00:56:55,015 line:-1
将它们带入app


1109
00:56:55,249 --> 00:56:57,951 line:-2
这时Xcode会
代码签名并打包


1110
00:56:58,018 --> 00:56:58,852 line:-1
与其他…


1111
00:57:00,387 --> 00:57:02,789 line:-2
app部分糅合
准备分发


1112
00:57:03,957 --> 00:57:04,791 line:-1
那么…


1113
00:57:05,926 --> 00:57:07,861 line:-1
这些基本都是开源的


1114
00:57:07,928 --> 00:57:09,329 line:-1
如果感兴趣


1115
00:57:09,396 --> 00:57:13,433 line:-2
可以研究Swift或Clang
或llbuild执行引擎


1116
00:57:14,801 --> 00:57:16,036 line:-1
对这些URL


1117
00:57:16,904 --> 00:57:18,805 line:-1
谢谢大家的到来


1118
00:57:19,206 --> 00:57:20,040 line:-1
而且…


1119
00:57:20,641 --> 00:57:23,310 line:-2
希望你们享受本次WWDC
我们将在实验室见


1120
00:57:23,377 --> 00:57:24,278 line:-1
谢谢

