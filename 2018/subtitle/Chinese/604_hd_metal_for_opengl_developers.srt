1
00:00:07,516 --> 00:00:15,500
[ 音乐 ]


2
00:00:21,516 --> 00:00:27,776
[ 掌声 ]


3
00:00:28,276 --> 00:00:28,666
>> 谢谢


4
00:00:29,326 --> 00:00:30,746
我叫 Dan Omachi


5
00:00:30,746 --> 00:00:32,946
我是 Apple Metal Ecosystem 团队的工程师


6
00:00:33,606 --> 00:00:35,536
现在我在团队内的主要工作是


7
00:00:35,536 --> 00:00:37,136
帮助开发者们学习 Metal


8
00:00:37,136 --> 00:00:38,766
以及获得很好的使用体验


9
00:00:39,476 --> 00:00:41,326
但是在这之前很多年


10
00:00:41,326 --> 00:00:43,456
我都致力于 Apple 的 OpenGL 和


11
00:00:43,636 --> 00:00:44,686
OpenGL ES 框架


12
00:00:45,086 --> 00:00:46,716
在我加入 Apple 以前


13
00:00:46,716 --> 00:00:47,746
我曾参与实现其他几个


14
00:00:47,746 --> 00:00:48,936
OpenGL 应用


15
00:00:50,926 --> 00:00:53,286
所以我非常骄傲


16
00:00:53,446 --> 00:00:55,576
我过去几年在


17
00:00:55,736 --> 00:00:57,866
OpenGL 上的成就


18
00:00:57,866 --> 00:00:59,976
但是对于 Metal 带领我们的方向


19
00:00:59,976 --> 00:01:02,166
我也非常激动


20
00:01:02,936 --> 00:01:04,726
今天我和我的同事


21
00:01:04,726 --> 00:01:05,906
Sukanya Sudugu


22
00:01:05,906 --> 00:01:07,556
将会向你们简略地


23
00:01:07,556 --> 00:01:10,066
介绍 Metal 同时对于


24
00:01:10,456 --> 00:01:12,526
如何轻松地移植你们的 OpenGL App


25
00:01:12,526 --> 00:01:15,156
提供一些建议


26
00:01:15,386 --> 00:01:16,906
今年尤其的重要


27
00:01:16,906 --> 00:01:19,016
因为 就像昨天


28
00:01:19,016 --> 00:01:20,876
在 union OpenGL 上说的


29
00:01:20,876 --> 00:01:23,466
OpenGL ES 和 OpenCL


30
00:01:23,676 --> 00:01:25,366
是不被允许的


31
00:01:26,336 --> 00:01:28,206
现在和即将发布的


32
00:01:28,206 --> 00:01:30,346
App 仍可在 tvOS 和 iOS 12 上使用


33
00:01:30,716 --> 00:01:35,006
OpenGL ES 以及在 macOS 10.14 Mojave 上


34
00:01:35,636 --> 00:01:40,706
使用 OpenGL and OpenCL


35
00:01:40,706 --> 00:01:44,626
而且这将持续一段时间


36
00:01:45,476 --> 00:01:48,286
但是 新项目应该


37
00:01:48,286 --> 00:01:50,486
从开始就面向 Metal


38
00:01:51,026 --> 00:01:51,886
所以如果你还不熟悉 Metal


39
00:01:51,886 --> 00:01:54,156
那么 你应该开始熟悉一下它


40
00:01:55,806 --> 00:01:56,886
在你把所有 OpenGL 代码都销毁


41
00:01:56,886 --> 00:01:58,416
并开始把所有东西 都转移到 Metal 之前


42
00:01:58,416 --> 00:01:59,526
你还有几个选择


43
00:01:59,526 --> 00:02:00,446
可以考虑


44
00:02:01,376 --> 00:02:03,156
Apple 提供了很多高层面


45
00:02:03,226 --> 00:02:04,906
的渲染框架


46
00:02:05,466 --> 00:02:06,446
不同种类的渲染


47
00:02:06,836 --> 00:02:08,846
适用于 2D 游戏的 SpriteKit


48
00:02:08,846 --> 00:02:10,756
适用于 3D 游戏的 SceneKit


49
00:02:10,756 --> 00:02:11,966
能有很棒效果的 Core Image


50
00:02:13,526 --> 00:02:15,456
另外 每个主要的


51
00:02:15,566 --> 00:02:17,366
第三方游戏引擎已经


52
00:02:17,366 --> 00:02:19,596
使用 Metal 作为他们的主要渲染器


53
00:02:20,776 --> 00:02:22,886
但你或许会认为


54
00:02:22,886 --> 00:02:24,426
这些方法不适合你


55
00:02:24,756 --> 00:02:25,866
你也可以


56
00:02:25,866 --> 00:02:28,086
自己在 Metal 里实现这些


57
00:02:28,086 --> 00:02:30,416
这就是我们今天要讨论的东西


58
00:02:30,566 --> 00:02:31,746
所以我们从 Metal 的设计


59
00:02:31,746 --> 00:02:33,966
和一些基本概念说起


60
00:02:35,536 --> 00:02:37,246
OpenGL 最开始


61
00:02:37,246 --> 00:02:39,326
是 25 年前开发的


62
00:02:39,366 --> 00:02:41,286
它的核心是反映了


63
00:02:41,286 --> 00:02:43,226
3D 图像的硬件加速


64
00:02:44,696 --> 00:02:46,676
所以新版本的更新


65
00:02:46,676 --> 00:02:48,266
和拓展确实为我们


66
00:02:48,266 --> 00:02:49,766
探索新的 GPU 特性和


67
00:02:49,836 --> 00:02:51,666
性能技术提供了服务


68
00:02:52,806 --> 00:02:54,436
但是 仍旧有一些


69
00:02:54,436 --> 00:02:56,276
基础设计决策


70
00:02:56,276 --> 00:02:58,396
不再适用于现在的硬件设备


71
00:03:00,856 --> 00:03:02,326
OpenGL 管道你曾是


72
00:03:02,326 --> 00:03:03,826
完全固定的功能


73
00:03:03,826 --> 00:03:07,526
虽然现在 OpenGL 提供可编程的管道


74
00:03:07,526 --> 00:03:12,826
但是它并不完全匹配当代 GPU


75
00:03:13,036 --> 00:03:15,356
另外 异步处理不再是


76
00:03:15,356 --> 00:03:16,726
API 的核心特性


77
00:03:17,476 --> 00:03:18,436
还有很多其他功能


78
00:03:18,436 --> 00:03:19,576
暗示 GPU 会与


79
00:03:19,576 --> 00:03:20,656
你的 App 同时工作


80
00:03:20,656 --> 00:03:22,586
但大多数都是隐式的


81
00:03:23,046 --> 00:03:27,766
25 年前 只有最贵的工作站


82
00:03:27,766 --> 00:03:29,186
和服务器是多核的


83
00:03:29,676 --> 00:03:30,956
所以 设计一个高效的


84
00:03:30,956 --> 00:03:33,216
多线模型 不是最优选择


85
00:03:33,216 --> 00:03:37,516
所以在 2014 年的时候很明显


86
00:03:37,516 --> 00:03:39,116
设计新的 GPU


87
00:03:39,116 --> 00:03:40,836
App 接口是必要的


88
00:03:41,696 --> 00:03:42,856
很明显我们需要


89
00:03:42,856 --> 00:03:45,406
一个可以高效利用 GPU 能力的接口


90
00:03:46,576 --> 00:03:48,076
要做到这一点


91
00:03:48,076 --> 00:03:49,826
App 需要 CPU 让道


92
00:03:49,826 --> 00:03:51,946
才能让 GPU 可以做他的事情


93
00:03:52,146 --> 00:03:53,836
但是当 App 需要 CPU 做渲染时


94
00:03:53,836 --> 00:03:54,976
它又可以


95
00:03:54,976 --> 00:03:56,466
调用所有的 CPU


96
00:03:56,906 --> 00:03:58,176
包括它的多核


97
00:03:59,626 --> 00:04:01,146
如果接口需要预测


98
00:04:01,146 --> 00:04:04,056
去避免开发者陷入


99
00:04:04,136 --> 00:04:08,586
API 的隐藏陷阱


100
00:04:08,586 --> 00:04:09,926
那么每一个调用需要有明显的结果


101
00:04:09,926 --> 00:04:12,146
并且最好不要有


102
00:04:12,206 --> 00:04:13,846
隐式的操作


103
00:04:14,336 --> 00:04:16,476
这种预测的一部分


104
00:04:16,576 --> 00:04:17,805
需要去控制


105
00:04:17,805 --> 00:04:19,916
资源分布和


106
00:04:19,956 --> 00:04:22,376
什么时候需要同步


107
00:04:27,896 --> 00:04:29,456
我们想要这个接口


108
00:04:29,456 --> 00:04:31,416
是可触及的


109
00:04:31,416 --> 00:04:32,536
它需要正确的


110
00:04:32,536 --> 00:04:34,306
平衡低层次控制和明确的用量


111
00:04:34,306 --> 00:04:36,436
因为当你了解一个东西以后


112
00:04:36,436 --> 00:04:40,566
你能更高效和有效的使用它


113
00:04:41,976 --> 00:04:43,766
当然 我们设计 Metal


114
00:04:43,766 --> 00:04:46,516
是为了更好地映射到各种当代 GPU 上


115
00:04:46,516 --> 00:04:49,486
特别是我们知道


116
00:04:49,486 --> 00:04:50,446
管道中的硬件


117
00:04:50,496 --> 00:04:53,216
需要软件去推动它


118
00:04:53,906 --> 00:04:55,556
这就包括了 Apple 设计的


119
00:04:55,696 --> 00:04:58,486
所有 A11 仿生 GPU


120
00:04:59,956 --> 00:05:01,736
所以为什么 Metal 不同于 OpenGL


121
00:05:02,196 --> 00:05:03,556
你会更少地去进行


122
00:05:03,626 --> 00:05:06,036
昂贵的操作


123
00:05:07,046 --> 00:05:08,236
对象的设计是这样的


124
00:05:08,236 --> 00:05:09,916
API 的状态可以被转换


125
00:05:09,916 --> 00:05:12,226
并且在创建时被预包装进


126
00:05:12,226 --> 00:05:13,926
GPU 命令


127
00:05:15,726 --> 00:05:17,406
这样做会在真正渲染时


128
00:05:17,406 --> 00:05:19,266
最大程度减少成本


129
00:05:20,576 --> 00:05:21,656
拥有 Vertex 和片段着色器的


130
00:05:21,686 --> 00:05:23,286
图形管道也


131
00:05:23,286 --> 00:05:24,756
反映了当代 GPU


132
00:05:25,716 --> 00:05:27,396
所以这会降低


133
00:05:27,516 --> 00:05:29,986
将 API 设置转换到 GP 命令的成本


134
00:05:31,236 --> 00:05:32,926
这并不表示


135
00:05:32,926 --> 00:05:34,296
管道是截然不同的


136
00:05:34,296 --> 00:05:36,026
或者说需要一个全新的方式去考虑


137
00:05:36,946 --> 00:05:38,256
Metal 最大的区别是


138
00:05:38,256 --> 00:05:39,406
将管道的各个阶段


139
00:05:39,436 --> 00:05:41,686
分组成对象


140
00:05:41,686 --> 00:05:43,326
是更高效的


141
00:05:43,326 --> 00:05:45,396
并不是管道本身改变了


142
00:05:46,816 --> 00:05:49,366
Metal 为了执行多线程


143
00:05:49,366 --> 00:05:50,616
还有一个清晰的模型


144
00:05:51,496 --> 00:05:52,356
有很多种不同的方法


145
00:05:52,356 --> 00:05:53,976
让 App 在不同线程上


146
00:05:53,976 --> 00:05:55,796
去驱动 GPU


147
00:05:56,286 --> 00:05:57,906
但是对于每一个


148
00:05:57,996 --> 00:05:59,686
都有明确但不受限的规则去实现它


149
00:06:01,036 --> 00:06:02,546
此外最常用的对象


150
00:06:02,546 --> 00:06:05,936
像纹理 缓冲和着色器 可以安全


151
00:06:05,936 --> 00:06:07,726
并有效地在不同线程中使用


152
00:06:08,526 --> 00:06:10,156
Metal 并不需要去实现


153
00:06:10,326 --> 00:06:11,776
昂贵的内部日志操作


154
00:06:11,776 --> 00:06:13,306
去防止这些


155
00:06:13,306 --> 00:06:14,546
对象进入


156
00:06:14,546 --> 00:06:15,456
无效状态


157
00:06:17,516 --> 00:06:21,036
最后 它的执行模式反映了软件与 GPU 之间


158
00:06:21,076 --> 00:06:22,696
真正发生的事


159
00:06:23,266 --> 00:06:24,926
很多通过 OpenGL 展现


160
00:06:25,046 --> 00:06:26,406
的隐性操作


161
00:06:26,406 --> 00:06:28,116
通过 Metal 在 App 中


162
00:06:28,116 --> 00:06:29,886
被明显地展示出来


163
00:06:30,636 --> 00:06:31,836
这就让你可以对于什么时候


164
00:06:31,836 --> 00:06:33,666
和怎样在 App 中使用 GPU


165
00:06:33,666 --> 00:06:35,966
做出明智的决定


166
00:06:36,946 --> 00:06:37,966
这还代表着


167
00:06:37,966 --> 00:06:39,036
你的 App 和 GPU 之间将有


168
00:06:39,036 --> 00:06:40,586
更少的软件


169
00:06:41,216 --> 00:06:43,286
大多数的 Metal 调用直接


170
00:06:43,286 --> 00:06:45,096
指向 GPU 驱动


171
00:06:45,096 --> 00:06:46,726
这样驱动也需要做更少的处理


172
00:06:46,726 --> 00:06:49,526
去将 API 调用转换为 GPU 命令


173
00:06:51,216 --> 00:06:52,216
所以让我们来跟深入地看看


174
00:06:52,216 --> 00:06:52,636
它是怎么工作的


175
00:06:53,256 --> 00:06:56,466
所有的 GL 调用都在 OpenGL 中


176
00:06:56,466 --> 00:06:57,506
展现出来


177
00:06:57,916 --> 00:06:59,846
这个内容就包含了很多东西


178
00:06:59,846 --> 00:07:01,966
它追踪 API 的状态


179
00:07:02,166 --> 00:07:03,766
它管理 OpenGL 对象和其它内存


180
00:07:03,766 --> 00:07:05,246
同时还转换


181
00:07:05,246 --> 00:07:06,506
并递交 GPU 命令


182
00:07:07,366 --> 00:07:09,066
Metal 将所有这些


183
00:07:09,066 --> 00:07:10,626
OpenGL 内容的工作分成


184
00:07:10,626 --> 00:07:12,956
很多个小对象


185
00:07:14,056 --> 00:07:18,616
第一个被创建的对象就是 Metal 设备


186
00:07:18,716 --> 00:07:20,626
它是一个物理 GPU 的


187
00:07:20,776 --> 00:07:21,686
抽象表现


188
00:07:22,256 --> 00:07:26,286
这个设备创建对象


189
00:07:26,286 --> 00:07:27,646
比如说纹理 缓冲


190
00:07:27,646 --> 00:07:29,906
和包含着色器的管道对象


191
00:07:31,026 --> 00:07:32,886
它还创建了一个关键对象


192
00:07:33,136 --> 00:07:34,636
叫做 Metal 命令队列


193
00:07:35,196 --> 00:07:37,816
这个命令队列只有一个工作


194
00:07:37,816 --> 00:07:39,796
就是去创建


195
00:07:39,796 --> 00:07:41,176
一系列的命令缓存


196
00:07:41,956 --> 00:07:43,506
这里我们已经创建了一个命令缓存


197
00:07:43,506 --> 00:07:44,856
并且这个命令缓存是


198
00:07:44,856 --> 00:07:46,706
一系列 GPU 命令的简单列表


199
00:07:46,956 --> 00:07:48,956
你的 App 将填写这个列表


200
00:07:48,956 --> 00:07:50,146
并且发送给 GPU 去执行


201
00:07:51,166 --> 00:07:52,836
通常你的 App 要在每一帧去创建一个


202
00:07:52,836 --> 00:07:54,926
单独的命令缓存


203
00:07:55,016 --> 00:07:55,866
但是有些情况下


204
00:07:55,866 --> 00:07:57,566
它也会觉得需要


205
00:07:57,696 --> 00:08:00,886
在一帧里创建两三个


206
00:08:01,026 --> 00:08:02,256
但是 App 本身并不会直接写这些


207
00:08:02,256 --> 00:08:03,606
命令到命令缓存里


208
00:08:03,606 --> 00:08:05,216
它是创建了一个


209
00:08:05,216 --> 00:08:06,586
Metal 命令编码器


210
00:08:07,886 --> 00:08:09,356
这个命令编码器将


211
00:08:09,446 --> 00:08:11,686
API 调用转换成 GPU 指令


212
00:08:11,906 --> 00:08:13,266
并将它们写入命令缓存


213
00:08:14,336 --> 00:08:15,666
在一系列命令


214
00:08:15,666 --> 00:08:17,426
被编码以后 App 就会


215
00:08:17,426 --> 00:08:19,336
结束编码 并且释放编码对象


216
00:08:20,536 --> 00:08:22,756
事实上有不同的编码器


217
00:08:22,756 --> 00:08:24,146
你的 App 可以从命令缓存中


218
00:08:24,146 --> 00:08:25,876
创建新的编码器 去编码更多的指令


219
00:08:31,156 --> 00:08:32,616
特别注意一点是


220
00:08:32,616 --> 00:08:34,346
直到现在在这流程上


221
00:08:34,346 --> 00:08:36,186
GPU 还什么都没做


222
00:08:37,106 --> 00:08:40,726
Metal 创建了对象和编码命令


223
00:08:40,775 --> 00:08:41,145
都是基于 CPU 的


224
00:08:41,876 --> 00:08:43,166
只有在你的 App


225
00:08:43,216 --> 00:08:45,356
完成编码命令和


226
00:08:45,356 --> 00:08:46,356
提交命令缓存以后


227
00:08:47,446 --> 00:08:49,226
GPU 才会开始工作并


228
00:08:49,226 --> 00:08:51,376
执行那些命令


229
00:08:52,576 --> 00:08:54,566
你也可以将这些命令编译成


230
00:08:54,566 --> 00:08:56,226
多个并行的命令缓存


231
00:08:56,266 --> 00:08:57,816
到分开的线程上


232
00:08:58,466 --> 00:09:02,056
现在我已经谈到了


233
00:09:02,056 --> 00:09:03,876
命令队列是如何


234
00:09:03,876 --> 00:09:06,276
产生一个命令缓存的序列


235
00:09:06,276 --> 00:09:07,606
并且你能从命令缓存中


236
00:09:07,606 --> 00:09:09,286
创建一个命令编译器


237
00:09:10,196 --> 00:09:11,216
让我们更细致地看一看


238
00:09:11,216 --> 00:09:13,096
这些用来写入命令缓存的


239
00:09:13,096 --> 00:09:14,466
编码器对象


240
00:09:15,726 --> 00:09:17,036
它们有三种主要类型


241
00:09:18,096 --> 00:09:18,986
Render Command Encoder


242
00:09:18,986 --> 00:09:20,606
它的命令类似于 OpenGL 命令字符串


243
00:09:20,606 --> 00:09:22,266
对于这些命令你可以


244
00:09:22,356 --> 00:09:23,776
设置状态


245
00:09:23,776 --> 00:09:25,316
绑定对象和发出绘图申请


246
00:09:26,446 --> 00:09:27,736
还有一个是 Blit Command Encoder


247
00:09:27,906 --> 00:09:29,306
基于它你可以发出纹理


248
00:09:29,306 --> 00:09:31,246
和缓存拷贝操作


249
00:09:31,576 --> 00:09:32,786
你也可以用它来生成


250
00:09:32,786 --> 00:09:34,526
用于纹理和从缓存中 转移


251
00:09:34,566 --> 00:09:36,156
像素数据的 Mipmap 就类似于


252
00:09:36,156 --> 00:09:38,076
glReadPixels 如何对 OpenGL 的


253
00:09:38,076 --> 00:09:40,266
像素缓存对象操作的


254
00:09:40,806 --> 00:09:43,496
最后是 Compute Command Encoder


255
00:09:43,756 --> 00:09:46,076
它让你可以


256
00:09:46,076 --> 00:09:48,466
分派内核


257
00:09:49,316 --> 00:09:50,826
Render Command Encoder 可能将会是


258
00:09:50,826 --> 00:09:51,746
你最熟悉的编码器


259
00:09:51,746 --> 00:09:54,346
因为它负责


260
00:09:54,346 --> 00:09:56,206
大部分基于图形的 App


261
00:09:56,206 --> 00:09:57,976
需要的操作


262
00:09:59,306 --> 00:10:00,816
这一组命令编译进


263
00:10:00,816 --> 00:10:01,966
Render Command Encoder


264
00:10:02,006 --> 00:10:03,836
通常被称为 Render Pass


265
00:10:05,406 --> 00:10:06,576
在 Render Pass 中你可以设置


266
00:10:06,576 --> 00:10:08,016
为图形管道建立的渲染对象


267
00:10:08,016 --> 00:10:10,236
和发出与这些对象一起的


268
00:10:10,676 --> 00:10:11,586
绘图命令


269
00:10:12,226 --> 00:10:13,726
这就包括了一些


270
00:10:13,726 --> 00:10:15,946
类似于 glDrawArrays 和


271
00:10:15,946 --> 00:10:18,696
glDrawElements 和其他一些


272
00:10:18,816 --> 00:10:19,566
OpenGL 绘图命令


273
00:10:21,006 --> 00:10:22,416
每个 Render Command Encoder 都


274
00:10:22,416 --> 00:10:24,156
紧密地与一系列渲染对象


275
00:10:24,306 --> 00:10:25,126
联系在一起


276
00:10:26,976 --> 00:10:28,806
渲染目标就是一个


277
00:10:28,806 --> 00:10:30,306
可以绘制的简单纹理


278
00:10:30,846 --> 00:10:32,636
它包括了颜色 深度和


279
00:10:32,666 --> 00:10:34,166
模板纹理以及


280
00:10:34,166 --> 00:10:35,356
多样本纹理


281
00:10:36,436 --> 00:10:37,606
你可以指定一系列渲染目标


282
00:10:37,606 --> 00:10:38,976
在你从命令缓存中


283
00:10:38,976 --> 00:10:42,336
创建渲染命令编码器的时候


284
00:10:42,516 --> 00:10:43,906
所有绘图命令


285
00:10:43,906 --> 00:10:45,596
都在编码器的寿命内


286
00:10:45,596 --> 00:10:47,036
指向这些目标


287
00:10:48,506 --> 00:10:49,826
如果想要导向 一个命令去新的对象


288
00:10:49,826 --> 00:10:51,396
你可以通过当前的渲染命令编译器


289
00:10:51,396 --> 00:10:52,886
结束编码过程


290
00:10:53,116 --> 00:10:55,536
然后去和新的对象去


291
00:10:55,536 --> 00:10:56,256
创建新的编译器


292
00:10:57,216 --> 00:10:58,836
这就明确地


293
00:10:58,836 --> 00:11:01,076
区分了导向


294
00:11:01,126 --> 00:11:03,506
不同渲染对象的命令


295
00:11:04,186 --> 00:11:06,196
我们再说一说


296
00:11:06,506 --> 00:11:08,256
你们在渲染过程中要用到的对象


297
00:11:09,446 --> 00:11:10,476
Metal 有很多类似于


298
00:11:10,476 --> 00:11:11,276
OpenGL 的对象


299
00:11:11,276 --> 00:11:14,346
包括纹理 缓存


300
00:11:15,136 --> 00:11:17,846
采样器和管道状态对象


301
00:11:17,846 --> 00:11:19,666
这些对象类似于 OpenGL 的


302
00:11:19,696 --> 00:11:22,086
程序对象


303
00:11:22,206 --> 00:11:23,766
还有深度模板状态对象


304
00:11:23,766 --> 00:11:24,966
它们并不真的存在于 OpenGL 中


305
00:11:25,176 --> 00:11:26,706
而只是 OpenGL 有的


306
00:11:26,706 --> 00:11:28,156
有相同深度和


307
00:11:28,396 --> 00:11:29,346
模板状态的容器


308
00:11:31,496 --> 00:11:32,996
一个区别 OpenGL 和 Metal 对象


309
00:11:33,076 --> 00:11:35,556
的重要不同是


310
00:11:35,906 --> 00:11:37,866
它们怎么被创建的和管理的


311
00:11:39,176 --> 00:11:40,336
这些对象都是通过


312
00:11:40,336 --> 00:11:41,756
设备对象创建的


313
00:11:41,756 --> 00:11:43,426
所以它们只与单个 GPU 相关联


314
00:11:44,716 --> 00:11:46,156
你设置大部分对象状态


315
00:11:46,276 --> 00:11:48,316
是你通过指定属性


316
00:11:48,646 --> 00:11:50,656
在描述符对象中创建它的时候


317
00:11:51,936 --> 00:11:53,656
所有状态都是在


318
00:11:53,656 --> 00:11:55,166
对象被创建的时候设置的


319
00:11:55,166 --> 00:11:55,596
这些状态是固定的 并且不可改变的


320
00:11:56,946 --> 00:11:58,306
虽然这个纹理和缓存的状态


321
00:11:58,306 --> 00:11:59,856
是在创建时就被固定的


322
00:11:59,856 --> 00:12:02,226
但是这些对象包含的数据


323
00:12:02,226 --> 00:12:03,976
是可以被改变的


324
00:12:04,626 --> 00:12:07,296
Metal 可以为这些对象


325
00:12:07,446 --> 00:12:09,596
创建新的编码器 当它被创建的时候


326
00:12:10,396 --> 00:12:12,146
OpenGL 的可变模型


327
00:12:12,176 --> 00:12:13,766
完全可能让


328
00:12:13,766 --> 00:12:15,186
你的 App 在触碰到一小块状态的时候


329
00:12:15,186 --> 00:12:18,176
这个对象会重新


330
00:12:18,176 --> 00:12:19,206
开始编译


331
00:12:19,946 --> 00:12:21,256
即便你的 App 没有


332
00:12:21,256 --> 00:12:23,846
改变对象的状态


333
00:12:23,846 --> 00:12:25,176
OpenGL 也会需要检查标记的层次结构


334
00:12:25,226 --> 00:12:27,326
这样做是为了在绘图之前确认无误


335
00:12:28,186 --> 00:12:30,596
所以通过这个不可改变的模型


336
00:12:30,596 --> 00:12:32,176
Metal 永远不需要检查


337
00:12:32,176 --> 00:12:34,106
对象状态的改变


338
00:12:34,106 --> 00:12:36,016
这就使绘图调用快很多


339
00:12:37,556 --> 00:12:39,166
另外 对象能在跨线程中


340
00:12:39,256 --> 00:12:41,106
更高效的被利用


341
00:12:41,516 --> 00:12:42,756
Metal 永远不用锁定一个对象


342
00:12:42,756 --> 00:12:43,746
只是因为避免它


343
00:12:43,746 --> 00:12:44,996
在转换到其他线程的时候


344
00:12:45,146 --> 00:12:45,956
陷入无效状态


345
00:12:51,306 --> 00:12:52,826
那么我们再来谈谈移植


346
00:12:52,826 --> 00:12:57,256
这是一个典型的阶段


347
00:12:57,256 --> 00:12:59,286
这些是一些经典的


348
00:12:59,286 --> 00:13:00,226
渲染 App 的阶段


349
00:13:01,046 --> 00:13:02,166
你搭建一个 App 去编译资源


350
00:13:02,166 --> 00:13:03,746
和捆绑资产


351
00:13:04,696 --> 00:13:05,926
开始并初始化它


352
00:13:06,306 --> 00:13:07,796
加载这些资产


353
00:13:07,796 --> 00:13:09,666
初始化将会一直


354
00:13:09,666 --> 00:13:11,986
出现在你 App 里的对象


355
00:13:13,236 --> 00:13:14,966
然后你不断地重复


356
00:13:15,456 --> 00:13:16,976
渲染设定状态


357
00:13:16,976 --> 00:13:19,336
发布多个绘图需求


358
00:13:19,486 --> 00:13:19,986
然后一帧一帧地展现


359
00:13:20,676 --> 00:13:23,816
我将会谈谈


360
00:13:23,816 --> 00:13:25,686
在早期阶段 App 中的


361
00:13:25,686 --> 00:13:26,796
Metal 开发过程


362
00:13:28,316 --> 00:13:29,806
包括着色器的离线创建


363
00:13:29,806 --> 00:13:32,136
创建对象的初始化


364
00:13:33,256 --> 00:13:34,666
之后 Sukanya 会解释如何


365
00:13:34,666 --> 00:13:36,656
移植每一帧的渲染代码


366
00:13:38,676 --> 00:13:39,936
所以让我们从


367
00:13:39,936 --> 00:13:41,706
App 的创建时间开始


368
00:13:41,706 --> 00:13:43,736
就是着色器被编译的时候


369
00:13:44,896 --> 00:13:47,006
我们将从着色语言开始


370
00:13:47,866 --> 00:13:49,006
Metal 的着色语言


371
00:13:49,126 --> 00:13:50,476
是基于 C++ 的


372
00:13:50,936 --> 00:13:53,316
所以就像你创建 C++ 的


373
00:13:53,386 --> 00:13:55,206
类 模板 结构


374
00:13:55,606 --> 00:13:57,336
定义 名称空间 一样


375
00:13:58,466 --> 00:14:00,156
比如说 GLSL


376
00:14:00,156 --> 00:14:02,796
我们有内置的向量和矩阵类型


377
00:14:02,796 --> 00:14:04,176
也有很多的内置方法和


378
00:14:04,176 --> 00:14:06,436
图形处理常用的运算符


379
00:14:06,486 --> 00:14:09,236
也有一些类


380
00:14:09,316 --> 00:14:11,006
指定采样器的状态


381
00:14:11,006 --> 00:14:11,426
并在纹理上执行


382
00:14:12,966 --> 00:14:13,986
描述这个语言最好的方式


383
00:14:13,986 --> 00:14:15,166
刚才已经展示给你们了


384
00:14:15,396 --> 00:14:17,846
所以这是顶点和片段着色器对


385
00:14:19,336 --> 00:14:20,966
顶部方法中的顶点关键字


386
00:14:20,966 --> 00:14:24,196
说明了它是一个顶点着色器


387
00:14:24,196 --> 00:14:25,886
同样适用于


388
00:14:25,886 --> 00:14:28,306
底部方法的片段关键字


389
00:14:29,706 --> 00:14:31,366
注意它们有自定义的名字


390
00:14:31,426 --> 00:14:33,226
这一点不像 GLSL 一样每个着色器


391
00:14:33,266 --> 00:14:34,116
就只是被叫做 main


392
00:14:34,756 --> 00:14:35,726
这非常的关键 因为


393
00:14:35,726 --> 00:14:37,166
它允许你去构建一个大型的库


394
00:14:37,166 --> 00:14:38,976
库里的每一个着色器都用名字


395
00:14:39,206 --> 00:14:41,506
去表明它们的功能


396
00:14:41,936 --> 00:14:44,446
每一个从你的 App 传出的东西


397
00:14:44,446 --> 00:14:47,266
都是这些其中一个着色器的参数


398
00:14:48,026 --> 00:14:49,316
并且它不像 GLSL 一样


399
00:14:49,316 --> 00:14:50,486
会在方法外有


400
00:14:50,486 --> 00:14:51,416
松散变量


401
00:14:52,486 --> 00:14:53,786
就像你看到的


402
00:14:53,846 --> 00:14:55,646
这些参数旁边会有括号


403
00:14:56,226 --> 00:14:58,136
它们是属性说明符


404
00:14:58,386 --> 00:14:59,946
这是从 C++ 里拓展来的


405
00:14:59,946 --> 00:15:02,236
为了表示特殊的变量


406
00:15:03,456 --> 00:15:05,666
所以这个顶点 ID 属性


407
00:15:05,746 --> 00:15:07,446
表明了这个 VID 参数


408
00:15:07,446 --> 00:15:08,576
应该在顶点被执行时包括


409
00:15:08,666 --> 00:15:12,826
当前顶点的索引值


410
00:15:13,196 --> 00:15:14,906
在这两个地方我们会用到它


411
00:15:14,906 --> 00:15:17,676
去将索引值放置到顶点数组中


412
00:15:18,226 --> 00:15:20,636
这些带有缓存属性的


413
00:15:20,636 --> 00:15:22,866
参数说明符


414
00:15:22,866 --> 00:15:24,186
表明了这些变量


415
00:15:24,226 --> 00:15:26,106
被 Metal API 里设定的


416
00:15:26,246 --> 00:15:27,436
缓存对象所填满


417
00:15:27,436 --> 00:15:29,596
我一会将会多说一些


418
00:15:29,596 --> 00:15:31,596
Metal API 是怎么与这些有关联的


419
00:15:32,266 --> 00:15:33,626
但是首先我们先来看看


420
00:15:33,626 --> 00:15:35,136
这里用到的一些类型


421
00:15:36,056 --> 00:15:37,776
现在这些都是你可以定义的


422
00:15:38,366 --> 00:15:39,386
自定义类型


423
00:15:40,406 --> 00:15:41,656
这里的顶点参数


424
00:15:41,656 --> 00:15:43,606
被定义为指向顶点类型的指针


425
00:15:43,606 --> 00:15:45,886
这就是它的定义


426
00:15:46,706 --> 00:15:48,836
这个结构包括两个成员


427
00:15:48,836 --> 00:15:50,586
一个是模型位置成员


428
00:15:50,586 --> 00:15:51,736
另一个是纹理坐标成员


429
00:15:52,446 --> 00:15:54,116
它在顶点数组里定义了 每一个顶点的


430
00:15:54,146 --> 00:15:56,186
布局和内存


431
00:15:56,526 --> 00:15:58,096
这个数据会被传递到这个顶点的着色器


432
00:15:59,836 --> 00:16:01,336
我们再来看看这个顶点的输出类型


433
00:16:01,336 --> 00:16:03,186
它是从顶点着色器里返回的


434
00:16:03,776 --> 00:16:06,506
它这里的定义指定了


435
00:16:06,506 --> 00:16:07,736
什么被传递下去用于


436
00:16:07,736 --> 00:16:09,186
光栈化阶段并


437
00:16:09,186 --> 00:16:10,806
最终用于分片程序


438
00:16:11,336 --> 00:16:13,756
包含了四个部分的


439
00:16:13,756 --> 00:16:15,146
浮动点成员被称为 clipPos


440
00:16:15,186 --> 00:16:17,396
clipPos 在他的旁边有


441
00:16:17,396 --> 00:16:18,766
位置属性说明符


442
00:16:19,336 --> 00:16:20,756
这就表明了这个成员


443
00:16:20,756 --> 00:16:22,096
会作为一个顶点着色器的


444
00:16:22,136 --> 00:16:23,746
位置输出


445
00:16:25,116 --> 00:16:26,376
这个 texCoord 成员


446
00:16:26,376 --> 00:16:27,326
并不带有默认为变量的


447
00:16:27,326 --> 00:16:30,096
属性说明符


448
00:16:30,306 --> 00:16:31,656
它会和其他顶点的纹理坐标值


449
00:16:31,656 --> 00:16:36,726
一起被插入去定义


450
00:16:36,726 --> 00:16:38,616
光栅化三角形


451
00:16:38,616 --> 00:16:39,986
这就跟 GLSL 很不一样


452
00:16:41,616 --> 00:16:42,616
我们再来看看


453
00:16:42,616 --> 00:16:44,046
我们分片着色器的参数


454
00:16:45,146 --> 00:16:46,796
所以我们会用到这个 vertexOutput 结构体


455
00:16:46,796 --> 00:16:48,966
我们刚刚看过的这个结构体


456
00:16:49,406 --> 00:16:51,716
会作为我们分片着色器的输入


457
00:16:52,336 --> 00:16:53,966
同时它给了我们插入的


458
00:16:54,006 --> 00:16:55,446
纹理坐标


459
00:16:55,716 --> 00:16:57,346
这个坐标我们已经在顶点着色器里构造了


460
00:16:58,486 --> 00:17:00,206
我们这里用它来


461
00:17:00,366 --> 00:17:02,966
从纹理中取样


462
00:17:03,086 --> 00:17:04,586
在我们写好的 Objective-C 


463
00:17:04,586 --> 00:17:06,486
App 代码中


464
00:17:06,486 --> 00:17:08,316
我们用 Render Command Encoder 去


465
00:17:08,406 --> 00:17:10,226
将对象映射到着色器参数


466
00:17:12,915 --> 00:17:15,016
这个带有请求的索引参数


467
00:17:15,016 --> 00:17:16,396
非常类似于


468
00:17:16,396 --> 00:17:18,316
OpenGL 的属性索引


469
00:17:18,366 --> 00:17:20,715
顶点属性索引和纹理单元


470
00:17:21,336 --> 00:17:23,415
它们指定了哪一个索引


471
00:17:23,526 --> 00:17:25,836
映射到了我们着色器参数


472
00:17:27,026 --> 00:17:29,056
所以通过请求编译器的含有三个索引值的


473
00:17:29,106 --> 00:17:30,526
集合片段缓存方法


474
00:17:30,526 --> 00:17:33,046
我们可以将我的标准缓存对象


475
00:17:33,046 --> 00:17:37,446
映射到我们的着色器的


476
00:17:37,446 --> 00:17:38,936
标准编码器参数


477
00:17:39,536 --> 00:17:42,326
我们进行类似的请求去


478
00:17:42,326 --> 00:17:44,836
设置我们的纹理和采样器对象


479
00:17:50,396 --> 00:17:52,096
现在我们来多说一下


480
00:17:52,096 --> 00:17:53,996
着色器开发里


481
00:17:54,106 --> 00:17:55,606
特别有用的一个库


482
00:17:57,236 --> 00:17:58,576
它叫 SIMD


483
00:17:58,896 --> 00:18:00,666
现在 SIMD 实际上是一个


484
00:18:00,966 --> 00:18:02,616
分离于 Metal 的库


485
00:18:03,126 --> 00:18:05,246
经常用于许多正交框架


486
00:18:05,836 --> 00:18:07,366
但是它在思想上


487
00:18:07,366 --> 00:18:07,686
跟 Metal 很相似


488
00:18:08,936 --> 00:18:10,886
SIMD 定义了常用的


489
00:18:10,886 --> 00:18:12,786
向量和矩阵类型


490
00:18:13,286 --> 00:18:15,056
去实现图形化算法


491
00:18:15,056 --> 00:18:16,036
所以它包括了三四个


492
00:18:16,036 --> 00:18:17,846
向量类型和


493
00:18:17,846 --> 00:18:19,976
三乘三和四乘四 矩阵类型


494
00:18:24,046 --> 00:18:24,906
这个库最棒的特性之一是


495
00:18:24,906 --> 00:18:26,676
你能用它


496
00:18:26,676 --> 00:18:30,496
在你的 App 代码


497
00:18:30,496 --> 00:18:33,306
和着色语言代码之间


498
00:18:33,306 --> 00:18:34,966
分享代码


499
00:18:35,596 --> 00:18:37,216
这真的很有用


500
00:18:37,216 --> 00:18:38,856
因为你可以定义数据的布局


501
00:18:38,926 --> 00:18:39,986
这些数据和结构就是通过这些类型


502
00:18:39,986 --> 00:18:42,066
从你的 App 传递


503
00:18:42,066 --> 00:18:43,426
到你的着色器


504
00:18:44,046 --> 00:18:44,766
它怎么工作的呢


505
00:18:45,996 --> 00:18:47,276
你先创建一个带有数据的结构


506
00:18:47,346 --> 00:18:48,216
这些数据是你想要从你的 App


507
00:18:48,216 --> 00:18:49,516
传递到你的着色器的


508
00:18:49,836 --> 00:18:51,396
所以举例来说


509
00:18:51,396 --> 00:18:52,536
如果你想传递一个


510
00:18:52,536 --> 00:18:55,206
模型视图投影矩阵


511
00:18:55,206 --> 00:18:56,646
和这个 SIMD 的首要光源位置


512
00:18:56,646 --> 00:18:58,696
你就可以在你的结构中


513
00:18:58,696 --> 00:19:01,546
通过 SIMD 类型去实现


514
00:19:01,976 --> 00:19:02,746
你将结构的定义


515
00:19:02,746 --> 00:19:05,106
和头文件都包含在


516
00:19:05,106 --> 00:19:08,796
你的 App 代码和 Metal 文件里


517
00:19:09,116 --> 00:19:10,756
这样的话你着色器里用的


518
00:19:10,756 --> 00:19:12,566
数据布局就能与你的代码


519
00:19:12,566 --> 00:19:14,036
匹配上 因为它们


520
00:19:14,036 --> 00:19:15,286
使用了相同的类型


521
00:19:16,686 --> 00:19:18,296
这样布局不匹配的问题就会


522
00:19:18,296 --> 00:19:19,976
出现的更少


523
00:19:24,046 --> 00:19:25,556
Metal 实现高效的


524
00:19:25,556 --> 00:19:27,716
一个关键因素是


525
00:19:27,716 --> 00:19:30,456
更早地开始工作并且频率更低


526
00:19:31,376 --> 00:19:33,426
所以你将需要在建立 App 的时候


527
00:19:33,426 --> 00:19:34,896
用 Xcode 去编译


528
00:19:34,896 --> 00:19:35,856
Metal 着色器


529
00:19:36,986 --> 00:19:38,206
这运行了一个前端编译


530
00:19:38,206 --> 00:19:39,866
来执行字符串解析


531
00:19:39,866 --> 00:19:41,826
着色器分析和


532
00:19:41,826 --> 00:19:43,226
一些基本的优化


533
00:19:43,986 --> 00:19:45,526
它将你的代码转换成


534
00:19:45,526 --> 00:19:46,796
一个二进制的中间表示


535
00:19:46,796 --> 00:19:49,456
它在任何硬件上都能使用


536
00:19:50,456 --> 00:19:52,566
实际的 GPU 机器代码


537
00:19:52,566 --> 00:19:54,156
直到你的代码在用户系统上运行以前


538
00:19:54,156 --> 00:19:54,976
都不会被构建的


539
00:19:55,516 --> 00:19:56,726
但是这在你的代码运行的时候


540
00:19:56,726 --> 00:19:58,976
移除了一半的编译时间


541
00:19:59,996 --> 00:20:02,886
这个搭建的


542
00:20:02,886 --> 00:20:05,286
二进制中间表示


543
00:20:05,376 --> 00:20:07,926
是通过 Metal 库文件实现的


544
00:20:08,576 --> 00:20:10,376
Xcode 会将所有 Metal


545
00:20:10,376 --> 00:20:11,656
着色器源文件编译进


546
00:20:11,776 --> 00:20:13,856
一个默认的 Metal 库


547
00:20:13,856 --> 00:20:16,256
为了运行时检索


548
00:20:16,256 --> 00:20:17,276
将他放进你的 App 包中


549
00:20:17,936 --> 00:20:20,686
除了有 Xcode 建立的着色器


550
00:20:20,686 --> 00:20:23,286
你也可以在 App


551
00:20:23,286 --> 00:20:24,726
运行过程中创建着色器


552
00:20:26,126 --> 00:20:27,436
一些 OpenGL App 在运行过程中


553
00:20:27,436 --> 00:20:28,446
创建着色器是通过


554
00:20:28,546 --> 00:20:30,096
连接字符串或者运行


555
00:20:30,096 --> 00:20:31,616
源代码生成器实现的


556
00:20:32,646 --> 00:20:33,846
要在构建期间


557
00:20:33,846 --> 00:20:35,826
获取所有着色器会非常有挑战性


558
00:20:36,846 --> 00:20:38,756
但是为了特定的目的或者


559
00:20:38,856 --> 00:20:40,476
如果构建时间编译


560
00:20:40,476 --> 00:20:41,486
在你的 App 里并不可能实现


561
00:20:41,876 --> 00:20:43,486
那么 Metal 是可以像 OpenGL 一样


562
00:20:43,486 --> 00:20:45,326
在运行期间通过源文件


563
00:20:45,326 --> 00:20:45,836
编译着色器的


564
00:20:46,386 --> 00:20:49,346
然而 这样做


565
00:20:49,346 --> 00:20:50,896
会有很多不好的地方


566
00:20:50,896 --> 00:20:52,416
最明显的是你会放弃


567
00:20:52,416 --> 00:20:53,636
节约性能


568
00:20:53,636 --> 00:20:54,986
因为这在用户系统之外工作


569
00:20:56,216 --> 00:20:57,206
你不会在构建期间


570
00:20:57,206 --> 00:20:58,546
看见任何的着色器编译错误


571
00:20:58,546 --> 00:21:00,776
所以你只能在你运行代码的时候才发现


572
00:21:01,896 --> 00:21:03,436
最后 如果你是在运行时编译


573
00:21:03,436 --> 00:21:04,766
你就不能在着色器中包含


574
00:21:04,766 --> 00:21:06,246
头文件 所以你就不能


575
00:21:06,246 --> 00:21:07,526
在你的 App 代码


576
00:21:07,526 --> 00:21:09,686
和着色器代码之间分享代码


577
00:21:10,236 --> 00:21:12,776
如果你在运行期间通过


578
00:21:12,776 --> 00:21:14,546
分享编译来使你的 App 工作


579
00:21:14,546 --> 00:21:16,066
那我强烈地建议你


580
00:21:16,066 --> 00:21:18,146
花点时间让你的


581
00:21:18,146 --> 00:21:19,966
着色器在 Xcode 里边编译


582
00:21:20,586 --> 00:21:21,676
这样做你可以获得很多好处


583
00:21:21,676 --> 00:21:23,056
比如说节约运行时间


584
00:21:23,056 --> 00:21:24,246
和更为方便


585
00:21:24,246 --> 00:21:26,046
你的着色器开发


586
00:21:26,526 --> 00:21:29,426
我们来看看


587
00:21:29,426 --> 00:21:30,646
你的 App 


588
00:21:30,646 --> 00:21:31,946
初始化你的 Metal 渲染器 的步骤


589
00:21:32,186 --> 00:21:33,376
这要创建


590
00:21:33,376 --> 00:21:34,246
很多对象


591
00:21:34,746 --> 00:21:36,286
我将从设备入手


592
00:21:36,286 --> 00:21:37,666
然后是命令队列


593
00:21:37,666 --> 00:21:39,826
之后我会描述怎样


594
00:21:39,826 --> 00:21:40,966
建立对象 


595
00:21:40,966 --> 00:21:43,426
包括纹理 缓存器和管道对象


596
00:21:45,046 --> 00:21:47,566
所以设备和队列


597
00:21:47,726 --> 00:21:50,016
是你要创建的第一个对象


598
00:21:50,636 --> 00:21:53,506
设备是 GPU 的一个


599
00:21:53,506 --> 00:21:54,866
抽象表现


600
00:21:56,226 --> 00:21:57,346
它负责创建


601
00:21:57,346 --> 00:21:58,436
用于渲染的对象


602
00:21:58,436 --> 00:21:59,416
它们包括


603
00:21:59,456 --> 00:22:01,386
纹理 缓存和管道对象


604
00:22:02,846 --> 00:22:04,506
在 iOS 还只有一个


605
00:22:04,506 --> 00:22:06,826
GPU 的时候


606
00:22:06,826 --> 00:22:08,626
你只能有一个设备


607
00:22:08,916 --> 00:22:10,356
但是在 macOS 系统上可以有


608
00:22:10,356 --> 00:22:12,216
多个设备因为它们可能


609
00:22:12,216 --> 00:22:14,126
都集成在了分散的 GPU


610
00:22:14,126 --> 00:22:16,026
或多个 eGPU 上


611
00:22:17,236 --> 00:22:18,286
虽然通常情况下


612
00:22:18,286 --> 00:22:20,146
用默认的设备对于大多数 App


613
00:22:20,146 --> 00:22:21,126
都足够了


614
00:22:21,886 --> 00:22:23,776
而且获取这个设备


615
00:22:23,826 --> 00:22:25,216
是很简单的


616
00:22:25,276 --> 00:22:26,876
你调用 MTLCreateSystem


617
00:22:26,876 --> 00:22:27,616
DefaultDevice 即可


618
00:22:28,296 --> 00:22:31,136
对于这个设备


619
00:22:31,136 --> 00:22:33,396
你要做的第一件事就是


620
00:22:33,396 --> 00:22:33,966
创建一个命令队列


621
00:22:35,746 --> 00:22:37,416
这个队列主要用于你的


622
00:22:37,416 --> 00:22:38,736
App 渲染循环


623
00:22:38,736 --> 00:22:40,036
去在每一帧里获取命令缓存


624
00:22:40,086 --> 00:22:41,536
但是你需要在


625
00:22:41,536 --> 00:22:42,836
初始化的时候创建


626
00:22:42,996 --> 00:22:43,826
命令队列


627
00:22:45,036 --> 00:22:46,176
通常情况下 单个队列就足够了


628
00:22:46,176 --> 00:22:48,006
但是更复杂的 App 


629
00:22:48,276 --> 00:22:49,926
会在多个队列中


630
00:22:49,926 --> 00:22:51,986
同时被执行


631
00:22:53,206 --> 00:22:54,696
创建一个队列也是非常简单的


632
00:22:54,696 --> 00:22:56,666
你可以调用 newCommandQueue


633
00:22:56,906 --> 00:22:58,336
和刚才你创建好的设备


634
00:22:58,956 --> 00:22:59,996
一旦你获取了你的队列


635
00:23:00,276 --> 00:23:02,306
你就可以得到渲染循环的命令缓存


636
00:23:02,806 --> 00:23:06,846
我们继续来看一看创建


637
00:23:06,846 --> 00:23:07,546
渲染对象


638
00:23:08,216 --> 00:23:10,546
我将会说一说创建


639
00:23:10,736 --> 00:23:12,106
三种类型的对象


640
00:23:12,106 --> 00:23:14,426
它们用于渲染 纹理 缓存和管道


641
00:23:15,496 --> 00:23:17,846
我们先从纹理开始


642
00:23:18,106 --> 00:23:19,466
就像之前所提到的


643
00:23:19,466 --> 00:23:21,066
你通过设备对象 创建渲染对象


644
00:23:22,416 --> 00:23:23,756
你大部分情况下 将会用到描述符对象


645
00:23:23,756 --> 00:23:24,836
去创造这些对象


646
00:23:25,546 --> 00:23:26,916
描述符是非常简单的对象


647
00:23:26,916 --> 00:23:28,756
它没有任何真方法


648
00:23:29,296 --> 00:23:31,856
它们只包含用于对象建立的属性


649
00:23:33,146 --> 00:23:34,526
举个例子


650
00:23:34,526 --> 00:23:36,326
你会需要一个纹理描述符去创建纹理


651
00:23:37,076 --> 00:23:38,306
你可以指定


652
00:23:38,306 --> 00:23:39,666
你想要创建的纹理的属性


653
00:23:40,186 --> 00:23:41,406
比如说纹理的类型


654
00:23:41,436 --> 00:23:43,396
2D 3D 和 cubeMap


655
00:23:44,146 --> 00:23:45,296
纹理的维度和


656
00:23:45,296 --> 00:23:47,286
它所需要的 Mipmap 的数量


657
00:23:47,286 --> 00:23:49,746
还有纹理中包含的


658
00:23:50,676 --> 00:23:51,576
数据像素格式


659
00:23:51,706 --> 00:23:53,416
一旦你设定好


660
00:23:53,416 --> 00:23:54,346
每一个属性需要的值


661
00:23:54,346 --> 00:23:56,076
你就可以在设备上调用方法


662
00:23:56,076 --> 00:23:58,856
去创建可用的纹理对象


663
00:24:00,816 --> 00:24:03,156
这也需要为返回纹理图像


664
00:24:03,266 --> 00:24:04,726
分配内存


665
00:24:06,086 --> 00:24:07,946
一旦你创建了对象 你就不再需要


666
00:24:07,946 --> 00:24:09,286
描述符了 因为它只是用来


667
00:24:09,286 --> 00:24:10,126
创建对象的


668
00:24:11,256 --> 00:24:12,296
然后你设置在描述符中的属性


669
00:24:12,296 --> 00:24:14,396
就会被锁定并且不能再改变


670
00:24:15,766 --> 00:24:17,056
然后 纹理图像的内容


671
00:24:17,056 --> 00:24:18,726
是可以修改的


672
00:24:18,756 --> 00:24:21,816
所以我会再说一下一个


673
00:24:21,816 --> 00:24:22,816
你将设定在纹理描述符中的属性


674
00:24:22,816 --> 00:24:24,096
同时你也能


675
00:24:24,096 --> 00:24:25,876
在创建缓存的时候使用


676
00:24:26,626 --> 00:24:28,166
这被称为存储模式


677
00:24:29,286 --> 00:24:30,366
就像之前提到的


678
00:24:30,366 --> 00:24:31,966
在你创建纹理的时候


679
00:24:31,966 --> 00:24:33,596
Metal 会为它分配内存


680
00:24:34,106 --> 00:24:35,276
存储模式属性告诉


681
00:24:35,276 --> 00:24:37,406
Metal 要在哪一个内存池中去分配内存


682
00:24:38,576 --> 00:24:40,056
最简单的方式


683
00:24:40,056 --> 00:24:42,436
去共享存储模式就是同时给


684
00:24:42,876 --> 00:24:44,046
CPU 和 GPU 访问权限


685
00:24:44,656 --> 00:24:46,076
对于缓存来说这就是


686
00:24:46,076 --> 00:24:47,666
你为指向对象的内存


687
00:24:47,666 --> 00:24:48,156
获取了一个指针


688
00:24:48,996 --> 00:24:50,166
Protector 代表着你可以


689
00:24:50,166 --> 00:24:51,926
调用简易的方法


690
00:24:52,196 --> 00:24:54,196
从纹理中去设定和获取数据


691
00:24:54,736 --> 00:24:57,246
你可以用私有存储模式


692
00:24:57,246 --> 00:24:58,836
这种模式只给了 GPU 访问


693
00:24:58,926 --> 00:25:00,486
数据的权限


694
00:25:00,486 --> 00:25:01,356
这就允许了 Metal 


695
00:25:01,356 --> 00:25:03,906
去执行优化


696
00:25:03,906 --> 00:25:05,786
不然可能在 CPU 有访问数据权限的时候


697
00:25:05,786 --> 00:25:06,206
是无法达成的


698
00:25:06,896 --> 00:25:08,776
但是只有 GPU 可以直接


699
00:25:08,886 --> 00:25:11,096
填写这种纹理类型的内容


700
00:25:12,606 --> 00:25:14,016
你也可以间接的通过 CPU 去填写数据


701
00:25:14,206 --> 00:25:15,996
这可以通过使用 blit 编码器让 CPU 实现


702
00:25:15,996 --> 00:25:17,786
blit 通过共享的存储


703
00:25:18,076 --> 00:25:21,026
从第二中间资源去拷贝


704
00:25:22,446 --> 00:25:23,966
在具有专用视频内存的设备上


705
00:25:23,966 --> 00:25:25,656
设定这个资源去使用


706
00:25:25,656 --> 00:25:27,306
私有存储


707
00:25:27,306 --> 00:25:28,396
将它分配成仅用于视频存储


708
00:25:30,396 --> 00:25:32,776
最后 在 macOS 上你可以使用


709
00:25:32,866 --> 00:25:34,756
第三种存储模式 托管存储


710
00:25:35,696 --> 00:25:37,796
这种模式允许 GPU 和 CPU 一起


711
00:25:37,826 --> 00:25:39,066
访问对象数据


712
00:25:39,776 --> 00:25:40,946
而且对于有专用视频内存的系统


713
00:25:40,946 --> 00:25:43,226
Metal 会建立一个镜像内存


714
00:25:43,226 --> 00:25:46,696
反向用于两个处理器的高效访问


715
00:25:47,926 --> 00:25:49,396
正因为这样


716
00:25:49,396 --> 00:25:51,166
显性的调用对于确认


717
00:25:51,236 --> 00:25:53,876
数据在 CPU GPU 上的同步访问是很有必要的


718
00:25:58,126 --> 00:26:00,376
这里是一个创建纹理对象的例子


719
00:26:00,816 --> 00:26:04,256
首先你创建一个纹理描述符


720
00:26:04,256 --> 00:26:06,126
以及内部的一系列属性


721
00:26:06,126 --> 00:26:08,586
包括存储模式


722
00:26:09,106 --> 00:26:12,836
然后我们通过这个设备


723
00:26:13,586 --> 00:26:14,556
去创建一个纹理


724
00:26:15,916 --> 00:26:17,166
为了去填充纹理的图像数据


725
00:26:17,316 --> 00:26:18,936
我们计算每一行的字节数


726
00:26:19,886 --> 00:26:21,336
这就像用 GLText 一样


727
00:26:21,336 --> 00:26:23,466
[ 音质不清晰 ] 我们指定一个区域去加载


728
00:26:26,196 --> 00:26:27,536
然后我们调用纹理对象的


729
00:26:27,536 --> 00:26:29,506
替换区域方法


730
00:26:29,756 --> 00:26:31,596
它从我们提供的指针中


731
00:26:31,596 --> 00:26:32,926
复制数据到纹理中


732
00:26:37,046 --> 00:26:38,266
这里是一些值得注意的


733
00:26:38,266 --> 00:26:39,396
OpenGL 和 Metal 纹理对象


734
00:26:39,396 --> 00:26:40,446
之间的一些区别


735
00:26:40,816 --> 00:26:42,556
虽然 OpenGL 确实有采样器对象


736
00:26:42,556 --> 00:26:43,886
但是他们是可选的


737
00:26:44,406 --> 00:26:45,576
在 OpenGL 中 


738
00:26:45,576 --> 00:26:46,826
包装模式和过滤器可以被设定在


739
00:26:46,826 --> 00:26:47,886
纹理对象中


740
00:26:48,276 --> 00:26:49,736
在 Metal 里你需要在着色器中


741
00:26:49,816 --> 00:26:51,376
去创建单独的采样器对象


742
00:26:51,376 --> 00:26:53,576
或者是指定的


743
00:26:54,206 --> 00:26:55,096
采样器参数


744
00:26:55,786 --> 00:26:57,336
在 Metal 里纹理图像数据


745
00:26:57,416 --> 00:26:57,946
是不可被翻转的


746
00:26:58,496 --> 00:27:00,996
OpenGL 使用的是左下角原点


747
00:27:01,306 --> 00:27:03,196
但是 Metal 用的是左上角原点


748
00:27:03,196 --> 00:27:04,426
所以在你加载纹理的时候


749
00:27:04,426 --> 00:27:06,266
你要留意这些区别


750
00:27:06,686 --> 00:27:09,696
桌面版 OpenGL 同时也执行转化


751
00:27:09,796 --> 00:27:10,866
当提供的数据是


752
00:27:10,916 --> 00:27:13,376
不同的格式而不是


753
00:27:13,376 --> 00:27:15,016
内部格式的时候


754
00:27:16,456 --> 00:27:18,106
但是 Metal 和 OpenGL ES 很类似


755
00:27:18,206 --> 00:27:20,346
所以你需要确认


756
00:27:20,346 --> 00:27:21,406
你的数据都已经被


757
00:27:21,436 --> 00:27:23,436
设定成了合适的格式或者


758
00:27:23,696 --> 00:27:25,696
执行路径去进行转化


759
00:27:29,066 --> 00:27:32,316
我们再来看看缓存器


760
00:27:32,456 --> 00:27:34,266
Metal 对于所有非结构体数据


761
00:27:34,266 --> 00:27:34,976
都是用的缓存器


762
00:27:41,456 --> 00:27:42,406
它们非常类似于 OpenGL 的顶点 


763
00:27:42,406 --> 00:27:45,646
元素和标准缓存


764
00:27:45,926 --> 00:27:47,076
所以如果你已经在 OpenGL 中用了这些缓存器


765
00:27:47,076 --> 00:27:48,456
你在处理你的端口的时候


766
00:27:48,506 --> 00:27:50,126
就会更容易一些


767
00:27:51,506 --> 00:27:52,686
通过设备你能很轻易地创建缓存器


768
00:27:52,686 --> 00:27:54,456
这个设备是你通过 newBufferWithLength


769
00:27:54,516 --> 00:27:55,986
调用的 它指定了你想要


770
00:27:55,986 --> 00:27:57,146
多大的缓存


771
00:27:57,826 --> 00:27:59,626
你也可以指定存储模式


772
00:28:00,986 --> 00:28:01,996
你通过内容属性


773
00:28:02,036 --> 00:28:03,506
去加载缓存器


774
00:28:03,506 --> 00:28:05,026
这个属性是一个没有返回值的指针


775
00:28:05,026 --> 00:28:06,186
指向返回缓存器的内存


776
00:28:07,276 --> 00:28:08,706
对于 Metal 的核


777
00:28:08,706 --> 00:28:10,076
这个数据是完全没有结构的


778
00:28:10,076 --> 00:28:11,896
所以这就取决于你要怎么去定义


779
00:28:12,196 --> 00:28:14,066
你 App 的布局和怎样


780
00:28:14,066 --> 00:28:14,296
去分享你的代码


781
00:28:15,086 --> 00:28:16,746
这里我们分配一个内容指针


782
00:28:16,826 --> 00:28:18,486
指向一个使用了一些 SIMD 类型的结构


783
00:28:18,486 --> 00:28:20,546
这个在之前


784
00:28:20,546 --> 00:28:21,236
我已经提到过了


785
00:28:21,236 --> 00:28:23,796
我们设置一系列结构体


786
00:28:23,796 --> 00:28:25,466
这些结构体填充缓存区的数据


787
00:28:25,466 --> 00:28:26,936
这是通过使用已经通过


788
00:28:26,936 --> 00:28:28,286
结构体的定义 定义过的布局或 App


789
00:28:28,606 --> 00:28:29,816
来实现的


790
00:28:31,306 --> 00:28:32,506
就像之前提到的


791
00:28:32,506 --> 00:28:34,026
你可以在你的 App


792
00:28:34,276 --> 00:28:35,406
之间分享你的代码


793
00:28:35,406 --> 00:28:36,736
这就确定了你的布局


794
00:28:36,736 --> 00:28:38,886
在这两个部件之间可以匹配


795
00:28:39,466 --> 00:28:44,846
一个很常见的错误是


796
00:28:44,886 --> 00:28:46,456
缓存数据和它


797
00:28:46,456 --> 00:28:48,226
如何在着色器中被翻译不匹配


798
00:28:48,356 --> 00:28:49,556
这是因为一个关于


799
00:28:49,556 --> 00:28:51,196
校准的假设


800
00:28:52,136 --> 00:28:53,476
举个例子


801
00:28:53,476 --> 00:28:54,496
你可能会假设着色器的语言是


802
00:28:54,826 --> 00:28:57,256
flout3 的类型


803
00:28:57,296 --> 00:28:57,576
它只消耗 12 个字节的内存


804
00:28:58,266 --> 00:29:00,506
三个 4 字节的部件就是


805
00:29:00,506 --> 00:29:01,096
12 个字节对吧


806
00:29:01,936 --> 00:29:03,436
那么如果你将你的数据这样打包


807
00:29:03,436 --> 00:29:04,716
你就会有麻烦的


808
00:29:05,356 --> 00:29:06,586
因为你的着色器语言


809
00:29:06,666 --> 00:29:08,296
实际上将 float3 类型解释为 


810
00:29:08,296 --> 00:29:09,586
会消耗 16 个字节


811
00:29:10,336 --> 00:29:11,236
这是因为类型被更严格


812
00:29:11,236 --> 00:29:12,936
地定义了对准方式


813
00:29:12,936 --> 00:29:16,366
这是为了 CPU 和 GPU 的优化以及


814
00:29:16,366 --> 00:29:16,816
CPU 和 GPU 的用量


815
00:29:18,026 --> 00:29:19,626
类似的错误还经常发生在


816
00:29:19,996 --> 00:29:21,176
三乘三的矩阵中


817
00:29:22,316 --> 00:29:23,936
如果你真的想追踪它


818
00:29:23,936 --> 00:29:26,046
如果你真的想紧密地包装数据


819
00:29:26,186 --> 00:29:28,996
我们在 Metal 着色器语言中


820
00:29:28,996 --> 00:29:30,776
提供了包装类型


821
00:29:31,246 --> 00:29:33,126
在你将打包好的数据传进缓存以后


822
00:29:33,126 --> 00:29:34,596
你的着色器代码将会


823
00:29:34,596 --> 00:29:37,356
去包装数据


824
00:29:37,356 --> 00:29:38,846
在你处理这些数据以前


825
00:29:38,846 --> 00:29:40,686
你需要将这些包装好的数据传递给


826
00:29:40,686 --> 00:29:42,236
一个规则向量


827
00:29:43,716 --> 00:29:45,436
所以在你发布你的 App 时


828
00:29:45,436 --> 00:29:48,446
我建议你使用


829
00:29:48,756 --> 00:29:50,376
最方便的存储模式


830
00:29:51,396 --> 00:29:53,436
这使得你在那些资源中


831
00:29:53,466 --> 00:29:55,976
访问数据变得更简单


832
00:29:57,006 --> 00:29:58,676
所以在 iOS 系统中


833
00:29:58,676 --> 00:29:59,696
我们通过 StorageModeShared 创建所有的


834
00:30:00,086 --> 00:30:00,976
纹理和缓存


835
00:30:02,386 --> 00:30:03,726
在 macOS 系统上 你就不能用


836
00:30:03,726 --> 00:30:05,076
StorageModeShared 处理纹理


837
00:30:05,246 --> 00:30:07,146
但是 StorageModeManaged 会让你访问


838
00:30:07,146 --> 00:30:08,526
图像数据变得更容易一些


839
00:30:08,856 --> 00:30:10,846
虽然私有存储是最优选择


840
00:30:16,046 --> 00:30:16,996
你可以在 macOS 上使用


841
00:30:16,996 --> 00:30:19,216
StorageModeShared 和缓存


842
00:30:19,216 --> 00:30:19,906
但你需要特别的小心


843
00:30:20,526 --> 00:30:22,456
如果你混合了 CPU 和 GPU 


844
00:30:22,576 --> 00:30:26,066
都需要访问的数据和只有


845
00:30:26,066 --> 00:30:28,336
GPU 需要访问的数据


846
00:30:28,376 --> 00:30:29,456
你可能在之后会很难去


847
00:30:29,456 --> 00:30:31,246
分开这两种类型的数据


848
00:30:31,246 --> 00:30:33,046
再把它们放到


849
00:30:33,046 --> 00:30:34,286
单独的内存池中


850
00:30:34,906 --> 00:30:37,816
现在我已经说了一些


851
00:30:37,816 --> 00:30:39,166
关于创建纹理和


852
00:30:39,166 --> 00:30:41,186
缓存对象的内容


853
00:30:41,186 --> 00:30:42,106
我会再提一下 MetalKit 框架


854
00:30:42,156 --> 00:30:43,526
它是用来更简单地去


855
00:30:43,526 --> 00:30:44,676
通过常用文件格式去


856
00:30:44,676 --> 00:30:46,606
创建纹理和顶点的框架


857
00:30:47,146 --> 00:30:48,336
这里面包含了纹理加载类


858
00:30:48,626 --> 00:30:50,286
和一些功能去创建


859
00:30:50,286 --> 00:30:52,216
Metal 缓存支持的网格


860
00:30:52,376 --> 00:30:53,936
这些网格是通过 Model I/O 加载的


861
00:30:58,046 --> 00:30:59,106
现在我们来说一说


862
00:30:59,106 --> 00:31:00,506
包含它们的着色器和


863
00:31:00,506 --> 00:31:02,036
渲染管道对象


864
00:31:02,776 --> 00:31:04,046
你可以通过渲染


865
00:31:04,046 --> 00:31:05,766
管道描述符对象创建


866
00:31:05,766 --> 00:31:07,096
管道状态对象


867
00:31:08,466 --> 00:31:10,116
这个对象包含了顶点和


868
00:31:10,116 --> 00:31:11,066
分片着色器对它


869
00:31:12,446 --> 00:31:13,886
也指定了提供


870
00:31:13,886 --> 00:31:16,416
顶点着色器的顶点布局


871
00:31:17,066 --> 00:31:19,506
你也能混合状态和


872
00:31:19,586 --> 00:31:21,586
渲染目标的像素格式


873
00:31:21,866 --> 00:31:23,706
这里的渲染目标是分片和着色器


874
00:31:23,706 --> 00:31:24,136
可以渲染到的


875
00:31:25,666 --> 00:31:27,206
就像用纹理对象一样


876
00:31:27,206 --> 00:31:28,556
你在设备上调用方法


877
00:31:28,556 --> 00:31:30,136
这会产生一个不可改变的


878
00:31:30,136 --> 00:31:32,406
渲染状态管道对象


879
00:31:33,706 --> 00:31:34,926
也就像纹理对象一样


880
00:31:35,056 --> 00:31:36,306
你只需要使用描述符


881
00:31:36,306 --> 00:31:37,546
去创建这些对象


882
00:31:38,156 --> 00:31:40,456
这里是一些代码


883
00:31:40,456 --> 00:31:41,726
展现了怎样去搭建这些


884
00:31:41,726 --> 00:31:42,226
管道状态对象


885
00:31:43,536 --> 00:31:44,916
在你创建管道以前


886
00:31:45,096 --> 00:31:47,456
你需要从 Metal 库中


887
00:31:47,456 --> 00:31:48,686
获取着色器


888
00:31:49,256 --> 00:31:51,446
这一行代码加载了我们在 Xcode 里


889
00:31:51,446 --> 00:31:54,586
搭建的默认的 Metal 库文件 


890
00:31:54,726 --> 00:31:56,616
对于这个库你可以


891
00:31:56,616 --> 00:31:58,316
通过他们的函数名


892
00:31:59,116 --> 00:32:00,726
获取你的顶点和分片着色器


893
00:32:01,906 --> 00:32:03,146
你创建一个渲染管道


894
00:32:03,146 --> 00:32:05,316
描述符对象在


895
00:32:05,316 --> 00:32:06,866
你设定这些着色函数的地方


896
00:32:06,866 --> 00:32:09,356
同时还有指定渲染目标像素格式


897
00:32:10,306 --> 00:32:12,336
最后你用设备和


898
00:32:12,336 --> 00:32:13,726
我们已经设定好的描述符对象


899
00:32:13,726 --> 00:32:17,026
来生成管道状态对象


900
00:32:18,136 --> 00:32:19,836
OpenGL 和 Metal 


901
00:32:19,866 --> 00:32:21,906
图形化管道之间


902
00:32:21,936 --> 00:32:25,316
最大的区别就是


903
00:32:25,316 --> 00:32:26,856
OpenGL 编写的对象


904
00:32:26,896 --> 00:32:28,196
只包含顶点和


905
00:32:28,226 --> 00:32:29,906
分片着色对


906
00:32:29,946 --> 00:32:31,816
但是 Metal 管道对象还包括了


907
00:32:31,816 --> 00:32:33,536
顶点布局 混合状态和


908
00:32:33,536 --> 00:32:34,726
渲染目标像素格式


909
00:32:35,566 --> 00:32:36,776
所以你需要在你搭建管道之前


910
00:32:36,816 --> 00:32:39,896
知道所有这些东西


911
00:32:40,016 --> 00:32:41,576
这些管道状态中的


912
00:32:41,646 --> 00:32:43,166
额外部分


913
00:32:43,166 --> 00:32:44,886
使得 Metal 可以在对象建立中完


914
00:32:44,886 --> 00:32:46,746
全将着色器编译进


915
00:32:46,816 --> 00:32:47,576
GPU 机器语言


916
00:32:48,116 --> 00:32:49,006
这是在 OpenGL 编程对象中


917
00:32:49,006 --> 00:32:50,836
根本不可能实现的


918
00:32:51,706 --> 00:32:52,796
现在你就需要去建立一个系统


919
00:32:52,796 --> 00:32:54,146
这个系统允许你在


920
00:32:54,146 --> 00:32:56,086
初始化你的 app 的时候去创建管道


921
00:32:57,266 --> 00:32:58,236
它可以很有用


922
00:32:58,236 --> 00:32:59,816
如果你选择一个规范的顶点布局


923
00:32:59,816 --> 00:33:01,546
和有限的渲染目标集合


924
00:33:02,156 --> 00:33:03,766
这就减少了你 App 


925
00:33:03,766 --> 00:33:05,486
的状态组合


926
00:33:05,486 --> 00:33:07,706
和需要的管道对象的数量


927
00:33:08,976 --> 00:33:10,786
然而不是所有人都知道


928
00:33:10,846 --> 00:33:12,656
他们的 App 会需要哪些管道


929
00:33:13,286 --> 00:33:14,666
一般情况下移植


930
00:33:14,666 --> 00:33:16,306
App 到 Metal 的第一步


931
00:33:16,306 --> 00:33:17,786
是持有一个管道词典


932
00:33:17,786 --> 00:33:18,396
这个词典是之前就已经建立好了的


933
00:33:19,326 --> 00:33:20,566
介于你的 App 会遇到


934
00:33:20,566 --> 00:33:22,196
新的状态组合


935
00:33:22,196 --> 00:33:23,836
它可以将描述符看作是钥匙


936
00:33:23,836 --> 00:33:25,326
去建立和存储管道


937
00:33:26,626 --> 00:33:28,206
一定要记得我刚才说到的这个方法


938
00:33:28,206 --> 00:33:30,326
是一种破解方法


939
00:33:30,326 --> 00:33:31,406
同时你也会想要你的 App 避免


940
00:33:31,406 --> 00:33:31,856
通过这种方法被传输


941
00:33:32,426 --> 00:33:33,856
这是因为创建这些对象中的


942
00:33:33,856 --> 00:33:35,316
任何一个都是很昂贵的


943
00:33:36,346 --> 00:33:37,196
当你想要创建管道对象的时候


944
00:33:37,196 --> 00:33:39,336
GPU 编译器会起到作用


945
00:33:39,336 --> 00:33:41,396
并且翻译和优化


946
00:33:41,396 --> 00:33:42,786
着色器的二进制中间


947
00:33:42,786 --> 00:33:44,636
表示到机器代码


948
00:33:45,386 --> 00:33:46,356
如果你的 App 在你的渲染器循环中


949
00:33:46,386 --> 00:33:47,986
及时地创建了这些


950
00:33:47,986 --> 00:33:51,046
你就很有可能会看到


951
00:33:51,356 --> 00:33:53,046
短时间内


952
00:33:53,046 --> 00:33:55,786
减少帧率


953
00:33:55,986 --> 00:33:57,366
给纹理和缓存


954
00:33:57,366 --> 00:33:58,906
分配内存也是很昂贵的操作


955
00:33:58,906 --> 00:34:00,526
这甚至不是


956
00:34:00,526 --> 00:34:01,586
要考虑将数据


957
00:34:01,586 --> 00:34:03,726
填充到这些资源中的操作


958
00:34:04,946 --> 00:34:06,076
然而一旦你创建了这些对象


959
00:34:06,076 --> 00:34:07,866
在你在渲染循环中使用它们的时候


960
00:34:07,866 --> 00:34:09,646
就只需要非常小的 CPU 了


961
00:34:09,746 --> 00:34:11,045
[ 音质不清晰 ] 因为这在之前的操作中


962
00:34:11,045 --> 00:34:12,966
已经做得够多了


963
00:34:14,176 --> 00:34:15,485
现在我们交给 Sukanya 去解释


964
00:34:15,485 --> 00:34:16,716
他会告诉你们


965
00:34:16,716 --> 00:34:17,735
如何移植你的渲染循环


966
00:34:18,516 --> 00:34:22,545
[ 掌声 ]


967
00:34:23,045 --> 00:34:24,065
>> 晚上好各位


968
00:34:24,065 --> 00:34:25,886
我是 Sukanya Sudugu


969
00:34:25,886 --> 00:34:26,856
是 Apple 的 GPU 软件工程师


970
00:34:27,646 --> 00:34:29,696
我真的超级兴奋去跟你们分享一些


971
00:34:29,696 --> 00:34:31,496
我们在移植上的经验


972
00:34:31,496 --> 00:34:32,976
所以我们来继续看看移植问题


973
00:34:35,876 --> 00:34:37,096
Dan 已经说了很多关于


974
00:34:37,096 --> 00:34:39,496
App 的建立 所以目前为止


975
00:34:39,496 --> 00:34:40,795
你已经建立了所有的


976
00:34:40,795 --> 00:34:43,596
着色器同时也创建了所有的


977
00:34:43,596 --> 00:34:45,216
帧分片所需要的


978
00:34:45,216 --> 00:34:46,275
持久对象


979
00:34:47,196 --> 00:34:48,656
那么现在我们来深入了解一下


980
00:34:48,656 --> 00:34:50,795
你的 App 的渲染循环


981
00:34:50,795 --> 00:34:52,926
它是在每一帧里都会执行的代码


982
00:34:53,186 --> 00:34:55,996
通过 Metal 你会


983
00:34:55,996 --> 00:34:57,616
在你的渲染循环里明确地


984
00:34:57,616 --> 00:35:00,196
管理 GPU 执行的异步性


985
00:35:00,876 --> 00:35:03,156
所以这包括了


986
00:35:03,206 --> 00:35:04,826
和 GPU 命令一起获取


987
00:35:04,826 --> 00:35:06,736
和提交命令缓存到 GPU


988
00:35:06,736 --> 00:35:10,046
同时以这样的方式 更新你的资源


989
00:35:10,046 --> 00:35:12,206
使得你的 GPU


990
00:35:12,206 --> 00:35:13,926
可以异步地从它里边读取信息


991
00:35:14,566 --> 00:35:16,086
这些资源是你之前 就已经写好在你的


992
00:35:16,176 --> 00:35:16,726
渲染循环里的


993
00:35:17,266 --> 00:35:19,526
然后通过创建渲染命令编码器


994
00:35:19,526 --> 00:35:21,326
来编码渲染通行证


995
00:35:21,936 --> 00:35:24,636
最后将你的帧


996
00:35:24,636 --> 00:35:25,776
展现出来


997
00:35:25,776 --> 00:35:29,196
所以我们先来说一说


998
00:35:29,196 --> 00:35:30,356
命令缓存对象


999
00:35:32,396 --> 00:35:34,066
与 OpenGL 最大的不同点之一就是


1000
00:35:34,066 --> 00:35:36,536
Metal 通过命令缓存


1001
00:35:36,606 --> 00:35:38,196
提供了准确的控制


1002
00:35:38,196 --> 00:35:40,366
这表示着创建这些命令缓存


1003
00:35:40,366 --> 00:35:42,396
完全是取决于你


1004
00:35:42,396 --> 00:35:44,106
同时你也能决定什么时候


1005
00:35:44,106 --> 00:35:46,486
去将这些执行提交给 GPU


1006
00:35:47,306 --> 00:35:49,496
一种直接的实现方法就是


1007
00:35:49,496 --> 00:35:51,056
创建一个命令缓存


1008
00:35:51,056 --> 00:35:53,236
它可以渲染你的整个帧


1009
00:35:53,946 --> 00:35:55,796
然后一旦你的 App 准备好了


1010
00:35:55,796 --> 00:35:57,916
并且可以跑了并且如果


1011
00:35:57,916 --> 00:35:59,816
你在 GPU 上看到一些空余时间


1012
00:35:59,816 --> 00:36:01,976
这样的话你就可以去考虑


1013
00:36:02,146 --> 00:36:03,396
将你的帧分开到


1014
00:36:03,396 --> 00:36:04,606
多个命令缓存内


1015
00:36:05,006 --> 00:36:08,086
然后 GPU 就可以在


1016
00:36:08,086 --> 00:36:09,796
CPU 编译其他命令缓存的时候开始


1017
00:36:10,086 --> 00:36:11,886
执行一个命令缓存


1018
00:36:13,346 --> 00:36:15,106
或者将你的帧


1019
00:36:15,106 --> 00:36:17,386
分割编译进多个线程


1020
00:36:17,386 --> 00:36:19,136
这就需要你去


1021
00:36:19,136 --> 00:36:20,436
在每一帧里都创建一个命令缓存


1022
00:36:20,436 --> 00:36:23,196
但是一定要记住


1023
00:36:23,196 --> 00:36:25,056
每一个命令缓存都会需要


1024
00:36:25,056 --> 00:36:27,056
额外的 CPU 消耗


1025
00:36:27,496 --> 00:36:30,066
所以你最好尽可能的少用


1026
00:36:32,216 --> 00:36:34,306
Metal 也提供 API 来


1027
00:36:34,356 --> 00:36:36,436
注册一个完整的回调


1028
00:36:37,136 --> 00:36:38,846
它会在 GPU 完成执行


1029
00:36:38,846 --> 00:36:41,386
这些命令缓存的时候被涉及到


1030
00:36:41,986 --> 00:36:43,686
让我来给你们展现一下


1031
00:36:43,686 --> 00:36:44,766
这些 API


1032
00:36:45,216 --> 00:36:48,316
你将会在你的


1033
00:36:48,316 --> 00:36:49,516
App 初始化方法里


1034
00:36:49,516 --> 00:36:50,856
创建命令队列


1035
00:36:51,356 --> 00:36:53,246
现在 在渲染循环里你将会用到它


1036
00:36:53,246 --> 00:36:55,676
去获取命令缓存


1037
00:36:55,676 --> 00:36:57,386
这是通过调用它的命令缓存方法来实现的


1038
00:36:57,946 --> 00:37:00,156
现在你要把这些命令编译进


1039
00:37:00,156 --> 00:37:01,156
这个命令缓存里


1040
00:37:01,156 --> 00:37:03,086
我将会简短地说一下


1041
00:37:03,146 --> 00:37:04,616
这个编码器


1042
00:37:05,936 --> 00:37:06,936
当你完成编码以后


1043
00:37:06,936 --> 00:37:08,846
你需要调用提交方法


1044
00:37:08,846 --> 00:37:11,446
来让这个命令缓存


1045
00:37:11,446 --> 00:37:14,366
被提交到 GPU 里执行


1046
00:37:14,366 --> 00:37:17,846
现在你有两个选择


1047
00:37:17,916 --> 00:37:19,686
去决定在这个命令缓存在 GPU 上被执行的时候


1048
00:37:19,686 --> 00:37:21,806
应该去做点什么


1049
00:37:22,316 --> 00:37:25,526
你可以通过调用这个


1050
00:37:25,526 --> 00:37:27,436
waitUntilCompleted 方法来等待


1051
00:37:27,436 --> 00:37:29,256
这就像 OpenGL 里边的


1052
00:37:29,256 --> 00:37:29,956
glFinish


1053
00:37:30,896 --> 00:37:33,026
这个方法会同步等待


1054
00:37:33,026 --> 00:37:35,456
并且只在所有命令缓存里的


1055
00:37:35,456 --> 00:37:38,806
命令被 GPU 执行完以后才会返回


1056
00:37:40,916 --> 00:37:44,816
或者在你提交这个


1057
00:37:44,816 --> 00:37:46,206
命令缓存给 GPU 以前


1058
00:37:46,206 --> 00:37:48,566
你可以添加一个完成处理器


1059
00:37:49,406 --> 00:37:51,286
这个处理器会在 GPU 


1060
00:37:51,286 --> 00:37:53,296
完成执行以后被调用


1061
00:37:53,946 --> 00:37:56,476
这就允许 CPU 和 GPU 去


1062
00:37:56,476 --> 00:37:57,576
并行执行


1063
00:37:58,456 --> 00:38:00,486
同时这样就允许我们去追踪


1064
00:38:00,486 --> 00:38:02,116
和有效地更新


1065
00:38:02,116 --> 00:38:04,236
在每一帧里都被改变的


1066
00:38:04,236 --> 00:38:05,076
分享的资源


1067
00:38:05,556 --> 00:38:08,676
既然我们到了这里 我们再来说一说


1068
00:38:08,676 --> 00:38:09,876
这些资源的更新


1069
00:38:09,876 --> 00:38:12,486
和看一看我们如何


1070
00:38:12,486 --> 00:38:14,656
通过完成处理器来让它们更高效


1071
00:38:14,656 --> 00:38:18,626
几乎所有的 App 都会在


1072
00:38:18,626 --> 00:38:21,436
每一帧将新的数据推送给 GPU


1073
00:38:21,926 --> 00:38:24,206
举个例子比如说动画里需要的


1074
00:38:24,316 --> 00:38:25,716
新的渲染单元


1075
00:38:26,256 --> 00:38:29,146
在 Metal 里 CPU 可以在任意时候


1076
00:38:29,146 --> 00:38:31,776
写入这些共享资源


1077
00:38:31,886 --> 00:38:33,966
即使 GPU 是在同一时刻访问


1078
00:38:35,206 --> 00:38:36,276
同一内存


1079
00:38:37,376 --> 00:38:38,876
Metal 并不能保护你不被这些


1080
00:38:38,876 --> 00:38:40,456
数据竞争影响


1081
00:38:41,256 --> 00:38:44,176
相比之下


1082
00:38:44,176 --> 00:38:45,666
OpenGL 默认地会避免这些


1083
00:38:45,666 --> 00:38:48,056
数据竞争


1084
00:38:48,056 --> 00:38:50,676
要么是等待 GPU 完成工作


1085
00:38:50,676 --> 00:38:53,166
要么是制作额外的副本


1086
00:38:53,166 --> 00:38:54,586
这样对你的 App 而言 可能并不是


1087
00:38:54,586 --> 00:38:55,376
最优选择


1088
00:38:56,256 --> 00:38:58,756
通过 Metal 你可以实现任何


1089
00:38:58,756 --> 00:39:01,546
最适合你 App 的


1090
00:39:01,546 --> 00:39:03,376
优化同步策略


1091
00:39:04,256 --> 00:39:06,966
所以在很多情况下


1092
00:39:07,026 --> 00:39:08,686
最好的方法是 你分享资源使用的多个缓存


1093
00:39:08,686 --> 00:39:11,706
这样的话 CPU 和 GPU


1094
00:39:11,706 --> 00:39:13,286
就永远不会同时试图


1095
00:39:13,286 --> 00:39:15,136
访问同一个缓存


1096
00:39:17,436 --> 00:39:19,916
让我们来看一个例子


1097
00:39:19,916 --> 00:39:22,126
你有一个 OpenGL App


1098
00:39:22,126 --> 00:39:24,676
并且你刚刚把它移植到 Metal


1099
00:39:24,736 --> 00:39:26,296
这个 App 使用的是单个缓存去


1100
00:39:26,296 --> 00:39:28,956
更新这些数据并且


1101
00:39:28,956 --> 00:39:30,386
你还没有在 App 里


1102
00:39:30,386 --> 00:39:32,766
实现任何同步方法


1103
00:39:32,766 --> 00:39:36,356
那么 可能发生的事情是


1104
00:39:36,906 --> 00:39:38,316
你的 App 会在


1105
00:39:38,316 --> 00:39:39,956
生成第一个帧的命令的时候


1106
00:39:39,956 --> 00:39:41,866
写进那个缓存里


1107
00:39:41,866 --> 00:39:45,426
然后将这个命令缓存提交给 GPU


1108
00:39:45,426 --> 00:39:47,406
然后当你的 GPU 在


1109
00:39:47,406 --> 00:39:48,876
执行这个命令缓存的时候


1110
00:39:48,876 --> 00:39:49,896
会尝试从缓存里读取信息


1111
00:39:50,436 --> 00:39:53,796
并且当你在为下一帧


1112
00:39:53,796 --> 00:39:55,446
更新同一个缓存的时候


1113
00:39:55,686 --> 00:39:57,816
GPU 依旧会从这个缓存里读取


1114
00:39:58,076 --> 00:40:01,266
所以这很明显是个


1115
00:40:01,266 --> 00:40:03,806
竞争条件并且结果还是未知的


1116
00:40:03,806 --> 00:40:06,826
有一些潜在的修复


1117
00:40:07,356 --> 00:40:09,806
你可以在你的 App 中实现它们


1118
00:40:10,396 --> 00:40:13,386
最简单的方法是在每一帧之后


1119
00:40:13,386 --> 00:40:14,396
调用命令缓存里的


1120
00:40:14,396 --> 00:40:17,306
waitUntilCompleted 方法


1121
00:40:18,516 --> 00:40:22,556
但是这样的话需要等到 GPU


1122
00:40:22,556 --> 00:40:24,246
在你为了下一帧重写这一缓存之前


1123
00:40:24,246 --> 00:40:26,296
完成读取工作之后


1124
00:40:27,096 --> 00:40:30,936
不过就像你看到的


1125
00:40:30,936 --> 00:40:32,866
这里 CPU 和 GPU 的利用率都很差


1126
00:40:33,036 --> 00:40:35,606
所以这并不是


1127
00:40:35,606 --> 00:40:38,166
你想要完成的传输代码


1128
00:40:38,936 --> 00:40:40,756
但是如果你想要你的 Metal 


1129
00:40:40,756 --> 00:40:42,856
App 设置好并跑起来它还是很有用的


1130
00:40:43,746 --> 00:40:45,976
甚至如果你的 App


1131
00:40:45,976 --> 00:40:47,766
真的有这样的数据冲突


1132
00:40:47,766 --> 00:40:49,716
它是能检测出来的


1133
00:40:51,756 --> 00:40:54,366
一个高效的方法去同步


1134
00:40:54,366 --> 00:40:55,926
你的资源更新是使用


1135
00:40:55,926 --> 00:40:56,826
多个缓存


1136
00:40:57,546 --> 00:40:58,906
所以在这种情况下我们会用到


1137
00:40:58,956 --> 00:41:00,526
三个缓存去更新


1138
00:41:00,526 --> 00:41:02,126
我们的动态数据


1139
00:41:02,816 --> 00:41:04,756
我们在第一帧里写进缓存


1140
00:41:04,756 --> 00:41:06,846
然后之后 GPU 会


1141
00:41:06,846 --> 00:41:07,516
从中读取


1142
00:41:08,206 --> 00:41:10,166
然后在第二帧里我们为了


1143
00:41:10,166 --> 00:41:11,856
避免竞争的情况我们写进


1144
00:41:11,856 --> 00:41:12,666
第二个缓存里


1145
00:41:13,326 --> 00:41:15,246
类似的我们在第三帧里


1146
00:41:15,246 --> 00:41:18,146
写第三个缓存


1147
00:41:18,346 --> 00:41:20,176
但是现在我们已经用完了所有


1148
00:41:20,176 --> 00:41:22,406
三个缓存并且用尽了我们的缓存池


1149
00:41:23,526 --> 00:41:25,246
我们需要等到 GPU 


1150
00:41:25,246 --> 00:41:27,166
完成第一帧这样我们才能


1151
00:41:27,166 --> 00:41:28,616
在第四帧重复使用


1152
00:41:29,186 --> 00:41:33,736
现在这个完成处理器就变得


1153
00:41:33,736 --> 00:41:35,906
得心应手了


1154
00:41:35,906 --> 00:41:38,046
它会让我们知道什么时候 GPU 完成了


1155
00:41:38,096 --> 00:41:38,406
这一帧的执行


1156
00:41:39,096 --> 00:41:41,396
所以当第一帧完成以后


1157
00:41:41,396 --> 00:41:43,586
我们可以在第四帧里重新使用它的缓存


1158
00:41:44,396 --> 00:41:48,696
以此类推 所以我们现在来看一个例子


1159
00:41:49,226 --> 00:41:52,916
对于你渲染循环外的


1160
00:41:53,326 --> 00:41:55,316
三个缓存实现


1161
00:41:55,316 --> 00:41:56,996
第一件事是我们会为三个缓存


1162
00:41:57,086 --> 00:41:57,726
创建一个 FIFO 队列


1163
00:41:58,286 --> 00:42:01,006
同时我们还需要一个


1164
00:42:01,006 --> 00:42:02,616
frameBoundarySemaphore


1165
00:42:02,616 --> 00:42:04,466
它在初始化的时候被设置成了 3


1166
00:42:05,096 --> 00:42:06,906
所以这就表明信号量


1167
00:42:06,906 --> 00:42:09,276
会在每一帧的边缘被测到


1168
00:42:09,576 --> 00:42:11,246
就是在 GPU 完成


1169
00:42:11,246 --> 00:42:14,046
执行一帧的时候


1170
00:42:14,046 --> 00:42:17,466
这允许 CPU 去重复使用它的缓存


1171
00:42:17,466 --> 00:42:19,826
同样 初始化缓存索引去


1172
00:42:19,826 --> 00:42:23,466
指向当前帧的缓存


1173
00:42:23,806 --> 00:42:26,386
而且在你的渲染循环里


1174
00:42:26,386 --> 00:42:28,006
在你写进缓存之前我们需要


1175
00:42:28,006 --> 00:42:30,006
先确定它的


1176
00:42:30,006 --> 00:42:31,276
响应帧已经


1177
00:42:31,326 --> 00:42:33,926
在 GPU 上完成了执行


1178
00:42:34,366 --> 00:42:35,836
所以在帧的一开始


1179
00:42:36,236 --> 00:42:37,386
我们等待


1180
00:42:37,386 --> 00:42:38,656
frameBoundarySemaphore


1181
00:42:39,696 --> 00:42:41,386
一旦信号量被检测到了


1182
00:42:41,506 --> 00:42:42,786
这就表明当前帧


1183
00:42:42,786 --> 00:42:44,166
已经完成了它的


1184
00:42:44,166 --> 00:42:46,126
GPU 上的执行 


1185
00:42:47,536 --> 00:42:50,846
所以为了新的一帧的数据


1186
00:42:50,846 --> 00:42:51,716
去重复利用缓存是安全的


1187
00:42:52,406 --> 00:42:55,426
而且现在我们会编码一些


1188
00:42:55,426 --> 00:42:59,176
命令去绑定这个缓存和 GPU


1189
00:42:59,176 --> 00:43:01,186
在我们提交这个命令缓存给 GPU 之前


1190
00:43:01,186 --> 00:43:03,066
我们会给这一帧添加


1191
00:43:03,066 --> 00:43:05,156
一个完成处理器


1192
00:43:05,156 --> 00:43:06,556
到命令缓存里


1193
00:43:07,186 --> 00:43:10,066
在添加完 完成处理器之后


1194
00:43:10,066 --> 00:43:12,026
我们会提交这个命令缓存给 GPU


1195
00:43:12,926 --> 00:43:16,036
现在一旦 GPU 完成了


1196
00:43:16,036 --> 00:43:17,806
执行这一帧


1197
00:43:17,806 --> 00:43:19,846
我们的完成处理器就会被调用


1198
00:43:19,846 --> 00:43:22,006
处理器之后就会在这一帧发出信号


1199
00:43:23,766 --> 00:43:26,156
这就允许 CPU 去重复使用它的缓存


1200
00:43:26,186 --> 00:43:27,986
给新的帧编码


1201
00:43:28,786 --> 00:43:30,666
所以这是一个简单的


1202
00:43:30,666 --> 00:43:32,196
三缓存实现


1203
00:43:32,196 --> 00:43:33,846
你可以用它来执行任何


1204
00:43:33,846 --> 00:43:35,996
动态数据的资源更新


1205
00:43:36,476 --> 00:43:39,376
现在我们有了命令缓存


1206
00:43:39,376 --> 00:43:41,426
同时我们还处理了


1207
00:43:41,726 --> 00:43:44,246
资源更新现在我们


1208
00:43:44,246 --> 00:43:46,136
来多说一点关于渲染通行编码器


1209
00:43:46,626 --> 00:43:48,306
它是你将会在你的绘图请求中


1210
00:43:48,306 --> 00:43:49,796
用到的编码


1211
00:43:50,276 --> 00:43:52,496
就像 Dan 之前提到的


1212
00:43:52,496 --> 00:43:56,906
命令编码器在命令缓存里


1213
00:43:57,146 --> 00:43:59,046
将 API 请求转换成


1214
00:43:59,046 --> 00:43:59,926
GPU 硬件命令


1215
00:43:59,926 --> 00:44:02,936
我将会谈到渲染命令编码器


1216
00:44:02,936 --> 00:44:06,656
它提供了一些针对典型图形的 API


1217
00:44:06,816 --> 00:44:08,216
一些操作 如设定管道


1218
00:44:08,216 --> 00:44:10,186
纹理缓存对象


1219
00:44:10,186 --> 00:44:12,276
还有绘图请求


1220
00:44:12,786 --> 00:44:16,816
所以当你们创建编码器时


1221
00:44:16,966 --> 00:44:18,906
你需要先去设定渲染目标


1222
00:44:18,936 --> 00:44:20,756
所以这是个渲染通行描述符


1223
00:44:20,756 --> 00:44:22,396
这里你将会设置你的


1224
00:44:22,396 --> 00:44:24,746
渲染目标并且在之后请求


1225
00:44:24,746 --> 00:44:26,586
命令缓存为了这个渲染通行


1226
00:44:26,586 --> 00:44:28,706
去创建一个新的编码器 


1227
00:44:29,366 --> 00:44:31,186
现在你就可以用这个编码器


1228
00:44:31,186 --> 00:44:33,256
去编码你的绘图请求了


1229
00:44:35,136 --> 00:44:37,946
跟 OpenGL 不一样的一个地方是


1230
00:44:38,106 --> 00:44:40,666
在 Metal 里一旦编码器被创建了


1231
00:44:40,666 --> 00:44:42,736
你不能再更改它的渲染目标


1232
00:44:42,736 --> 00:44:45,606
因为 GPU 如果看见了一个


1233
00:44:45,696 --> 00:44:47,646
巨大的绘图请求跨度


1234
00:44:47,646 --> 00:44:49,776
它会表现得好很多


1235
00:44:49,776 --> 00:44:51,436
这些请求是去渲染同一个


1236
00:44:51,436 --> 00:44:53,106
渲染目标集合


1237
00:44:54,046 --> 00:44:56,906
所以 Metal API 通过给渲染通行一个


1238
00:44:57,246 --> 00:44:59,876
明确的开始和结束


1239
00:44:59,956 --> 00:45:00,906
来反映这一点


1240
00:45:01,316 --> 00:45:03,636
现在这个编码器给出的所有绘图请求


1241
00:45:03,636 --> 00:45:05,596
会渲染进


1242
00:45:05,596 --> 00:45:06,936
这些渲染目标里


1243
00:45:08,566 --> 00:45:09,816
当你想要向不同的渲染目标


1244
00:45:09,816 --> 00:45:11,406
绘图的时候


1245
00:45:11,576 --> 00:45:13,246
你可以结束这个渲染通行


1246
00:45:13,246 --> 00:45:14,226
然后开启一个新的


1247
00:45:14,756 --> 00:45:18,936
这就是我们创建


1248
00:45:18,936 --> 00:45:20,286
一个渲染通行描述符


1249
00:45:20,286 --> 00:45:23,876
并且绑定颜色和深度关系的地方


1250
00:45:25,166 --> 00:45:27,036
现在你可以使用那个描述符


1251
00:45:27,086 --> 00:45:29,716
并且创建一个渲染命令编码器


1252
00:45:30,436 --> 00:45:33,116
现在所有由这个编码器发出的图画


1253
00:45:33,116 --> 00:45:34,966
都会被渲染到这些目标


1254
00:45:37,216 --> 00:45:39,426
另外在 Metal 里


1255
00:45:39,426 --> 00:45:41,856
你也可以为这些附件提供


1256
00:45:41,856 --> 00:45:43,546
加载和存储行为


1257
00:45:43,786 --> 00:45:46,126
这是为了优化 GPU 的带宽用量


1258
00:45:48,236 --> 00:45:50,076
所以这些加载和存储的行为


1259
00:45:50,076 --> 00:45:52,086
允许你去控制


1260
00:45:52,086 --> 00:45:53,796
纹理内容会在渲染通行


1261
00:45:53,956 --> 00:45:55,876
之前和之后被怎样处理


1262
00:45:56,266 --> 00:45:59,016
现在我们有了为渲染通行产生的


1263
00:45:59,016 --> 00:46:01,856
颜色和深度附属品


1264
00:46:02,066 --> 00:46:03,856
如果它清晰地为两个


1265
00:46:03,856 --> 00:46:05,906
渲染目标指定了加载行为


1266
00:46:05,906 --> 00:46:08,346
GPU 就会首先


1267
00:46:08,386 --> 00:46:09,836
清除它们的内容


1268
00:46:10,266 --> 00:46:13,246
之后 GPU 会在这个编码器中


1269
00:46:13,246 --> 00:46:14,556
执行命令


1270
00:46:14,556 --> 00:46:16,346
来渲染这些渲染目标


1271
00:46:16,886 --> 00:46:19,616
现在你可以指定


1272
00:46:19,616 --> 00:46:21,026
在渲染通行的末尾


1273
00:46:21,136 --> 00:46:22,176
进行的存储行为


1274
00:46:22,536 --> 00:46:24,486
这里对于颜色缓存来说


1275
00:46:24,486 --> 00:46:25,996
介于存储行为被存储起来了


1276
00:46:25,996 --> 00:46:28,656
它会在渲染通行


1277
00:46:28,686 --> 00:46:30,966
的最后保留颜色缓存的内容


1278
00:46:31,576 --> 00:46:33,006
然后对于深度附件来说


1279
00:46:33,006 --> 00:46:35,286
因为我们说了存储行为是不关心的


1280
00:46:35,286 --> 00:46:37,786
所以它会放弃它的内容


1281
00:46:39,006 --> 00:46:40,876
所以这些纹理加载和存储


1282
00:46:40,876 --> 00:46:42,806
是非常昂贵的


1283
00:46:42,806 --> 00:46:44,376
消耗内存带宽的操作


1284
00:46:44,946 --> 00:46:47,346
所以慎重地选择并且不要关心


1285
00:46:47,346 --> 00:46:48,416
是不是可能


1286
00:46:48,976 --> 00:46:52,246
那么这就是你怎么设定你行为的过程


1287
00:46:52,526 --> 00:46:54,876
在这个例子里我们指定了清除为


1288
00:46:54,876 --> 00:46:57,966
加载行为并且设定了清除颜色


1289
00:46:59,186 --> 00:47:01,236
然后这里我们指定了存储行为为存储


1290
00:47:01,806 --> 00:47:03,656
相似的你可以为每一个渲染目标


1291
00:47:03,656 --> 00:47:05,636
指定加载和存储行为


1292
00:47:05,636 --> 00:47:07,196
这些渲染目标是你设定在


1293
00:47:07,196 --> 00:47:08,326
渲染通行描述符里的


1294
00:47:08,926 --> 00:47:11,936
所以这就是我们如何配置我们的


1295
00:47:11,936 --> 00:47:12,896
渲染目标


1296
00:47:12,946 --> 00:47:16,596
现在你可以从这个描述符


1297
00:47:16,596 --> 00:47:19,076
创建编码器


1298
00:47:19,076 --> 00:47:20,526
然后我们就可以开始编码绘图请求了


1299
00:47:21,886 --> 00:47:23,606
但是在这之前我想给你们展现


1300
00:47:23,606 --> 00:47:25,756
一些 OpenGL 命令


1301
00:47:25,756 --> 00:47:27,326
然后它们会向你们展现它们的


1302
00:47:27,326 --> 00:47:28,146
Metal 等价表示


1303
00:47:28,686 --> 00:47:32,626
这就是典型 OpenGL 绘图序列


1304
00:47:33,156 --> 00:47:36,526
在这个分片里我们先绑定一个


1305
00:47:36,526 --> 00:47:38,776
会设定所有渲染目标的


1306
00:47:38,776 --> 00:47:39,826
帧缓存器


1307
00:47:41,096 --> 00:47:42,966
然后我们绑定我们的程序


1308
00:47:42,966 --> 00:47:45,676
程序内包含了顶点和分片着色器


1309
00:47:46,226 --> 00:47:48,206
然后我们绑定带有顶点数据的


1310
00:47:48,206 --> 00:47:49,676
顶点缓存器


1311
00:47:50,136 --> 00:47:53,036
之后我们再绑定另一个


1312
00:47:53,036 --> 00:47:54,576
含有所有标准数据的缓存器


1313
00:47:55,416 --> 00:47:57,686
再然后我们就会设定一个


1314
00:47:57,686 --> 00:47:58,536
被采样的纹理


1315
00:47:59,776 --> 00:48:00,916
最后绘图


1316
00:48:01,546 --> 00:48:03,956
所以这就是 Metal 的等价操作


1317
00:48:04,566 --> 00:48:05,956
这会稍微多出几行代码


1318
00:48:05,996 --> 00:48:07,936
因为它是明确的但是它


1319
00:48:07,936 --> 00:48:09,766
和 OpenGL 非常类似


1320
00:48:10,586 --> 00:48:11,866
首先我们用渲染通行描述符


1321
00:48:11,866 --> 00:48:13,336
创建一个渲染命令编码器


1322
00:48:13,336 --> 00:48:15,456
这个描述符含有我们的


1323
00:48:15,456 --> 00:48:16,346
渲染目标


1324
00:48:17,696 --> 00:48:19,296
然后我们设定含有


1325
00:48:19,296 --> 00:48:20,506
着色器的管道对象


1326
00:48:21,836 --> 00:48:24,606
然后我们再去设定缓存器


1327
00:48:24,606 --> 00:48:26,276
去访问顶点着色器


1328
00:48:26,676 --> 00:48:27,836
同时它还含有我们要画的


1329
00:48:27,836 --> 00:48:29,226
图像的顶点


1330
00:48:30,436 --> 00:48:32,316
值得注意的是 Metal 并不会


1331
00:48:32,316 --> 00:48:33,846
区别包含标准数据


1332
00:48:33,846 --> 00:48:36,026
的缓存器和那些


1333
00:48:36,026 --> 00:48:37,176
包含顶点的缓存器


1334
00:48:37,816 --> 00:48:40,276
所以我们会用相同的 API


1335
00:48:40,276 --> 00:48:41,386
去设置标准缓存


1336
00:48:41,386 --> 00:48:44,026
所以这里第一个请求会给


1337
00:48:44,026 --> 00:48:46,026
缓存器访问顶点着色器的权限


1338
00:48:46,026 --> 00:48:47,236
第二个请求会给出访问


1339
00:48:47,236 --> 00:48:48,746
分片着色器的权限


1340
00:48:49,286 --> 00:48:52,166
接下来我们为要去采样的


1341
00:48:52,166 --> 00:48:54,026
分片着色器设定纹理


1342
00:48:54,516 --> 00:48:56,556
然后绘图


1343
00:48:57,076 --> 00:48:59,846
一旦我们完成了编码命令


1344
00:48:59,846 --> 00:49:01,456
我们会通过在编码对象上


1345
00:49:01,456 --> 00:49:03,396
调用 endEncoding 向 Metal 


1346
00:49:03,396 --> 00:49:05,376
指出这些


1347
00:49:06,196 --> 00:49:07,916
所以这就是一个简单的


1348
00:49:07,916 --> 00:49:09,406
Metal 渲染通行的例子


1349
00:49:09,926 --> 00:49:12,926
现在我们已经有了一个完整的渲染通行 


1350
00:49:12,926 --> 00:49:14,696
我们再来看看怎样去


1351
00:49:14,696 --> 00:49:16,806
让这些渲染表现出来


1352
00:49:17,336 --> 00:49:21,526
通过 OpenGl 你将你的渲染帧


1353
00:49:21,526 --> 00:49:23,156
展现到屏幕上


1354
00:49:23,436 --> 00:49:25,336
但是你并没有明确地管理


1355
00:49:25,336 --> 00:49:27,996
系统的渲染缓存


1356
00:49:27,996 --> 00:49:29,006
依旧被设定为 drawable


1357
00:49:30,336 --> 00:49:32,126
但是要是通过 Metal 将你的


1358
00:49:32,126 --> 00:49:34,476
内容显示在屏幕上


1359
00:49:34,906 --> 00:49:36,186
首先你需要确认包含特殊的纹理


1360
00:49:36,186 --> 00:49:37,516
这种特殊纹理在系统里


1361
00:49:37,516 --> 00:49:39,116
被称为 drawable


1362
00:49:39,746 --> 00:49:41,676
所以你可以使用 MetalKit 视图


1363
00:49:41,816 --> 00:49:42,756
MetalKit 视图提供了每一帧中的


1364
00:49:42,756 --> 00:49:44,846
drawable 纹理


1365
00:49:45,426 --> 00:49:46,886
然后一旦你获得这个 drawable


1366
00:49:46,886 --> 00:49:49,276
你就可以编码渲染通行


1367
00:49:49,276 --> 00:49:51,226
并且渲染到这些


1368
00:49:51,226 --> 00:49:53,096
drawable 就像你


1369
00:49:53,096 --> 00:49:54,586
渲染到任意其他一个纹理一样


1370
00:49:55,126 --> 00:49:57,766
然而并不像其他纹理一样


1371
00:49:57,766 --> 00:49:59,976
现在你可以将这个 drawable 展现出来


1372
00:50:00,096 --> 00:50:02,996
那么让我来给你们展示一下代码例子


1373
00:50:03,516 --> 00:50:06,196
首先我需要说一下


1374
00:50:06,196 --> 00:50:07,886
这些 drawable 受限于你的


1375
00:50:08,166 --> 00:50:10,696
着色器系统资源


1376
00:50:10,696 --> 00:50:12,206
所以你应该尽可能简单


1377
00:50:12,206 --> 00:50:13,536
地处理他们


1378
00:50:14,236 --> 00:50:15,776
这代表着你应该


1379
00:50:15,776 --> 00:50:18,096
在你获取 drawable 以前编码


1380
00:50:18,126 --> 00:50:20,606
所有的离线渲染通行


1381
00:50:21,906 --> 00:50:23,626
之后你可以创建一个 MetalKit 视图


1382
00:50:23,626 --> 00:50:26,856
不但可以去看一个完整的


1383
00:50:26,856 --> 00:50:29,206
填充渲染通行描述符


1384
00:50:29,466 --> 00:50:30,926
这个描述符你可以直接用来


1385
00:50:30,926 --> 00:50:33,836
创建编码器 就是这里你们看到的这个


1386
00:50:33,836 --> 00:50:36,336
同时你还可以通过


1387
00:50:36,336 --> 00:50:37,746
view.currentDrawable 属性


1388
00:50:37,976 --> 00:50:41,626
请求指定的纹理


1389
00:50:41,626 --> 00:50:42,706
之后你可以围绕它创建你自己的


1390
00:50:42,706 --> 00:50:45,086
渲染通行描述符


1391
00:50:47,136 --> 00:50:48,846
一旦你完成了编码你的帧


1392
00:50:48,846 --> 00:50:50,496
你可以调用


1393
00:50:50,496 --> 00:50:51,896
现有的命令缓存中的


1394
00:50:51,896 --> 00:50:53,456
drawable 方法


1395
00:50:53,456 --> 00:50:55,626
这在 GPU 完成执行命令换内存后


1396
00:50:55,626 --> 00:50:58,166
将你的 drawable 输出到屏幕上


1397
00:50:58,986 --> 00:51:00,946
所以一旦 GPU 完成了


1398
00:51:00,946 --> 00:51:02,586
执行这一帧


1399
00:51:02,586 --> 00:51:04,116
你就可以在显示上看到这一帧


1400
00:51:04,646 --> 00:51:07,606
这样的话通过 Metal


1401
00:51:07,606 --> 00:51:09,286
将你的渲染展现出来


1402
00:51:09,286 --> 00:51:10,596
就变得相当的快了


1403
00:51:11,156 --> 00:51:14,166
但是我还有几个小建议与你们分享


1404
00:51:15,366 --> 00:51:17,296
将一个渲染器


1405
00:51:17,966 --> 00:51:19,936
传递到 Metal 是可行的


1406
00:51:19,936 --> 00:51:21,436
IOSurface 和 CVPixelBuffer


1407
00:51:21,436 --> 00:51:25,696
API 可以被用来创建纹理


1408
00:51:25,726 --> 00:51:27,596
这个纹理可以在


1409
00:51:27,596 --> 00:51:29,266
OpenGL 和 Metal 之间共享


1410
00:51:30,376 --> 00:51:32,586
这就允许你在 OpenGL 里面


1411
00:51:32,586 --> 00:51:34,596
渲染一个纹理


1412
00:51:34,596 --> 00:51:36,746
然后从 Metal 里读取


1413
00:51:36,746 --> 00:51:36,926
反之亦然


1414
00:51:36,926 --> 00:51:39,876
所以一些 App 可以


1415
00:51:39,876 --> 00:51:41,616
利用这一点去


1416
00:51:41,616 --> 00:51:43,476
逐步移植


1417
00:51:43,756 --> 00:51:45,076
特别是当存在搭建在 OpenGL 里的


1418
00:51:45,076 --> 00:51:46,466
插件结构的时候


1419
00:51:47,206 --> 00:51:49,546
所以这里有一个关联到这个会话的


1420
00:51:49,686 --> 00:51:51,796
示例代码准确地展现了


1421
00:51:51,796 --> 00:51:52,846
如何做到这一点


1422
00:51:55,416 --> 00:51:56,796
现在你已经有了一个 Metal App


1423
00:51:56,796 --> 00:51:58,806
你可以采用所有


1424
00:51:58,806 --> 00:51:59,906
新的 Metal 特性


1425
00:52:01,076 --> 00:52:03,046
如果你的 App 是与 CPU 绑定的


1426
00:52:03,046 --> 00:52:05,436
那么使你的 CPU 编码多线程工作


1427
00:52:05,436 --> 00:52:07,006
会很有用


1428
00:52:07,746 --> 00:52:09,636
你可以在不同线程上


1429
00:52:09,636 --> 00:52:11,316
同时编码多个


1430
00:52:11,316 --> 00:52:12,346
命令缓存


1431
00:52:12,926 --> 00:52:14,776
你甚至可以将一个单独的命令缓存


1432
00:52:14,776 --> 00:52:16,556
拆分编码到


1433
00:52:16,556 --> 00:52:18,346
多个线程中


1434
00:52:18,346 --> 00:52:18,976
这是通过使用并行渲染命令编码器实现的


1435
00:52:25,046 --> 00:52:26,926
同样的通过计划处理


1436
00:52:26,926 --> 00:52:30,186
API 来做的 GPU 计算内置于 Metal 中


1437
00:52:30,776 --> 00:52:33,536
你可以用全新的方法去使用 GPU


1438
00:52:34,046 --> 00:52:36,666
不用 CPU 去开始的话


1439
00:52:36,666 --> 00:52:38,976
你可以利用计算管道来


1440
00:52:38,976 --> 00:52:40,746
生成图像的 GPU 数据


1441
00:52:41,336 --> 00:52:43,616
通过让 GPU 去生成它自己的数据


1442
00:52:43,616 --> 00:52:45,346
你不但可以


1443
00:52:45,346 --> 00:52:47,846
减少 CPU 的利用率和同步率


1444
00:52:47,846 --> 00:52:49,776
同时你还可以


1445
00:52:49,776 --> 00:52:50,796
自由地决定数据对于 GPU


1446
00:52:50,796 --> 00:52:52,106
所需的带宽


1447
00:52:53,176 --> 00:52:54,946
现在通过这个高带宽


1448
00:52:55,246 --> 00:52:56,846
计算处理器你可以


1449
00:52:56,846 --> 00:52:58,456
实现更多更复杂的


1450
00:52:58,456 --> 00:52:58,966
算法 就像这些


1451
00:53:03,356 --> 00:53:05,256
Metal 支持很多很强大的特性


1452
00:53:05,296 --> 00:53:07,216
这些功能你可以用到


1453
00:53:07,216 --> 00:53:09,706
你的 App 里来提高其自身的性能


1454
00:53:10,256 --> 00:53:13,556
此外作为你移植过程的一部分


1455
00:53:13,596 --> 00:53:15,186
我们强烈地鼓励你


1456
00:53:15,186 --> 00:53:17,406
去使用我们的 Metal 


1457
00:53:17,406 --> 00:53:19,096
的极其强大的调试和


1458
00:53:19,096 --> 00:53:21,226
优化工具


1459
00:53:21,256 --> 00:53:23,456
它们都被集合在了 Xcode 里


1460
00:53:24,446 --> 00:53:26,476
所以 Metal 有一个很强大的 API


1461
00:53:26,476 --> 00:53:28,536
验证层来表明


1462
00:53:28,796 --> 00:53:30,816
任何不正常的 API 用量


1463
00:53:30,816 --> 00:53:33,176
的细节信息


1464
00:53:33,176 --> 00:53:34,756
同时也会给出一些可能的修复策略


1465
00:53:36,316 --> 00:53:38,826
这是一个可以让你


1466
00:53:38,826 --> 00:53:40,536
一步一步进行 Metal 


1467
00:53:40,596 --> 00:53:42,706
的调用和


1468
00:53:42,706 --> 00:53:44,466
一步一步看到你的帧是如何被渲染的


1469
00:53:44,466 --> 00:53:45,816
GPU 调试器


1470
00:53:46,726 --> 00:53:48,796
你可以看到和你的帧


1471
00:53:48,796 --> 00:53:50,246
一起出现的所有资源


1472
00:53:50,926 --> 00:53:53,116
它也基于资源的用量


1473
00:53:53,166 --> 00:53:55,036
给 GPU 提供了专业的建议


1474
00:53:55,586 --> 00:53:58,916
今年我们还添加了


1475
00:53:58,916 --> 00:54:00,556
着色器调试器 


1476
00:54:00,916 --> 00:54:02,326
这样你可以调试你的着色器方法


1477
00:54:02,326 --> 00:54:04,006
就像其他的函数一样


1478
00:54:04,516 --> 00:54:07,686
我们还添加了着色器分析器


1479
00:54:07,956 --> 00:54:09,646
它会显示一个


1480
00:54:09,646 --> 00:54:11,266
与你的着色器有关的


1481
00:54:11,266 --> 00:54:11,936
性能矩阵集合


1482
00:54:12,046 --> 00:54:15,556
同时还有一个依赖观察器


1483
00:54:15,556 --> 00:54:17,156
让你能评判


1484
00:54:17,156 --> 00:54:18,626
渲染通行的依赖关系


1485
00:54:18,626 --> 00:54:22,096
你也可以潜在的


1486
00:54:22,096 --> 00:54:24,336
合并任何多余的渲染通行


1487
00:54:24,336 --> 00:54:26,726
以此来提高你的


1488
00:54:26,726 --> 00:54:27,976
App 的性能


1489
00:54:30,216 --> 00:54:32,166
最后 在instruments 里的


1490
00:54:32,166 --> 00:54:33,966
Metal 系统追踪工具


1491
00:54:33,966 --> 00:54:36,696
会给你展现一个完整的


1492
00:54:36,736 --> 00:54:38,486
App 表现和性能


1493
00:54:38,486 --> 00:54:40,276
所以我们强烈建议你


1494
00:54:40,276 --> 00:54:42,396
使用这些工具去


1495
00:54:42,396 --> 00:54:44,146
简化你的移植工作量


1496
00:54:45,296 --> 00:54:47,906
将它打包起来 


1497
00:54:47,906 --> 00:54:49,536
OpenGL 和 OpenCL 已经被放弃了


1498
00:54:49,536 --> 00:54:52,656
但是它们依旧在


1499
00:54:52,656 --> 00:54:54,466
我们很担忧它们的未来使用率


1500
00:54:54,826 --> 00:54:56,526
现在是时候接受 Metal 了


1501
00:54:57,216 --> 00:54:59,106
我们有一整套的开发者工具


1502
00:54:59,106 --> 00:55:00,806
很多经验来


1503
00:55:00,806 --> 00:55:02,896
帮助开发团队成功地


1504
00:55:02,896 --> 00:55:04,616
完成了这项工作


1505
00:55:04,616 --> 00:55:07,006
并且大幅提高了性能


1506
00:55:07,736 --> 00:55:09,236
我希望我今天分享的信息


1507
00:55:09,236 --> 00:55:10,846
可以给予你们


1508
00:55:10,846 --> 00:55:12,356
顺利移植地经验


1509
00:55:12,866 --> 00:55:15,846
同时我们也很愿意与你们沟通


1510
00:55:15,846 --> 00:55:17,376
谈一谈你们的 App 和


1511
00:55:17,376 --> 00:55:19,406
你们如何通过 Metal 让他们运行的


1512
00:55:20,006 --> 00:55:21,776
所以明天下午我们将


1513
00:55:21,776 --> 00:55:23,506
在 OpenGL 到 Metal 移植实验室里


1514
00:55:23,666 --> 00:55:25,736
介时会有很多


1515
00:55:25,736 --> 00:55:27,696
关于 Metal 的会议


1516
00:55:28,006 --> 00:55:29,426
我建议你们来参加这些会议


1517
00:55:29,426 --> 00:55:31,546
可以学到很多关于


1518
00:55:31,546 --> 00:55:33,106
如何利用 Metal 去调试和


1519
00:55:33,106 --> 00:55:34,466
优化你的 App 的方法


1520
00:55:36,106 --> 00:55:37,866
在此感谢大家参与这次会议


1521
00:55:37,866 --> 00:55:39,706
希望你们能享受这一周


1522
00:55:39,706 --> 00:55:40,716
剩下的时光


1523
00:55:41,516 --> 00:55:44,500
[ 掌声 ]

