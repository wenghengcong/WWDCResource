1
00:00:07,516 --> 00:00:15,500
[ 音乐 ]


2
00:00:17,516 --> 00:00:23,056
[ 掌声 ]


3
00:00:23,556 --> 00:00:24,156
>> 大家好


4
00:00:24,876 --> 00:00:26,136
非常高兴见到今天


5
00:00:26,136 --> 00:00:26,446
到场的各位


6
00:00:27,306 --> 00:00:29,676
我是 Dave 之后的 40 分钟


7
00:00:29,676 --> 00:00:32,436
是关于理解


8
00:00:32,485 --> 00:00:33,996
和致敬 驱动我们的


9
00:00:34,036 --> 00:00:35,716
程序运行的东西


10
00:00:36,766 --> 00:00:38,286
我们将会聊到一些实用的建议


11
00:00:38,636 --> 00:00:40,986
但这并不是一个关于


12
00:00:41,056 --> 00:00:43,116
技巧 技术


13
00:00:43,116 --> 00:00:44,876
或者任何具体算法的演讲


14
00:00:44,876 --> 00:00:45,816
尽管我们仍会有所涉及


15
00:00:47,026 --> 00:00:49,156
这个演讲主要的内容是


16
00:00:49,296 --> 00:00:50,956
揭示一些根本的东西 它的潜力


17
00:00:51,036 --> 00:00:54,006
已经在你的代码中有所体现


18
00:00:54,936 --> 00:00:57,216
我希望至少对于你们之中的一些人


19
00:00:57,216 --> 00:00:58,796
这标志着与编程实践


20
00:00:58,796 --> 00:01:01,056
建立新关系的开始


21
00:01:02,236 --> 00:01:03,446
就个人而言 


22
00:01:03,446 --> 00:01:05,116
当我发现这种方法时


23
00:01:05,116 --> 00:01:06,446
我的生活和事业的航向


24
00:01:06,756 --> 00:01:07,486
就由此改变


25
00:01:08,446 --> 00:01:09,926
这就是为什么


26
00:01:09,926 --> 00:01:11,966
我如此关心软件库


27
00:01:11,966 --> 00:01:13,786
但它也是


28
00:01:13,786 --> 00:01:15,866
我所编写过的具体代码的


29
00:01:15,866 --> 00:01:17,976
每一部分之中的可靠性


30
00:01:17,976 --> 00:01:19,436
可维护性以及性能表现的来源


31
00:01:20,836 --> 00:01:22,876
但在我们开始之前


32
00:01:22,876 --> 00:01:24,226
请允许我向你们介绍


33
00:01:24,226 --> 00:01:24,396
我的一个朋友


34
00:01:26,776 --> 00:01:27,506
他就是 Crusty


35
00:01:28,516 --> 00:01:31,616
[ 掌声 ]


36
00:01:32,116 --> 00:01:34,006
Crusty 是一个传统派


37
00:01:34,896 --> 00:01:37,026
他不相信调试工具


38
00:01:37,026 --> 00:01:40,016
也不爱使用集成开发环境


39
00:01:40,806 --> 00:01:43,246
没错 他喜欢那种 80 × 24


40
00:01:43,246 --> 00:01:45,436
的纯文本终端窗口


41
00:01:45,506 --> 00:01:46,246
非常感谢


42
00:01:47,516 --> 00:01:49,566
现在 Crusty 对最新的编程潮流


43
00:01:49,566 --> 00:01:51,916
持悲观态度


44
00:01:51,916 --> 00:01:53,476
所以想把他拖到 21 世纪


45
00:01:53,476 --> 00:01:55,166
有时会比较费力


46
00:01:56,126 --> 00:01:57,636
他总是有不同的想法


47
00:01:58,656 --> 00:02:00,866
但是如果你仔细听


48
00:02:00,866 --> 00:02:03,336
你肯定会学到点东西


49
00:02:03,576 --> 00:02:05,356
有时他会有一些


50
00:02:05,356 --> 00:02:07,666
神奇的表达方式


51
00:02:07,666 --> 00:02:10,156
比如“编程揭示本真”  甚至可以说


52
00:02:10,156 --> 00:02:10,675
有点玄幻了


53
00:02:11,416 --> 00:02:13,576
为了理解他


54
00:02:13,576 --> 00:02:15,096
我发现一种方法很有帮助


55
00:02:15,096 --> 00:02:16,286
那就是写代码


56
00:02:17,526 --> 00:02:18,796
所以最近我在编写


57
00:02:18,796 --> 00:02:20,586
一个叫做《Shapes》的小程序


58
00:02:21,656 --> 00:02:22,906
我希望将它创造成


59
00:02:22,906 --> 00:02:24,216
一个全能矢量绘图程序


60
00:02:24,216 --> 00:02:26,876
但目前为止 它只能让你


61
00:02:26,876 --> 00:02:28,836
在无限画布上排列形状


62
00:02:30,416 --> 00:02:31,376
现在 我想与你们讲一个


63
00:02:31,376 --> 00:02:33,226
关于删除选择指令的故事


64
00:02:33,226 --> 00:02:37,826
因为我从实现这一功能的过程中


65
00:02:37,826 --> 00:02:38,266
学习到了很多


66
00:02:39,596 --> 00:02:41,216
我想我们可能都


67
00:02:41,216 --> 00:02:43,426
经历过这个过程的一部分


68
00:02:43,426 --> 00:02:45,436
作为程序员 我们要学会


69
00:02:45,436 --> 00:02:46,856
如何从数组中删除东西


70
00:02:47,816 --> 00:02:49,106
每一个人都会从


71
00:02:49,106 --> 00:02:51,000
做这种事情开始


72
00:02:53,596 --> 00:02:57,026
刚刚这个就是删除选择指令


73
00:02:58,656 --> 00:03:02,316
我们从 0 开始循环计数


74
00:03:02,316 --> 00:03:03,326
当我们发现要删除的东西


75
00:03:03,326 --> 00:03:05,126
我们就调用 remove(at: )方法


76
00:03:05,126 --> 00:03:07,546
然后我们就可以继续循环


77
00:03:07,546 --> 00:03:11,846
直到 哦 溢出了


78
00:03:13,366 --> 00:03:14,906
数组会变短


79
00:03:14,906 --> 00:03:16,256
但是当循环开始时


80
00:03:16,256 --> 00:03:17,166
我们选择了固定的迭代次数


81
00:03:17,876 --> 00:03:19,196
幸运的是 如果你使用 Swift 


82
00:03:19,246 --> 00:03:20,796
并测试你的代码 你不可能遗漏这个 Bug


83
00:03:20,826 --> 00:03:23,436
因为程序会产生内中断


84
00:03:23,946 --> 00:03:25,226
但如果你像我一样


85
00:03:25,266 --> 00:03:26,996
是 C 语言出身的程序员


86
00:03:26,996 --> 00:03:28,966
面对这种问题 你可能没那么幸运


87
00:03:29,926 --> 00:03:30,256
好的


88
00:03:30,626 --> 00:03:32,796
我们可以通过将 for 循环替换为


89
00:03:32,796 --> 00:03:34,096
更难看的 while 循环


90
00:03:34,096 --> 00:03:36,346
来修复它 


91
00:03:36,346 --> 00:03:37,516
这可以使我们在每一次迭代中


92
00:03:37,516 --> 00:03:38,096
检查计数


93
00:03:38,646 --> 00:03:42,736
但这里也有一个细微的 Bug


94
00:03:43,956 --> 00:03:46,056
如果两个连续的元素被选中


95
00:03:46,056 --> 00:03:48,706
它将会删除第一个


96
00:03:48,706 --> 00:03:51,916
并且立即


97
00:03:51,916 --> 00:03:54,256
跳过下一个


98
00:03:54,466 --> 00:03:56,956
这个 Bug 更加的阴险


99
00:03:56,956 --> 00:03:58,496
因为它隐藏了起来


100
00:03:58,496 --> 00:04:00,286
除非你的测试碰巧


101
00:04:00,286 --> 00:04:02,716
试运行了它


102
00:04:02,946 --> 00:04:04,416
但是如果我们足够幸运注意到了它


103
00:04:04,416 --> 00:04:06,496
我们便可以继续


104
00:04:06,496 --> 00:04:08,826
用一个 else 代码块


105
00:04:08,826 --> 00:04:10,026
来保护自增语句 再次修复


106
00:04:10,026 --> 00:04:10,586
这个实现


107
00:04:11,226 --> 00:04:13,596
那么 我们完成了吗


108
00:04:13,596 --> 00:04:16,476
我们有把握确定 这次是正确的吗


109
00:04:17,706 --> 00:04:19,906
我认为我可以自证


110
00:04:19,995 --> 00:04:20,755
它能够运行


111
00:04:21,875 --> 00:04:24,106
不管怎样 经过这次的严峻的考验


112
00:04:24,106 --> 00:04:25,356
我们收获了什么


113
00:04:25,746 --> 00:04:27,336
当然 我们将这个


114
00:04:27,336 --> 00:04:28,696
九行的代码套路 牢记在脑中


115
00:04:28,696 --> 00:04:30,506
这样我们就可以在想要


116
00:04:30,506 --> 00:04:32,456
删除什么的时候 把它调出来


117
00:04:33,026 --> 00:04:35,666
现在 我确定你们中的许多人


118
00:04:35,666 --> 00:04:36,676
正控制着自己


119
00:04:36,676 --> 00:04:38,566
不向我大声喊叫


120
00:04:38,656 --> 00:04:40,506
因为有一个


121
00:04:40,506 --> 00:04:41,906
更加优雅的方式可以用


122
00:04:41,906 --> 00:04:43,206
我仍然记得 自己发现了


123
00:04:43,206 --> 00:04:44,686
这个技巧的那一天


124
00:04:45,106 --> 00:04:46,666
因为一旦你发现了它 你就不用


125
00:04:46,666 --> 00:04:48,456
再用那九行套路代码了


126
00:04:49,406 --> 00:04:51,496
迭代限制以及


127
00:04:51,556 --> 00:04:52,786
下一个要检查的项的索引


128
00:04:52,786 --> 00:04:54,956
像传送带一样不断滚动


129
00:04:54,956 --> 00:04:56,866
因为 remove(at: i)


130
00:04:57,746 --> 00:04:59,696
改变了数组中 i 之后的部分


131
00:05:00,766 --> 00:05:06,266
但是如果你从后往前检查


132
00:05:06,266 --> 00:05:07,526
你只会迭代数组中


133
00:05:07,526 --> 00:05:08,896
你还没有改变的部分


134
00:05:10,056 --> 00:05:10,776
干得漂亮 对吗


135
00:05:11,456 --> 00:05:12,556
这就是我一直


136
00:05:12,606 --> 00:05:14,916
使用的模式


137
00:05:14,946 --> 00:05:19,476
因为它简洁并且从不失败


138
00:05:20,086 --> 00:05:21,736
直到几个月前


139
00:05:21,736 --> 00:05:24,056
一天早晨 我刚吃完


140
00:05:24,056 --> 00:05:26,216
我的牛油果吐司


141
00:05:26,306 --> 00:05:28,376
并漫不经心地摆弄我的 App


142
00:05:28,376 --> 00:05:29,986
当我尝试从一个非常复杂的画布中


143
00:05:29,986 --> 00:05:31,686
删除差不多一半的图形时


144
00:05:33,016 --> 00:05:35,166
我的 iPad 卡死了


145
00:05:35,526 --> 00:05:36,206
将近 3 秒钟


146
00:05:36,886 --> 00:05:40,586
所以 我喝了一口


147
00:05:40,626 --> 00:05:42,746
装在竹质随行保温杯里的


148
00:05:43,156 --> 00:05:44,716
三倍浓度半因拿铁咖啡压压惊


149
00:05:44,716 --> 00:05:45,936
开始考虑我的对策


150
00:05:47,656 --> 00:05:48,526
这令人十分不安


151
00:05:49,136 --> 00:05:50,006
我的意思是 这是一个


152
00:05:50,006 --> 00:05:51,716
非常简单的操作


153
00:05:51,716 --> 00:05:53,686
我的代码如此简洁


154
00:05:53,686 --> 00:05:54,286
怎么可能出错呢


155
00:05:56,176 --> 00:05:58,256
性能分析结果告诉我


156
00:05:58,256 --> 00:06:01,156
红点就在这 但是除了这个


157
00:06:01,156 --> 00:06:02,056
我一点头绪都没有


158
00:06:02,706 --> 00:06:05,636
然后 就在这时


159
00:06:05,636 --> 00:06:07,076
Crusty 在我身后经过


160
00:06:07,076 --> 00:06:09,416
拿着一罐从当地超市买的


161
00:06:09,416 --> 00:06:10,796
准备作为日常饮品的


162
00:06:10,796 --> 00:06:11,546
杂牌咖啡


163
00:06:12,936 --> 00:06:15,876
“卡住了？” 他说


164
00:06:16,086 --> 00:06:18,016
“是的” 我叹了口气


165
00:06:18,016 --> 00:06:19,216
并向他解释情况


166
00:06:19,706 --> 00:06:24,556
“那么 你有为此


167
00:06:24,556 --> 00:06:25,796
看过文档吗？”


168
00:06:27,826 --> 00:06:29,916
显然我没有 所以我呼出了


169
00:06:29,916 --> 00:06:31,516
remove(at: ) 的 “Quick Help（快速帮助）”


170
00:06:31,806 --> 00:06:33,526
Crusty 靠近了一点


171
00:06:34,316 --> 00:06:35,856
“你的问题就在这” 


172
00:06:35,856 --> 00:06:38,986
他说 并在我华丽的


173
00:06:38,986 --> 00:06:41,036
视网膜显示屏上留下了一个指纹


174
00:06:42,906 --> 00:06:45,506
我用一块手工制作的


175
00:06:45,546 --> 00:06:47,216
意大利超细纤维布


176
00:06:47,216 --> 00:06:50,596
小心地擦掉了指纹


177
00:06:50,596 --> 00:06:53,386
这时 Crusty 说 “小子


178
00:06:53,996 --> 00:06:54,856
它告诉你了什么”


179
00:06:55,096 --> 00:06:57,516
“唔” 我说 “它说


180
00:06:57,596 --> 00:06:59,056
移除一个元素


181
00:06:59,056 --> 00:07:01,216
需要使用大量的步骤


182
00:07:01,216 --> 00:07:02,476
而且与数组的长度成正比”


183
00:07:02,476 --> 00:07:04,456
这的确有些道理


184
00:07:04,456 --> 00:07:06,686
因为数组需要将


185
00:07:06,686 --> 00:07:08,316
之后所有的元素


186
00:07:08,316 --> 00:07:09,186
放入它们的新位置


187
00:07:10,996 --> 00:07:12,466
“那么 这对你的删除选择指令


188
00:07:12,466 --> 00:07:14,996
又有什么意义呢” 他问道


189
00:07:16,166 --> 00:07:17,646
“呃” 我说


190
00:07:18,186 --> 00:07:21,606
就在这时他拿出


191
00:07:21,606 --> 00:07:22,976
一包薄荷糖


192
00:07:22,976 --> 00:07:24,086
然后排成线放在我的桌子上


193
00:07:24,756 --> 00:07:25,596
“你自己试一试”


194
00:07:27,246 --> 00:07:29,216
所以我走完一遍流程


195
00:07:29,216 --> 00:07:30,656
试图回答他的问题


196
00:07:30,896 --> 00:07:32,096
“嗯 既然删除选择指令


197
00:07:32,096 --> 00:07:34,116
需要进行 O(n) 个步骤


198
00:07:34,116 --> 00:07:35,486
每一步都对应每一个已选的元素


199
00:07:35,486 --> 00:07:36,996
而且你可以选择最多 n 个元素


200
00:07:37,276 --> 00:07:38,396
那么总步数将与


201
00:07:38,396 --> 00:07:40,906
n 的二次方成正比”


202
00:07:42,276 --> 00:07:44,356
Crusty 继续说 “那可是二次方


203
00:07:44,356 --> 00:07:46,296
小子 无论你用丑陋的方式正着走


204
00:07:46,296 --> 00:07:48,186
还是穿着花哨的


205
00:07:48,186 --> 00:07:50,346
裤子倒着来”


206
00:07:50,976 --> 00:07:54,106
我那时才意识到


207
00:07:54,106 --> 00:07:56,036
对于我的 10 到 20 个元素的


208
00:07:56,036 --> 00:07:58,006
小型测试案例 我们只需使用


209
00:07:58,006 --> 00:08:00,376
几百个步骤


210
00:08:00,376 --> 00:08:01,936
由于每一步都运行迅速


211
00:08:02,046 --> 00:08:02,876
一切看起来棒极了


212
00:08:04,116 --> 00:08:05,396
但是问题是


213
00:08:05,396 --> 00:08:06,296
它的延展性不足


214
00:08:06,796 --> 00:08:10,576
50 的二次方是 2500


215
00:08:10,576 --> 00:08:11,986
100 的二次方更能达到 10000


216
00:08:12,546 --> 00:08:15,326
如果你所做的所有测试


217
00:08:15,326 --> 00:08:17,186
都在这个狭小范围之内


218
00:08:17,476 --> 00:08:18,766
那你可能永远发现不了问题


219
00:08:19,336 --> 00:08:21,746
但是延展性很重要


220
00:08:21,746 --> 00:08:23,336
因为人们正在使用他们的手机和 iPad


221
00:08:23,336 --> 00:08:25,626
处理越来越多的数据


222
00:08:25,626 --> 00:08:27,376
我们也一直提供带有


223
00:08:27,376 --> 00:08:29,096
更多存储空间的设备


224
00:08:29,096 --> 00:08:29,586
帮助他们这么做


225
00:08:30,606 --> 00:08:32,346
你们要关心这一点


226
00:08:32,346 --> 00:08:34,476
因为对你们的用户而言


227
00:08:34,476 --> 00:08:35,296
延展性意味着可预测性


228
00:08:35,826 --> 00:08:39,946
所以 我理解了问题所在


229
00:08:39,946 --> 00:08:41,986
但是我仍然不能确定


230
00:08:41,986 --> 00:08:42,746
我应该怎么解决它


231
00:08:43,326 --> 00:08:43,706
“现在我该怎么办？”


232
00:08:43,706 --> 00:08:44,446
我问 Crusty


233
00:08:45,526 --> 00:08:47,056
“你知道吗 小伙子” 他一边说


234
00:08:47,496 --> 00:08:49,776
一边把一粒薄荷糖放到嘴里


235
00:08:49,776 --> 00:08:51,466
“有一个解决这个问题的算法”


236
00:08:53,056 --> 00:08:56,236
我和他说 “听着 Crusty


237
00:08:56,236 --> 00:08:57,176
我是一个 App 开发者


238
00:08:58,226 --> 00:09:00,716
你说过你不做面向对象的东西


239
00:09:00,716 --> 00:09:02,646
同样 我也不做算法


240
00:09:03,276 --> 00:09:04,406
你关注在算法类中的


241
00:09:04,406 --> 00:09:06,066
数据结构


242
00:09:06,396 --> 00:09:08,036
因为你知道


243
00:09:08,036 --> 00:09:09,806
找工作的时候


244
00:09:09,806 --> 00:09:10,946
你的面试官会考你


245
00:09:11,346 --> 00:09:12,776
但在真正的编程世界


246
00:09:12,776 --> 00:09:14,766
区分大神和菜鸟的关键


247
00:09:14,926 --> 00:09:16,946
是将控制器 委托


248
00:09:16,946 --> 00:09:18,396
以及响应程序


249
00:09:18,396 --> 00:09:19,766
连接在一起


250
00:09:19,766 --> 00:09:22,546
构建一个工作系统的能力”


251
00:09:22,996 --> 00:09:24,906
“豆包” 他说 


252
00:09:24,906 --> 00:09:27,276
我不知道为什么他这么称呼我


253
00:09:27,506 --> 00:09:28,656
“计算机是做什么的”


254
00:09:30,096 --> 00:09:30,816
“它们计算”


255
00:09:31,796 --> 00:09:33,086
“那么 你的代码中的计算


256
00:09:33,086 --> 00:09:34,286
在哪里呢”


257
00:09:35,356 --> 00:09:37,966
“好吧” 我回答 


258
00:09:37,966 --> 00:09:39,106
“我想在我的代码里


259
00:09:39,106 --> 00:09:40,496
我看不见什么东西像个算法”


260
00:09:41,046 --> 00:09:43,296
但是 Crusty 不这么认为


261
00:09:43,806 --> 00:09:45,106
“哦 你的 App 里面可全都是算法”


262
00:09:45,106 --> 00:09:46,646
他说 接着将一本破旧的字典


263
00:09:46,646 --> 00:09:47,956
扔在我的桌子上


264
00:09:48,526 --> 00:09:50,496
“翻翻看”


265
00:09:51,266 --> 00:09:54,066
在我镇定下来后


266
00:09:54,066 --> 00:09:55,396
我小心地将书移到一边


267
00:09:55,396 --> 00:09:57,226
在聚焦搜索栏中输入


268
00:09:57,226 --> 00:09:58,886
“define: Algorithm (定义：算法)”


269
00:09:58,886 --> 00:10:00,000
Crusty 认为这是个巧妙的技巧


270
00:10:03,976 --> 00:10:04,976
嗯


271
00:10:05,046 --> 00:10:06,876
在计算或其他解决问题的


272
00:10:06,876 --> 00:10:08,656
运算中


273
00:10:08,656 --> 00:10:10,416
要遵循的过程或规则集


274
00:10:11,756 --> 00:10:13,356
好吧 细想一下


275
00:10:13,806 --> 00:10:16,016
这听起来像大多数的代码


276
00:10:16,016 --> 00:10:16,906
但是我仍不能确定


277
00:10:18,036 --> 00:10:19,446
“你有做过长除法吗”


278
00:10:19,596 --> 00:10:20,236
Crusty 问道


279
00:10:20,646 --> 00:10:21,576
“那就是一个算法”


280
00:10:25,766 --> 00:10:27,606
我又开始将它打到聚焦搜索中


281
00:10:27,606 --> 00:10:29,266
但是他突然说


282
00:10:29,266 --> 00:10:29,646
“在纸上算”


283
00:10:30,306 --> 00:10:31,616
不想让自己难堪


284
00:10:31,616 --> 00:10:32,746
我把话题转回到


285
00:10:32,746 --> 00:10:33,476
我的代码上


286
00:10:35,316 --> 00:10:35,386
“嗯”


287
00:10:36,256 --> 00:10:39,926
我问 “所以 这个可以解决


288
00:10:39,926 --> 00:10:41,666
我的代码性能问题的


289
00:10:41,666 --> 00:10:42,856
神奇的算法是什么呢”


290
00:10:44,126 --> 00:10:45,496
“那么 如果你愿意


291
00:10:45,496 --> 00:10:46,976
让我用一下你的打字机”


292
00:10:46,976 --> 00:10:48,626
他说 “这个东西怎么用


293
00:10:48,626 --> 00:10:49,816
哦 这是一个触控板


294
00:10:49,816 --> 00:10:50,826
我会尽量不碰它


295
00:10:51,226 --> 00:10:53,356
所以首先 你要删掉这些


296
00:10:53,356 --> 00:10:54,330
愚蠢的代码


297
00:10:57,046 --> 00:11:00,676
然后 shapes.removeAll


298
00:11:00,676 --> 00:11:02,186
(where: { $0.isSelected})


299
00:11:03,146 --> 00:11:03,326
嗯


300
00:11:04,026 --> 00:11:05,236
试试合不合身”


301
00:11:06,216 --> 00:11:07,756
然后 Crusty 离开了


302
00:11:07,756 --> 00:11:08,856
去洗他的咖啡机的拉花缸


303
00:11:08,856 --> 00:11:11,066
留下我去琢磨


304
00:11:11,066 --> 00:11:12,816
我的代码里到底


305
00:11:13,666 --> 00:11:13,766
发生了什么


306
00:11:14,736 --> 00:11:17,756
首先 我检查过并且发现


307
00:11:17,756 --> 00:11:19,286
性能问题确实解决了


308
00:11:19,856 --> 00:11:20,226
太棒了


309
00:11:21,536 --> 00:11:22,886
我不想再听一遍


310
00:11:22,886 --> 00:11:24,226
Crusty 唠叨说看文档


311
00:11:24,226 --> 00:11:26,626
所以我弹出 removeAll(where: ) 的


312
00:11:26,626 --> 00:11:28,126
“Quick Help”


313
00:11:28,676 --> 00:11:32,856
然后我发现它的复杂度


314
00:11:32,856 --> 00:11:34,266
也与集合的长度


315
00:11:34,266 --> 00:11:36,176
成正地变化


316
00:11:36,176 --> 00:11:36,806
就像 removeAt 一样


317
00:11:37,796 --> 00:11:39,656
但是由于我不必


318
00:11:39,656 --> 00:11:41,576
把它放入循环中


319
00:11:41,576 --> 00:11:42,836
那么它就变成了我整个


320
00:11:42,836 --> 00:11:43,376
运算的复杂度


321
00:11:44,576 --> 00:11:46,776
现在 我想让你们


322
00:11:46,776 --> 00:11:48,026
直观地理解


323
00:11:48,106 --> 00:11:50,106
这能带来什么不同


324
00:11:50,566 --> 00:11:52,476
O(n) 表示算法运行的时间


325
00:11:52,476 --> 00:11:54,216
与问题的大小


326
00:11:54,566 --> 00:11:56,166
成线性关系


327
00:11:56,696 --> 00:11:57,936
这个图是一条直线


328
00:11:59,396 --> 00:12:00,826
然后 这个橙色线是


329
00:12:00,826 --> 00:12:02,076
n 的二次方的形状


330
00:12:03,356 --> 00:12:04,846
正如你所见


331
00:12:04,846 --> 00:12:06,406
线性算法也许在小型问题中


332
00:12:06,406 --> 00:12:07,956
表现稍差


333
00:12:07,956 --> 00:12:09,596
但他最终比


334
00:12:09,596 --> 00:12:10,606
二次方算法运行更快


335
00:12:11,926 --> 00:12:13,716
很棒的是


336
00:12:13,716 --> 00:12:15,546
不管你用线性算法


337
00:12:15,546 --> 00:12:16,856
的成本有多高


338
00:12:16,856 --> 00:12:19,226
如果你继续放更大的问题尺寸


339
00:12:19,226 --> 00:12:22,456
你总是会找到


340
00:12:22,566 --> 00:12:24,736
一个线性算法会赢


341
00:12:24,736 --> 00:12:27,206
并且在后面


342
00:12:27,206 --> 00:12:28,206
一直赢的点


343
00:12:29,346 --> 00:12:30,506
所以 我们正在讨论的是


344
00:12:30,506 --> 00:12:33,000
延展性 而不是绝对的性能


345
00:12:36,436 --> 00:12:40,346
好了 我的延展性问题终于解决了


346
00:12:40,346 --> 00:12:42,316
但我真的很想看看


347
00:12:42,316 --> 00:12:44,196
标准程序库如何改进


348
00:12:44,196 --> 00:12:46,616
我倒着来的删除方法


349
00:12:47,886 --> 00:12:49,586
Crusty 提醒我说


350
00:12:49,586 --> 00:12:50,986
Swift 是开放源码 所以我可以把它


351
00:12:50,986 --> 00:12:53,426
放在他口中的“嬉皮士网”上


352
00:12:53,816 --> 00:12:55,500
也就是我们其他人所知的 GitHub


353
00:12:59,266 --> 00:13:00,776
现在 我注意到的第一件事


354
00:13:00,776 --> 00:13:03,106
便是点注释


355
00:13:03,136 --> 00:13:04,456
它是所有 “Quick Help” 的来源


356
00:13:04,456 --> 00:13:09,136
描述了算法的功能以及复杂度


357
00:13:09,596 --> 00:13:14,046
接下来 结果是


358
00:13:14,046 --> 00:13:15,946
removeAll(where) 不是什么


359
00:13:15,946 --> 00:13:18,486
常规的方法


360
00:13:18,486 --> 00:13:20,466
它是一个通用的算法


361
00:13:20,466 --> 00:13:22,126
这意味着


362
00:13:22,126 --> 00:13:22,926
它可以在各种不同的集合上运行


363
00:13:24,286 --> 00:13:25,296
这取决于很多因素


364
00:13:25,296 --> 00:13:28,376
重新排列元素的能力


365
00:13:28,376 --> 00:13:29,556
它来自于


366
00:13:29,556 --> 00:13:31,636
MutableCollection


367
00:13:31,966 --> 00:13:34,626
改变长度和结构的能力


368
00:13:34,626 --> 00:13:36,506
它来自于


369
00:13:36,506 --> 00:13:37,656
RangeReplaceableCollection


370
00:13:38,186 --> 00:13:41,606
它是由一些其他的


371
00:13:41,606 --> 00:13:43,206
O(n) 算法构成的


372
00:13:44,016 --> 00:13:46,126
第一个是 halfStablePartition


373
00:13:46,126 --> 00:13:48,096
它将所有


374
00:13:48,096 --> 00:13:49,416
满足某些谓词的元素


375
00:13:49,416 --> 00:13:53,456
移动到末尾


376
00:13:53,456 --> 00:13:54,846
并告诉我们后缀从哪里开始


377
00:13:56,136 --> 00:13:57,786
halfStable 正如其名


378
00:13:58,186 --> 00:14:00,196
表明了


379
00:14:00,196 --> 00:14:02,116
它保留了不移动的


380
00:14:02,116 --> 00:14:03,646
元素的顺序


381
00:14:04,486 --> 00:14:06,396
但是它也可以打乱


382
00:14:06,436 --> 00:14:09,026
移动到最后的元素


383
00:14:09,206 --> 00:14:10,426
有些时候


384
00:14:10,426 --> 00:14:11,786
这不是很重要


385
00:14:11,786 --> 00:14:13,166
因为第二个算法 removeSubrange()


386
00:14:13,166 --> 00:14:14,146
无论如何也会


387
00:14:14,146 --> 00:14:14,456
删除子区间


388
00:14:16,476 --> 00:14:17,956
我们都见过这个


389
00:14:17,956 --> 00:14:18,696
部分区间的标记吗


390
00:14:19,256 --> 00:14:21,426
它是一种非常方便的


391
00:14:21,426 --> 00:14:22,656
方式来编写扩展到


392
00:14:22,656 --> 00:14:24,000
集合末尾的范围


393
00:14:26,896 --> 00:14:27,116
好的


394
00:14:27,846 --> 00:14:29,986
现在 removeSubrange 是


395
00:14:29,986 --> 00:14:31,826
库全局 API 的一部分


396
00:14:31,826 --> 00:14:33,496
因此你可以在网上找到它的文档


397
00:14:33,496 --> 00:14:36,276
但是 halfStablePartition


398
00:14:36,456 --> 00:14:37,696
是一个运行的细节


399
00:14:38,236 --> 00:14:42,166
现在 我们不打算


400
00:14:42,166 --> 00:14:43,556
一一介绍 但是这里有一些


401
00:14:43,556 --> 00:14:45,116
值得注意的地方


402
00:14:46,516 --> 00:14:48,846
首先 它一开始


403
00:14:48,846 --> 00:14:49,696
调用另一个算法


404
00:14:50,486 --> 00:14:52,596
firstIndex(where: )


405
00:14:52,856 --> 00:14:54,716
来查找属于后缀的


406
00:14:54,716 --> 00:14:55,796
第一个元素的位置


407
00:14:57,176 --> 00:14:58,766
接下来 它设置了一个循环变量 j


408
00:14:58,766 --> 00:15:01,126
有一个循环


409
00:15:01,616 --> 00:15:04,906
然后这个循环指数 j 在每次迭代中


410
00:15:05,046 --> 00:15:06,646
会从前向后移动一位


411
00:15:07,696 --> 00:15:09,196
所以 可以肯定的是


412
00:15:09,196 --> 00:15:10,716
j 只对元素进行了一次传递


413
00:15:11,116 --> 00:15:14,086
你几乎可以从这里看到


414
00:15:14,086 --> 00:15:20,306
量级和复杂度


415
00:15:20,516 --> 00:15:22,106
最后 由于该方法


416
00:15:22,106 --> 00:15:23,526
需要重新排列元素


417
00:15:23,526 --> 00:15:24,726
但不更改


418
00:15:24,726 --> 00:15:26,396
集合的长度或结构 


419
00:15:26,396 --> 00:15:27,506
因此它只依赖于对


420
00:15:27,506 --> 00:15:28,606
MutableCollection 的遵循


421
00:15:29,146 --> 00:15:32,676
所以 这就是我学到的第一堂课


422
00:15:33,686 --> 00:15:34,966
熟悉 Swift


423
00:15:34,966 --> 00:15:36,166
标准库中的内容


424
00:15:37,176 --> 00:15:38,606
它包含一组


425
00:15:38,606 --> 00:15:40,416
提供文档描述


426
00:15:40,416 --> 00:15:42,316
和性能特征的算法


427
00:15:43,406 --> 00:15:45,526
虽然我们看了一点执行过程


428
00:15:45,526 --> 00:15:47,416
你也可以从中学到很多东西


429
00:15:47,416 --> 00:15:49,126
但由于它是设计好的


430
00:15:49,156 --> 00:15:50,946
所以你不必用我之前的笨方法


431
00:15:52,426 --> 00:15:53,756
官方文档会告诉你


432
00:15:53,756 --> 00:15:55,046
需要知道的一切


433
00:15:55,046 --> 00:15:58,006
以便有效地使用该库


434
00:15:58,996 --> 00:16:00,126
你甚至可以在那找到


435
00:16:00,126 --> 00:16:00,846
一个 Playground 教程


436
00:16:01,906 --> 00:16:03,856
我知道 Swift 中有很多内容


437
00:16:03,856 --> 00:16:05,436
所以它的确可能看起来很吓人


438
00:16:06,196 --> 00:16:07,706
但是你不需要记住一切


439
00:16:08,696 --> 00:16:10,066
知道那里有什么


440
00:16:10,066 --> 00:16:12,156
以及如何找到它将


441
00:16:12,156 --> 00:16:13,326
为你省下很多精力


442
00:16:14,396 --> 00:16:16,466
现在 在我们继续之前


443
00:16:16,466 --> 00:16:18,326
我想指出


444
00:16:18,326 --> 00:16:19,576
当 Crusty 做出此更改时


445
00:16:19,576 --> 00:16:20,276
在代码中发生的其他事情


446
00:16:21,136 --> 00:16:22,816
这两个中哪一个最直接地


447
00:16:22,816 --> 00:16:23,776
描述了它的意义


448
00:16:24,346 --> 00:16:27,166
现在 我必须先通读


449
00:16:27,226 --> 00:16:28,406
并思考第一个


450
00:16:28,406 --> 00:16:29,216
才能知道它在做什么


451
00:16:30,086 --> 00:16:30,376
嗯


452
00:16:30,616 --> 00:16:31,836
也许我最好加个注释


453
00:16:32,806 --> 00:16:33,026
好的


454
00:16:33,026 --> 00:16:33,646
看起来怎么样


455
00:16:34,196 --> 00:16:35,836
哦 即使有了评论


456
00:16:35,836 --> 00:16:37,156
反向迭代仍旧有点棘手


457
00:16:37,156 --> 00:16:38,356
而且我也不想


458
00:16:38,356 --> 00:16:40,826
有人因为他们不理解而破坏


459
00:16:40,826 --> 00:16:40,946
这个代码


460
00:16:41,266 --> 00:16:45,046
所以我最好解释一下


461
00:16:45,256 --> 00:16:45,726
好的


462
00:16:46,126 --> 00:16:47,596
当我们一一澄清时


463
00:16:47,656 --> 00:16:49,866
Crusty 改过的代码实际上更好理解


464
00:16:49,866 --> 00:16:50,956
因为它有一个


465
00:16:50,956 --> 00:16:51,606
尾随闭包语法


466
00:16:51,966 --> 00:16:54,896
现在 让我们深呼吸


467
00:16:54,896 --> 00:16:55,196
然后再看


468
00:16:56,606 --> 00:16:58,346
哪一个更明显是正确的


469
00:16:59,526 --> 00:17:00,956
即使带有这些评论


470
00:17:00,956 --> 00:17:02,016
我仍然需要通读第一个


471
00:17:02,016 --> 00:17:03,936
去明白它其实和第二个


472
00:17:03,936 --> 00:17:05,886
做的是同样的事


473
00:17:05,955 --> 00:17:06,976
但是效率更低


474
00:17:08,056 --> 00:17:09,465
使用这个算法可以使代码


475
00:17:09,465 --> 00:17:10,955
在各个方面都做得更好


476
00:17:11,526 --> 00:17:15,356
所以 这是你的代码的


477
00:17:15,356 --> 00:17:16,955
一个准则 也是一个目标


478
00:17:16,986 --> 00:17:18,486
是由 Sean Parent 首先提出的


479
00:17:19,636 --> 00:17:20,836
每当你编写一个循环时


480
00:17:21,316 --> 00:17:22,526
就用对某个算法的调用


481
00:17:22,526 --> 00:17:23,046
来替换它


482
00:17:23,846 --> 00:17:25,955
如果你找不到对应的算法


483
00:17:25,955 --> 00:17:27,366
就自己做一个算法


484
00:17:27,366 --> 00:17:28,656
然后用这个算法来执行循环


485
00:17:30,656 --> 00:17:32,496
实际上 现在对你来说


486
00:17:32,496 --> 00:17:34,156
这似乎是不现实的


487
00:17:34,196 --> 00:17:36,166
但是在谈话的最后


488
00:17:36,516 --> 00:17:37,056
我希望它不再是这样


489
00:17:38,096 --> 00:17:39,356
不过为了获得一点动力


490
00:17:39,856 --> 00:17:42,246
回想一下上一次


491
00:17:42,246 --> 00:17:43,536
你看到乱得像面条一样的代码的时候


492
00:17:44,066 --> 00:17:46,296
是不是充满了循环


493
00:17:47,506 --> 00:17:50,276
我打赌一定是


494
00:17:50,766 --> 00:17:51,236
好吧


495
00:17:51,386 --> 00:17:52,286
大功告成


496
00:17:52,506 --> 00:17:53,666
我已经使代码


497
00:17:53,666 --> 00:17:56,066
变得更短 更快 


498
00:17:56,066 --> 00:17:56,686
在各个方面都更好


499
00:17:56,686 --> 00:17:58,726
我准备今天到此为止


500
00:17:59,376 --> 00:18:00,546
“感谢你的帮助 Crusty”


501
00:18:00,546 --> 00:18:02,576
我说 同时系上


502
00:18:02,576 --> 00:18:05,036
我定制的皮革邮差包上的钛制钩环


503
00:18:05,036 --> 00:18:07,336
但他怀疑地看着我


504
00:18:07,336 --> 00:18:09,586
然后说


505
00:18:09,586 --> 00:18:10,966
“你不认为你可能在别的地方


506
00:18:10,966 --> 00:18:12,330
犯过那样的错误吗”


507
00:18:14,166 --> 00:18:16,746
我叹了口气 把包放下


508
00:18:16,746 --> 00:18:18,746
开始追踪我代码中的循环


509
00:18:20,016 --> 00:18:21,786
然后我发现 在处理层级命令的


510
00:18:22,106 --> 00:18:24,106
文件中 有很多


511
00:18:24,426 --> 00:18:28,666
放到最前 放到最后


512
00:18:29,596 --> 00:18:31,126
向前移动一层


513
00:18:31,126 --> 00:18:32,686
也就是把选定的图形移到


514
00:18:32,686 --> 00:18:33,486
前面的图形上


515
00:18:34,746 --> 00:18:38,206
让我们来多做几次吧


516
00:18:38,406 --> 00:18:40,536
向后移动


517
00:18:40,536 --> 00:18:41,756
放在选定的图形下面


518
00:18:41,756 --> 00:18:45,486
最后


519
00:18:45,486 --> 00:18:49,776
在左边的图形列表中拖拽


520
00:18:49,776 --> 00:18:52,196
现在 这些操作听起来非常简单


521
00:18:52,746 --> 00:18:56,126
直到你意识到


522
00:18:56,126 --> 00:18:57,566
它们都需要对多个选定的图形进行操作


523
00:18:57,566 --> 00:18:59,096
这些图形在列表中


524
00:18:59,096 --> 00:19:01,316
甚至可能都不是连续的


525
00:19:05,226 --> 00:19:06,486
因此结果表明 


526
00:19:06,486 --> 00:19:07,906
在操作完成后


527
00:19:07,906 --> 00:19:09,166
将所有选定的元素


528
00:19:09,166 --> 00:19:10,826
放在一起


529
00:19:10,826 --> 00:19:12,126
才是有意义的


530
00:19:13,126 --> 00:19:14,176
所以 当你把图形向前移动时


531
00:19:14,176 --> 00:19:15,596
你把选定的最前面的图形


532
00:19:15,596 --> 00:19:17,136
放在紧邻它的图形前面


533
00:19:17,136 --> 00:19:18,936
然后你把所有其他的图形


534
00:19:18,936 --> 00:19:20,566
放在它后面


535
00:19:22,386 --> 00:19:23,736
当你向后移动图形时


536
00:19:23,776 --> 00:19:25,496
你把选定的最后面的图形


537
00:19:25,496 --> 00:19:26,926
放在紧邻它的图形后面


538
00:19:26,926 --> 00:19:28,396
然后把其他的图形


539
00:19:28,396 --> 00:19:30,366
放在它前面


540
00:19:33,756 --> 00:19:36,256
如果你没有完全跟上


541
00:19:36,256 --> 00:19:37,626
不要担心


542
00:19:37,626 --> 00:19:38,526
我们会回头再讲


543
00:19:38,856 --> 00:19:41,386
但我只想说


544
00:19:41,386 --> 00:19:42,836
我有一些精心设计的代码


545
00:19:42,836 --> 00:19:44,606
来正确地处理所有这些细节 就足够了


546
00:19:45,866 --> 00:19:47,996
例如 这是 bringToFront()


547
00:19:47,996 --> 00:19:51,256
当我看到它时


548
00:19:51,256 --> 00:19:53,656
我十分地确定


549
00:19:53,656 --> 00:19:55,366
这些图形有一个 O(n) 的循环


550
00:19:55,956 --> 00:19:57,716
还包含两个 O(n) 的运算


551
00:19:57,716 --> 00:20:00,186
remove(at:)  insert(at:)


552
00:20:00,186 --> 00:20:02,756
这就产生了


553
00:20:03,246 --> 00:20:04,786
没错 n 的二次方


554
00:20:06,246 --> 00:20:08,526
事实上 同样的问题


555
00:20:08,526 --> 00:20:10,076
出现在每一个


556
00:20:10,076 --> 00:20:11,076
我其他的四个命令中


557
00:20:12,516 --> 00:20:14,046
这里的所有执行


558
00:20:14,386 --> 00:20:16,196
都对数组进行循环


559
00:20:16,196 --> 00:20:17,936
执行插入和删除操作


560
00:20:17,936 --> 00:20:19,126
这意味着它们都是二次的


561
00:20:19,626 --> 00:20:23,096
现在 我有点气馁


562
00:20:23,096 --> 00:20:24,996
所以我问 Crusty


563
00:20:24,996 --> 00:20:26,106
他是否愿意和我一起看


564
00:20:27,406 --> 00:20:29,106
他说 “我不能待太晚”


565
00:20:29,186 --> 00:20:31,156
他说 “我今晚有一个


566
00:20:31,156 --> 00:20:33,096
交际舞聚会 但是我想


567
00:20:33,226 --> 00:20:34,546
我们还是抓紧继续吧”


568
00:20:35,306 --> 00:20:37,486
我在 bringToFront() 这里停下来


569
00:20:38,686 --> 00:20:40,946
Crusty 的第一个问题是


570
00:20:42,156 --> 00:20:44,546
“它到底是做什么的”


571
00:20:45,846 --> 00:20:47,566
“好吧” 我说 “这是个 while 循环


572
00:20:47,566 --> 00:20:49,426
j 跟踪插入点


573
00:20:49,426 --> 00:20:51,266
i 跟踪我们正在


574
00:20:51,266 --> 00:20:51,906
查看的元素


575
00:20:52,226 --> 00:20:54,216
“用语言 而不是用代码”


576
00:20:54,246 --> 00:20:57,126
Crusty 说“描述它”


577
00:20:58,146 --> 00:20:59,286
“好吧 我们来看看


578
00:20:59,776 --> 00:21:01,616
它将选定的图形移动到前面


579
00:21:01,616 --> 00:21:04,176
保持它们的相对顺序”


580
00:21:04,706 --> 00:21:07,136
“把它写在点注释上


581
00:21:07,136 --> 00:21:08,376
然后读给我听”


582
00:21:10,406 --> 00:21:13,146
我是一个手速超快的打字员


583
00:21:15,236 --> 00:21:17,416
“将选定的图形移动到前面


584
00:21:17,416 --> 00:21:19,286
保持它们的相对顺序”


585
00:21:19,706 --> 00:21:21,766
“听起来熟悉吗”


586
00:21:22,186 --> 00:21:22,796
Crusty 说


587
00:21:24,066 --> 00:21:25,276
就在那时我意识到


588
00:21:25,276 --> 00:21:26,736
它很像 halfStablePartition


589
00:21:26,766 --> 00:21:29,676
但它是完全稳定的


590
00:21:29,676 --> 00:21:32,046
我开始激动起来


591
00:21:32,556 --> 00:21:34,226
“你觉得这个叫什么”


592
00:21:34,906 --> 00:21:36,516
我不得不猜


593
00:21:36,516 --> 00:21:37,026
“stablePartition”


594
00:21:37,566 --> 00:21:38,346
“没错


595
00:21:38,536 --> 00:21:41,126
我最喜欢的一个


596
00:21:41,126 --> 00:21:42,426
你可以在这个 Swift 开源项目中


597
00:21:42,426 --> 00:21:43,946
找到一个


598
00:21:43,946 --> 00:21:45,486
执行文件”


599
00:21:46,356 --> 00:21:48,396
因此 我把文件拖进了我的项目中


600
00:21:48,396 --> 00:21:50,006
同时 Crusty 含糊地说


601
00:21:50,006 --> 00:21:51,266
我们添加的注释


602
00:21:51,266 --> 00:21:52,206
应该在一开始就写上


603
00:21:52,206 --> 00:21:55,756
我开始编写代码


604
00:21:56,936 --> 00:22:00,196
写了这么多 就又遇到了一个问题


605
00:22:01,666 --> 00:22:03,716
你看 stablePartition 使用了一个谓词


606
00:22:03,716 --> 00:22:06,306
它表示是否将元素


607
00:22:06,306 --> 00:22:09,126
移动到集合的后缀中


608
00:22:09,946 --> 00:22:11,326
所以 要把东西搬到后面


609
00:22:11,516 --> 00:22:13,496
我需要执行


610
00:22:13,496 --> 00:22:14,046
bringToFront()


611
00:22:15,406 --> 00:22:16,256
我看向 Crusty


612
00:22:17,276 --> 00:22:19,286
“脑补一下” 他说


613
00:22:20,286 --> 00:22:21,986
于是 我闭上眼睛


614
00:22:22,646 --> 00:22:24,176
看着那些未被选中的图形


615
00:22:24,176 --> 00:22:25,936
聚集在后面


616
00:22:25,936 --> 00:22:26,616
这就给了我答案


617
00:22:27,226 --> 00:22:31,096
我猜 sendToBack 会更加简单


618
00:22:31,096 --> 00:22:32,436
因为我们只需


619
00:22:32,436 --> 00:22:33,276
反转谓词


620
00:22:33,836 --> 00:22:34,996
我们将选定的图形


621
00:22:35,056 --> 00:22:38,126
移动到后面


622
00:22:38,346 --> 00:22:40,566
现在 我正准备执行


623
00:22:40,566 --> 00:22:42,476
向前移动的命令


624
00:22:42,476 --> 00:22:43,986
我想 Crusty 会和我一样


625
00:22:43,986 --> 00:22:46,346
急于继续


626
00:22:46,346 --> 00:22:47,436
考虑到他晚上的计划


627
00:22:47,756 --> 00:22:48,376
但他阻止了我


628
00:22:49,296 --> 00:22:50,446
“刹车 Snuffy


629
00:22:51,616 --> 00:22:52,856
我不想错过开场探戈


630
00:22:52,856 --> 00:22:54,676
但你不打算看看


631
00:22:54,676 --> 00:22:55,926
它能不能延展尺寸吗”


632
00:22:57,326 --> 00:22:59,776
他有道理 所以我弹出 stablePartition 的


633
00:22:59,776 --> 00:23:00,766
“Quick Help”


634
00:23:00,806 --> 00:23:04,196
然后看到它的复杂度


635
00:23:04,416 --> 00:23:06,046
是 O(n log n) 


636
00:23:06,606 --> 00:23:09,356
为了有一个 O(n log n) 的概念


637
00:23:09,356 --> 00:23:11,506
我们不妨看看 O(log n)


638
00:23:12,096 --> 00:23:15,236
它从开始很快就进入


639
00:23:15,236 --> 00:23:17,246
平稳状态 n 越大


640
00:23:17,496 --> 00:23:19,856
它增长的越慢


641
00:23:19,886 --> 00:23:21,716
越接近一个常数


642
00:23:22,526 --> 00:23:24,136
所以当你乘 n 时


643
00:23:24,136 --> 00:23:27,366
你所得到延展性图像


644
00:23:27,566 --> 00:23:29,376
与 O(n) 的并不同


645
00:23:29,876 --> 00:23:31,466
但是随着它的增长它


646
00:23:31,466 --> 00:23:32,946
越来越接近线性


647
00:23:34,146 --> 00:23:36,696
所以 O(n log n) 


648
00:23:36,696 --> 00:23:38,556
通常被认为


649
00:23:38,556 --> 00:23:40,066
和 O(n) 差不多


650
00:23:40,896 --> 00:23:42,296
我对此十分开心


651
00:23:43,056 --> 00:23:44,326
所以我们继续处理


652
00:23:44,326 --> 00:23:44,696
bringFoward()


653
00:23:45,246 --> 00:23:49,646
现在 就像我们之前说过的


654
00:23:49,726 --> 00:23:51,626
bringFoward() 将最前面选定的图形


655
00:23:51,626 --> 00:23:53,006
向前移动一层


656
00:23:53,006 --> 00:23:55,296
并将后面的其他


657
00:23:55,296 --> 00:23:56,576
被选定的图形聚集起来


658
00:23:57,876 --> 00:24:00,156
但是 Crusty 根本不喜欢


659
00:24:00,156 --> 00:24:01,506
这种思考方法


660
00:24:02,146 --> 00:24:03,396
“刚开始的时候


661
00:24:03,396 --> 00:24:05,026
那个绕来绕去的东西 让那行代码


662
00:24:05,026 --> 00:24:06,096
像是在跳狐步舞狐步舞”


663
00:24:06,356 --> 00:24:08,466
他说 “你并不需要它”


664
00:24:09,096 --> 00:24:10,906
当我茫然地看着他的时候


665
00:24:10,906 --> 00:24:12,206
他又拿出了薄荷糖


666
00:24:13,976 --> 00:24:15,616
用他五根灵活的手指


667
00:24:15,616 --> 00:24:17,836
执行了


668
00:24:17,836 --> 00:24:19,926
bringForward() 指令


669
00:24:22,556 --> 00:24:23,506
“看到了吗”


670
00:24:23,776 --> 00:24:24,226
他问


671
00:24:25,416 --> 00:24:26,816
我感觉就像 明知道“赌徒三张”是一个陷阱


672
00:24:26,816 --> 00:24:33,976
但我还是踩了进去


673
00:24:34,256 --> 00:24:35,176
“看着熟悉吗”


674
00:24:36,336 --> 00:24:36,616
“不”


675
00:24:37,826 --> 00:24:40,006
他用手帕盖住了前几个


676
00:24:42,296 --> 00:24:46,366
“现在呢”


677
00:24:46,636 --> 00:24:48,876
就在这时我意识到


678
00:24:48,876 --> 00:24:50,226
这就是另一个 stablePartition


679
00:24:51,416 --> 00:24:51,766
好吧


680
00:24:52,236 --> 00:24:54,046
我明白了 我想


681
00:24:55,856 --> 00:24:58,096
如果我们找到选定的


682
00:24:58,096 --> 00:25:01,716
最前面的图形


683
00:25:01,746 --> 00:25:05,326
然后移动到它前面图形的位置


684
00:25:05,606 --> 00:25:07,086
并隔离从那里开始的数组的部分


685
00:25:07,086 --> 00:25:10,666
我们可以对它进行分区


686
00:25:12,236 --> 00:25:14,166
“但是，你如何只修改


687
00:25:14,166 --> 00:25:14,776
集合中的一部分呢”


688
00:25:14,976 --> 00:25:15,676
我问 Crusty


689
00:25:16,876 --> 00:25:18,296
“你难道没听说过切片吗”


690
00:25:18,526 --> 00:25:19,946
他说 同时接管了键盘


691
00:25:23,156 --> 00:25:25,106
“shapes


692
00:25:25,726 --> 00:25:26,336
[predecessor...]


693
00:25:27,656 --> 00:25:28,256
好了


694
00:25:28,256 --> 00:25:29,596
把它放在你的算法里


695
00:25:29,596 --> 00:25:30,146
然后进行变换”


696
00:25:30,896 --> 00:25:32,000
我立即照做


697
00:25:37,716 --> 00:25:41,456
因此 人类关于如何


698
00:25:41,456 --> 00:25:43,096
正确有效地


699
00:25:43,096 --> 00:25:44,976
计算事物的知识


700
00:25:44,976 --> 00:25:47,156
要比计算机早几千年


701
00:25:47,156 --> 00:25:48,846
至少可以追溯到古埃及


702
00:25:49,546 --> 00:25:50,656
自从计算机发明以来


703
00:25:50,656 --> 00:25:52,086
这一领域的工作


704
00:25:52,086 --> 00:25:53,696
出现了爆炸式增长


705
00:25:55,186 --> 00:25:56,586
如果标准库没有


706
00:25:56,586 --> 00:25:58,386
你所需要的


707
00:25:58,386 --> 00:26:00,556
那么你需要做的


708
00:26:00,556 --> 00:26:03,396
可能是测试 阅读文档


709
00:26:03,396 --> 00:26:04,786
通常更正后还要检查一下


710
00:26:05,746 --> 00:26:07,436
要学会如何在网络上


711
00:26:07,436 --> 00:26:08,746
搜索适用于


712
00:26:08,746 --> 00:26:10,086
你的问题领域的研究


713
00:26:12,716 --> 00:26:12,946
好的


714
00:26:12,946 --> 00:26:13,596
回到代码上来


715
00:26:14,076 --> 00:26:15,656
我对这个切片很感兴趣


716
00:26:15,706 --> 00:26:17,136
当我检查它的类型时


717
00:26:17,136 --> 00:26:20,156
我发现它不是一个数组


718
00:26:20,716 --> 00:26:23,306
由于我们是在一个数组上


719
00:26:23,306 --> 00:26:24,876
使用了 stablePartition


720
00:26:24,876 --> 00:26:27,216
bringToFront 以及 sendToBack


721
00:26:27,216 --> 00:26:28,776
现在我们还在一个数组切片上使用它


722
00:26:28,776 --> 00:26:30,876
所以我大胆猜测


723
00:26:30,876 --> 00:26:32,496
它一定是通用的


724
00:26:32,496 --> 00:26:34,636
“当然是


725
00:26:35,176 --> 00:26:36,446
stablePartition


726
00:26:36,446 --> 00:26:37,846
和特定的数组有什么关系”


727
00:26:39,166 --> 00:26:40,436
“没错 没有联系


728
00:26:41,336 --> 00:26:44,046
说到这 豆包


729
00:26:44,046 --> 00:26:45,416
bringForward() 与图形和选择


730
00:26:45,416 --> 00:26:46,946
又有什么关系呢”


731
00:26:48,616 --> 00:26:51,166
“嗯” 我说 “它作用于图形


732
00:26:51,166 --> 00:26:52,876
然后将选定的图形


733
00:26:52,876 --> 00:26:53,796
移到前面”


734
00:26:54,046 --> 00:26:55,936
“没错 也没关系”


735
00:26:55,936 --> 00:26:56,736
他听都没听便说道


736
00:26:58,636 --> 00:27:00,006
“你能在一排薄荷糖上


737
00:27:00,006 --> 00:27:00,926
执行向前移动吗


738
00:27:01,926 --> 00:27:03,106
当然 你可以


739
00:27:04,086 --> 00:27:05,516
所以 这和图形


740
00:27:06,206 --> 00:27:06,500
没有关系”


741
00:27:08,206 --> 00:27:08,446
嗯


742
00:27:08,896 --> 00:27:10,916
“你是在建议我们让它


743
00:27:10,916 --> 00:27:11,376
变得通用吗”


744
00:27:11,556 --> 00:27:12,056
我问道


745
00:27:12,676 --> 00:27:13,626
“难道它不早就是


746
00:27:13,626 --> 00:27:14,426
通用的了吗”


747
00:27:15,416 --> 00:27:16,546
用一个新问题回答了这个问题


748
00:27:16,546 --> 00:27:20,866
Crusty 回答道


749
00:27:20,866 --> 00:27:22,416
“唔 你打算怎样


750
00:27:22,416 --> 00:27:23,330
测试这个方法”


751
00:27:24,946 --> 00:27:26,736
“好的” 我说


752
00:27:26,736 --> 00:27:27,376
“我会创造一个画布


753
00:27:27,616 --> 00:27:29,186
我会添加一些随机的图形


754
00:27:29,186 --> 00:27:30,886
我会选定它们中的一些


755
00:27:30,886 --> 00:27:31,676
然后最终”


756
00:27:32,466 --> 00:27:33,776
但我的话没有说完


757
00:27:33,776 --> 00:27:35,506
因为我知道


758
00:27:35,506 --> 00:27:36,216
这是个坏主意


759
00:27:37,076 --> 00:27:39,126
如果我就这么做


760
00:27:39,126 --> 00:27:40,456
我真的会测试我的功能吗


761
00:27:40,966 --> 00:27:42,066
还是我会测试


762
00:27:42,066 --> 00:27:43,646
画布和不同图形的初始化设定


763
00:27:43,646 --> 00:27:45,606
addMethod() 方法


764
00:27:45,606 --> 00:27:47,776
再或者测试


765
00:27:47,976 --> 00:27:49,136
各种形状的 isSelected 属性是否


766
00:27:49,136 --> 00:27:49,706
计算出来


767
00:27:50,106 --> 00:27:52,356
我的确应该建立测试用例


768
00:27:52,356 --> 00:27:54,506
但是理想情况下


769
00:27:54,736 --> 00:27:56,266
那段代码不应取决于其他


770
00:27:56,266 --> 00:27:57,826
我需要再测试的代码


771
00:27:59,126 --> 00:28:00,506
如果我可以将薄荷糖向前移


772
00:28:00,506 --> 00:28:02,776
那么我也应有可能


773
00:28:02,776 --> 00:28:04,406
用 Playground 中的整数


774
00:28:04,866 --> 00:28:05,636
做一些随机的事


775
00:28:05,986 --> 00:28:08,226
就像这样 用 bringForward() 方法


776
00:28:08,226 --> 00:28:09,796
把能被 3 整除的数提到前面来


777
00:28:13,276 --> 00:28:14,596
现在 在频谱的另一端


778
00:28:14,596 --> 00:28:16,296
我应该可以向它抛出


779
00:28:16,296 --> 00:28:19,856
大量随机生成的测试数据


780
00:28:19,856 --> 00:28:21,256
并确保算法的


781
00:28:21,256 --> 00:28:22,386
可扩展性


782
00:28:23,246 --> 00:28:24,696
只要代码与画布和图形


783
00:28:24,696 --> 00:28:26,076
绑定在一起


784
00:28:26,116 --> 00:28:27,906
这些事情就都不会简单


785
00:28:29,146 --> 00:28:33,546
所以 我向 Crusty 承认他是对的


786
00:28:33,546 --> 00:28:34,846
并开始把这个非通用的


787
00:28:35,616 --> 00:28:37,106
bringForward() 变成通用的算法


788
00:28:38,436 --> 00:28:40,666
第一步是将它


789
00:28:40,666 --> 00:28:44,896
从画布中解耦出来 


790
00:28:44,896 --> 00:28:45,696
并将其移动到图形数组中


791
00:28:47,216 --> 00:28:49,266
当然 这个数组就是 shapes


792
00:28:49,266 --> 00:28:50,556
所以我必须用 self


793
00:28:50,556 --> 00:28:54,366
把它替换掉


794
00:28:54,366 --> 00:28:56,866
然后我通过传递一个谓词


795
00:28:56,866 --> 00:28:58,636
将它从选择中解耦出来


796
00:28:58,736 --> 00:29:00,046
该谓词指示是否应该将选定的图形


797
00:29:00,046 --> 00:29:00,866
向前移动


798
00:29:04,716 --> 00:29:06,156
一切都在正常编译着


799
00:29:07,036 --> 00:29:07,386
太棒了


800
00:29:08,266 --> 00:29:10,826
此时 我很高兴地发现


801
00:29:10,826 --> 00:29:12,086
在 shapes 上没有依赖


802
00:29:12,086 --> 00:29:14,266
我可以删除


803
00:29:14,426 --> 00:29:15,406
where 子句了


804
00:29:15,956 --> 00:29:18,106
非常好 我想


805
00:29:18,106 --> 00:29:20,106
现在 我可以在任何数组中


806
00:29:20,106 --> 00:29:20,506
执行 bringForward 了


807
00:29:21,636 --> 00:29:23,386
我看了看 Crusty 


808
00:29:23,386 --> 00:29:24,636
他一直在角落里


809
00:29:24,676 --> 00:29:26,876
安静地练习恰恰舞


810
00:29:26,876 --> 00:29:28,586
但他似乎认为我还


811
00:29:29,736 --> 00:29:30,000
没有结束


812
00:29:31,316 --> 00:29:32,996
“bringForward() 和数组


813
00:29:32,996 --> 00:29:37,196
有什么关系”他问


814
00:29:37,436 --> 00:29:38,976
“好吧 的确没有” 我叹了口气


815
00:29:38,976 --> 00:29:40,046
然后开始思考


816
00:29:40,046 --> 00:29:41,206
如何移除这个依赖


817
00:29:42,656 --> 00:29:43,706
让我们看看 


818
00:29:43,706 --> 00:29:46,066
这有一个 stablePartition()


819
00:29:46,066 --> 00:29:47,636
需要遵循 MutableCollection 


820
00:29:48,186 --> 00:29:49,416
所以 也许我只需要将它移动到


821
00:29:49,416 --> 00:29:52,676
MutableCollection 中


822
00:29:53,006 --> 00:29:53,466
嗯


823
00:29:53,896 --> 00:29:56,076
我想 显然索引类型


824
00:29:56,116 --> 00:29:59,746
与 int 类型不匹配 好吧


825
00:29:59,746 --> 00:30:01,000
这应该很好修复 对吧


826
00:30:04,216 --> 00:30:04,936
你是这么做的吗


827
00:30:06,176 --> 00:30:08,106
不要这么做


828
00:30:09,546 --> 00:30:11,326
它编译好了


829
00:30:11,326 --> 00:30:12,586
但是 Crusty 突然停止了跳舞


830
00:30:12,586 --> 00:30:15,156
我知道有些不对劲


831
00:30:15,366 --> 00:30:16,166
“什么” 我说


832
00:30:16,966 --> 00:30:18,836
“菜鸟总是这样做”


833
00:30:18,836 --> 00:30:20,036
Crusty 边摇着头边说


834
00:30:21,566 --> 00:30:23,216
“首先 你让它与 0 的比较


835
00:30:23,216 --> 00:30:26,056
这对于数组切片来说是错误的


836
00:30:26,686 --> 00:30:29,456
所以 你知道数组切片


837
00:30:29,456 --> 00:30:31,596
它们的索引不是


838
00:30:31,596 --> 00:30:32,216
从 0 开始的吗


839
00:30:32,216 --> 00:30:35,696
所有切片的索引


840
00:30:35,966 --> 00:30:37,506
从它们被切片的


841
00:30:37,506 --> 00:30:38,786
底层集合中的


842
00:30:38,786 --> 00:30:40,246
相应索引开始


843
00:30:40,796 --> 00:30:42,976
这种关系十分关键


844
00:30:42,976 --> 00:30:44,126
如果你想要用切片


845
00:30:44,126 --> 00:30:46,466
组成通用算法


846
00:30:47,056 --> 00:30:47,946
所以它真的很重要”


847
00:30:49,156 --> 00:30:52,406
好吧 我知道要修正这个问题


848
00:30:53,146 --> 00:30:54,126
只需将它与开始索引


849
00:30:54,126 --> 00:30:54,516
进行比较


850
00:30:55,766 --> 00:30:58,346
但是真正的问题是


851
00:30:58,346 --> 00:31:00,056
“bringForward() 与拥有整数索引


852
00:31:00,056 --> 00:31:01,846
有什么关系”


853
00:31:01,846 --> 00:31:02,576
我打断了他


854
00:31:03,416 --> 00:31:04,416
“是的 我知道”


855
00:31:05,266 --> 00:31:07,466
“我必须在 i 之前


856
00:31:07,466 --> 00:31:10,156
得到索引


857
00:31:10,156 --> 00:31:10,876
我可以用减法获得”


858
00:31:12,856 --> 00:31:14,976
Crusty 只是叹了口气


859
00:31:14,976 --> 00:31:15,906
然后又将薄荷糖拿了出来


860
00:31:17,466 --> 00:31:19,376
然后 他把两个手指


861
00:31:19,376 --> 00:31:22,156
放在桌子上 像小人一样走啊走


862
00:31:22,566 --> 00:31:24,966
直到右手指向


863
00:31:25,136 --> 00:31:27,276
第一块绿色的薄荷糖


864
00:31:27,806 --> 00:31:31,446
“整支舞中都没有


865
00:31:31,446 --> 00:31:32,506
向后的舞步” 他说


866
00:31:33,406 --> 00:31:35,286
之后我意识到 


867
00:31:35,286 --> 00:31:37,586
Crusty 刚刚向我展示了一个新的算法


868
00:31:38,636 --> 00:31:39,546
“我们叫它


869
00:31:39,696 --> 00:31:40,986
indexBeforeFirst 吧”


870
00:31:42,066 --> 00:31:43,776
“现在 这里的诀窍是


871
00:31:43,776 --> 00:31:46,086
保持注意力集中


872
00:31:46,086 --> 00:31:46,976
假设有人已经为你写了它”


873
00:31:47,826 --> 00:31:49,116
然后他把我们不需要的


874
00:31:49,116 --> 00:31:50,336
代码都删掉了


875
00:31:50,336 --> 00:31:53,906
像这样 这样


876
00:31:56,616 --> 00:32:00,866
“predecessor 就是第一个


877
00:32:00,866 --> 00:32:02,416
在谓词被满足之前的元素


878
00:32:02,416 --> 00:32:04,286
前面的索引


879
00:32:05,346 --> 00:32:06,656
现在 快来看看这读起来


880
00:32:06,656 --> 00:32:07,046
多么动人”


881
00:32:08,486 --> 00:32:10,946
如果你看到了这个代码


882
00:32:10,946 --> 00:32:11,706
你就会发现他是对的


883
00:32:13,116 --> 00:32:15,006
删除所有无关的细节


884
00:32:15,006 --> 00:32:17,436
包括图形 选择


885
00:32:17,546 --> 00:32:20,066
数据以及整数


886
00:32:20,066 --> 00:32:22,006
给我留下更清晰的代码


887
00:32:22,006 --> 00:32:23,626
因为它只处理


888
00:32:23,696 --> 00:32:24,356
问题的本质


889
00:32:24,926 --> 00:32:27,496
“我已经向你展示了


890
00:32:27,496 --> 00:32:28,956
indexBeforeFirst 是如何工作的


891
00:32:29,266 --> 00:32:32,236
试一试你能不能写出来” 他说


892
00:32:32,706 --> 00:32:34,036
所以 我想我现在开始


893
00:32:34,036 --> 00:32:36,016
跟得上他了


894
00:32:36,016 --> 00:32:37,036
因为我第一次做对了


895
00:32:37,666 --> 00:32:40,996
我说过 我是个手速超快的打字员


896
00:32:41,466 --> 00:32:41,726
好吧


897
00:32:42,236 --> 00:32:45,436
所以 返回第一个


898
00:32:45,436 --> 00:32:48,536
successor 与谓词匹配的索引


899
00:32:49,206 --> 00:32:51,556
我非常兴奋地看到


900
00:32:51,556 --> 00:32:52,396
这进展得有多么顺利


901
00:32:53,436 --> 00:32:54,456
“好吧 Crusty” 我说


902
00:32:54,766 --> 00:32:55,726
“让我们做下一个”


903
00:32:57,516 --> 00:32:58,946
“你难道没有忘记什么事吗


904
00:32:58,946 --> 00:33:00,586
豆包” 他问道


905
00:33:00,586 --> 00:33:02,306
我不知道


906
00:33:02,306 --> 00:33:02,906
他在说什么


907
00:33:03,466 --> 00:33:05,276
代码很简洁


908
00:33:05,276 --> 00:33:05,666
而且运行正常


909
00:33:07,016 --> 00:33:08,336
“语义 小子


910
00:33:09,046 --> 00:33:10,216
我怎么能从其他代码中使用它们


911
00:33:10,216 --> 00:33:11,416
如果我不知道


912
00:33:11,416 --> 00:33:12,156
它们是什么意思呢”


913
00:33:12,786 --> 00:33:17,156
于是我意识到


914
00:33:17,156 --> 00:33:18,926
每一次我们使用新的算法


915
00:33:19,446 --> 00:33:20,326
我们都依靠他的文档


916
00:33:20,326 --> 00:33:21,936
得出关于


917
00:33:21,936 --> 00:33:23,416
我们自己代码的


918
00:33:23,726 --> 00:33:25,296
意义和效率的结论


919
00:33:26,346 --> 00:33:27,846
因为大多数算法都是


920
00:33:27,846 --> 00:33:29,456
由其他算法构建的


921
00:33:29,896 --> 00:33:32,816
所以它们依赖于相同的东西


922
00:33:33,026 --> 00:33:34,826
最近 我正在面试一位


923
00:33:34,826 --> 00:33:36,486
未来的实习生并且问他


924
00:33:36,486 --> 00:33:38,236
关于文档的作用


925
00:33:38,636 --> 00:33:40,226
他以一个我不会忘记的


926
00:33:40,226 --> 00:33:41,156
短语开始


927
00:33:41,966 --> 00:33:44,206
“哦 它实在太重要了” 他说


928
00:33:45,646 --> 00:33:46,816
“我们正在构建这些抽象的塔”


929
00:33:46,816 --> 00:33:48,996
我在向你们复述他的话


930
00:33:48,996 --> 00:33:50,946
“我们之所以能够成功构建


931
00:33:50,946 --> 00:33:52,286
而无需经常检查


932
00:33:52,286 --> 00:33:54,086
下面层级的内容


933
00:33:54,706 --> 00:33:56,036
是因为我们构建的部分


934
00:33:56,036 --> 00:33:57,176
是有文档记录的”


935
00:33:57,666 --> 00:34:01,966
现在 作为一名 App 开发者


936
00:34:02,176 --> 00:34:03,746
你正在一个塔尖上工作


937
00:34:03,746 --> 00:34:05,356
这个塔贯穿了


938
00:34:05,356 --> 00:34:07,966
你的系统框架 DOS


939
00:34:07,966 --> 00:34:09,556
一直延伸到硬件


940
00:34:10,146 --> 00:34:11,216
这是基于物理定律的


941
00:34:12,815 --> 00:34:14,096
但是一旦你调用了


942
00:34:14,096 --> 00:34:15,936
你自己的方法


943
00:34:15,936 --> 00:34:18,146
它就成为你的基础的一部分


944
00:34:18,146 --> 00:34:19,666
所以 请为你的代码写文档


945
00:34:20,235 --> 00:34:21,565
顺便说一下


946
00:34:21,565 --> 00:34:23,946
那位实习生被录用了


947
00:34:26,295 --> 00:34:26,406
他就坐在那里


948
00:34:26,616 --> 00:34:28,896
所以 我接受了提示


949
00:34:28,896 --> 00:34:29,936
并把 Crusty 的新算法写入了文档


950
00:34:29,936 --> 00:34:32,956
这意味着


951
00:34:32,956 --> 00:34:33,716
我们可以忘记


952
00:34:33,716 --> 00:34:36,956
它如何实现 并使用它


953
00:34:37,206 --> 00:34:38,306
因为我们知道 “Quick Help”


954
00:34:38,306 --> 00:34:39,416
拥有我们所需要的一切


955
00:34:41,246 --> 00:34:43,496
现在 我也记录了 bringForward


956
00:34:45,956 --> 00:34:46,565
酷


957
00:34:48,136 --> 00:34:49,456
现在 因为它似乎


958
00:34:49,456 --> 00:34:51,626
解决了我所有的问题


959
00:34:51,626 --> 00:34:53,496
在这时 我真的很好奇


960
00:34:53,496 --> 00:34:55,786
想看看在 stablePartition 里


961
00:34:55,786 --> 00:34:56,596
发生了什么


962
00:34:57,806 --> 00:34:59,456
结果是我得到了很好的回报


963
00:34:59,526 --> 00:35:01,416
因为这是一个非常漂亮


964
00:35:01,416 --> 00:35:02,486
而且有指导意义的算法


965
00:35:03,766 --> 00:35:05,196
这个公共的方法


966
00:35:05,196 --> 00:35:06,846
获取集合计数


967
00:35:06,846 --> 00:35:10,506
并将其传递给这个 helper 方法


968
00:35:10,506 --> 00:35:11,776
该 helper 方法使用“分而治之”的策略


969
00:35:13,056 --> 00:35:15,136
首先 它会处理基本情况 


970
00:35:15,136 --> 00:35:17,276
当计数小于 2 时


971
00:35:17,276 --> 00:35:18,436
我们便结束了


972
00:35:18,966 --> 00:35:19,916
我们只需要弄清楚


973
00:35:20,396 --> 00:35:21,656
分区点是在


974
00:35:21,656 --> 00:35:23,046
集合的开始处


975
00:35:23,046 --> 00:35:26,016
或者在集合的末尾


976
00:35:26,116 --> 00:35:28,496
接下来 我们将集合


977
00:35:28,546 --> 00:35:29,416
分成两部分


978
00:35:31,136 --> 00:35:33,696
现在 在这一点上 


979
00:35:33,746 --> 00:35:35,136
你必须暂时相信


980
00:35:35,136 --> 00:35:37,146
算法是有效的


981
00:35:37,146 --> 00:35:38,346
因为我们要用 stablePartition() 处理


982
00:35:38,346 --> 00:35:41,446
左半边和右半边


983
00:35:42,136 --> 00:35:46,766
现在 如果你看一下这两端


984
00:35:46,766 --> 00:35:49,166
你会发现


985
00:35:49,166 --> 00:35:50,746
所有东西都在正确的位置


986
00:35:50,746 --> 00:35:54,556
但是这个中心区段


987
00:35:54,556 --> 00:35:56,516
有两个部分


988
00:35:56,516 --> 00:35:57,316
需要交换


989
00:35:58,806 --> 00:36:01,016
现在 它们不会总是


990
00:36:01,016 --> 00:36:03,126
和在这个例子中一样长


991
00:36:03,126 --> 00:36:06,716
幸运的是


992
00:36:06,716 --> 00:36:07,986
“有一个算法可以使用”


993
00:36:08,906 --> 00:36:10,636
我们叫它 rotate()


994
00:36:11,176 --> 00:36:11,276
好的


995
00:36:14,466 --> 00:36:16,496
我不打算在这里深入讨论 rotate 算法


996
00:36:16,496 --> 00:36:18,226
但是它真的很漂亮


997
00:36:18,256 --> 00:36:19,156
如果你感兴趣


998
00:36:19,156 --> 00:36:22,446
你可以在与 stablePartition 同样的文件中


999
00:36:22,446 --> 00:36:23,436
找到它的实现方法


1000
00:36:24,116 --> 00:36:24,216
好的


1001
00:36:25,596 --> 00:36:27,146
回到图形


1002
00:36:28,186 --> 00:36:32,486
现在 这个烂摊子实现了


1003
00:36:32,696 --> 00:36:34,706
在图形列表中拖放


1004
00:36:34,706 --> 00:36:36,626
这一直是我最复杂


1005
00:36:36,626 --> 00:36:39,326
和 Bug 最多的运算之一


1006
00:36:40,336 --> 00:36:41,616
我的策略是


1007
00:36:41,616 --> 00:36:43,246
分配临时缓冲区


1008
00:36:44,536 --> 00:36:46,486
然后在插入点之前


1009
00:36:47,076 --> 00:36:48,506
对 shapes 进行循环


1010
00:36:48,736 --> 00:36:50,196
提取选定的图形


1011
00:36:50,196 --> 00:36:51,576
并调整插入点


1012
00:36:52,526 --> 00:36:54,086
然后在不调整插入点的情况下


1013
00:36:54,086 --> 00:36:55,896
分别对其余的图形


1014
00:36:55,896 --> 00:36:57,236
进行循环


1015
00:36:57,236 --> 00:36:58,596
提取选定的图形


1016
00:36:59,126 --> 00:37:02,916
最后 重新插入它们


1017
00:37:06,536 --> 00:37:10,726
老实说 我有点害怕触碰代码


1018
00:37:10,726 --> 00:37:12,156
因为我觉得我终于做对了


1019
00:37:12,156 --> 00:37:14,276
距离我最后一次发现新 Bug


1020
00:37:14,276 --> 00:37:15,536
已经差不多有


1021
00:37:15,536 --> 00:37:16,056
一个星期了


1022
00:37:16,526 --> 00:37:21,026
但是我现在已经在这个过程中


1023
00:37:21,026 --> 00:37:22,726
做得很好了


1024
00:37:23,286 --> 00:37:28,976
所以我试着把操作可视化一次完成


1025
00:37:29,106 --> 00:37:31,116
嘿 看起来很熟悉


1026
00:37:31,326 --> 00:37:34,856
让我们再看看


1027
00:37:35,056 --> 00:37:35,486
嗯


1028
00:37:36,946 --> 00:37:39,826
假设我们先做这个


1029
00:37:39,826 --> 00:37:40,926
然后分别处理


1030
00:37:40,926 --> 00:37:41,456
各个部分


1031
00:37:43,456 --> 00:37:44,246
没错


1032
00:37:44,706 --> 00:37:45,946
这就是两个


1033
00:37:45,946 --> 00:37:48,976
带有反转谓词的 stablePartition


1034
00:37:49,596 --> 00:37:51,316
所以 这个通用的算法


1035
00:37:51,736 --> 00:37:52,846
被压缩到了这两行


1036
00:37:52,886 --> 00:37:57,636
而这是 Canvas 上剩下的


1037
00:37:58,186 --> 00:38:01,126
现在 让我们把它放在


1038
00:38:01,126 --> 00:38:02,426
旧代码旁边看看


1039
00:38:04,456 --> 00:38:07,886
还不错 但是我们得到了


1040
00:38:07,886 --> 00:38:10,396
一个可重复使用的


1041
00:38:10,766 --> 00:38:12,346
高效文档化的通用算法


1042
00:38:12,346 --> 00:38:13,846
这是非常棒的


1043
00:38:14,446 --> 00:38:21,846
好的 这是一种需要习得的技能


1044
00:38:21,846 --> 00:38:23,746
审视特定于你的 App


1045
00:38:23,746 --> 00:38:25,086
领域的细节


1046
00:38:25,086 --> 00:38:27,056
了解你的代码从根本上在做什么


1047
00:38:27,056 --> 00:38:29,126
并在可重复使用的通用代码中


1048
00:38:29,126 --> 00:38:31,416
捕获这些细节


1049
00:38:32,276 --> 00:38:33,776
这需要实践


1050
00:38:34,966 --> 00:38:35,636
但是 为什么要那么麻烦呢


1051
00:38:36,536 --> 00:38:38,636
实践得到的答案是


1052
00:38:38,636 --> 00:38:39,966
因为它们是从无关的细节中


1053
00:38:39,966 --> 00:38:41,896
解耦出来的


1054
00:38:42,336 --> 00:38:44,126
通用的算法更加


1055
00:38:44,126 --> 00:38:46,296
可重复使用 经得起考验


1056
00:38:46,296 --> 00:38:47,976
甚至比对应的非通用代码


1057
00:38:47,976 --> 00:38:48,706
更加简洁


1058
00:38:49,676 --> 00:38:51,336
但我也认为


1059
00:38:51,586 --> 00:38:53,156
对于任何真正喜欢编程的人来说


1060
00:38:53,296 --> 00:38:54,446
这都是非常有益的


1061
00:38:55,646 --> 00:38:56,996
它是对真与美的追求


1062
00:38:56,996 --> 00:38:59,406
而不是抽象的


1063
00:38:59,406 --> 00:39:01,266
不可触及的真理


1064
00:39:01,266 --> 00:39:02,876
因为实际硬件的约束


1065
00:39:02,876 --> 00:39:03,696
让你保持诚实


1066
00:39:04,836 --> 00:39:06,066
就像 Crusty 常说的


1067
00:39:07,026 --> 00:39:10,136
“编程揭示本真”


1068
00:39:10,346 --> 00:39:12,296
因此 将你的计算视为


1069
00:39:12,296 --> 00:39:14,576
具有类型


1070
00:39:14,576 --> 00:39:16,186
和 App 体系结构的


1071
00:39:16,186 --> 00:39:19,856
具有权利和义务的 VIP


1072
00:39:20,316 --> 00:39:22,566
标识它 给它一个名字


1073
00:39:22,846 --> 00:39:25,756
对它进行单元测试


1074
00:39:25,756 --> 00:39:27,006
并记录它的语义和性能


1075
00:39:27,096 --> 00:39:30,556
最后 我想把


1076
00:39:30,556 --> 00:39:32,366
Sean Parent 的建议


1077
00:39:32,366 --> 00:39:34,136
包括上下文引用一下 作为结束语


1078
00:39:34,676 --> 00:39:37,466
“如果你想要提高


1079
00:39:37,466 --> 00:39:39,146
组织中的代码质量


1080
00:39:39,606 --> 00:39:41,586
请将所有的代码标准


1081
00:39:41,586 --> 00:39:44,976
替换为一个目标 不要单独写循环”


1082
00:39:46,386 --> 00:39:46,696
谢谢大家


1083
00:39:47,516 --> 00:39:52,500
[ 掌声 ]

