1
00:00:17,784 --> 00:00:21,288 line:0
（Natural Language
框架简介 演讲713）


2
00:00:26,093 --> 00:00:27,461 line:-1
大家下午好


3
00:00:27,761 --> 00:00:30,364 line:-1
欢迎参加关于自然语言处理的演讲


4
00:00:30,964 --> 00:00:33,033 line:-2
今天我很高兴见到
这里聚集了这么多人


5
00:00:33,267 --> 00:00:36,937 line:-2
我很激动地向大家介绍一些
我们在NLP领域研发的一些


6
00:00:37,004 --> 00:00:39,606 line:-1
又新又酷炫的功能


7
00:00:40,607 --> 00:00:43,076 line:-2
我是Vivek 我将与同事
Doug Davidson


8
00:00:43,277 --> 00:00:44,711 line:-1
一起进行这次演讲


9
00:00:45,012 --> 00:00:45,979 line:-1
让我们开始吧


10
00:00:47,648 --> 00:00:50,551 line:-1
去年我们重点关注你的app


11
00:00:50,751 --> 00:00:53,921 line:-1
并告诉你如何利用NLP的力量


12
00:00:54,788 --> 00:00:57,291 line:-1
来让你的app变得更聪明 更智能


13
00:00:58,225 --> 00:01:00,127 line:-1
我们曾通过向你演示


14
00:01:00,194 --> 00:01:03,764 line:-2
NSLinguisticTagger中
提供的NLP API来做到这一点


15
00:01:05,065 --> 00:01:08,869 line:-1
正如大多数人熟悉或曾使用过的那样


16
00:01:09,603 --> 00:01:14,141 line:-2
NSLinguisticTagger是一个基础类
它为NLP的实现提供了基本构建单元


17
00:01:14,641 --> 00:01:18,412 line:-2
从语言识别到语言组织
以及词类标注


18
00:01:18,745 --> 00:01:19,580 line:-1
等等


19
00:01:20,347 --> 00:01:22,683 line:-1
我们在NSLinguisticTagger中


20
00:01:22,749 --> 00:01:26,386 line:-2
通过在幕后无缝地融合
语言学和机器学习技术来实现这一点


21
00:01:26,987 --> 00:01:30,591 line:-2
这样 你作为一名开发人员
就可以专注于使用这些API


22
00:01:30,657 --> 00:01:32,125 line:-1
并专注于完成你的任务


23
00:01:33,160 --> 00:01:34,194 line:-1
这很棒


24
00:01:34,528 --> 00:01:36,063 line:-1
今年NLP新特性是什么呢？


25
00:01:37,364 --> 00:01:41,168 line:-2
我们很高兴地宣布
我们有一个全新的NLP框架


26
00:01:41,235 --> 00:01:42,503 line:-2
我们称它为
Natural Language


27
00:01:43,203 --> 00:01:48,041 line:-2
Natural Language将成为
在所有Apple平台上的设备上


28
00:01:48,108 --> 00:01:50,544 line:-1
实现NLP所有功能的一站式商店


29
00:01:51,545 --> 00:01:53,881 line:-2
Natural Language
有一些非常酷的功能


30
00:01:53,947 --> 00:01:55,449 line:-1
让我们谈谈其中的每一个


31
00:01:57,117 --> 00:02:00,387 line:-2
首先 它有一个
完全重新设计的API接口


32
00:02:01,255 --> 00:02:04,358 line:-1
因此它支持NSLinguisticTagger过去以及


33
00:02:04,424 --> 00:02:08,529 line:-2
现在仍在使用的所有功能
但它用真正的Swift API


34
00:02:09,496 --> 00:02:10,464 line:-1
但还不仅如此


35
00:02:11,064 --> 00:02:13,734 line:-1
我们现在支持自定义的NLP模型


36
00:02:14,067 --> 00:02:18,172 line:-2
这些是你可以使用
Create ML创建


37
00:02:18,238 --> 00:02:21,041 line:-2
并使用Core ML API或
Natural Language进行部署的模型


38
00:02:22,676 --> 00:02:24,444 line:-2
我们在Natural Language中
支持的所有功能


39
00:02:24,511 --> 00:02:27,581 line:-2
所有机器学习NLP
都具有很好的性能


40
00:02:27,814 --> 00:02:31,118 line:-2
它针对Apple硬件和模型大小
进行了优化


41
00:02:32,352 --> 00:02:35,956 line:-1
最后 这一切都是完全私有的


42
00:02:36,156 --> 00:02:39,760 line:-2
使用Natural Language框架的
NLP中的所有机器学习过程


43
00:02:40,093 --> 00:02:42,496 line:-1
都在设备上完成以保护用户的隐私


44
00:02:42,963 --> 00:02:45,832 line:-1
这正是我们在Apple中为了实现


45
00:02:46,200 --> 00:02:49,469 line:-1
在设备上进行NLP而使用的技术


46
00:02:50,537 --> 00:02:53,774 line:-2
我来谈谈Natural Language的
这些特征


47
00:02:54,007 --> 00:02:55,809 line:-1
我们从Swift API开始


48
00:02:58,312 --> 00:03:01,648 line:-2
正如我所提到的
Natural Language支持


49
00:03:01,715 --> 00:03:03,217 line:-1
所有NSLinguisticTagger的基本构建块


50
00:03:03,517 --> 00:03:07,020 line:0
但使用更好 更易于使用的API


51
00:03:08,055 --> 00:03:11,124 line:0
为了演示其中的一部分API


52
00:03:11,191 --> 00:03:13,560 line:0
我将用一个假想app来说明它们


53
00:03:15,229 --> 00:03:18,398 line:0
我们假设你写的第一个app


54
00:03:19,666 --> 00:03:22,402 line:-2
作为该app的一部分
你实现了社交消息


55
00:03:22,469 --> 00:03:23,971 line:-1
或点对点消息功能


56
00:03:25,439 --> 00:03:27,574 line:-1
你在此app中创建的附加功能


57
00:03:27,641 --> 00:03:30,944 line:-1
是显示正确的贴纸


58
00:03:31,545 --> 00:03:35,482 line:-1
根据消息的内容 在这个例子中是


59
00:03:35,549 --> 00:03:38,051 line:-2
“现在太晚了 我很累了
我们明早再继续 晚安”


60
00:03:38,352 --> 00:03:40,053 line:-1
你的app会显示合适的贴纸


61
00:03:40,120 --> 00:03:42,556 line:-1
你解析了这段文字 然后显示贴纸


62
00:03:42,823 --> 00:03:44,992 line:-1
用户可以附加并发送它作为回应


63
00:03:45,425 --> 00:03:47,561 line:-2
这一切都很棒
这个app做得很好


64
00:03:47,628 --> 00:03:48,929 line:-1
你得到的好评如潮


65
00:03:49,897 --> 00:03:52,833 line:-2
但是你也会收到反馈
说你的app不支持多语言


66
00:03:53,734 --> 00:03:56,336 line:-1
现在有越来越多的双语用户


67
00:03:56,403 --> 00:03:58,772 line:-1
他们倾向于用几种不同的语言沟通


68
00:03:59,106 --> 00:04:01,241 line:-1
当你的app收到中文信息时


69
00:04:01,542 --> 00:04:03,043 line:-1
它根本不知道如何处理它


70
00:04:04,077 --> 00:04:06,747 line:-2
我们如何使用Natural Language
来克服这个问题呢？


71
00:04:08,348 --> 00:04:11,652 line:-2
我们可以通过对两个不同API的
简单调用来完成此操作


72
00:04:12,219 --> 00:04:13,887 line:-1
首先是语言识别


73
00:04:15,088 --> 00:04:16,456 line:-1
使用新的Natural Language框架


74
00:04:16,523 --> 00:04:18,725 line:-1
首先你要导入NaturalLanguage


75
00:04:19,793 --> 00:04:23,197 line:-2
你创建一个
NLLanguageRecognizer类的实例


76
00:04:24,431 --> 00:04:26,433 line:-1
你附上你想要处理的字符串


77
00:04:27,201 --> 00:04:29,636 line:-2
你只需调用
dominantLanguage API


78
00:04:30,404 --> 00:04:33,373 line:-1
现在这将根据字符串的语言


79
00:04:34,074 --> 00:04:35,742 line:-1
返回最可能的语言类别


80
00:04:36,777 --> 00:04:39,479 line:0
这里的输出是简体中文


81
00:04:40,480 --> 00:04:43,150 line:0
现在在Natural Language中
我们也支持一个新的API


82
00:04:43,483 --> 00:04:45,219 line:0
有些情况下你想知道


83
00:04:45,285 --> 00:04:47,988 line:0
特定字符串的较优猜测


84
00:04:48,622 --> 00:04:50,958 line:0
所以你想知道最可能的语言是哪些


85
00:04:51,024 --> 00:04:52,759 line:0
及其相关概率


86
00:04:53,160 --> 00:04:56,230 line:0
你可以设想
在几个不同的app中使用它


87
00:04:56,296 --> 00:04:59,366 line:0
这些app中包含多语言信息
所以你需要


88
00:04:59,433 --> 00:05:01,435 line:0
为这些可能的语言留有余地


89
00:05:02,269 --> 00:05:05,839 line:0
你可以用一个叫做languageHypotheses的
新API来做到这一点


90
00:05:06,139 --> 00:05:08,775 line:0
你可以指定返回语言的最大数量


91
00:05:08,842 --> 00:05:11,778 line:0
其将返回的是最可能语言的对象


92
00:05:11,845 --> 00:05:13,447 line:0
以及各自的概率


93
00:05:14,581 --> 00:05:16,683 line:0
为了对这个中文文本进行分词


94
00:05:16,984 --> 00:05:19,253 line:-1
你可以看到它的用法非常类似


95
00:05:20,053 --> 00:05:21,688 line:-2
你再次导入
NaturalLanguage


96
00:05:22,356 --> 00:05:24,458 line:-2
创建一个
NLTokenizer的实例


97
00:05:25,158 --> 00:05:28,428 line:-2
在这个实例中
将单位设为“word”


98
00:05:28,495 --> 00:05:30,664 line:-1
因为你要将字符串切分为单词


99
00:05:32,799 --> 00:05:33,901 line:-1
你传入了字符串


100
00:05:34,535 --> 00:05:38,105 line:-2
然后只需在对象的字符串上
调用tokens方法即可


101
00:05:39,039 --> 00:05:41,175 line:0
在这里你得到一个tokens数组


102
00:05:41,975 --> 00:05:45,345 line:0
现在有了这个tokens数组
你可以查找一个特定的token


103
00:05:45,412 --> 00:05:46,580 line:0
这里是“晚安”


104
00:05:47,381 --> 00:05:50,250 line:0
瞧 你的app现在支持多语言了


105
00:05:50,984 --> 00:05:54,421 line:-1
因此 你的app现在可以通过


106
00:05:54,488 --> 00:05:57,858 line:-2
简单的调用语言识别和分词API
来支持中文


107
00:05:59,059 --> 00:06:01,261 line:-2
让我们看看另一种
不同类型的API 我的意思是


108
00:06:01,328 --> 00:06:05,065 line:-2
语言识别和分词都很好
但我们也想使用


109
00:06:05,132 --> 00:06:07,501 line:-1
自动语音标记 命名实体识别等功能


110
00:06:08,035 --> 00:06:11,238 line:-2
我来演示一下
如何在我们的假想app中


111
00:06:11,305 --> 00:06:12,806 line:-1
使用命名实体识别API


112
00:06:14,341 --> 00:06:17,110 line:-2
这里有一个app
它是一个新闻推荐app


113
00:06:17,644 --> 00:06:20,514 line:-2
在你的app中
你的用户一直在阅读


114
00:06:20,581 --> 00:06:23,383 line:-2
很多关于皇室婚礼的事情
这是一个非常好奇的用户


115
00:06:23,450 --> 00:06:25,085 line:-1
他们想了解有关皇室婚礼的一切


116
00:06:25,752 --> 00:06:27,955 line:-2
他们已经在你的app中
浏览了很多页面


117
00:06:28,488 --> 00:06:31,592 line:-2
然后他们进入搜索栏
并输入“Harry”


118
00:06:32,326 --> 00:06:35,662 line:-1
然而却看到与他们一直在寻找的


119
00:06:35,729 --> 00:06:37,231 line:-1
完全不相关的东西


120
00:06:37,297 --> 00:06:39,199 line:-1
比如哈利波特等等


121
00:06:39,566 --> 00:06:44,705 line:-2
你想看到的是
与皇室婚礼有关的哈里王子


122
00:06:45,372 --> 00:06:47,674 line:-1
现在你可以在app中


123
00:06:47,741 --> 00:06:50,310 line:-2
通过使用命名实体识别API
来解决这个问题


124
00:06:51,378 --> 00:06:54,348 line:-2
正如我所提到的
这里的语法非常相似


125
00:06:54,414 --> 00:06:57,684 line:-2
你们中那些习惯使用
NSLinguisticTagger的人


126
00:06:57,751 --> 00:07:00,487 line:-2
应该觉得这看起来感觉很熟悉
但是它更容易


127
00:07:00,554 --> 00:07:01,788 line:-1
记忆和使用


128
00:07:02,656 --> 00:07:03,957 line:-2
你导入
NaturalLanguage


129
00:07:04,892 --> 00:07:07,127 line:-2
你现在创建一个
NLTagger的实例


130
00:07:07,694 --> 00:07:10,030 line:-2
并指定scheme类型
为nameType


131
00:07:10,898 --> 00:07:12,199 line:-1
若你想添加词性标注功能


132
00:07:12,266 --> 00:07:14,868 line:-2
你需要指定该scheme类型
为lexical类


133
00:07:16,036 --> 00:07:18,539 line:-1
你再次指定要处理的字符串


134
00:07:19,439 --> 00:07:21,141 line:-1
在这个例子中


135
00:07:21,208 --> 00:07:24,611 line:-1
你将语言设置为英语


136
00:07:25,379 --> 00:07:26,747 line:-1
如果你不熟悉


137
00:07:26,813 --> 00:07:28,982 line:-1
或者你不确定语言是什么


138
00:07:29,149 --> 00:07:32,252 line:-2
Natural Language
会使用语言识别API


139
00:07:32,319 --> 00:07:34,922 line:-1
在底层自动识别该语言种类


140
00:07:36,190 --> 00:07:40,561 line:0
最后 你在刚创建的对象上
调用tags方法


141
00:07:40,794 --> 00:07:44,131 line:0
将unit参数设为word
并将scheme参数设为nameType


142
00:07:44,998 --> 00:07:48,669 line:0
你得到的输出是这里的人名


143
00:07:48,735 --> 00:07:51,538 line:0
哈里王子和梅格汉马克尔
以及地点为温莎


144
00:07:51,805 --> 00:07:54,241 line:0
现在 如果用户返回到搜索栏


145
00:07:54,741 --> 00:07:57,811 line:-1
基于用户浏览的内容信息


146
00:07:57,878 --> 00:08:00,914 line:-1
你可以显著提高app中的搜索体验


147
00:08:03,817 --> 00:08:06,920 line:-2
若想了解更多
关于如何使用这些API的信息


148
00:08:06,987 --> 00:08:09,990 line:-1
你可以参考开发者文档


149
00:08:10,390 --> 00:08:15,696 line:-2
我想强调的是我们虽然仍支持
NSLinguisticTagger


150
00:08:16,029 --> 00:08:18,498 line:-2
但NLP的未来是
Natural Language


151
00:08:18,565 --> 00:08:22,903 line:-2
因此我们建议并鼓励你
迁移到Natural Language


152
00:08:22,970 --> 00:08:26,240 line:-2
以便可以在此框架中获得
NLP的所有最新功能


153
00:08:27,341 --> 00:08:30,777 line:-1
现在让我们思考另一种情况


154
00:08:30,944 --> 00:08:32,913 line:-1
你有一个app的想法


155
00:08:33,614 --> 00:08:35,948 line:-1
或者你需要在你的app中添加一个


156
00:08:36,316 --> 00:08:38,085 line:-2
Natural Language
不支持的功能


157
00:08:39,586 --> 00:08:40,419 line:-1
你该怎么办？


158
00:08:41,455 --> 00:08:45,025 line:-1
你当然可以创造这些东西 这很棒


159
00:08:45,292 --> 00:08:48,228 line:-2
但如果我们给你提供工具
来使这变得更容易呢？


160
00:08:50,931 --> 00:08:56,003 line:-2
为了讨论自定义NLP模型
以及如何使用Create ML构建自定义NLP模型


161
00:08:56,270 --> 00:08:59,873 line:-2
并使用这些在Natural Language中
实质上为Core ML模型的后续模型


162
00:08:59,940 --> 00:09:02,809 line:-2
我将把这个话题交给
Doug Davidson


163
00:09:09,750 --> 00:09:10,584 line:-1
感谢Vivek


164
00:09:11,118 --> 00:09:15,656 line:-2
我对新的Natural Language框架
感到非常激动


165
00:09:15,722 --> 00:09:19,526 line:-1
但我最感兴趣的部分是


166
00:09:19,593 --> 00:09:21,361 line:-1
对构建和使用定制化模型的支持


167
00:09:21,595 --> 00:09:22,663 line:-1
为什么呢？


168
00:09:23,397 --> 00:09:26,733 line:-1
我想让你考虑一下你的app


169
00:09:27,167 --> 00:09:30,871 line:-2
这可能是你已编写的app
或你想要编写的app


170
00:09:31,405 --> 00:09:35,008 line:-1
并考虑如果它们能够


171
00:09:35,075 --> 00:09:39,646 line:-2
更好理解他们所处理的文本
这将如何改善用户体验


172
00:09:40,380 --> 00:09:44,852 line:-1
然后想一想你自己是如何分析文本的


173
00:09:44,985 --> 00:09:48,088 line:-1
也许你看到一些样板文本


174
00:09:48,488 --> 00:09:49,990 line:-1
你从中学习一些信息


175
00:09:50,691 --> 00:09:55,262 line:-2
然后明白发生了什么
接着你就可以看一段其它的文本


176
00:09:55,329 --> 00:09:58,432 line:-2
并且马上可以理解
它说的是什么


177
00:09:59,333 --> 00:10:00,767 line:-1
那么 如果是这样的话


178
00:10:00,934 --> 00:10:04,605 line:-1
你就有一定可能


179
00:10:05,572 --> 00:10:07,274 line:-1
通过设计一个机器学习模型


180
00:10:07,774 --> 00:10:13,347 line:-1
给它一些例子以便训练和学习


181
00:10:13,780 --> 00:10:17,150 line:-2
来在你的app中自动为你
进行这种分析 并最终训练出一个


182
00:10:17,684 --> 00:10:19,219 line:-1
能够进行这类分析的模型


183
00:10:19,920 --> 00:10:25,559 line:-2
当前NLP有很多种类的
机器学习模型


184
00:10:25,626 --> 00:10:27,194 line:-1
并且有许多不同的方式来训练它


185
00:10:27,261 --> 00:10:30,030 line:-2
你们中许多人可能已经
在训练机器学习模型


186
00:10:30,330 --> 00:10:34,468 line:-1
但我们这里的任务是寻找一种


187
00:10:34,535 --> 00:10:37,671 line:-1
让这种训练变得极其简单


188
00:10:38,372 --> 00:10:40,340 line:-1
并能够与Natural Language框架和API


189
00:10:40,641 --> 00:10:43,210 line:-1
整合得非常好的方法


190
00:10:43,510 --> 00:10:48,081 line:-2
考虑到这一点
我们现在支持两种类型的模型


191
00:10:48,282 --> 00:10:52,119 line:-2
我们认为这些模型能够
支持各种各样的功能


192
00:10:52,486 --> 00:10:54,955 line:-2
且能与NLTagger中的范式
很好地协同工作


193
00:10:55,022 --> 00:10:58,492 line:-1
即将标签app于文本片段


194
00:10:58,759 --> 00:11:02,429 line:-1
我们支持的第一个模型是文本分类器


195
00:11:02,796 --> 00:11:03,630 line:0
这个…


196
00:11:03,697 --> 00:11:08,235 line:0
文本分类器读取一块文本
可能是一个句子或一个段落


197
00:11:08,302 --> 00:11:11,405 line:0
或整个文档 并为其打上一个标签


198
00:11:11,738 --> 00:11:15,976 line:0
我们现有的API中的例子
是语言识别


199
00:11:16,043 --> 00:11:17,377 line:0
脚本识别


200
00:11:18,245 --> 00:11:21,215 line:0
我们支持的第二种模型是单词标记器


201
00:11:21,648 --> 00:11:26,653 line:0
一个单词标记器将一个句子
视为一个单词序列


202
00:11:26,920 --> 00:11:31,225 line:0
然后根据上下文
为句子中的每个单词打上标签


203
00:11:31,458 --> 00:11:35,696 line:0
现有API中的例子
包括词性标注


204
00:11:35,762 --> 00:11:37,264 line:0
和命名实体识别


205
00:11:37,598 --> 00:11:43,337 line:0
但这些都是这类模型的通用示例


206
00:11:44,004 --> 00:11:45,906 line:0
如果你在app中
有一个特殊用途模型


207
00:11:45,973 --> 00:11:48,876 line:0
你可以用他们做更多的事情


208
00:11:48,942 --> 00:11:49,810 line:0
让我给你


209
00:11:49,877 --> 00:11:51,478 line:-1
一些假设的例子


210
00:11:51,912 --> 00:11:56,283 line:-2
对于文本分类
假设你正在处理用户评论


211
00:11:56,350 --> 00:11:58,118 line:-1
你想自动知道


212
00:11:58,352 --> 00:12:01,288 line:-1
给定的评论是正面评论


213
00:12:01,588 --> 00:12:03,857 line:-1
还是负面评论或介于两者之间的地方


214
00:12:04,291 --> 00:12:06,960 line:-2
这是你可以通过
训练一个文本分类器来做到的事情


215
00:12:07,027 --> 00:12:08,595 line:-1
这属于情感分类


216
00:12:10,464 --> 00:12:13,567 line:-1
或者假设你有文章或文章摘要


217
00:12:13,634 --> 00:12:17,137 line:-1
甚至只是文章标题


218
00:12:17,504 --> 00:12:20,274 line:-1
而你想根据你最喜欢的主题分类方案


219
00:12:20,674 --> 00:12:22,376 line:-1
自动确定它们属于哪个主题


220
00:12:22,709 --> 00:12:25,045 line:-1
这也是你可以训练


221
00:12:25,779 --> 00:12:28,115 line:-1
一个文本分类器为你做的事情


222
00:12:30,050 --> 00:12:34,388 line:-2
或者再进一步
假设你正在写一个自动旅行代理


223
00:12:34,655 --> 00:12:37,124 line:-1
当你收到客户的请求时


224
00:12:37,191 --> 00:12:40,561 line:-2
你想知道的第一件事可能是
他们问的是什么


225
00:12:40,727 --> 00:12:44,331 line:-2
是酒店还是餐馆或是航班
还是任何其他你可以处理的内容


226
00:12:45,065 --> 00:12:49,236 line:-2
这是你可以训练一个文本分类器
来替你回答的事情


227
00:12:50,904 --> 00:12:52,506 line:-1
继续说单词标记


228
00:12:53,040 --> 00:12:57,711 line:-1
我们提供了能为许多语言


229
00:12:57,778 --> 00:13:01,815 line:-2
做词性标注的单词标记器
但假设你碰巧需要


230
00:13:01,882 --> 00:13:05,886 line:-2
针对某种我们尚未支持的语言
做词性标注


231
00:13:06,420 --> 00:13:10,924 line:-2
而有了自定义模型的支持 你就可以
训练一个单词标记器为你完成这件事


232
00:13:12,259 --> 00:13:14,261 line:-1
或者命名实体识别


233
00:13:14,728 --> 00:13:16,730 line:-1
我们提供了内置的命名实体识别功能


234
00:13:16,797 --> 00:13:20,634 line:-1
它能够识别人名、地名和组织名称


235
00:13:21,368 --> 00:13:22,936 line:-2
但若你对其它类型名字
特别感兴趣


236
00:13:23,003 --> 00:13:26,173 line:-1
而这类名字我们碰巧不支持


237
00:13:26,473 --> 00:13:28,575 line:-1
例如产品名称


238
00:13:29,009 --> 00:13:31,912 line:-2
你可以训练你自己的
自定义命名实体识别器


239
00:13:31,979 --> 00:13:36,383 line:-1
作为可以识别你特别感兴趣的


240
00:13:36,450 --> 00:13:38,886 line:-1
名称或其他术语的单词标记器


241
00:13:40,587 --> 00:13:43,590 line:-1
再者 对于你的自动旅行代理


242
00:13:43,657 --> 00:13:45,726 line:-1
一旦你知道用户在问什么


243
00:13:46,159 --> 00:13:48,161 line:-1
可能你想知道的下一件事是


244
00:13:48,228 --> 00:13:50,464 line:-1
他们的请求中有哪些相关信息


245
00:13:50,597 --> 00:13:54,434 line:-2
例如 如果这是航班请求
他们想从哪里飞去哪里


246
00:13:55,502 --> 00:14:00,908 line:-2
单词标记器可以
识别句子中的各种条件


247
00:14:02,309 --> 00:14:04,444 line:0
又或者假设有另一个app


248
00:14:04,511 --> 00:14:07,581 line:0
你需要把一个句子分成若干短语


249
00:14:07,648 --> 00:14:10,617 line:0
名词短语、动词短语、命题短语


250
00:14:10,984 --> 00:14:15,589 line:0
有了适当的标签 你可以训练
一个单词标记器来做到这一点


251
00:14:15,656 --> 00:14:22,029 line:-2
以及许多其他类型的
可以用标签来表达的任务


252
00:14:22,095 --> 00:14:26,600 line:-2
为文本块打上标签
无论其是序列中的单词


253
00:14:26,667 --> 00:14:29,903 line:-1
还是文本分类器中的文本块


254
00:14:33,674 --> 00:14:36,944 line:-1
这些都是有监督机器学习模型


255
00:14:37,010 --> 00:14:40,047 line:-1
所以总是包括两个阶段


256
00:14:40,214 --> 00:14:43,684 line:-2
第一阶段是训练
第二阶段是推理


257
00:14:43,750 --> 00:14:47,721 line:-1
训练是你在开发过程中需要做的部分


258
00:14:48,188 --> 00:14:51,058 line:-1
你将带标签的训练数据


259
00:14:51,892 --> 00:14:55,896 line:-2
输入Create ML
并生成一个模型


260
00:14:57,231 --> 00:15:00,367 line:0
推理就是当你在运行时


261
00:15:00,434 --> 00:15:04,538 line:0
将该模型整合到你的app中后
所发生的事情


262
00:15:04,605 --> 00:15:07,407 line:0
当它遇到来自用户的一些数据时


263
00:15:07,808 --> 00:15:09,176 line:0
它会分析这些数据


264
00:15:09,243 --> 00:15:11,311 line:0
并预测适当的标签


265
00:15:12,012 --> 00:15:13,847 line:0
让我们看看这些阶段是如何工作的


266
00:15:14,948 --> 00:15:18,852 line:-2
让我们从训练开始
而训练总是从数据开始


267
00:15:19,419 --> 00:15:23,557 line:-1
你将你的训练数据输入到


268
00:15:23,624 --> 00:15:29,429 line:-2
Playground或脚本
包装器中的Create ML


269
00:15:30,264 --> 00:15:32,199 line:-2
如你在Create ML演讲中
所见


270
00:15:32,633 --> 00:15:34,101 line:-1
Create ML在底层调用


271
00:15:34,168 --> 00:15:37,304 line:-2
Natural Language
框架来进行训练


272
00:15:38,005 --> 00:15:44,545 line:-2
其输出的是一个Core ML模型
并已针对设备上的使用进行了优化


273
00:15:45,979 --> 00:15:48,348 line:-1
让我们看看这些数据是什么样子的


274
00:15:49,750 --> 00:15:52,920 line:-2
Create ML支持
多种不同的数据格式


275
00:15:53,987 --> 00:15:58,692 line:-2
在这里我们使用JSON显示数据
因为JSON使事情变得非常清晰


276
00:16:00,093 --> 00:16:03,830 line:-1
这是一部分训练数据


277
00:16:03,897 --> 00:16:07,668 line:-2
被用来训练文本分类器
在这里也是一个情感分类器


278
00:16:07,901 --> 00:16:10,103 line:-1
每个训练的样例


279
00:16:11,104 --> 00:16:12,139 line:-1
比如这个


280
00:16:12,206 --> 00:16:15,142 line:-1
都由两部分组成 一块文本


281
00:16:15,509 --> 00:16:18,111 line:-1
以及与其对应的标签


282
00:16:18,679 --> 00:16:21,415 line:-1
例如这是一个表达正面情感的句子


283
00:16:21,481 --> 00:16:24,852 line:-2
所以其标签为“积极”
但你可以选择你想要的任何标签


284
00:16:27,754 --> 00:16:33,193 line:-2
当你开始使用Create ML时
Create ML提供了一个


285
00:16:33,260 --> 00:16:36,930 line:-2
极其简单的只需几行代码
就可以训练模型的方法


286
00:16:36,997 --> 00:16:42,803 line:-2
第一行 我们只是从JSON文件
加载我们的训练数据


287
00:16:42,870 --> 00:16:48,976 line:-2
我们给它一个JSON文件的URL
用它创建Create ML数据表


288
00:16:49,943 --> 00:16:55,649 line:-2
然后仅在一行代码中 使用这些数据
创建并训练一个文本分类器


289
00:16:55,782 --> 00:16:59,686 line:-2
你需要告诉它的只是字段名称
在这里是“文本”和“标签”


290
00:17:01,455 --> 00:17:02,589 line:-1
一旦训练完成


291
00:17:02,656 --> 00:17:05,291 line:-2
你就可以用一行代码
将该模型写入磁盘


292
00:17:07,261 --> 00:17:09,630 line:-1
训练一个单词标记器的方法与这类似


293
00:17:09,963 --> 00:17:12,199 line:-1
只是数据稍微复杂一些


294
00:17:12,266 --> 00:17:15,068 line:-1
因为每个示例不是一块单独的文本


295
00:17:15,301 --> 00:17:17,838 line:-1
而是一个token序列


296
00:17:18,704 --> 00:17:21,375 line:-1
并且标签也是一个


297
00:17:21,441 --> 00:17:24,611 line:-2
与token序列具有相同数量标签
的序列 每个标签对应一token


298
00:17:24,944 --> 00:17:29,883 line:-2
例如 这是训练
一个单词标记器的数据


299
00:17:29,950 --> 00:17:35,722 line:-2
它可以进行命名实体识别每个单词
即每个token 都有一个标签


300
00:17:36,023 --> 00:17:42,095 line:-2
若是“NONE”则不是一个名称
若是“ORG”则是一个组织名称


301
00:17:42,162 --> 00:17:45,532 line:-1
若是“PROD”则是产品名称


302
00:17:45,599 --> 00:17:47,901 line:-1
以及还有许多你想要识别的其他标签


303
00:17:48,268 --> 00:17:49,937 line:-1
每个token都有一个标签


304
00:17:50,737 --> 00:17:55,475 line:-1
每个样本由一个token序列


305
00:17:55,542 --> 00:17:57,044 line:-1
和它所对应的标签组成


306
00:17:58,579 --> 00:18:02,983 line:-2
用来训练它的Create ML
几乎是完全一样的


307
00:18:03,951 --> 00:18:08,355 line:-2
你将训练数据
从JSON加载到数据表中


308
00:18:10,190 --> 00:18:13,927 line:-2
然后你创建并训练
一个WordTagger对象


309
00:18:13,994 --> 00:18:15,429 line:-1
而非之前的文本分类器对象


310
00:18:15,863 --> 00:18:17,931 line:-1
然后将其写入磁盘


311
00:18:18,298 --> 00:18:23,504 line:-2
Create ML中还有许多
其他选项和API可以使用


312
00:18:23,570 --> 00:18:25,305 line:-1
我鼓励你 如果你还没有的话


313
00:18:25,372 --> 00:18:28,876 line:-2
看看昨天举办的
Create ML演讲


314
00:18:28,942 --> 00:18:32,246 line:-2
以及Create ML文档
以获取更多信息


315
00:18:33,046 --> 00:18:36,550 line:0
现在 一旦你训练好了模型
我们就可以进入推理部分


316
00:18:36,717 --> 00:18:40,120 line:0
你把你的模型拖到
你的Xcode项目中


317
00:18:40,187 --> 00:18:44,091 line:0
Xcode将编译并将其
包含在你的app资源中


318
00:18:44,458 --> 00:18:48,929 line:0
然后你在运行时做什么呢？
记住这是一个Core ML模型


319
00:18:48,996 --> 00:18:50,998 line:0
你可以像使用其他任何
Core ML模型一样使用它


320
00:18:51,431 --> 00:18:56,270 line:-2
但有趣的是这些模型能够很好地
与Natural Language API共同工作


321
00:18:56,570 --> 00:19:01,441 line:-1
就像是我们自己的


322
00:19:01,508 --> 00:19:05,279 line:-1
提供了NLP功能的内置模型一样


323
00:19:06,613 --> 00:19:07,447 line:-1
所以…


324
00:19:08,115 --> 00:19:10,384 line:-1
数据将进来


325
00:19:11,251 --> 00:19:15,856 line:0
你将它传递给Natural Language
其将使用该模型执行必要的工作


326
00:19:15,923 --> 00:19:19,993 line:0
来找出所有的标签


327
00:19:20,060 --> 00:19:23,830 line:0
然后为一个分类器传回单个标签


328
00:19:23,897 --> 00:19:27,167 line:0
或为一个标记器传回一个标签序列


329
00:19:30,370 --> 00:19:33,740 line:-2
你如何在Natural Language API中
做到这一点呢？


330
00:19:34,341 --> 00:19:37,945 line:-1
你首先需要做的是


331
00:19:38,011 --> 00:19:41,348 line:-2
在app资源中找到该模型
然后使用它创建


332
00:19:41,415 --> 00:19:44,852 line:-2
Natural Language中的一个类
NLModel的实例


333
00:19:45,986 --> 00:19:48,822 line:-1
然后 你可以用它做的最简单的事


334
00:19:48,889 --> 00:19:53,861 line:-2
至少对于一个分类器来说 就是向它
输入一个文本块并且获取一个标签


335
00:19:54,695 --> 00:19:59,066 line:-1
但更有趣的是你可以


336
00:19:59,132 --> 00:20:00,434 line:-1
在NLTagger中使用这些模型


337
00:20:01,468 --> 00:20:05,105 line:-1
其方式与你使用


338
00:20:05,639 --> 00:20:07,708 line:-1
内置模型中的功能的方式完全相同


339
00:20:08,175 --> 00:20:09,543 line:-1
让我向你展示这如何工作


340
00:20:10,344 --> 00:20:13,647 line:-1
除了我们现有的标签方案


341
00:20:13,714 --> 00:20:16,350 line:-1
像命名实体识别 词性标注


342
00:20:16,817 --> 00:20:20,020 line:-2
你可以创建自己的自定义标签方案
并为其命名


343
00:20:21,788 --> 00:20:23,924 line:-1
然后你可以创建一个包含任意数量的


344
00:20:24,424 --> 00:20:26,860 line:-1
不同标签方案的标记器


345
00:20:27,094 --> 00:20:29,796 line:-2
它可以包括自定义标签方案
或任何内置的标签方案


346
00:20:29,863 --> 00:20:30,697 line:-1
或者它们全部


347
00:20:32,266 --> 00:20:35,302 line:-1
然后你所要做的就是告诉标记器


348
00:20:35,369 --> 00:20:38,272 line:-1
使用自定义模型作为自定义标签方案


349
00:20:39,873 --> 00:20:42,776 line:-1
接下来你只需要正常使用它


350
00:20:43,210 --> 00:20:46,647 line:-1
你将一个字符串传给标记器


351
00:20:46,713 --> 00:20:48,115 line:-1
然后你可以


352
00:20:49,650 --> 00:20:53,620 line:-2
以最合适你的模型的单位
遍历这些标签


353
00:20:54,488 --> 00:20:56,990 line:-1
标记器会自动


354
00:20:57,257 --> 00:21:01,094 line:-2
根据需要调用该模型以获取标签
并将标签返回给你


355
00:21:01,161 --> 00:21:05,399 line:-2
并且还会执行NLTagger
自动执行的所有其他操作


356
00:21:05,465 --> 00:21:08,635 line:-1
像语言识别、分词等等


357
00:21:10,070 --> 00:21:14,107 line:-2
我想通过一个简单的例子
向你展示这一点


358
00:21:14,641 --> 00:21:21,014 line:-2
这个假设的例子是这样一个app
用户可以用它来


359
00:21:21,081 --> 00:21:24,251 line:-1
保存他们所遇到的文章的书签


360
00:21:24,318 --> 00:21:26,253 line:-1
用户可能打算稍后阅读这些文章


361
00:21:27,187 --> 00:21:30,357 line:-1
但是这个app目前的问题是


362
00:21:30,424 --> 00:21:32,459 line:-1
这个书签列表


363
00:21:32,526 --> 00:21:35,095 line:-1
只是一个未经组织的长列表


364
00:21:35,529 --> 00:21:36,597 line:-1
若我们可以自动分类这些文章


365
00:21:36,663 --> 00:21:39,800 line:-1
并根据主题将它们组织起来


366
00:21:40,167 --> 00:21:42,803 line:-1
这不是很好吗？


367
00:21:43,504 --> 00:21:46,340 line:-2
我们可以训练一个分类器
来为我们做这件事


368
00:21:47,040 --> 00:21:49,743 line:-1
另一件事是 当我们看这些文章时


369
00:21:49,810 --> 00:21:51,478 line:-1
它们是一段很长的文本


370
00:21:52,346 --> 00:21:56,750 line:-2
也许我们想在这些文章中
突出显示一些有趣的事情


371
00:21:56,817 --> 00:21:58,385 line:-1
比如名字


372
00:21:58,752 --> 00:22:02,823 line:-1
我们已经对人名、地名和组织名称


373
00:22:02,890 --> 00:22:05,425 line:-1
提供了内置的命名实体识别功能


374
00:22:06,260 --> 00:22:09,162 line:-1
但也许我们也想突出显示产品的名称


375
00:22:09,229 --> 00:22:13,467 line:-2
我们可以训练一个自定义单词标记器
来为我们识别这些名称


376
00:22:15,369 --> 00:22:17,271 line:-1
现在让我切换到演示机


377
00:22:22,809 --> 00:22:25,379 line:-1
这是我们在


378
00:22:25,445 --> 00:22:29,149 line:-2
app任何自然语言处理技术
之前的app


379
00:22:29,383 --> 00:22:33,153 line:-2
正如你所看到的
这只是一个长长的文章列表


380
00:22:33,220 --> 00:22:36,490 line:-1
以及我们右边文章的大块文本


381
00:22:36,557 --> 00:22:37,491 line:-1
让我们来解决这个问题


382
00:22:38,759 --> 00:22:41,061 line:-1
让我们进入…


383
00:22:42,162 --> 00:22:46,667 line:-1
训练模型的第一部分是数据


384
00:22:47,167 --> 00:22:50,671 line:-2
幸运的是 我在Apple有一些
非常努力的同事


385
00:22:50,737 --> 00:22:54,508 line:-2
他们收集了一些训练数据
来让我训练这两个模型


386
00:22:54,741 --> 00:22:57,811 line:-1
第一个模型是一个文本分类器


387
00:22:58,145 --> 00:23:00,480 line:-1
它将根据主题对文章进行分类


388
00:23:00,848 --> 00:23:03,217 line:-1
这是一部分训练数据的样子


389
00:23:03,717 --> 00:23:09,523 line:-2
每个训练示例都包括一个文本块
和对应主题的适当标签


390
00:23:09,590 --> 00:23:12,626 line:-1
娱乐、政治、体育等等


391
00:23:15,495 --> 00:23:20,601 line:-2
我还有一些用来训练单词标记器的
训练数据


392
00:23:21,235 --> 00:23:25,839 line:-2
这个标记器将被用来
识别句子中的产品名称


393
00:23:26,206 --> 00:23:28,175 line:-1
这些训练数据非常简单


394
00:23:28,675 --> 00:23:33,947 line:-1
每个例子都包含一个token序列


395
00:23:34,014 --> 00:23:37,885 line:-2
以及一个标签序列 每个标签
要么是“NONE” 代表非产品名


396
00:23:37,951 --> 00:23:41,388 line:-1
要么是“PROD” 代表是产品名


397
00:23:43,624 --> 00:23:46,493 line:-1
我们试着用这些数据进行训练


398
00:23:47,160 --> 00:23:48,896 line:-1
我想要做的第一件事


399
00:23:49,663 --> 00:23:54,067 line:-2
是启动一个运行Create ML
的Playground


400
00:23:54,935 --> 00:23:57,604 line:-1
这个Playground将会加载


401
00:23:58,372 --> 00:24:01,542 line:-1
我的产品单词标记器


402
00:24:01,742 --> 00:24:05,279 line:-2
它会加载训练数据
从中创建一个单词标记器


403
00:24:05,879 --> 00:24:08,348 line:-1
并将其写入磁盘


404
00:24:09,483 --> 00:24:10,817 line:-1
现在让我们运行它


405
00:24:11,151 --> 00:24:16,056 line:0
它加载了数据 我们在底层


406
00:24:16,123 --> 00:24:19,126 line:0
自动处理了所有的分词 特征提取
以及训练过程


407
00:24:19,459 --> 00:24:21,795 line:0
我们实现了这个训练过程
这是一个相当小的模型


408
00:24:22,162 --> 00:24:28,302 line:0
所以它不需要很长时间来训练
我已经将其设置为


409
00:24:28,368 --> 00:24:32,906 line:0
自动将我的模型保存到我的桌面上
它就在那里


410
00:24:36,109 --> 00:24:37,544 line:-1
好的 这是其中一个模型


411
00:24:38,579 --> 00:24:42,850 line:-2
这里有另一个Playground
来训练我的文本分类器


412
00:24:43,116 --> 00:24:46,153 line:-2
如你所见 它看起来非常相似
加载训练数据


413
00:24:47,421 --> 00:24:50,424 line:-2
从中创建一个文本分类器
并将其写入磁盘


414
00:24:51,692 --> 00:24:52,826 line:-1
现在运行它


415
00:24:53,393 --> 00:24:59,266 line:0
同样 Natural Language
自动加载所有数据对其进行分词


416
00:24:59,633 --> 00:25:00,901 line:0
并从中提取特征


417
00:25:01,201 --> 00:25:04,471 line:0
这是一个更大的模型
训练需要几分钟


418
00:25:04,538 --> 00:25:07,574 line:0
我们让它跑去吧 同时


419
00:25:08,175 --> 00:25:12,112 line:-2
我们看看在运行时
必须用到的一些代码


420
00:25:12,713 --> 00:25:16,617 line:-2
我写了两个非常小的类
来完成我在运行时需要做的事情


421
00:25:17,117 --> 00:25:23,857 line:-2
第一个通过在我的app资源中
找到该模型来使用文本分类器


422
00:25:24,157 --> 00:25:25,859 line:-1
并为其创建一个NLModel对象


423
00:25:26,793 --> 00:25:29,162 line:-1
然后 当我碰到一篇文章时


424
00:25:30,430 --> 00:25:31,899 line:-1
我只是让模型返回


425
00:25:31,965 --> 00:25:36,637 line:-2
为该文章预测的标签
而这就是它的全部了


426
00:25:38,472 --> 00:25:43,577 line:-1
使用单词标记器的代码稍多一些


427
00:25:44,144 --> 00:25:47,214 line:-2
正如你之前所见
我有一个实现产品名称识别的


428
00:25:47,948 --> 00:25:50,350 line:-1
自定义标签方案


429
00:25:50,918 --> 00:25:54,621 line:-1
我真正感兴趣的唯一标签是产品标签


430
00:25:54,688 --> 00:25:56,890 line:-1
我为此创建了一个自定义标签


431
00:25:58,325 --> 00:26:01,962 line:-2
同样 我必须在捆绑资源中
找到该模型


432
00:26:03,030 --> 00:26:04,498 line:-1
为它创建一个NLModel对象


433
00:26:05,232 --> 00:26:06,733 line:-1
然后创建一个NLTagger


434
00:26:07,067 --> 00:26:10,304 line:-2
在这个NLTagger中
我指定了两个方案


435
00:26:10,370 --> 00:26:15,509 line:-2
第一种是内置名称类型方案
用来进行命名实体识别


436
00:26:15,776 --> 00:26:18,412 line:-1
第二个是我的自定义产品标签方案


437
00:26:18,478 --> 00:26:20,681 line:-1
它们都以完全相同的方式运行


438
00:26:21,548 --> 00:26:23,650 line:-1
然后 我只需让那个标记器


439
00:26:23,717 --> 00:26:26,820 line:-2
将我的自定义模型
用于我的自定义方案


440
00:26:27,721 --> 00:26:29,523 line:-1
现在 如果我要支持多种语言


441
00:26:29,590 --> 00:26:32,326 line:-1
我可能会在这个方案中有多个模型


442
00:26:34,528 --> 00:26:40,334 line:-1
然后 我要做的是突出显示


443
00:26:40,667 --> 00:26:44,304 line:-1
这篇文章中被识别为一种名称的文本


444
00:26:44,505 --> 00:26:47,274 line:-1
我会得到一个可变属性字符串


445
00:26:47,341 --> 00:26:49,176 line:-1
我将向它添加一些属性


446
00:26:50,043 --> 00:26:53,547 line:-2
首先获取
这个可变属性字符串的字符串值


447
00:26:53,847 --> 00:26:55,215 line:-1
将其赋值给我的标记器


448
00:26:55,949 --> 00:26:59,253 line:-1
然后我将对标签进行几轮遍历


449
00:26:59,653 --> 00:27:03,123 line:-1
第一轮使用内置的名称类型方案


450
00:27:03,490 --> 00:27:06,860 line:-2
来为人物、地点和组织
进行命名实体识别


451
00:27:07,361 --> 00:27:12,165 line:-2
如果我找到标记为
人名或地名或组织名的内容


452
00:27:12,699 --> 00:27:15,969 line:0
我将添加一个属性到这个属性字符串


453
00:27:16,236 --> 00:27:18,071 line:0
这会给它设置一些颜色


454
00:27:20,240 --> 00:27:24,144 line:-2
然后我们可以用我们的自定义模型
做同样的事情


455
00:27:24,845 --> 00:27:28,182 line:-2
我们将使用我们的
自定义产品标签方案进行遍历


456
00:27:29,583 --> 00:27:32,186 line:-1
在这种情况下 如果我们发现有东西


457
00:27:32,252 --> 00:27:34,021 line:-1
被我们的自定义产品标签所标记


458
00:27:34,321 --> 00:27:37,891 line:-2
就可以以完全相同的方式
为它添加颜色


459
00:27:39,059 --> 00:27:43,363 line:-2
所以你可以在Natural Language API中
使用自定义模型


460
00:27:43,730 --> 00:27:47,000 line:-1
就像你使用内置模型一样


461
00:27:47,568 --> 00:27:49,169 line:-2
现在 让我们回到
Playground


462
00:27:49,903 --> 00:27:53,273 line:-1
我们看到模型训练已经完成


463
00:27:53,340 --> 00:27:56,143 line:-1
现在有两个模型显示在我的桌面上


464
00:27:58,045 --> 00:28:01,281 line:-2
我需要做的就是将它们
拖到我的app中


465
00:28:02,082 --> 00:28:06,320 line:-1
让我们把这个拖到项目中


466
00:28:08,322 --> 00:28:09,189 line:-1
好了


467
00:28:11,892 --> 00:28:17,431 line:-1
我们把这个也拖进来


468
00:28:18,632 --> 00:28:22,569 line:-2
Xcode会自动编译它们
并将它们包含在我的app中


469
00:28:22,836 --> 00:28:26,073 line:0
我所要做的就是构建并运行它


470
00:28:31,378 --> 00:28:34,314 line:-1
让我们隐藏这个


471
00:28:34,915 --> 00:28:38,886 line:-2
这是我的新app
你会注意到我的文章列表


472
00:28:39,119 --> 00:28:42,289 line:-1
全部按主题自动分类


473
00:28:45,859 --> 00:28:50,464 line:-1
如果我进去看看其中一篇文章


474
00:28:50,697 --> 00:28:54,067 line:-1
你会注意到名称在其中突出显示


475
00:28:54,134 --> 00:28:56,937 line:-2
你可以看到
通过使用内置的命名实体识别功能


476
00:28:57,004 --> 00:28:59,940 line:-1
我们突出显示了人名、地名和组织名


477
00:29:00,274 --> 00:29:01,642 line:-1
但进一步来看


478
00:29:02,409 --> 00:29:06,180 line:-2
你可以看到它使用了
我们的自定义产品标记器


479
00:29:06,580 --> 00:29:11,818 line:-2
突显了iPad、MacBook
iPad mini等产品的名称


480
00:29:13,520 --> 00:29:18,625 line:-1
这显示了训练你自己的自定义模型


481
00:29:18,692 --> 00:29:22,563 line:-2
并将它们与Natural Language API
一起使用是多么容易


482
00:29:30,904 --> 00:29:34,341 line:-1
现在我要把话筒交给Vivek


483
00:29:34,408 --> 00:29:37,811 line:-1
来谈论训练模型的一些重要考虑因素


484
00:29:44,017 --> 00:29:46,887 line:-2
感谢Doug向我们展示如何使用
这些自定义NLP模型


485
00:29:46,954 --> 00:29:50,224 line:-2
我们非常高兴能将Natural Language
和Create ML


486
00:29:50,290 --> 00:29:53,293 line:-1
以及Core ML栈紧密整合


487
00:29:53,861 --> 00:29:57,631 line:-2
我们希望你能用这个新API
做一些真正令人难以置信的事情


488
00:29:58,765 --> 00:30:02,169 line:-1
现在我想再次转移话题并谈论性能


489
00:30:03,103 --> 00:30:07,508 line:-2
正如我之前提到的 Natural Language
可以在所有Apple平台上使用


490
00:30:08,108 --> 00:30:12,379 line:-2
它也能为你提供我们称之为
“标准化文本处理”的特性


491
00:30:13,146 --> 00:30:15,682 line:-2
所以让我们再花点时间
来理解这其中的含义


492
00:30:16,383 --> 00:30:19,319 line:-2
若你看看不使用Create ML
的传统机器学习管道


493
00:30:19,386 --> 00:30:22,222 line:-1
你会从哪里开始呢？


494
00:30:22,289 --> 00:30:24,458 line:-1
你会从一些训练数据开始


495
00:30:25,292 --> 00:30:27,694 line:-2
你会获取训练数据
对其进行分词


496
00:30:27,761 --> 00:30:29,263 line:-1
还可能会提取一些特征


497
00:30:29,630 --> 00:30:32,799 line:-1
这对中文和日文等语言非常重要


498
00:30:32,866 --> 00:30:34,434 line:-1
它们的分词效果对训练结果至关重要


499
00:30:35,369 --> 00:30:37,704 line:-2
你会把这些东西丢到
你最喜欢的机器学习工具包中


500
00:30:38,472 --> 00:30:41,141 line:-1
然后你会得到一个机器学习模型


501
00:30:41,975 --> 00:30:43,577 line:-1
现在 为了在Apple设备上


502
00:30:43,644 --> 00:30:44,945 line:-1
使用该机器学习模型


503
00:30:45,012 --> 00:30:47,147 line:-2
你必须将其转换为
Core ML模型


504
00:30:47,981 --> 00:30:50,817 line:-2
你会怎么做？你会使用
Core ML转换器来做到这点


505
00:30:51,585 --> 00:30:56,523 line:-2
这是从数据到模型
并将其部署到Apple设备上的


506
00:30:56,590 --> 00:30:58,225 line:-1
整个训练过程


507
00:30:59,893 --> 00:31:00,727 line:-1
现在


508
00:31:01,261 --> 00:31:04,998 line:-2
在推理阶段
你将你的模型放入app中


509
00:31:05,399 --> 00:31:06,466 line:-1
但这不是全部


510
00:31:07,234 --> 00:31:08,569 line:-1
你也必须确保


511
00:31:09,169 --> 00:31:13,207 line:-1
你编写的用于分词和特征提取的代码


512
00:31:13,273 --> 00:31:14,741 line:-1
与训练时所用代码效果一致


513
00:31:16,543 --> 00:31:18,879 line:-2
这需要付出很大的努力
因为你必须考虑


514
00:31:18,946 --> 00:31:20,681 line:-1
最大限度地提高模型的保真度


515
00:31:20,814 --> 00:31:24,785 line:-1
确保在训练和推理阶段都使用


516
00:31:24,852 --> 00:31:27,154 line:-1
相同的分词和特征提取方法非常重要


517
00:31:27,888 --> 00:31:31,291 line:-2
但现有了Natural Language
你可以完全避免这种情况


518
00:31:31,792 --> 00:31:35,929 line:-2
如果你看一下训练的流程
这是训练数据


519
00:31:37,231 --> 00:31:40,334 line:-2
你可通过我们讨论过的API
将它传递给Create ML


520
00:31:41,134 --> 00:31:43,971 line:0
Create ML在底层调用
Natural Language


521
00:31:44,037 --> 00:31:47,708 line:0
后者进行分词 特征提取
选择机器学习库


522
00:31:47,774 --> 00:31:52,045 line:0
完成所有这些工作
并返回一个Core ML模型


523
00:31:53,080 --> 00:31:56,850 line:0
在推理阶段 你做的事仍然是
将这个模型放入你的app中


524
00:31:58,151 --> 00:32:00,721 line:0
但你不必关心分词 特征提取


525
00:32:00,787 --> 00:32:04,024 line:0
或其他任何东西
事实上你不必编写一行代码


526
00:32:04,091 --> 00:32:07,060 line:0
因为Natural Language
为你做了所有这些事


527
00:32:07,361 --> 00:32:11,298 line:-2
你只需专注于你的app和任务
并简单地拖放模型即可


528
00:32:13,834 --> 00:32:17,304 line:-2
正如我之前提到的
Natural Language的另一特性是


529
00:32:17,371 --> 00:32:19,540 line:-2
它针对Apple硬件
和模型大小做了优化


530
00:32:20,007 --> 00:32:22,676 line:-1
我们来看几个例子


531
00:32:23,810 --> 00:32:26,547 line:0
Doug谈到了命名实体识别和分块


532
00:32:27,114 --> 00:32:28,615 line:0
这里有两个不同的基准


533
00:32:28,682 --> 00:32:32,920 line:0
这些分别是我们使用
CRFSuite开源工具包


534
00:32:32,986 --> 00:32:35,389 line:0
和Natural Language建立的模型


535
00:32:35,689 --> 00:32:38,559 line:0
模型由相同的训练数据训练而成


536
00:32:38,625 --> 00:32:40,394 line:0
并在相同的测试数据上进行测试


537
00:32:40,827 --> 00:32:42,429 line:0
它们实现了相同的功能


538
00:32:42,496 --> 00:32:45,132 line:0
这两个模型所获得的准确度是相同的


539
00:32:45,732 --> 00:32:49,002 line:0
但是你看看Natural Language
所产生的模型大小


540
00:32:49,403 --> 00:32:53,307 line:0
它的命名实体识别模型
只有大约1.4兆字节


541
00:32:53,373 --> 00:32:56,143 line:0
分块只用了1.8兆字节


542
00:32:56,543 --> 00:33:00,113 line:0
这为你的app节省了大量的空间
以用来做一些其他事情


543
00:33:02,950 --> 00:33:04,885 line:-1
就机器学习算法而言


544
00:33:05,752 --> 00:33:07,521 line:-1
我们支持两种不同的选项


545
00:33:08,455 --> 00:33:10,090 line:-1
我们可为文本分类指定这些选项


546
00:33:10,157 --> 00:33:12,559 line:-2
对于文本分类
我们有两个不同的选择


547
00:33:12,960 --> 00:33:16,063 line:-2
一个是maxEnt
它是Maximum Entropy的缩写


548
00:33:16,563 --> 00:33:20,701 line:-2
在NLP中 我们认为maxEnt本质上
是一个多项式逻辑回归模型


549
00:33:20,934 --> 00:33:23,036 line:-2
我们在NLP领域中直接将其称为
Maximum Entropy


550
00:33:23,871 --> 00:33:25,305 line:-1
另一个是CRF


551
00:33:25,372 --> 00:33:27,674 line:-1
这是Conditional Random Field的缩写


552
00:33:28,642 --> 00:33:31,512 line:-2
这两种算法的选择实际上
取决于你的任务类型


553
00:33:31,912 --> 00:33:35,382 line:-2
因此我们鼓励你尝试
分别用这两个选项来建立模型


554
00:33:37,184 --> 00:33:38,585 line:-1
就单词标记而言


555
00:33:38,919 --> 00:33:41,688 line:-1
Conditional Random Field是默认选项


556
00:33:41,955 --> 00:33:44,224 line:-2
当你实例化一个MLWordTagger
并为其指定数据时


557
00:33:44,291 --> 00:33:49,162 line:-2
你将使用的默认模型就是
Conditional Random Field


558
00:33:50,531 --> 00:33:52,399 line:-2
正如我所提到的
如何选择这些算法


559
00:33:52,466 --> 00:33:53,734 line:-1
实际上取决于你的任务


560
00:33:54,168 --> 00:33:55,536 line:-1
但我想强调一下


561
00:33:55,602 --> 00:34:00,073 line:-1
这与你的传统开发过程有点类似


562
00:34:00,307 --> 00:34:04,111 line:-2
当你有一个app的新想法时
你需要经历一个开发周期 对吧


563
00:34:04,278 --> 00:34:08,114 line:-2
你可以把机器学习看成是一种
与这非常类似的工作流程


564
00:34:08,982 --> 00:34:10,751 line:-1
你从哪里开始呢 从数据开始


565
00:34:11,752 --> 00:34:14,888 line:-2
当你有数据之后
你必须考虑几个问题


566
00:34:15,621 --> 00:34:18,725 line:-2
你必须验证你的训练数据
你必须确保


567
00:34:18,792 --> 00:34:21,460 line:-2
你的数据中没有虚假示例
并且数据没有受到污染


568
00:34:22,329 --> 00:34:23,330 line:-1
一旦你这样做


569
00:34:23,397 --> 00:34:26,500 line:-1
你可以检视每个类的训练实例的数量


570
00:34:26,567 --> 00:34:29,369 line:-1
假设你在训练一个情感分类模型


571
00:34:29,436 --> 00:34:31,471 line:-1
你有一千个积极情绪的例子


572
00:34:31,538 --> 00:34:33,373 line:-1
却只有五个负面情绪的例子


573
00:34:33,873 --> 00:34:36,510 line:-1
你无法训练出健壮的模型


574
00:34:36,577 --> 00:34:39,246 line:-1
来确定或区分这两个类


575
00:34:39,513 --> 00:34:41,648 line:-1
你必须确保训练样本的数量


576
00:34:41,715 --> 00:34:43,851 line:-1
对于每个类都是平衡的


577
00:34:44,918 --> 00:34:48,188 line:-2
一旦你准备好了数据
下一步就是训练


578
00:34:48,789 --> 00:34:49,922 line:-1
如前所述


579
00:34:49,989 --> 00:34:53,159 line:-1
我们的建议是你运行可选的不同选项


580
00:34:53,694 --> 00:34:54,962 line:-1
并弄清楚哪些是好的


581
00:34:55,462 --> 00:34:57,297 line:-1
但你如何定义什么是好的呢？


582
00:34:57,664 --> 00:35:01,835 line:-2
你必须对模型进行评估才能找出
适合你的app的模型


583
00:35:02,169 --> 00:35:05,305 line:-1
因此工作流程中的下一步就是评估


584
00:35:07,207 --> 00:35:10,477 line:-1
机器学习的传统评估方法是这样


585
00:35:10,544 --> 00:35:14,548 line:-2
当你获得训练数据时
你将数据分成一个训练集


586
00:35:14,915 --> 00:35:17,317 line:-1
一个验证集和一个测试集


587
00:35:17,751 --> 00:35:19,987 line:-1
你通常会使用验证集调整算法的参数


588
00:35:20,053 --> 00:35:22,723 line:-1
然后在测试集上对其进行测试


589
00:35:23,090 --> 00:35:26,093 line:-1
我们鼓励你做同样的事情 即app


590
00:35:26,159 --> 00:35:29,096 line:-2
这种长期以来一直被使用的
机器学习指导方针


591
00:35:29,997 --> 00:35:33,867 line:-2
我们鼓励你做的另一件事是
测试域外数据


592
00:35:34,134 --> 00:35:35,102 line:-1
这是什么意思


593
00:35:35,502 --> 00:35:38,939 line:-2
当你有一个app想法时
你会想到某种类型的数据


594
00:35:39,006 --> 00:35:41,608 line:-1
将被你的机器学习模型摄入


595
00:35:42,276 --> 00:35:45,612 line:-2
现在假设你正在构建一个
酒店评论app


596
00:35:45,679 --> 00:35:50,517 line:-1
你想将酒店评论分为不同的等级


597
00:35:51,485 --> 00:35:54,888 line:-2
这时用户抛出一个
完全在此领域外的数据


598
00:35:54,955 --> 00:35:57,624 line:-1
也许这是一条餐厅评论


599
00:35:57,691 --> 00:36:00,727 line:-2
或电影评论
你的模型能够强大到应付它吗


600
00:36:01,595 --> 00:36:03,430 line:-1
这是一个你应该问自己的问题


601
00:36:04,097 --> 00:36:07,868 line:-1
最后一步 在传统的开发流程中


602
00:36:07,935 --> 00:36:11,705 line:-2
你会编写补丁程序 修复错误
并更新你的app


603
00:36:12,439 --> 00:36:13,907 line:-1
在机器学习中如何做到这点？


604
00:36:16,043 --> 00:36:20,147 line:-1
解决机器学习问题的方法就是找出


605
00:36:20,214 --> 00:36:22,382 line:-1
你的模型何时表现不佳


606
00:36:22,449 --> 00:36:24,718 line:-1
然后你必须用正确的数据来完善它


607
00:36:25,219 --> 00:36:29,656 line:-2
通过添加数据并重新训练你的模型
你基本上可以得到一个新模型


608
00:36:29,823 --> 00:36:33,493 line:-2
所以 正如我所提到的
它与开发流程非常相似


609
00:36:33,560 --> 00:36:35,495 line:-1
它们几乎是平行的


610
00:36:35,562 --> 00:36:39,700 line:-2
所以如果你正在app中
使用机器学习模型 你可以将其视为


611
00:36:39,766 --> 00:36:40,734 line:-1
基础结构的一部分


612
00:36:40,801 --> 00:36:43,570 line:-1
你可以将其融入开发流程本身之中


613
00:36:45,973 --> 00:36:48,842 line:-1
我想在这里强调的最后一件事是隐私


614
00:36:49,543 --> 00:36:51,345 line:-1
你在本次演讲中看到的所有内容


615
00:36:52,246 --> 00:36:55,182 line:-1
所有的机器学习和自然语言处理


616
00:36:55,382 --> 00:36:57,284 line:-1
都完全发生在设备上


617
00:36:57,918 --> 00:37:00,220 line:-1
我们Apple非常注重隐私


618
00:37:00,287 --> 00:37:02,689 line:-1
而完全在设备上使用机器学习技术


619
00:37:02,756 --> 00:37:06,026 line:-1
可以很好的保护用户的隐私


620
00:37:06,693 --> 00:37:07,594 line:-1
因此


621
00:37:08,595 --> 00:37:10,330 line:-2
Natural Language
是迈向


622
00:37:10,397 --> 00:37:12,399 line:-1
隐私保护型机器学习的另一步


623
00:37:12,466 --> 00:37:14,301 line:-1
但这次我们将其app于NLP领域


624
00:37:16,203 --> 00:37:17,104 line:-1
总而言之


625
00:37:18,539 --> 00:37:21,742 line:-2
我们谈到了一个名为
Natural Language的新框架


626
00:37:22,376 --> 00:37:25,012 line:-2
它与Apple机器学习技术栈
紧密集成


627
00:37:25,579 --> 00:37:29,950 line:-2
你现可使用Create ML来训练模型
然后使用Core ML API


628
00:37:30,017 --> 00:37:32,920 line:-2
或Natural Language
来处理这些模型


629
00:37:34,421 --> 00:37:37,291 line:-2
我们使用Natural Language
及其API生成的模型


630
00:37:37,357 --> 00:37:40,227 line:-1
具有优秀的性能 并在所有平台上


631
00:37:40,294 --> 00:37:41,628 line:-1
针对Apple硬件进行了优化


632
00:37:42,229 --> 00:37:46,867 line:-2
最后 它支持隐私保护
因为NLP中的所有机器学习


633
00:37:46,934 --> 00:37:48,402 line:-1
都发生在用户的设备上


634
00:37:51,071 --> 00:37:54,474 line:0
屏幕上有更多信息 明天还有一个
Natural Language实验室


635
00:37:54,541 --> 00:37:58,378 line:0
我们鼓励你尝试这些API并与我们交流
或向我们提出


636
00:37:58,445 --> 00:38:01,682 line:0
你想要哪些改进的建议
或者甚至咨询你自己app


637
00:38:01,748 --> 00:38:02,816 line:0
的一些问题


638
00:38:03,750 --> 00:38:05,519 line:0
我们也有一个机器学习聚会


639
00:38:05,586 --> 00:38:09,690 line:0
并且随后还有一个
并行Create ML实验


640
00:38:09,990 --> 00:38:13,126 line:0
因此你可以来实验室继续与我们交谈


641
00:38:13,594 --> 00:38:16,296 line:0
感谢你的关注
谢谢

