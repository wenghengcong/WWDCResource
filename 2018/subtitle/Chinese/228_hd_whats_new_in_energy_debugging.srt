1
00:00:17,618 --> 00:00:21,955 line:0
（能耗调试新特性）


2
00:00:22,022 --> 00:00:22,856 line:-1
谢谢


3
00:00:24,825 --> 00:00:25,659 line:-1
谢谢


4
00:00:26,593 --> 00:00:27,594 line:-1
大家下午好


5
00:00:27,961 --> 00:00:29,029 line:-1
我是Phil Azar


6
00:00:29,096 --> 00:00:31,031 line:-2
我是Apple能耗团队的
软件工程师


7
00:00:31,832 --> 00:00:33,767 line:-1
今天很荣幸和同事David一起


8
00:00:34,168 --> 00:00:37,237 line:-1
和你们分享能耗调试新特性


9
00:00:40,574 --> 00:00:42,976 line:-1
电池待机时间对客户来说非常重要


10
00:00:43,410 --> 00:00:45,279 line:-1
能耗组竭尽全力


11
00:00:45,345 --> 00:00:48,182 line:-1
设法让每个人每天


12
00:00:48,248 --> 00:00:49,750 line:-1
只用为设备充一次电


13
00:00:50,918 --> 00:00:53,220 line:-1
我们和Apple的开发人员


14
00:00:53,287 --> 00:00:55,989 line:-2
通力合作指导协助
他们制定高效的电池设计


15
00:00:56,056 --> 00:00:58,825 line:-1
以优化电池待机时间


16
00:01:00,527 --> 00:01:03,197 line:-1
app对客户来说也非常重要


17
00:01:03,497 --> 00:01:06,733 line:-1
事实上 我们发现大多数设备


18
00:01:06,800 --> 00:01:09,269 line:-1
都直接用于第三方app


19
00:01:09,536 --> 00:01:10,637 line:-1
这很不可思议


20
00:01:10,704 --> 00:01:13,841 line:-1
关注app设计的电池效率


21
00:01:14,374 --> 00:01:17,678 line:-1
变得比以往更加重要


22
00:01:18,812 --> 00:01:21,548 line:-1
为此 我们今天将谈到三个方面


23
00:01:22,883 --> 00:01:25,586 line:-1
首先 我们会讲到app中能用到的


24
00:01:25,652 --> 00:01:27,821 line:-1
电池待机时间的几个概念


25
00:01:28,155 --> 00:01:30,757 line:-1
以确保app尽可能低能耗


26
00:01:31,925 --> 00:01:35,295 line:-1
然后会讲到几个可用的工具


27
00:01:35,696 --> 00:01:39,533 line:-2
以理解和度量app中
哪儿消耗了电池电量


28
00:01:40,200 --> 00:01:42,936 line:-1
最后 交给同事David


29
00:01:43,003 --> 00:01:45,205 line:-1
他会介绍可用的新工具


30
00:01:45,272 --> 00:01:47,674 line:-1
让能耗调试更进一步


31
00:01:48,809 --> 00:01:50,444 line:-1
现在开始


32
00:01:50,511 --> 00:01:52,112 line:-1
介绍几个通用的概念


33
00:01:53,113 --> 00:01:55,215 line:-1
为了获得满意的电池待机时间


34
00:01:55,282 --> 00:01:57,117 line:-1
要从几个首要原则开始


35
00:01:57,184 --> 00:02:00,354 line:-1
并理解电池待机时间的构成


36
00:02:01,388 --> 00:02:02,222 line:-1
现在开始吧


37
00:02:04,091 --> 00:02:04,958 line:-1
能量是什么？


38
00:02:05,025 --> 00:02:06,093 line:-1
（能量是什么？）


39
00:02:06,159 --> 00:02:08,228 line:-1
从根本上 从物理角度


40
00:02:08,595 --> 00:02:10,864 line:-1
能量是动力和时间的产物


41
00:02:11,732 --> 00:02:14,301 line:-1
app在平台上运行


42
00:02:14,368 --> 00:02:16,803 line:-1
以不同的速度消耗能量


43
00:02:17,704 --> 00:02:19,606 line:-1
因为app进行的任务不同


44
00:02:19,673 --> 00:02:21,241 line:-1
消耗的能量也不同


45
00:02:21,975 --> 00:02:25,345 line:-1
此外 app进行的耗能任务越多


46
00:02:25,412 --> 00:02:27,181 line:-1
要面对的能量消耗也越多


47
00:02:27,881 --> 00:02:29,149 line:-1
可以画一张图


48
00:02:30,150 --> 00:02:32,419 line:-1
可以看到app在运行


49
00:02:32,486 --> 00:02:34,955 line:-1
有不同能量消耗的峰值和低谷


50
00:02:35,856 --> 00:02:38,892 line:0
曲线下方是能量消耗


51
00:02:39,760 --> 00:02:41,895 line:0
这直接关系到app


52
00:02:41,962 --> 00:02:43,163 line:0
不同的运行模式


53
00:02:44,798 --> 00:02:47,568 line:-1
app激活和空闲时


54
00:02:48,235 --> 00:02:50,103 line:-1
消耗的能量不同


55
00:02:50,838 --> 00:02:53,173 line:-1
app激活时


56
00:02:53,240 --> 00:02:54,408 line:-1
消耗能量的速度最快


57
00:02:55,209 --> 00:02:57,578 line:-1
因为用户为了所需的功能


58
00:02:57,644 --> 00:02:59,580 line:-1
才直接使用app


59
00:03:00,314 --> 00:03:02,850 line:-1
app空闲但保持运行时


60
00:03:02,916 --> 00:03:04,351 line:-1
能量消耗下降


61
00:03:06,186 --> 00:03:07,955 line:0
最后app挂起时


62
00:03:08,021 --> 00:03:10,157 line:0
仍有基本的能量消耗


63
00:03:11,091 --> 00:03:12,392 line:0
这也很有意思


64
00:03:13,594 --> 00:03:16,597 line:-1
app执行本来设计的任务时


65
00:03:16,663 --> 00:03:19,399 line:-1
会请求系统调用


66
00:03:19,466 --> 00:03:21,101 line:-1
执行任务需要的硬件


67
00:03:21,902 --> 00:03:23,604 line:-1
调用相关硬件


68
00:03:23,670 --> 00:03:25,706 line:-1
所需要的能量


69
00:03:26,240 --> 00:03:27,241 line:0
称作开销


70
00:03:28,141 --> 00:03:30,544 line:0
app无法直接控制开销


71
00:03:30,878 --> 00:03:34,414 line:0
但它的任何行为都会有影响


72
00:03:35,883 --> 00:03:38,886 line:-1
app第一次使用硬件资源时


73
00:03:39,253 --> 00:03:40,687 line:-1
叫做激活能量


74
00:03:41,088 --> 00:03:43,891 line:-1
app访问 比如说 无线电


75
00:03:44,224 --> 00:03:46,226 line:-1
或者访问 比如说 相机


76
00:03:46,527 --> 00:03:48,328 line:-1
并用到子系统


77
00:03:49,263 --> 00:03:51,999 line:-1
消耗的能量称作激活能量


78
00:03:53,100 --> 00:03:54,501 line:-1
所以能看到


79
00:03:54,968 --> 00:03:58,372 line:-2
电池待机问题是两部分
组成的优化问题


80
00:03:58,872 --> 00:04:00,340 line:-1
我们要考虑


81
00:04:00,407 --> 00:04:02,176 line:-1
在消耗的激活能量上保持高效


82
00:04:02,543 --> 00:04:05,746 line:-1
也要考虑向系统


83
00:04:05,812 --> 00:04:08,348 line:-1
请求不同的硬件资源产生的开销


84
00:04:11,218 --> 00:04:12,386 line:-1
我讲过硬件


85
00:04:13,020 --> 00:04:15,455 line:-1
和这些子系统都会消耗能量


86
00:04:15,989 --> 00:04:18,257 line:-1
系统里到底什么在消耗能量


87
00:04:18,892 --> 00:04:19,927 line:-1
作为开发者


88
00:04:19,993 --> 00:04:22,529 line:-1
app开发过程中


89
00:04:22,863 --> 00:04:24,364 line:-1
将遇到一些不同的硬件子系统


90
00:04:25,499 --> 00:04:28,335 line:-1
但我们认为有四个子系统


91
00:04:28,402 --> 00:04:30,771 line:-1
是能量消耗最多的


92
00:04:30,871 --> 00:04:32,606 line:-1
（什么消耗能量？）


93
00:04:32,673 --> 00:04:33,907 line:-1
这里列出来了


94
00:04:34,842 --> 00:04:38,345 line:-1
任务处理、网络、位置和图像


95
00:04:39,813 --> 00:04:41,882 line:-2
我们看看这些
并试着理解它们是指什么


96
00:04:43,483 --> 00:04:45,185 line:-1
任务处理是你能想象到的


97
00:04:46,386 --> 00:04:48,388 line:-1
它是app使用系统资源时


98
00:04:48,455 --> 00:04:50,424 line:-1
要消耗的资源


99
00:04:50,490 --> 00:04:51,625 line:-1
系统芯片作为例子


100
00:04:51,692 --> 00:04:54,228 line:-1
例如内存、CPU等等


101
00:04:55,128 --> 00:04:56,964 line:-1
是真正干活的部分


102
00:04:57,598 --> 00:04:58,966 line:-1
这里消耗的能量


103
00:04:59,032 --> 00:05:02,503 line:-1
大幅取决于app执行的代码


104
00:05:02,569 --> 00:05:04,771 line:-1
请求系统执行的任务


105
00:05:06,006 --> 00:05:06,874 line:-1
总的来说


106
00:05:07,307 --> 00:05:09,776 line:-1
app执行的代码越多


107
00:05:10,143 --> 00:05:12,713 line:-1
处理时消耗的能量就越多


108
00:05:12,779 --> 00:05:14,581 line:-1
（任务处理）


109
00:05:14,648 --> 00:05:17,484 line:-1
当我们谈到设备消耗的能量时


110
00:05:17,551 --> 00:05:20,153 line:-1
网络是下一个要考虑的主要子系统


111
00:05:22,356 --> 00:05:24,458 line:-1
网络消耗的能量是你能想到的


112
00:05:24,892 --> 00:05:27,594 line:-1
只要app请求执行任何通过


113
00:05:27,661 --> 00:05:29,830 line:-2
移动网、Wi-Fi
蓝牙的网络任务


114
00:05:30,297 --> 00:05:32,799 line:-1
就会以网络的形式消耗能量


115
00:05:34,268 --> 00:05:35,969 line:-1
这部分能量取决于流量


116
00:05:36,470 --> 00:05:38,605 line:-1
app请求通过这些技术


117
00:05:38,672 --> 00:05:40,307 line:-1
发送越多的数据流量


118
00:05:40,374 --> 00:05:41,808 line:-1
消耗的能量越多


119
00:05:42,543 --> 00:05:43,510 line:-1
（网络）


120
00:05:43,577 --> 00:05:44,611 line:-1
粗略而言


121
00:05:44,678 --> 00:05:46,747 line:-1
app的网络请求越多


122
00:05:47,114 --> 00:05:49,183 line:-1
网络方面消耗的能量越多


123
00:05:51,018 --> 00:05:53,020 line:-1
位置服务也类似但有轻微不同


124
00:05:54,321 --> 00:05:55,822 line:-1
位置子系统中


125
00:05:55,889 --> 00:06:01,395 line:-2
app请求通过GPS
Wi-Fi、移动网定位时


126
00:06:02,062 --> 00:06:03,864 line:-1
位置系统就会耗能


127
00:06:05,899 --> 00:06:09,236 line:-2
位置服务消耗的能量
取决于精度和频率


128
00:06:10,103 --> 00:06:13,373 line:-1
如果频繁的请求


129
00:06:13,440 --> 00:06:15,108 line:-1
高精度的定位用户位置


130
00:06:15,542 --> 00:06:17,311 line:-1
位置服务就会


131
00:06:17,377 --> 00:06:18,412 line:-1
消耗大量能量


132
00:06:18,478 --> 00:06:20,314 line:-1
（定位）


133
00:06:20,380 --> 00:06:21,582 line:-1
归纳一下


134
00:06:21,648 --> 00:06:24,551 line:-1
app越长时间跟踪位置


135
00:06:24,618 --> 00:06:27,221 line:-1
位置服务消耗能量越多


136
00:06:30,457 --> 00:06:32,226 line:-1
最后还有图像


137
00:06:33,994 --> 00:06:35,395 line:-1
图像子系统中


138
00:06:35,462 --> 00:06:38,966 line:-2
能想到GPU和CPU
这些处理单元


139
00:06:39,032 --> 00:06:41,635 line:-1
在绘图部分消耗能量


140
00:06:42,769 --> 00:06:44,938 line:-1
这取决于动画和用户界面


141
00:06:45,839 --> 00:06:48,742 line:-1
app请求显示动画


142
00:06:48,809 --> 00:06:50,043 line:-1
或者渲染用户界面时


143
00:06:50,344 --> 00:06:52,613 line:-1
绘图系统就会消耗能量


144
00:06:54,248 --> 00:06:56,016 line:-1
这高度取决于复杂度


145
00:06:56,783 --> 00:06:59,219 line:-1
动画和用户界面越复杂


146
00:06:59,286 --> 00:07:01,922 line:-1
绘图消耗能量越多


147
00:07:01,989 --> 00:07:03,957 line:-1
（绘图）


148
00:07:04,024 --> 00:07:06,059 line:-1
最后 总的来说


149
00:07:06,126 --> 00:07:08,462 line:-1
app显示动画


150
00:07:08,529 --> 00:07:10,030 line:-1
和用户界面时渲染越多


151
00:07:10,397 --> 00:07:12,833 line:-1
绘图消耗能量越多


152
00:07:15,802 --> 00:07:17,571 line:-1
我们讲了四个子系统


153
00:07:18,071 --> 00:07:19,339 line:-1
结论是什么


154
00:07:19,873 --> 00:07:21,942 line:-1
有共同线索把它们联系起来


155
00:07:22,009 --> 00:07:22,876 line:-1
app开发过程中


156
00:07:23,610 --> 00:07:26,480 line:-1
执行任务越多 消耗能量越多


157
00:07:28,282 --> 00:07:31,952 line:-2
反过来不一定
因为那意味着app可能做得越少


158
00:07:32,853 --> 00:07:36,023 line:-1
因此关键是要优化我们的任务


159
00:07:36,089 --> 00:07:38,091 line:-1
并尽量使其能耗低


160
00:07:40,460 --> 00:07:41,628 line:-1
可这并不容易


161
00:07:42,663 --> 00:07:45,065 line:-1
考虑耗能效率是一个过程


162
00:07:45,933 --> 00:07:47,768 line:-1
不是简单优化一下


163
00:07:47,835 --> 00:07:51,572 line:-1
突然app能耗就低起来


164
00:07:51,638 --> 00:07:53,407 line:-1
app就能延长电池待机时间


165
00:07:54,842 --> 00:07:57,110 line:-1
要建立这样的思维模式


166
00:07:57,177 --> 00:07:58,779 line:-1
app有一组要用到的资源


167
00:07:58,846 --> 00:08:00,781 line:-1
并需要高效的使用这些资源


168
00:08:02,649 --> 00:08:03,550 line:-1
如上面所说


169
00:08:03,951 --> 00:08:07,120 line:-1
我们看看现实世界的例子


170
00:08:07,421 --> 00:08:11,425 line:-1
考虑低能耗并开始这个过程


171
00:08:12,559 --> 00:08:14,294 line:-1
举例说app在前台时


172
00:08:15,596 --> 00:08:16,763 line:-1
app在前台时


173
00:08:17,097 --> 00:08:19,700 line:-1
它要提供主要的用户体验


174
00:08:19,766 --> 00:08:22,736 line:-2
对很多人来说
这是app最主要和最关键的部分


175
00:08:23,504 --> 00:08:24,471 line:-1
如上所述


176
00:08:25,506 --> 00:08:27,107 line:-1
前台的能耗效率


177
00:08:27,174 --> 00:08:29,476 line:-1
在于向用户提供价值


178
00:08:30,177 --> 00:08:33,313 line:-1
确保在用户体验方面


179
00:08:33,679 --> 00:08:34,914 line:-1
做什么都有立即响应


180
00:08:34,982 --> 00:08:35,816 line:-1
（前台）


181
00:08:35,883 --> 00:08:39,119 line:-1
一个原则是只做必要的工作


182
00:08:40,053 --> 00:08:41,255 line:-1
听起来很直白


183
00:08:42,089 --> 00:08:45,893 line:-1
我们看一个例子 为何这如此重要


184
00:08:47,261 --> 00:08:48,962 line:-1
例如正在构建一个媒体app


185
00:08:49,530 --> 00:08:51,565 line:-1
媒体app的主要目标


186
00:08:51,632 --> 00:08:54,535 line:-1
是以固定的频率向用户展示内容


187
00:08:54,601 --> 00:08:55,435 line:-1
（例子）


188
00:08:55,502 --> 00:08:57,704 line:-1
一个有效的方案


189
00:08:57,771 --> 00:09:00,107 line:-1
是以时间为基准


190
00:09:00,174 --> 00:09:01,475 line:-1
刷新显示内容


191
00:09:02,109 --> 00:09:04,811 line:-1
这将确保用户看到的内容


192
00:09:04,878 --> 00:09:07,814 line:-1
尽可能最新并没有干扰


193
00:09:09,249 --> 00:09:11,118 line:-1
这不是个低能耗的方案


194
00:09:12,019 --> 00:09:13,453 line:-1
我们想想为什么


195
00:09:14,888 --> 00:09:18,625 line:-1
如果为方案画出耗能时间曲线


196
00:09:19,059 --> 00:09:21,094 line:-1
能看到每次绘图时


197
00:09:21,395 --> 00:09:23,964 line:-1
就要消耗一些激活能量


198
00:09:25,199 --> 00:09:28,669 line:-1
但真正重要的在于有大量的开销


199
00:09:29,503 --> 00:09:33,040 line:-1
因为每次请求显示新内容时


200
00:09:33,106 --> 00:09:36,944 line:-2
很可能要调用网络
绘图、处理等子系统


201
00:09:37,010 --> 00:09:39,947 line:-1
处理这些任务并显示内容


202
00:09:40,013 --> 00:09:41,748 line:-1
而用户未必想要这个


203
00:09:42,282 --> 00:09:44,751 line:-1
我们会在app运行时


204
00:09:44,818 --> 00:09:46,053 line:-1
持续大量耗能


205
00:09:47,354 --> 00:09:48,188 line:-1
我们能做得更好


206
00:09:49,656 --> 00:09:51,758 line:-1
如果考虑用户实际想要的


207
00:09:51,825 --> 00:09:52,759 line:-1
刷新内容


208
00:09:53,160 --> 00:09:55,996 line:-1
我们能实现一个贴合需求的方案


209
00:09:57,231 --> 00:09:58,732 line:0
新方案里


210
00:09:58,799 --> 00:10:01,902 line:0
用户交互或者某类服务器通知


211
00:10:02,402 --> 00:10:05,606 line:0
会提供新内容并显示给用户


212
00:10:07,574 --> 00:10:08,942 line:0
这个方案区别不大


213
00:10:09,009 --> 00:10:10,777 line:0
但是个低耗能的方案


214
00:10:11,011 --> 00:10:13,847 line:0
在耗能方面有巨大的不同


215
00:10:14,314 --> 00:10:15,482 line:-1
我们看看为什么


216
00:10:16,483 --> 00:10:18,952 line:-1
设想app在前台运行


217
00:10:19,019 --> 00:10:20,254 line:-1
现在发生用户交互


218
00:10:20,587 --> 00:10:23,790 line:-1
我们会刷新内容并向用户显示


219
00:10:24,358 --> 00:10:27,895 line:-1
然后app进入空闲


220
00:10:28,729 --> 00:10:31,164 line:-1
此时用户滚动并阅读刚显示的内容


221
00:10:32,132 --> 00:10:34,468 line:-1
会注意到这里的开销还是有点高


222
00:10:34,535 --> 00:10:36,336 line:-1
但已经降低不少


223
00:10:36,970 --> 00:10:40,174 line:-1
窍门在于让不再需要的子系统


224
00:10:40,240 --> 00:10:42,309 line:-1
进入睡眠并空闲下来


225
00:10:45,546 --> 00:10:47,147 line:-1
另一个降低


226
00:10:47,447 --> 00:10:49,683 line:-1
前台能耗的原则是


227
00:10:50,517 --> 00:10:52,286 line:-1
将用户界面的复杂度最小化


228
00:10:53,353 --> 00:10:55,322 line:-1
我提到过绘图能耗


229
00:10:55,722 --> 00:10:58,725 line:-1
高度取决于复杂度


230
00:10:59,760 --> 00:11:02,296 line:-1
而我们想让app看起来尽可能好


231
00:11:02,362 --> 00:11:05,265 line:-1
因此我们花大量时间让用户界面


232
00:11:05,332 --> 00:11:07,401 line:-1
和动画看起来美观


233
00:11:08,669 --> 00:11:10,737 line:-1
然而 这可能有意外的副作用


234
00:11:11,705 --> 00:11:13,640 line:-1
举个例子看看为什么


235
00:11:15,642 --> 00:11:16,710 line:-1
如果我是一个视频播放器


236
00:11:17,177 --> 00:11:19,179 line:-1
目标是让用户观看视频


237
00:11:19,913 --> 00:11:20,747 line:-1
很简单


238
00:11:21,114 --> 00:11:25,252 line:-2
但我可能试图在视频上
加新的控件和用户界面


239
00:11:25,319 --> 00:11:29,823 line:-2
例如 和视频相关的
进度条或者音量控制


240
00:11:30,824 --> 00:11:33,193 line:-1
这让用户在使用app


241
00:11:33,594 --> 00:11:36,096 line:-1
和观看视频时有更大的控制权


242
00:11:37,898 --> 00:11:40,234 line:-1
这实际上可能耗能很高


243
00:11:41,134 --> 00:11:42,503 line:-1
我们想想为什么


244
00:11:43,570 --> 00:11:46,974 line:-1
大多数设备上


245
00:11:47,040 --> 00:11:49,843 line:-1
当屏幕上没有用户界面时允许低耗能


246
00:11:49,910 --> 00:11:51,512 line:-1
播放视频的地方有显示优化


247
00:11:52,513 --> 00:11:54,214 line:-1
当构建这样的app时


248
00:11:54,281 --> 00:11:56,149 line:-1
这一点会不那么清晰


249
00:11:56,216 --> 00:11:58,252 line:-1
然而却造成了很大不同


250
00:11:59,620 --> 00:12:02,523 line:-1
一个利用优化


251
00:12:02,589 --> 00:12:05,993 line:-1
应对我们看到的高耗能的好方案


252
00:12:07,127 --> 00:12:10,497 line:0
是自动隐藏用户界面控件


253
00:12:12,065 --> 00:12:14,568 line:0
这意味着任何显示在视频上


254
00:12:14,635 --> 00:12:17,337 line:0
或者用户界面层的相关内容


255
00:12:17,404 --> 00:12:19,540 line:0
在用户不交互时直接隐藏


256
00:12:20,707 --> 00:12:23,177 line:0
这在视频播放时的耗能方面


257
00:12:23,243 --> 00:12:24,278 line:0
带来很大不同


258
00:12:24,778 --> 00:12:26,747 line:0
这个显示优化对


259
00:12:26,813 --> 00:12:30,083 line:-1
维持低耗能的播放非常关键


260
00:12:33,720 --> 00:12:35,155 line:-1
我们讲了很多前台任务


261
00:12:35,589 --> 00:12:36,757 line:-1
那后台任务呢？


262
00:12:37,391 --> 00:12:39,760 line:-1
很多构建诸如音乐播放器


263
00:12:40,160 --> 00:12:42,763 line:-2
或者闹钟这类app的人
都关注后台任务


264
00:12:43,130 --> 00:12:46,800 line:-1
主要体验来自app后台的高效运行


265
00:12:49,069 --> 00:12:50,270 line:-1
我们在后台时


266
00:12:50,337 --> 00:12:52,139 line:-1
有一些要注意的事情


267
00:12:53,240 --> 00:12:56,076 line:-1
可能app运行时


268
00:12:56,143 --> 00:12:57,845 line:-1
要同时连接到设备其他系统


269
00:12:58,478 --> 00:13:01,615 line:-2
例如要使用iMessage
甚至FaceTime


270
00:13:02,516 --> 00:13:05,686 line:-2
这样 我们应该关注
最小化工作任务


271
00:13:06,119 --> 00:13:08,322 line:-1
以确保后台运行低能耗


272
00:13:08,388 --> 00:13:09,990 line:-1
（后台）


273
00:13:10,057 --> 00:13:11,825 line:-1
这是个很宽泛的描述


274
00:13:11,892 --> 00:13:13,360 line:-1
让我们试着理解一下


275
00:13:14,494 --> 00:13:15,562 line:-1
在后台运行时


276
00:13:16,029 --> 00:13:18,632 line:-1
你能够使用系统上其他app


277
00:13:18,699 --> 00:13:20,267 line:-1
已经使用的子系统


278
00:13:20,834 --> 00:13:22,269 line:-1
然而 注意


279
00:13:22,336 --> 00:13:25,205 line:-1
能耗的优先级很重要


280
00:13:25,272 --> 00:13:27,407 line:-1
倾向于那些前台的app


281
00:13:28,208 --> 00:13:31,345 line:-1
所以我们要关注最小化工作任务


282
00:13:31,411 --> 00:13:33,347 line:-1
确保不会中断那些体验


283
00:13:34,515 --> 00:13:38,118 line:-2
能开始考虑的一个办法
是把任务结合起来


284
00:13:38,919 --> 00:13:40,254 line:-1
例如 如果要在后台


285
00:13:40,320 --> 00:13:41,722 line:-1
进行大量维护工作


286
00:13:42,122 --> 00:13:44,491 line:-1
或者我们要执行大量网络任务


287
00:13:44,858 --> 00:13:48,028 line:-1
最好是把这些任务


288
00:13:48,095 --> 00:13:49,429 line:-1
合起来一次完成


289
00:13:50,130 --> 00:13:53,567 line:-2
那样我们对系统其他任务的
影响最小


290
00:13:55,202 --> 00:13:57,337 line:-1
一个遇到的很常见的例子


291
00:13:57,404 --> 00:14:00,541 line:-1
是上传分析以及与app分析配合


292
00:14:00,607 --> 00:14:01,675 line:-1
（举例）


293
00:14:01,742 --> 00:14:04,144 line:-1
可能你收集这些分析数据时


294
00:14:04,211 --> 00:14:07,381 line:-2
会立即发送
因为这是一个很健壮的方案


295
00:14:07,447 --> 00:14:09,216 line:-1
它让你构建一个数据集


296
00:14:09,583 --> 00:14:11,685 line:-1
以应对app的崩溃情况


297
00:14:12,920 --> 00:14:15,122 line:-1
那样做可能会能耗有点高


298
00:14:15,856 --> 00:14:18,692 line:-1
如果每次进入后台都发送分析数据


299
00:14:19,159 --> 00:14:21,328 line:-1
我们可能过度使用网络硬件


300
00:14:22,729 --> 00:14:23,764 line:0
我们看看能耗时间曲线


301
00:14:23,830 --> 00:14:25,699 line:0
它是这个样子的


302
00:14:26,567 --> 00:14:27,901 line:0
每次进入后台


303
00:14:28,235 --> 00:14:31,138 line:0
我们驱动网络资源发送分析数据


304
00:14:31,205 --> 00:14:32,806 line:0
然后再次空闲下来


305
00:14:34,074 --> 00:14:37,110 line:0
图上三点看起来不算太多


306
00:14:37,177 --> 00:14:40,247 line:-1
但可以想象如果大量使用app


307
00:14:40,314 --> 00:14:41,648 line:-1
这些会一次次叠加起来


308
00:14:44,051 --> 00:14:46,353 line:-1
解决问题的正确方法非常简单


309
00:14:47,921 --> 00:14:50,057 line:-1
就是分批次发送这些数据


310
00:14:50,958 --> 00:14:54,461 line:-1
我们有大量符合聚合原则的API


311
00:14:54,928 --> 00:14:56,830 line:-2
其中一个很大的组成部分
是NSURLSession


312
00:14:57,798 --> 00:15:00,334 line:-1
通过一个自由属性


313
00:15:00,567 --> 00:15:01,602 line:-1
和后台回话


314
00:15:01,869 --> 00:15:06,106 line:-2
使用NSURLSession
能快速让你利用这种优化


315
00:15:08,375 --> 00:15:09,576 line:-1
这也是解决的正确方法


316
00:15:11,178 --> 00:15:13,280 line:-1
这样做以后


317
00:15:13,347 --> 00:15:15,182 line:-1
我们再看看能耗时间曲线的样子


318
00:15:16,850 --> 00:15:20,454 line:0
这里能看到app执行


319
00:15:20,521 --> 00:15:23,023 line:0
上传分析数据的时间长了一些


320
00:15:23,090 --> 00:15:26,393 line:0
能耗却小了很多


321
00:15:26,727 --> 00:15:28,962 line:0
都集中在一次消耗


322
00:15:29,596 --> 00:15:32,766 line:0
这就是在后台运行时


323
00:15:33,200 --> 00:15:34,168 line:0
聚合任务的效果


324
00:15:35,335 --> 00:15:37,838 line:0
完成任务的短期能耗很高


325
00:15:37,905 --> 00:15:39,973 line:-1
但一旦完成后


326
00:15:40,374 --> 00:15:42,276 line:-1
不再需要担心这些任务


327
00:15:42,342 --> 00:15:44,811 line:-1
或者中断另一个任务的体验


328
00:15:47,247 --> 00:15:50,184 line:-1
另一个直观的例子


329
00:15:50,250 --> 00:15:51,585 line:-1
是快速结束任务


330
00:15:52,686 --> 00:15:54,121 line:-1
使用系统上允许


331
00:15:54,188 --> 00:15:55,989 line:-1
你利用后台运行的API


332
00:15:57,224 --> 00:16:00,394 line:-2
例如用户界面后台任务或者
UIKit、VOIP、PushKit


333
00:16:01,995 --> 00:16:06,066 line:-1
这些API有办法让你指明


334
00:16:06,133 --> 00:16:07,935 line:-1
你不再需要在后台运行


335
00:16:10,704 --> 00:16:13,340 line:-1
因此作为开发者


336
00:16:13,407 --> 00:16:14,908 line:-1
如果在使用这些后台模式


337
00:16:15,742 --> 00:16:18,045 line:-1
你应该调用这些完成处理函数


338
00:16:18,111 --> 00:16:19,279 line:-1
让系统知道任务完成


339
00:16:20,080 --> 00:16:23,584 line:-1
事实不总是这样 很多情况下


340
00:16:23,650 --> 00:16:26,954 line:-1
我们可能忘了或者不想结束任务


341
00:16:27,821 --> 00:16:29,423 line:-1
所以 让任务自己过期


342
00:16:30,757 --> 00:16:32,459 line:-1
这对能耗影响很大


343
00:16:32,526 --> 00:16:37,798 line:-1
也确实不是软件开发过程中


344
00:16:37,865 --> 00:16:39,066 line:-1
必须看到的


345
00:16:40,133 --> 00:16:42,135 line:-1
用能耗时间曲线解释一下


346
00:16:42,202 --> 00:16:43,470 line:-1
为什么这会高能耗


347
00:16:44,705 --> 00:16:47,040 line:-1
想象因为什么原因进入后台


348
00:16:47,107 --> 00:16:49,676 line:-1
任务开始 一段时间后任务完成


349
00:16:50,277 --> 00:16:53,213 line:-1
如果像说过的 让任务自己过期


350
00:16:53,981 --> 00:16:56,450 line:-1
我们进入消耗能量的这段空闲期


351
00:16:56,517 --> 00:16:58,051 line:-1
app在后台运行


352
00:16:58,118 --> 00:17:00,754 line:-1
因为某些原因请求API


353
00:17:01,288 --> 00:17:02,823 line:-1
但并没什么发生


354
00:17:03,490 --> 00:17:05,325 line:-1
然后我们有长期的开销


355
00:17:05,392 --> 00:17:06,926 line:-1
因为保持系统唤醒


356
00:17:07,227 --> 00:17:09,896 line:-1
使用资源的子系统


357
00:17:10,230 --> 00:17:13,333 line:-1
现在等着我们完成


358
00:17:15,368 --> 00:17:16,470 line:-1
一个快速的解决办法


359
00:17:17,237 --> 00:17:21,308 line:0
是可用时随时调用完成处理函数


360
00:17:22,675 --> 00:17:25,612 line:0
如前所述 用户界面后台任务
是最大组成部分之一


361
00:17:25,913 --> 00:17:27,981 line:0
从前台进入后台时


362
00:17:28,348 --> 00:17:29,917 line:0
我们调用该API和UIKit


363
00:17:30,717 --> 00:17:32,686 line:0
如果不让系统知道我们不再需要


364
00:17:33,086 --> 00:17:35,322 line:0
如果让系统知道
我们不再需要执行任何任务


365
00:17:35,622 --> 00:17:39,226 line:0
我们让硬件系统在需要时进入空闲


366
00:17:39,526 --> 00:17:40,494 line:0
从而节省大量能量


367
00:17:41,428 --> 00:17:43,864 line:-1
这是我们调用完成处理函数的样子


368
00:17:44,932 --> 00:17:45,866 line:-1
能看见


369
00:17:45,933 --> 00:17:48,368 line:-1
激活能量的尾部没有了


370
00:17:48,735 --> 00:17:51,438 line:-1
也大幅降低了开销的尾部


371
00:17:52,973 --> 00:17:56,810 line:-1
方案简单却极大影响能耗


372
00:18:01,381 --> 00:18:03,317 line:-1
我们讲了一些方法


373
00:18:03,383 --> 00:18:05,986 line:-1
开始把低能耗当做一个过程来考虑


374
00:18:06,587 --> 00:18:10,157 line:-1
如果在所有用例中关注任务优化


375
00:18:10,624 --> 00:18:13,093 line:-1
我们就能有效


376
00:18:13,160 --> 00:18:14,461 line:-1
优化app能耗


377
00:18:16,630 --> 00:18:18,765 line:-1
要继续深入刚才讲过的


378
00:18:18,832 --> 00:18:20,567 line:-1
或者更深入了解


379
00:18:20,634 --> 00:18:23,003 line:-1
讨论过的这些优化后的代码


380
00:18:23,470 --> 00:18:25,906 line:0
强烈建议查阅去年的视频


381
00:18:26,273 --> 00:18:27,741 line:0
怎样编写低能耗app


382
00:18:28,675 --> 00:18:29,576 line:0
那场演讲中


383
00:18:29,643 --> 00:18:31,512 line:0
能找大量有趣资源


384
00:18:31,578 --> 00:18:35,449 line:0
以及app中使用低能耗设计的


385
00:18:35,516 --> 00:18:36,416 line:0
更多例子


386
00:18:40,521 --> 00:18:41,722 line:-1
现在讲过了


387
00:18:42,222 --> 00:18:43,957 line:-1
app设计中


388
00:18:44,024 --> 00:18:45,292 line:-1
改善能耗的一些方法


389
00:18:46,827 --> 00:18:49,897 line:-1
我们花了大量时间讨论


390
00:18:50,464 --> 00:18:52,366 line:-1
通过考虑app后面的


391
00:18:52,933 --> 00:18:54,835 line:-1
硬件系统改善app能耗的方法


392
00:18:55,769 --> 00:18:57,538 line:-1
我们如何量化这些


393
00:18:57,971 --> 00:18:58,839 line:-1
例如修改后


394
00:18:58,906 --> 00:19:02,042 line:-1
想了解对app的真实影响


395
00:19:03,177 --> 00:19:04,778 line:-1
现在我们讲讲


396
00:19:04,845 --> 00:19:07,681 line:-1
做那方面工作能用到的工具


397
00:19:09,983 --> 00:19:11,885 line:-1
今天有两个能用来


398
00:19:12,186 --> 00:19:14,321 line:-1
量化耗能影响的工具


399
00:19:15,489 --> 00:19:17,257 line:-1
第一个是能耗表


400
00:19:17,324 --> 00:19:19,526 line:-1
Xcode调试器里能直接访问


401
00:19:20,494 --> 00:19:21,995 line:-1
能耗表是个不错的方法


402
00:19:22,062 --> 00:19:24,464 line:-1
让你在代码能耗方面快速迭代


403
00:19:24,898 --> 00:19:26,800 line:-1
帮助你在较高的层面理解


404
00:19:27,601 --> 00:19:30,170 line:-1
哪些子系统消耗了能量


405
00:19:31,605 --> 00:19:33,240 line:-1
如果能耗表还不够


406
00:19:33,607 --> 00:19:36,376 line:-1
你能直接进入开发者工具包的工具


407
00:19:37,344 --> 00:19:38,645 line:-1
工具会让你深入到


408
00:19:38,712 --> 00:19:41,448 line:-1
设备的不同子系统


409
00:19:41,515 --> 00:19:45,519 line:-2
在较低的层面理解
这些子系统的表现


410
00:19:46,019 --> 00:19:46,920 line:-1
和它们在干什么


411
00:19:48,622 --> 00:19:50,224 line:-1
我们先看看能耗表


412
00:19:51,892 --> 00:19:54,995 line:-2
如上所述 这些能在Xcode
调试器用户界面里直接访问


413
00:19:55,295 --> 00:19:56,763 line:-1
所以很方便使用


414
00:19:56,830 --> 00:19:58,298 line:-1
（能耗表）


415
00:19:58,365 --> 00:19:59,466 line:-1
我们跳到用户界面


416
00:19:59,967 --> 00:20:02,436 line:-1
如你所见 选择耗能多的一行


417
00:20:02,503 --> 00:20:04,872 line:-1
这片用户界面的主要区域


418
00:20:04,938 --> 00:20:06,673 line:-1
由三部分组成


419
00:20:07,741 --> 00:20:10,377 line:-1
左上是经典读数表


420
00:20:11,411 --> 00:20:15,382 line:-1
读数从低到高到非常高


421
00:20:15,449 --> 00:20:17,584 line:-1
表示app即时的


422
00:20:17,651 --> 00:20:19,620 line:-1
平均能量消耗


423
00:20:20,821 --> 00:20:23,724 line:-1
有必要知道读数下降的地方


424
00:20:23,790 --> 00:20:25,692 line:-1
未必意味着好或者坏


425
00:20:26,126 --> 00:20:27,928 line:-1
它表示不论app在做什么


426
00:20:28,495 --> 00:20:30,697 line:-1
都相对消耗了这么多能量


427
00:20:31,698 --> 00:20:34,968 line:-2
这很重要 取决于你
因为作为开发者


428
00:20:35,035 --> 00:20:36,036 line:-1
需要考虑你的用例


429
00:20:36,103 --> 00:20:37,905 line:-1
并且你是否想要它做


430
00:20:39,606 --> 00:20:40,574 line:-1
右边


431
00:20:41,008 --> 00:20:42,743 line:-1
是平均组件利用率


432
00:20:43,577 --> 00:20:45,012 line:-1
这是个饼图


433
00:20:45,078 --> 00:20:47,581 line:-1
显示了不同组件


434
00:20:47,848 --> 00:20:50,551 line:-1
相对整体


435
00:20:51,018 --> 00:20:52,753 line:-1
消耗的能量百分比


436
00:20:53,854 --> 00:20:54,855 line:-1
这非常有用


437
00:20:54,922 --> 00:20:56,857 line:-1
因为它代表了我们之前


438
00:20:56,924 --> 00:20:57,958 line:-1
提到的不同子系统


439
00:20:58,025 --> 00:21:01,695 line:-1
如果有过多的开销 它有助于识别


440
00:21:01,762 --> 00:21:03,931 line:-1
或者意料外的某个组件


441
00:21:03,997 --> 00:21:04,865 line:-1
消耗了过多能量


442
00:21:06,834 --> 00:21:08,268 line:-1
然后在那下面


443
00:21:08,936 --> 00:21:11,104 line:-1
构成平均组件利用率饼图的


444
00:21:11,772 --> 00:21:12,940 line:-1
是一个时序图


445
00:21:13,540 --> 00:21:16,610 line:-1
代表app实际运行时


446
00:21:16,677 --> 00:21:18,278 line:-1
每个组件平均利用率


447
00:21:18,946 --> 00:21:19,947 line:-1
这里也能看到


448
00:21:20,280 --> 00:21:22,749 line:-1
app当前运行状态


449
00:21:23,116 --> 00:21:25,819 line:-1
前台或者后台 也会列出挂起


450
00:21:27,154 --> 00:21:28,455 line:-1
这是十分有用的工具


451
00:21:28,522 --> 00:21:31,124 line:-1
便于理解app的实时行为


452
00:21:33,760 --> 00:21:35,829 line:-1
如我所说 能耗表用于


453
00:21:36,864 --> 00:21:38,899 line:-1
高层面的特征识别


454
00:21:39,666 --> 00:21:40,901 line:-1
和快速分析非常不错


455
00:21:41,502 --> 00:21:42,369 line:-1
这是关键所在


456
00:21:42,736 --> 00:21:44,004 line:-1
在代码上迭代时


457
00:21:44,071 --> 00:21:46,073 line:-1
作为开发者 你试着完成任务


458
00:21:46,139 --> 00:21:47,508 line:-1
试着将其组合起来


459
00:21:48,075 --> 00:21:51,078 line:-1
对耗能的设想不能立即清晰起来


460
00:21:51,345 --> 00:21:52,946 line:-1
但耗能表是个不错的开始


461
00:21:55,482 --> 00:21:56,517 line:-1
但假如已经那样做过


462
00:21:56,583 --> 00:21:58,218 line:-1
能耗表对你来说不够


463
00:21:59,786 --> 00:22:00,854 line:-1
这时候就要用到工具


464
00:22:01,922 --> 00:22:03,824 line:-1
直接通过耗能表的用户界面


465
00:22:04,124 --> 00:22:05,926 line:-1
能访问三个和之前说过的


466
00:22:05,993 --> 00:22:09,329 line:-1
子系统最相关的工具


467
00:22:10,998 --> 00:22:14,568 line:-1
这些包括时间分析器、网络分析器


468
00:22:14,868 --> 00:22:16,003 line:-1
以及位置分析器


469
00:22:17,171 --> 00:22:19,206 line:-1
如果从能耗表用户界面


470
00:22:19,273 --> 00:22:20,507 line:-1
点击进入这些工具


471
00:22:20,874 --> 00:22:22,876 line:-1
就能从当前的调试会话


472
00:22:23,277 --> 00:22:24,478 line:-1
转换成工具会话


473
00:22:26,246 --> 00:22:28,749 line:-1
我们看看这些工具之一


474
00:22:28,815 --> 00:22:31,084 line:-1
时间分析器并试着理解用户界面


475
00:22:31,518 --> 00:22:33,487 line:-1
（时间分析器）


476
00:22:33,554 --> 00:22:35,722 line:-1
现在工具都有标准用户界面


477
00:22:36,089 --> 00:22:39,526 line:-1
但有趣的是它们可用性很高


478
00:22:40,227 --> 00:22:41,161 line:-1
我们来看看


479
00:22:42,396 --> 00:22:44,464 line:-1
这里能看见时间分析器用户界面


480
00:22:45,199 --> 00:22:46,867 line:-1
顶部是一个横条


481
00:22:46,934 --> 00:22:49,503 line:-1
代表了实际工具


482
00:22:49,570 --> 00:22:50,838 line:-1
的不同控件


483
00:22:51,405 --> 00:22:53,707 line:-1
左上是运行暂停按钮


484
00:22:53,774 --> 00:22:56,043 line:-1
还有要分析的目标


485
00:22:56,810 --> 00:22:58,912 line:-1
右边是个加号按钮


486
00:22:58,979 --> 00:23:01,882 line:-1
让你快速拖放其他工具


487
00:23:01,949 --> 00:23:05,018 line:-1
到这里的分析面板


488
00:23:06,253 --> 00:23:08,322 line:-1
这个分析面板让你看到


489
00:23:08,388 --> 00:23:11,058 line:-1
当前正在运行和分析app的工具


490
00:23:11,959 --> 00:23:15,329 line:-2
因为用的是时间分析器
这里是CPU使用率


491
00:23:15,696 --> 00:23:17,965 line:-1
图形展示不同时间的


492
00:23:18,031 --> 00:23:19,533 line:-1
CPU利用率


493
00:23:21,635 --> 00:23:23,704 line:-1
那下面是权重调用图


494
00:23:24,238 --> 00:23:26,607 line:-1
因为用的是时间分析器


495
00:23:27,007 --> 00:23:28,809 line:-1
我们要理解app怎样使用CPU


496
00:23:30,143 --> 00:23:31,879 line:-1
为此 有个权重调用图


497
00:23:31,945 --> 00:23:35,115 line:-1
让你精确看到app调用情况


498
00:23:35,182 --> 00:23:38,018 line:-1
以及使用的CPU权重


499
00:23:39,520 --> 00:23:41,989 line:-1
在那右边是app


500
00:23:42,055 --> 00:23:44,057 line:-1
最重堆栈调用加总


501
00:23:44,858 --> 00:23:45,826 line:-1
那基本表明了


502
00:23:46,593 --> 00:23:48,962 line:-1
分析进行时最重的堆栈调用


503
00:23:50,964 --> 00:23:53,133 line:-1
还有很多可用的出色工具


504
00:23:54,468 --> 00:23:55,636 line:-1
这是其中的一些


505
00:23:55,702 --> 00:23:57,971 line:-1
（工具有利于…）


506
00:23:58,038 --> 00:23:59,973 line:-1
这意味着十分


507
00:24:00,541 --> 00:24:01,542 line:-1
有利于一些任务


508
00:24:02,242 --> 00:24:06,113 line:-1
其一是工具有利于根因分析


509
00:24:06,180 --> 00:24:08,315 line:-1
例如特定子系统遇到问题


510
00:24:08,382 --> 00:24:09,850 line:-1
例如 处理或者网络


511
00:24:11,018 --> 00:24:13,120 line:-1
能用时间分析器


512
00:24:13,587 --> 00:24:15,989 line:-1
或者网络分析器


513
00:24:16,423 --> 00:24:17,391 line:-1
快速定位问题


514
00:24:18,458 --> 00:24:19,993 line:-1
工具也有利于


515
00:24:20,761 --> 00:24:22,763 line:-1
深入分析app


516
00:24:23,730 --> 00:24:27,734 line:-1
如果实现了某种CPU效率改进


517
00:24:27,801 --> 00:24:30,537 line:-1
例如削减算法运行时间


518
00:24:31,538 --> 00:24:34,775 line:-1
工具是个不错的理解方式


519
00:24:34,842 --> 00:24:36,910 line:-1
子系统上


520
00:24:36,977 --> 00:24:38,712 line:-1
计划的优化是否生效


521
00:24:40,514 --> 00:24:41,582 line:-1
工具还有利于


522
00:24:41,648 --> 00:24:43,150 line:-1
一个今天还


523
00:24:43,550 --> 00:24:44,685 line:-1
没讲到的东西


524
00:24:45,686 --> 00:24:47,054 line:-1
就是不受限分析


525
00:24:48,388 --> 00:24:51,358 line:-1
有个叫能耗日志的工具


526
00:24:51,892 --> 00:24:54,895 line:-1
能让你在app运行时


527
00:24:55,329 --> 00:24:57,998 line:-1
在设备上进行不受限分析


528
00:24:58,632 --> 00:25:00,767 line:-1
可以在开发者设置里直接访问


529
00:25:01,301 --> 00:25:02,769 line:-1
启动它时


530
00:25:03,070 --> 00:25:04,605 line:-1
能像往常一样使用电话


531
00:25:04,671 --> 00:25:06,206 line:-1
如期望那样


532
00:25:06,273 --> 00:25:07,474 line:-1
按任意数量用例使用app


533
00:25:08,275 --> 00:25:09,576 line:-1
任务完成之后


534
00:25:09,643 --> 00:25:11,912 line:-1
直接从开发者工具停止录制


535
00:25:12,346 --> 00:25:14,515 line:-1
并跳到工具上传跟踪信息


536
00:25:15,282 --> 00:25:16,783 line:-1
如果遇到


537
00:25:16,850 --> 00:25:18,852 line:-1
影响能耗的环境问题时


538
00:25:18,919 --> 00:25:20,888 line:-1
这非常有用


539
00:25:23,056 --> 00:25:25,626 line:-1
我们讲过了工具 还讲过概念


540
00:25:26,159 --> 00:25:27,728 line:-1
现在我想演示一下


541
00:25:28,195 --> 00:25:29,830 line:-1
通过一个例子


542
00:25:29,897 --> 00:25:31,865 line:-1
讲解怎样把这些串联起来


543
00:25:31,932 --> 00:25:34,902 line:-1
解决能耗问题 让app低能耗


544
00:25:39,506 --> 00:25:42,609 line:-1
今天我们准备了一个简单的能耗游戏


545
00:25:42,676 --> 00:25:44,211 line:-1
其在屏幕上绘制小动画


546
00:25:44,578 --> 00:25:47,314 line:-1
让app注入一些漏洞


547
00:25:47,915 --> 00:25:49,616 line:-1
我们构建了一个简单的app


548
00:25:49,683 --> 00:25:51,652 line:-1
只在视图控制器上有个代理


549
00:25:51,718 --> 00:25:55,455 line:-1
主要目的是展示如何快速使用工具


550
00:25:55,522 --> 00:25:56,924 line:-1
以迭代代码


551
00:25:58,625 --> 00:26:00,727 line:-2
我将在这里通过Xcode的
用户界面


552
00:26:00,794 --> 00:26:03,297 line:-1
构建耗能游戏然后运行它


553
00:26:04,064 --> 00:26:06,200 line:-1
你将看见在右边


554
00:26:06,667 --> 00:26:08,969 line:-1
它实际上在随机时间画了一个


555
00:26:09,036 --> 00:26:10,037 line:-1
电池小动画


556
00:26:10,704 --> 00:26:12,272 line:-1
这样 非常简单


557
00:26:13,006 --> 00:26:16,009 line:-1
如果直接跳到Xcode调试器


558
00:26:16,076 --> 00:26:19,279 line:-1
跳到能耗影响 就能看见能耗表


559
00:26:21,081 --> 00:26:22,783 line:-1
这是之前说过的用户界面


560
00:26:23,350 --> 00:26:25,886 line:-1
这是之前讨论过的相同的三个区域


561
00:26:26,420 --> 00:26:28,922 line:-1
能看到app


562
00:26:29,189 --> 00:26:30,324 line:-1
完全按照设计在执行


563
00:26:30,824 --> 00:26:33,026 line:-1
在屏幕上绘制小动画


564
00:26:33,927 --> 00:26:35,562 line:-1
但注意到我在进行网络传输


565
00:26:35,629 --> 00:26:38,765 line:-1
我的开销无缘无故有点高


566
00:26:39,466 --> 00:26:42,503 line:-1
这是因为我们在进行少量网络传输


567
00:26:42,569 --> 00:26:45,739 line:-2
每当在屏幕上绘制动画时
上传动画计数


568
00:26:46,874 --> 00:26:48,375 line:-1
如此通过Xcode能耗表


569
00:26:48,442 --> 00:26:50,410 line:-1
能看到那样做的影响


570
00:26:51,879 --> 00:26:54,648 line:-1
现在我要把这停下来


571
00:26:54,982 --> 00:26:57,885 line:-1
跳到代码部分理解其中的原因


572
00:26:59,853 --> 00:27:02,656 line:-1
假如前往添加新动画的视图控制器


573
00:27:02,956 --> 00:27:05,192 line:-1
我有一个函数上传动画计数


574
00:27:05,259 --> 00:27:08,896 line:-2
其创建简单连接对象
并在每次添加动画时


575
00:27:08,962 --> 00:27:10,163 line:-1
上传动画计数


576
00:27:10,597 --> 00:27:12,132 line:-1
我将注释掉代码


577
00:27:13,433 --> 00:27:14,801 line:-1
然后前往app代理


578
00:27:14,868 --> 00:27:17,905 line:-1
将其移动到后台运行时


579
00:27:17,971 --> 00:27:19,006 line:-1
唯一的上传动画计数


580
00:27:20,407 --> 00:27:21,441 line:-1
在这个演示里


581
00:27:21,508 --> 00:27:23,277 line:-1
我将其命名为网络优化


582
00:27:24,077 --> 00:27:25,846 line:-1
然后重新构建能耗游戏


583
00:27:26,713 --> 00:27:28,916 line:-1
向你们展示这对能耗表的影响


584
00:27:31,885 --> 00:27:33,687 line:-1
能耗游戏再次运行


585
00:27:34,321 --> 00:27:36,456 line:-1
我将回到Xcode调试器用户界面


586
00:27:37,324 --> 00:27:38,692 line:-1
回到耗能影响


587
00:27:39,693 --> 00:27:42,696 line:-1
我们再看不到网络耗能


588
00:27:42,763 --> 00:27:44,932 line:-1
也看不到任何开销 这很不错


589
00:27:45,699 --> 00:27:47,034 line:-1
这是个简单优化


590
00:27:47,367 --> 00:27:50,304 line:-1
简单将网络请求从一处移到另一处


591
00:27:50,737 --> 00:27:52,739 line:-1
阻止其频繁发生


592
00:27:53,473 --> 00:27:56,143 line:-1
让我们在安静的用例中


593
00:27:56,910 --> 00:27:58,111 line:-1
大幅降低能耗


594
00:28:00,047 --> 00:28:01,915 line:-1
现在我要注入一个漏洞


595
00:28:01,982 --> 00:28:03,584 line:-1
看看使用Xcode能耗表时


596
00:28:04,284 --> 00:28:06,019 line:-1
怎样发现漏洞


597
00:28:07,254 --> 00:28:09,823 line:-2
漏洞1是个简单漏洞
在屏幕左下角


598
00:28:10,257 --> 00:28:12,793 line:-1
其导致CPU在后台运转


599
00:28:13,260 --> 00:28:16,530 line:-1
这是很多人在实际开发中会遇到的


600
00:28:17,464 --> 00:28:18,999 line:-1
我将注入这个漏洞


601
00:28:20,968 --> 00:28:23,337 line:-2
现在已经注入
我将进入后台能耗游戏


602
00:28:24,304 --> 00:28:26,273 line:-1
能在能耗表的用户界面中看见


603
00:28:26,340 --> 00:28:27,541 line:-1
我们切换到后台


604
00:28:28,542 --> 00:28:29,643 line:-1
进行少量网络传输


605
00:28:29,710 --> 00:28:31,879 line:-1
因为将网络调用移到后台


606
00:28:32,613 --> 00:28:35,516 line:-1
现在也能看见CPU在疯狂运转


607
00:28:36,950 --> 00:28:38,819 line:-1
这就是能耗表的作用


608
00:28:38,886 --> 00:28:40,754 line:-1
我们知道其中注入了一个漏洞


609
00:28:40,821 --> 00:28:42,756 line:-2
但能在能耗表中
直接发现这个漏洞


610
00:28:44,024 --> 00:28:45,125 line:-1
现在为了找到根因


611
00:28:45,192 --> 00:28:47,494 line:-1
我要前往时间分析器


612
00:28:47,561 --> 00:28:49,897 line:-1
如前所述 转换调试会话


613
00:28:54,034 --> 00:28:57,204 line:-2
现在转换了调试会话
其会自动运行


614
00:28:59,940 --> 00:29:03,677 line:-2
如你所见
权重调用图稍候开始增加


615
00:29:07,214 --> 00:29:09,283 line:-1
这里能看到发布线程


616
00:29:09,349 --> 00:29:10,717 line:-1
消耗最多的CPU时间


617
00:29:11,051 --> 00:29:12,352 line:-1
我们深入一点看


618
00:29:15,422 --> 00:29:19,059 line:-2
我们看到在叫做
appdelegate.compute的地方结束


619
00:29:20,194 --> 00:29:23,497 line:-1
我们回到app 试着理解那是什么


620
00:29:29,837 --> 00:29:31,205 line:-1
演示的目的


621
00:29:32,206 --> 00:29:33,841 line:-1
耗能游戏进入后台时


622
00:29:33,907 --> 00:29:35,475 line:-2
我们调用叫做
computation的东西


623
00:29:36,877 --> 00:29:39,913 line:-2
Computation
是个可怕的函数


624
00:29:41,415 --> 00:29:45,853 line:-2
当注入漏洞1时 其基本在
while true死循环里


625
00:29:46,286 --> 00:29:47,654 line:-1
疯狂运转


626
00:29:48,021 --> 00:29:50,090 line:-1
演示目的很简单


627
00:29:50,157 --> 00:29:53,060 line:-1
但是用能耗表和时间分析器


628
00:29:53,126 --> 00:29:55,629 line:-1
能直接定位问题发生的位置


629
00:29:56,530 --> 00:29:59,199 line:-2
能看到
while true循环是不好的


630
00:30:00,400 --> 00:30:02,035 line:-1
我要把这个注释掉


631
00:30:04,004 --> 00:30:06,139 line:-1
我喜欢注释而不是删除


632
00:30:07,608 --> 00:30:09,476 line:-1
然后重新构建耗能游戏


633
00:30:13,514 --> 00:30:16,283 line:-1
回到能耗表看到一切正常


634
00:30:16,650 --> 00:30:18,619 line:-1
我们再次注入漏洞1


635
00:30:22,789 --> 00:30:23,690 line:-1
然后进入后台


636
00:30:29,796 --> 00:30:32,633 line:-2
我们看到预期的网络活动
但没有CPU狂转


637
00:30:33,600 --> 00:30:34,801 line:-1
不错 问题解决


638
00:30:35,435 --> 00:30:38,839 line:-1
两个工具30秒到一分钟解决


639
00:30:39,606 --> 00:30:41,275 line:-1
这就是工具的效力


640
00:30:41,341 --> 00:30:43,744 line:-1
让你快速迭代发现


641
00:30:43,810 --> 00:30:45,746 line:-1
日常开发遇到的问题根源


642
00:30:47,214 --> 00:30:48,515 line:-1
我们回到幻灯片


643
00:30:51,785 --> 00:30:53,820 line:-1
（耗能演示调试）


644
00:30:55,022 --> 00:30:56,557 line:-1
这个演示的能获得一些结论


645
00:30:58,392 --> 00:31:00,060 line:-1
第一个结论是耗能表


646
00:31:00,127 --> 00:31:01,962 line:-1
有利于快速迭代


647
00:31:02,996 --> 00:31:05,866 line:-1
他们让你快速定位问题


648
00:31:06,633 --> 00:31:08,068 line:-1
让你进一步


649
00:31:08,135 --> 00:31:09,203 line:-1
找出解决问题的方法


650
00:31:10,637 --> 00:31:11,638 line:-1
（app已发布 然后呢？）


651
00:31:11,705 --> 00:31:13,140 line:-1
第二个结论是


652
00:31:13,907 --> 00:31:16,476 line:-1
工具有利于深入分析


653
00:31:18,145 --> 00:31:20,380 line:-1
最后第三个结论是


654
00:31:20,447 --> 00:31:22,482 line:-1
我们要你把能耗


655
00:31:22,950 --> 00:31:25,319 line:-1
当做app开发的主要目标


656
00:31:25,953 --> 00:31:28,789 line:-1
我们有强力的工具让你快速


657
00:31:29,122 --> 00:31:31,391 line:-1
定位消耗能量的地方并发现


658
00:31:31,658 --> 00:31:32,793 line:-1
能耗相关问题的根源


659
00:31:34,294 --> 00:31:35,696 line:-1
如果你都做到了


660
00:31:35,762 --> 00:31:36,964 line:-1
app也发布了


661
00:31:37,764 --> 00:31:39,566 line:-1
其在App Store里发布


662
00:31:39,633 --> 00:31:42,302 line:-1
所有用户都感激你


663
00:31:42,369 --> 00:31:43,303 line:-1
及时发布了app


664
00:31:43,370 --> 00:31:44,238 line:-1
然后呢？


665
00:31:44,972 --> 00:31:48,175 line:-2
假如仍有用户抱怨
app缩短电池待机时间


666
00:31:48,842 --> 00:31:50,277 line:-1
你有怎样的资源


667
00:31:51,311 --> 00:31:54,248 line:-1
现在要交给同事David


668
00:31:54,615 --> 00:31:55,816 line:-1
他将向你们介绍


669
00:31:55,883 --> 00:31:57,551 line:-1
如何面对这些挑战


670
00:31:57,618 --> 00:31:59,419 line:-1
并使用新工具解决它们


671
00:31:59,486 --> 00:32:00,354 line:-1
David


672
00:32:05,359 --> 00:32:06,260 line:-1
下午好


673
00:32:06,894 --> 00:32:09,196 line:-1
我是David 我今天来介绍


674
00:32:09,263 --> 00:32:12,900 line:-1
能耗调试的一些新工具


675
00:32:15,903 --> 00:32:17,171 line:-1
如果你是iOS开发者


676
00:32:17,838 --> 00:32:20,307 line:-2
在App Store或
TestFlight上发布app


677
00:32:20,541 --> 00:32:22,376 line:-1
这部分介绍就是为你准备的


678
00:32:23,744 --> 00:32:25,312 line:-1
我将从下面的问题开始


679
00:32:26,413 --> 00:32:27,514 line:-1
既然app已经发布


680
00:32:28,115 --> 00:32:30,217 line:-1
如何知道app在外表现如何？


681
00:32:30,284 --> 00:32:31,285 line:-1
既然app已经发布


682
00:32:31,351 --> 00:32:33,687 line:-1
换句话说 如何知道


683
00:32:34,087 --> 00:32:36,657 line:-1
用户是否遭受


684
00:32:37,024 --> 00:32:38,792 line:-1
缩短电池待机时间的耗能问题


685
00:32:40,394 --> 00:32:43,163 line:-2
用户可能在
App Store上留言


686
00:32:44,665 --> 00:32:47,134 line:-1
使用app是电池电量消耗很多


687
00:32:48,335 --> 00:32:50,804 line:-1
但他们没法告诉你发生了什么


688
00:32:51,705 --> 00:32:53,974 line:-1
更糟的是 他们直接删除app


689
00:32:54,041 --> 00:32:55,709 line:-1
没留下任何反馈


690
00:32:56,743 --> 00:32:58,779 line:-1
所以弄清楚app


691
00:32:59,146 --> 00:33:01,181 line:-1
是否有能耗问题是个挑战


692
00:33:02,583 --> 00:33:04,718 line:-1
即使知道有能耗问题


693
00:33:05,552 --> 00:33:08,989 line:-1
如何在客户设备上调试问题


694
00:33:11,058 --> 00:33:12,526 line:-1
你能使用Phil介绍过的


695
00:33:12,926 --> 00:33:15,395 line:-1
工具和能耗表


696
00:33:16,196 --> 00:33:18,065 line:-1
但除非知道要测试什么


697
00:33:18,465 --> 00:33:20,234 line:-1
否则将很难复现


698
00:33:21,502 --> 00:33:23,203 line:-1
可能有环境因素


699
00:33:23,770 --> 00:33:25,472 line:-1
例如客户遭遇到


700
00:33:25,772 --> 00:33:27,107 line:-1
糟糕的Wi-Fi环境


701
00:33:28,442 --> 00:33:30,511 line:-1
而你的办公桌Wi-Fi环境良好


702
00:33:32,946 --> 00:33:34,848 line:-1
因此这是富有挑战的问题


703
00:33:37,718 --> 00:33:39,286 line:-1
为了帮助回答这些问题


704
00:33:39,353 --> 00:33:41,288 line:-1
我今天有幸介绍


705
00:33:41,922 --> 00:33:44,191 line:-2
使用Xcode能耗日志和
Xcode能耗分析器


706
00:33:46,126 --> 00:33:49,530 line:-1
调试耗能问题的新方法


707
00:33:49,596 --> 00:33:50,597 line:-1
（调试耗能问题的新方法）


708
00:33:50,664 --> 00:33:52,799 line:-1
首先我将介绍Xcode能耗日志


709
00:33:53,066 --> 00:33:56,703 line:-1
其是报告设备能耗问题的新方法


710
00:33:57,704 --> 00:34:00,107 line:-2
然后我将介绍Xcode
能耗分析器


711
00:34:00,174 --> 00:34:02,543 line:-1
其是查看能耗日志的新工具


712
00:34:04,344 --> 00:34:06,847 line:-1
第一次用这些工具


713
00:34:06,914 --> 00:34:08,614 line:-1
你将获得找到


714
00:34:10,050 --> 00:34:12,753 line:-1
并解决能耗问题的数据


715
00:34:13,487 --> 00:34:14,388 line:-1
我们开始


716
00:34:16,023 --> 00:34:18,091 line:-1
Xcode能耗日志是


717
00:34:18,158 --> 00:34:19,793 line:-1
从设备报告问题的新方法


718
00:34:19,860 --> 00:34:22,029 line:-1
（Xcode能耗日志）


719
00:34:22,094 --> 00:34:24,264 line:-1
我们从CPU高能耗事件开始


720
00:34:24,331 --> 00:34:26,967 line:-1
此时app占用大量CPU


721
00:34:27,967 --> 00:34:30,871 line:-1
每个能耗日志有权重调用图


722
00:34:31,170 --> 00:34:33,806 line:-1
其将指出代码中集中耗能点


723
00:34:34,975 --> 00:34:36,710 line:-1
这些日志将在


724
00:34:36,777 --> 00:34:38,846 line:-2
TestFlight
和App Store中可用


725
00:34:39,112 --> 00:34:40,647 line:-1
你将获取真实世界


726
00:34:40,714 --> 00:34:43,250 line:-1
用户的实际数据


727
00:34:43,984 --> 00:34:45,052 line:-1
用这些日志


728
00:34:45,118 --> 00:34:47,688 line:-1
你能够开始改进电池待机时间


729
00:34:50,123 --> 00:34:53,427 line:-2
让我们讲讲Xcode
能耗日志产生时


730
00:34:54,661 --> 00:34:56,463 line:-1
例如用户正在使用app


731
00:34:56,897 --> 00:34:59,533 line:-1
其给CPU带来沉重负荷


732
00:34:59,600 --> 00:35:00,801 line:-1
（Xcode能耗日志何时产生？）


733
00:35:00,868 --> 00:35:03,370 line:-2
这可能很自然
取决于app在干什么


734
00:35:04,671 --> 00:35:07,007 line:-1
假设其长期给CPU


735
00:35:07,508 --> 00:35:08,475 line:-1
带来沉重负荷


736
00:35:12,179 --> 00:35:15,148 line:0
导致检测到CPU高能耗事件


737
00:35:17,251 --> 00:35:18,919 line:0
现在CPU高能耗事件


738
00:35:19,419 --> 00:35:20,587 line:0
有检测到


739
00:35:21,221 --> 00:35:22,523 line:0
两个关键阈值


740
00:35:23,156 --> 00:35:26,627 line:0
第一个阈值是app在前台


741
00:35:26,894 --> 00:35:29,496 line:0
占用80%CPU超过三分钟


742
00:35:30,297 --> 00:35:33,634 line:0
第二个阈值是app在后台


743
00:35:34,001 --> 00:35:36,136 line:0
占用80%CPU超过一分钟


744
00:35:37,104 --> 00:35:38,038 line:-1
第二种情况


745
00:35:38,338 --> 00:35:42,042 line:-2
为了避免后台过度占用
app可能已经终止


746
00:35:45,145 --> 00:35:47,814 line:-1
每个CPU能耗日志条目


747
00:35:48,048 --> 00:35:51,585 line:-2
表示app占用大量CPU
而应该标识出来


748
00:35:52,619 --> 00:35:54,188 line:-1
实际上是说


749
00:35:54,955 --> 00:35:58,692 line:-1
典型情况就是其导致了1%的


750
00:35:59,359 --> 00:36:00,260 line:-1
电量下降


751
00:36:01,795 --> 00:36:03,564 line:-1
你可能对自己说


752
00:36:03,630 --> 00:36:05,766 line:-1
1%电量也没多糟


753
00:36:07,067 --> 00:36:08,168 line:-1
但放到现实情况


754
00:36:09,136 --> 00:36:13,040 line:-2
iPhone 6s的1%
额外电量


755
00:36:13,807 --> 00:36:17,177 line:-1
用户能额外通话8分钟


756
00:36:17,978 --> 00:36:20,180 line:-1
或上网浏览6分钟


757
00:36:20,914 --> 00:36:23,550 line:-1
或听音乐30分钟


758
00:36:24,718 --> 00:36:26,820 line:-1
如果app继续这个速度消耗


759
00:36:28,121 --> 00:36:29,957 line:-1
电池可能消耗更多


760
00:36:30,624 --> 00:36:32,593 line:-1
因此编写CPU高效的app


761
00:36:32,826 --> 00:36:33,894 line:-1
非常重要


762
00:36:34,394 --> 00:36:36,029 line:-1
用户也会注意到


763
00:36:37,865 --> 00:36:39,833 line:-1
能耗日志有三个部分


764
00:36:39,900 --> 00:36:41,835 line:-1
能帮助理解发生了什么


765
00:36:42,736 --> 00:36:44,037 line:-1
第一是触发报告时


766
00:36:44,104 --> 00:36:46,874 line:-1
发生了什么的环境信息


767
00:36:47,441 --> 00:36:48,842 line:-1
例如 其会说


768
00:36:49,343 --> 00:36:52,513 line:-1
app消耗了80%超过三分钟


769
00:36:52,579 --> 00:36:53,914 line:-1
（能耗日志里有什么？）


770
00:36:53,981 --> 00:36:56,350 line:-1
第二部分信息是


771
00:36:56,416 --> 00:36:58,452 line:-1
能耗日志创建位置的元数据


772
00:36:59,152 --> 00:37:01,388 line:-1
例如 是iPhone还是iPad


773
00:37:02,122 --> 00:37:04,224 line:-1
还是app的Build 30版本


774
00:37:05,492 --> 00:37:07,861 line:-1
第三 也是最重要的信息


775
00:37:08,195 --> 00:37:09,563 line:-1
是权重调用图


776
00:37:09,763 --> 00:37:11,865 line:-1
其将展示代码里的集中能耗点


777
00:37:13,200 --> 00:37:15,335 line:-1
我们深入介绍权重调用图


778
00:37:16,003 --> 00:37:17,204 line:-1
它是怎样产生的


779
00:37:17,571 --> 00:37:19,640 line:-1
如何用它调试能耗问题


780
00:37:21,375 --> 00:37:23,343 line:-2
（Xcode能耗日志：
权重调用图）


781
00:37:23,410 --> 00:37:26,280 line:-1
假如app由主函数


782
00:37:26,647 --> 00:37:27,614 line:-1
还有一些方法构成


783
00:37:27,681 --> 00:37:30,784 line:-1
方法1、方法2、方法3、方法4


784
00:37:33,687 --> 00:37:35,055 line:-1
代码开始运行


785
00:37:35,389 --> 00:37:37,891 line:-1
直到检测到CPU高能耗事件


786
00:37:40,661 --> 00:37:44,031 line:-1
到这时以每秒固定周期


787
00:37:44,431 --> 00:37:46,867 line:-1
采样调用堆栈


788
00:37:47,701 --> 00:37:50,571 line:-1
调用堆栈是运行时


789
00:37:51,371 --> 00:37:54,107 line:-1
活动帧的采样


790
00:37:55,876 --> 00:37:57,544 line:0
例如第一个调用堆栈


791
00:37:58,045 --> 00:38:01,348 line:0
显示主函数、方法1
方法2被激活


792
00:38:04,084 --> 00:38:07,855 line:0
第二个调用堆栈显示


793
00:38:07,921 --> 00:38:11,158 line:0
主函数、方法3
方法4被激活等等


794
00:38:17,464 --> 00:38:20,467 line:0
现在试着把调用堆栈结合起来


795
00:38:20,534 --> 00:38:22,202 line:0
组成全局图


796
00:38:23,370 --> 00:38:25,439 line:0
这里看到的是权重调用图


797
00:38:26,106 --> 00:38:28,442 line:0
这个非常有用


798
00:38:29,443 --> 00:38:31,378 line:0
主函数在收集到的


799
00:38:31,445 --> 00:38:33,847 line:0
六个采样中都能看见


800
00:38:35,015 --> 00:38:37,451 line:0
意味着主函数全部时间都在运行


801
00:38:38,886 --> 00:38:42,189 line:0
其中方法1有五个采样


802
00:38:43,290 --> 00:38:45,559 line:0
而方法3只有一个


803
00:38:46,994 --> 00:38:50,297 line:0
方法1中看到方法2和方法3


804
00:38:50,364 --> 00:38:53,367 line:0
分别有三个和一个采样


805
00:38:54,501 --> 00:38:56,870 line:0
这给我们一个整体图


806
00:38:56,937 --> 00:38:59,406 line:0
关于哪儿的代码在执行


807
00:38:59,473 --> 00:39:01,341 line:0
花费多少时间


808
00:39:03,644 --> 00:39:04,978 line:-1
（权重调用图）


809
00:39:05,045 --> 00:39:06,747 line:-1
能耗日志创建时


810
00:39:07,481 --> 00:39:09,716 line:-1
每秒有周期性


811
00:39:10,250 --> 00:39:11,585 line:-1
采样调用堆栈


812
00:39:12,186 --> 00:39:13,554 line:-1
每个调用堆栈


813
00:39:15,189 --> 00:39:18,592 line:-1
包含CPU执行的活动帧


814
00:39:19,726 --> 00:39:22,196 line:-1
这些调用堆栈按


815
00:39:23,197 --> 00:39:25,899 line:-1
采样数聚合成树形图


816
00:39:26,733 --> 00:39:29,369 line:-1
越多采样意味着越多代码执行次数


817
00:39:30,437 --> 00:39:32,139 line:-1
能使用权重调用图


818
00:39:32,206 --> 00:39:35,175 line:-1
识别app意外的工作负荷


819
00:39:37,578 --> 00:39:39,513 line:-1
现在知道了能耗日志是什么


820
00:39:39,980 --> 00:39:41,114 line:-1
怎么访问它们呢？


821
00:39:42,783 --> 00:39:45,285 line:-1
首先能耗日志在设备上创建


822
00:39:46,687 --> 00:39:49,189 line:-1
然后测试人员


823
00:39:49,256 --> 00:39:50,357 line:-1
和下载app的客户


824
00:39:50,924 --> 00:39:53,360 line:-1
将上传日志到Apple


825
00:39:54,628 --> 00:39:55,762 line:-1
可能有成百


826
00:39:55,829 --> 00:39:57,564 line:-1
甚至上千的日志


827
00:39:58,699 --> 00:40:01,401 line:-1
我们把日志聚合起来


828
00:40:01,735 --> 00:40:06,240 line:-2
分类以一系列顶级
能耗问题展现给你


829
00:40:07,307 --> 00:40:09,409 line:-2
你能用新的Xcode
能耗分析器工具


830
00:40:09,676 --> 00:40:12,446 line:-1
下载查看这些日志


831
00:40:14,348 --> 00:40:17,618 line:-1
Xcode能耗分析器是


832
00:40:17,684 --> 00:40:20,187 line:-1
调试外界能耗问题的命令中心


833
00:40:20,254 --> 00:40:21,455 line:-1
（Xcode能耗分析器）


834
00:40:21,522 --> 00:40:25,025 line:-2
能耗分析器使得查看
能耗日志非常简单


835
00:40:26,627 --> 00:40:29,997 line:-2
能耗分析器连到App Store
的TestFlight


836
00:40:30,063 --> 00:40:32,366 line:-1
将看到全部iOS app的列表


837
00:40:35,569 --> 00:40:37,437 line:-1
能够看到外界这些能耗问题


838
00:40:37,504 --> 00:40:40,340 line:-1
发生频率的统计数据


839
00:40:42,075 --> 00:40:44,211 line:-1
将看到按多少设备受影响分类的


840
00:40:44,278 --> 00:40:46,446 line:-1
顶级能耗问题的列表


841
00:40:48,515 --> 00:40:50,317 line:-1
将看到一些不同日志的


842
00:40:50,784 --> 00:40:52,085 line:-1
权重调用图


843
00:40:52,519 --> 00:40:55,155 line:-1
能分页查看日志


844
00:40:57,724 --> 00:41:01,295 line:-1
项目中用打开命令直接前往代码库


845
00:41:01,361 --> 00:41:03,497 line:-1
能开始调试这些能耗问题


846
00:41:04,431 --> 00:41:06,333 line:-1
现在讲展示一个例子


847
00:41:15,676 --> 00:41:18,579 line:-1
现在我确保登录了开发者账户


848
00:41:19,012 --> 00:41:21,381 line:-1
也上传了能耗游戏app


849
00:41:21,815 --> 00:41:23,750 line:-2
到App Store
的TestFlight


850
00:41:24,952 --> 00:41:26,453 line:-1
为了调用能耗分析器


851
00:41:26,787 --> 00:41:28,488 line:-1
能前往这里的窗口


852
00:41:30,791 --> 00:41:31,892 line:-1
点击分析器


853
00:41:35,896 --> 00:41:37,898 line:-1
这是能耗分析器的用户界面


854
00:41:39,433 --> 00:41:42,169 line:-1
确保选中顶部的能耗面板


855
00:41:43,470 --> 00:41:45,038 line:-1
如果使用崩溃分析器


856
00:41:45,305 --> 00:41:47,908 line:-1
你应该对这个用户界面很熟悉


857
00:41:48,909 --> 00:41:51,311 line:-1
左边是全部的app列表


858
00:41:52,479 --> 00:41:55,182 line:-1
之后是顶级能耗问题列表


859
00:41:56,083 --> 00:41:58,118 line:-1
中间是权重调用图


860
00:41:59,152 --> 00:42:01,755 line:-1
右边是一些能耗问题的


861
00:42:01,822 --> 00:42:03,390 line:-1
统计数据


862
00:42:04,758 --> 00:42:06,827 line:-1
我们前往左边


863
00:42:07,761 --> 00:42:09,162 line:-1
选择能耗游戏


864
00:42:09,229 --> 00:42:10,731 line:-1
这是我们正在开发的游戏


865
00:42:12,332 --> 00:42:15,068 line:-1
然后确保正确构建


866
00:42:20,040 --> 00:42:22,609 line:-1
这里看见一系列


867
00:42:23,177 --> 00:42:25,012 line:-1
按影响次数分类的能耗问题


868
00:42:27,147 --> 00:42:29,183 line:-1
前往第一个能耗问题


869
00:42:30,717 --> 00:42:32,553 line:-1
其影响了64台设备


870
00:42:36,790 --> 00:42:38,258 line:-1
右手的面板上


871
00:42:38,325 --> 00:42:40,494 line:-1
有发生了什么的细节


872
00:42:41,628 --> 00:42:42,563 line:-1
还有能耗问题


873
00:42:42,629 --> 00:42:44,932 line:-1
发生频率的分析


874
00:42:45,432 --> 00:42:50,304 line:-2
能看见其在iPad、iPod
iPod Touch上都有发生


875
00:42:51,338 --> 00:42:54,007 line:-1
能看见在过去两周


876
00:42:54,074 --> 00:42:55,275 line:-1
其发生频率的分布情况


877
00:42:56,710 --> 00:42:58,478 line:-1
我们看看权重调用图


878
00:43:01,815 --> 00:43:04,017 line:-1
看到有大量时间


879
00:43:04,351 --> 00:43:05,586 line:-1
花费在调用


880
00:43:06,053 --> 00:43:09,022 line:-1
这个app代理计算函数里


881
00:43:10,691 --> 00:43:12,459 line:-1
现在用这个按钮


882
00:43:13,327 --> 00:43:15,863 line:-1
直接前往代码库


883
00:43:22,002 --> 00:43:24,104 line:-1
直接回到代码


884
00:43:24,972 --> 00:43:28,375 line:-1
左边是权重调用图里的


885
00:43:28,442 --> 00:43:29,843 line:-1
调用堆栈采样之一


886
00:43:32,079 --> 00:43:34,448 line:-1
能看到我们花费大量时间


887
00:43:34,515 --> 00:43:35,883 line:-1
在这个计算函数里


888
00:43:37,351 --> 00:43:39,386 line:-1
这就是Phil之前


889
00:43:39,887 --> 00:43:42,155 line:-1
在演示里提到的函数


890
00:43:49,296 --> 00:43:50,197 line:-1
我们能看到


891
00:43:51,999 --> 00:43:53,934 line:-1
他已将代码注释掉


892
00:43:54,001 --> 00:43:55,903 line:-1
已经解决了耗能问题


893
00:43:56,270 --> 00:43:57,771 line:-1
我们回到分析器


894
00:44:04,578 --> 00:44:06,647 line:-1
我能点击这个按钮


895
00:44:07,381 --> 00:44:09,049 line:-1
把问题标记成已解决


896
00:44:10,150 --> 00:44:13,187 line:-1
这样做的用处是


897
00:44:13,921 --> 00:44:16,089 line:-2
下次打开分析器时
能看到问题已经解决


898
00:44:17,724 --> 00:44:19,526 line:-1
我们前往第二个问题


899
00:44:19,826 --> 00:44:21,161 line:-1
它影响了42台设备


900
00:44:22,763 --> 00:44:24,364 line:-1
前往权重调用图之前


901
00:44:24,431 --> 00:44:25,532 line:-1
我想让你们注意


902
00:44:25,599 --> 00:44:27,367 line:-1
底部的三个特性


903
00:44:29,803 --> 00:44:32,573 line:0
第一是日志分页


904
00:44:33,674 --> 00:44:37,044 line:0
我能从外界42个设备的


905
00:44:37,110 --> 00:44:39,046 line:0
五个耗能日志采样中选出一个


906
00:44:42,382 --> 00:44:43,584 line:-1
这些页面之间浏览


907
00:44:44,651 --> 00:44:47,554 line:-1
能发现权重调用图有一点不同


908
00:44:48,088 --> 00:44:50,924 line:-1
这没什么问题


909
00:44:50,991 --> 00:44:53,393 line:-1
因为调用堆栈和权重调用图只是采样


910
00:44:54,595 --> 00:44:57,731 line:-1
我们按相似度将其分类


911
00:44:57,798 --> 00:45:00,367 line:-1
这些日志让你看起来很相似


912
00:45:02,870 --> 00:45:05,939 line:-1
我点击这里的按钮时


913
00:45:06,373 --> 00:45:09,009 line:-1
显示出之前隐藏的


914
00:45:09,076 --> 00:45:11,411 line:-1
所有系统库帧


915
00:45:12,946 --> 00:45:15,249 line:-1
这里的按钮


916
00:45:15,782 --> 00:45:19,052 line:-1
显示所有低采样数据的帧


917
00:45:19,987 --> 00:45:21,555 line:-1
我们会默认为你


918
00:45:21,955 --> 00:45:23,924 line:-1
把大多数这些帧都隐藏起来


919
00:45:23,991 --> 00:45:26,360 line:-1
只显示最重要的帧


920
00:45:34,501 --> 00:45:35,802 line:-1
我们看看这个函数


921
00:45:38,705 --> 00:45:40,507 line:-1
看起来这个计时函数里


922
00:45:40,574 --> 00:45:42,109 line:-1
花费了大量时间


923
00:45:42,910 --> 00:45:45,846 line:-2
事实上之前听Phil
提过这个漏洞


924
00:45:45,913 --> 00:45:47,681 line:-1
他说他会看一眼的


925
00:45:47,781 --> 00:45:48,782 line:-1
因此我留给他处理


926
00:45:50,417 --> 00:45:51,752 line:-1
我将其重命名


927
00:45:56,723 --> 00:45:58,058 line:-1
然后前往下一个漏洞


928
00:45:59,126 --> 00:46:00,661 line:-1
我们再看一个漏洞


929
00:46:13,607 --> 00:46:16,076 line:-1
我看见大量时间花费在


930
00:46:16,143 --> 00:46:19,112 line:-1
设置下一个定时器和添加新动画


931
00:46:19,713 --> 00:46:20,747 line:-1
其作用是什么？


932
00:46:21,481 --> 00:46:22,449 line:-1
我们深入看看


933
00:46:25,652 --> 00:46:27,221 line:-1
我直接前往代码


934
00:46:37,197 --> 00:46:39,533 line:-1
看到大量时间花费在


935
00:46:39,600 --> 00:46:41,702 line:-1
添加新动画的函数里


936
00:46:42,636 --> 00:46:44,738 line:-1
好吧 添加新动画开销很大


937
00:46:46,073 --> 00:46:48,408 line:-1
但要问我们自己一个问题


938
00:46:48,475 --> 00:46:50,177 line:-1
这是预期的工作量吗？


939
00:46:51,178 --> 00:46:53,847 line:-1
这种情况下 答案并非如此


940
00:46:54,414 --> 00:46:57,284 line:-1
因为预期每隔几秒


941
00:46:57,518 --> 00:46:58,919 line:-1
才添加一次动画


942
00:46:59,586 --> 00:47:00,921 line:-1
所以耗费


943
00:47:00,988 --> 00:47:02,956 line:-1
这么多CPU没什么道理


944
00:47:04,191 --> 00:47:06,660 line:-1
我们看看调用堆栈有谁调用了我们


945
00:47:08,161 --> 00:47:11,131 line:-1
我们被设置下次刷新定时器调用了


946
00:47:12,232 --> 00:47:13,433 line:-1
所以函数的功能是什么


947
00:47:18,005 --> 00:47:20,407 line:-1
看到在设置下次刷新定时器之内


948
00:47:20,474 --> 00:47:22,242 line:-1
我们被调用以添加新动画


949
00:47:23,610 --> 00:47:24,845 line:-1
函数末尾


950
00:47:25,479 --> 00:47:28,148 line:-1
我们调用更新定时器


951
00:47:28,482 --> 00:47:31,418 line:-1
计划该函数下次调用时间


952
00:47:33,487 --> 00:47:34,855 line:-1
定时器设定在


953
00:47:34,922 --> 00:47:38,358 line:-2
现在和下次刷新间隔内的
某个时间触发


954
00:47:40,494 --> 00:47:44,831 line:-1
下次刷新间隔递减1 直到0


955
00:47:46,200 --> 00:47:50,337 line:-1
然后在这行代码重新初始化


956
00:47:52,639 --> 00:47:54,274 line:-1
这就是问题所在


957
00:47:55,609 --> 00:47:57,711 line:-1
从上次刷新到现在的


958
00:47:58,212 --> 00:48:00,280 line:-1
时间间隔有可能是负数


959
00:48:01,281 --> 00:48:03,016 line:-1
我们见过这种事情


960
00:48:03,483 --> 00:48:06,220 line:-1
特别是用户折腾系统的时候


961
00:48:07,087 --> 00:48:08,355 line:-1
可能是在玩游戏


962
00:48:09,523 --> 00:48:11,191 line:-1
也可能他们想重置时钟


963
00:48:11,758 --> 00:48:14,261 line:-1
也许他们想要额外的时间或者机会


964
00:48:14,695 --> 00:48:16,029 line:-1
所以他们前往系统设置


965
00:48:16,330 --> 00:48:18,332 line:-1
把时间改到24小时之前


966
00:48:19,566 --> 00:48:21,168 line:-1
这种情况下


967
00:48:21,235 --> 00:48:23,704 line:-1
这将导致下次刷新时间变成负数


968
00:48:24,605 --> 00:48:27,140 line:-2
当我们为定时器设置一个
过去的时间


969
00:48:27,508 --> 00:48:31,311 line:-1
定时器将马上触发


970
00:48:31,778 --> 00:48:33,847 line:-1
然后反复调用自身


971
00:48:34,948 --> 00:48:37,317 line:-1
所以这里就成死循环了


972
00:48:39,653 --> 00:48:41,655 line:-1
幸运的是这很容易修复


973
00:48:42,756 --> 00:48:47,761 line:-2
我们前往这个函数
将其改成小于或等于0


974
00:48:48,328 --> 00:48:50,931 line:-1
这样即使下次刷新时间是负数


975
00:48:51,465 --> 00:48:52,733 line:-1
也能从循环退出


976
00:48:54,468 --> 00:48:56,570 line:-1
这是不错的例子


977
00:48:56,870 --> 00:49:00,607 line:-1
这个能耗问题在普通测试中


978
00:49:01,909 --> 00:49:02,943 line:-1
很难发现


979
00:49:03,810 --> 00:49:06,980 line:-1
可一旦看到变量的值就变得明显


980
00:49:08,415 --> 00:49:10,150 line:-1
这就是能耗日志的作用


981
00:49:11,018 --> 00:49:13,220 line:-1
这就是能耗分析器的作用


982
00:49:14,521 --> 00:49:17,191 line:-1
我们看看这个演示的三个结论


983
00:49:17,257 --> 00:49:18,492 line:-1
（能耗分析器演示的结论）


984
00:49:18,559 --> 00:49:20,427 line:-1
你能使用能耗分析器


985
00:49:20,494 --> 00:49:23,230 line:-1
发现顶级能耗问题


986
00:49:24,264 --> 00:49:25,766 line:-1
通过查看顶级问题


987
00:49:26,133 --> 00:49:27,901 line:-1
查看发生的频率


988
00:49:28,535 --> 00:49:31,738 line:-1
查看受影响的设备和版本


989
00:49:33,173 --> 00:49:35,609 line:-1
其次 你能使用权重调用图


990
00:49:36,043 --> 00:49:37,611 line:-1
查看集中能耗点


991
00:49:38,512 --> 00:49:41,281 line:-1
寻找不寻常的高采样计数的帧


992
00:49:42,549 --> 00:49:44,651 line:-1
留心非预期的工作量


993
00:49:46,286 --> 00:49:50,657 line:-2
最后使用OpenEnd项目
直接前往代码


994
00:49:51,191 --> 00:49:53,994 line:-1
能针对在运行的


995
00:49:55,028 --> 00:49:55,863 line:-1
修改并检查


996
00:49:58,398 --> 00:49:59,933 line:-1
总结下今天我们学到什么


997
00:50:03,036 --> 00:50:05,572 line:-1
首先考虑能量使用


998
00:50:05,639 --> 00:50:09,643 line:-1
在设计、开发和测试的每个方面


999
00:50:10,344 --> 00:50:11,745 line:-1
都优先考虑能耗


1000
00:50:12,980 --> 00:50:15,182 line:-1
其次 使用出色的工具


1001
00:50:16,350 --> 00:50:19,786 line:-1
例如能耗表和工具以分析app


1002
00:50:21,088 --> 00:50:23,290 line:-1
第三 花点时间


1003
00:50:23,357 --> 00:50:25,859 line:-1
查看新的Xcode能耗分析器


1004
00:50:26,159 --> 00:50:29,596 line:-1
理解和修复能耗问题


1005
00:50:31,598 --> 00:50:34,568 line:0
更多信息请查阅下面的链接


1006
00:50:35,602 --> 00:50:38,438 line:0
记得参与周五9点到11点的


1007
00:50:39,273 --> 00:50:40,507 line:0
“动力性能实验室”


1008
00:50:41,308 --> 00:50:42,643 line:-1
谢谢并愿大家度过愉快的夜晚

