1
00:00:17,451 --> 00:00:21,388 line:0
（高效使用集合 演讲229）


2
00:00:21,922 --> 00:00:22,923 line:-1
早上好


3
00:00:23,991 --> 00:00:24,992 line:-1
我叫Michael LeHew


4
00:00:25,092 --> 00:00:27,995 line:-2
我在Apple Foundation团队
从事集合相关工作


5
00:00:28,962 --> 00:00:31,465 line:-1
今天我想谈一些


6
00:00:31,532 --> 00:00:34,268 line:-2
你应该知道的事
以确保你能够尽可能高效地


7
00:00:34,334 --> 00:00:35,636 line:-1
在Swift中使用集合


8
00:00:37,104 --> 00:00:39,006 line:-1
今天我会讨论很多领域


9
00:00:39,339 --> 00:00:43,277 line:-2
关于Swift中可用集合的
详细信息和各个方面


10
00:00:43,844 --> 00:00:45,812 line:-1
我们将探索一些常见的误区


11
00:00:46,113 --> 00:00:48,048 line:-2
以及如何避免它们
包括性能问题


12
00:00:48,115 --> 00:00:50,250 line:-1
我也将提供非常具体的建议


13
00:00:50,317 --> 00:00:52,553 line:-1
关于何时该选择哪些特定集合


14
00:00:53,287 --> 00:00:54,288 line:-1
让我们开始吧


15
00:00:54,988 --> 00:00:56,356 line:-1
我想让你想象一个


16
00:00:57,758 --> 00:00:59,326 line:-1
没有集合的世界


17
00:01:01,795 --> 00:01:03,797 line:-2
在这个世界中
我们可能没有数组


18
00:01:04,063 --> 00:01:05,432 line:-1
但它仍然有熊


19
00:01:07,100 --> 00:01:08,702 line:-1
但每次当我们需要另一只熊


20
00:01:09,870 --> 00:01:11,939 line:-1
我们就需要定义另一个变量


21
00:01:12,005 --> 00:01:13,607 line:-1
我们想对这些熊做些事情


22
00:01:13,674 --> 00:01:15,475 line:-1
我们只能够重复自己


23
00:01:16,243 --> 00:01:17,311 line:-1
很可怕 对吧


24
00:01:18,545 --> 00:01:21,448 line:-2
但更糟的是
这个世界也没有字典


25
00:01:22,482 --> 00:01:24,451 line:-1
但幸好我们是聪明的开发者


26
00:01:24,785 --> 00:01:26,520 line:-1
我们可以用函数来解决这个问题


27
00:01:26,820 --> 00:01:29,690 line:-2
我们煞费苦心地定义了
我们关心的每种情况


28
00:01:30,691 --> 00:01:33,427 line:0
使用这个函数与使用字典非常相似


29
00:01:33,627 --> 00:01:36,163 line:0
除了我们需要的那些动态功能


30
00:01:36,630 --> 00:01:37,965 line:0
但谁喜欢可变状态 对吧？


31
00:01:38,899 --> 00:01:41,268 line:0
但幸运的是
我们并不生活在这个世界中


32
00:01:42,336 --> 00:01:44,805 line:-2
值得庆幸的是
我们的世界有既有熊也有集合


33
00:01:45,072 --> 00:01:47,741 line:-1
以及用于定义它们的丰富的原生语法


34
00:01:49,576 --> 00:01:52,212 line:-2
还有当我们迭代时
帮助我们不必重复自己


35
00:01:53,847 --> 00:01:55,949 line:-1
或获取集合中的元素的API


36
00:01:57,584 --> 00:02:01,021 line:-2
集合非常普遍并且共享如此多的
常见特性和算法


37
00:02:01,088 --> 00:02:03,490 line:-2
因此在Swift中
它们都遵守一个通用协议


38
00:02:05,058 --> 00:02:07,027 line:-2
毫不奇怪
它叫Collection


39
00:02:08,161 --> 00:02:09,795 line:-1
在Swift中 集合就是序列


40
00:02:09,863 --> 00:02:12,199 line:-1
其中的元素可以以非破坏性的方式


41
00:02:12,366 --> 00:02:13,367 line:-1
多次遍历


42
00:02:13,534 --> 00:02:15,802 line:-1
并且其元素可以通过下标访问


43
00:02:16,103 --> 00:02:17,771 line:-1
（COLLECTION协议）


44
00:02:17,838 --> 00:02:19,139 line:-1
我们看看这是如何做到的


45
00:02:19,206 --> 00:02:21,808 line:-1
考虑一下集合的抽象表示


46
00:02:21,875 --> 00:02:22,876 line:-1
（集合存储元素）


47
00:02:22,943 --> 00:02:25,445 line:-2
这可能是一个在连续内存中
定义的数组


48
00:02:25,646 --> 00:02:27,681 line:-1
哈希表 红黑树


49
00:02:28,815 --> 00:02:30,918 line:-2
链接、列表或你可以想象的
任何其它东西


50
00:02:31,451 --> 00:02:34,154 line:-1
重要的是它支持初始索引的概念


51
00:02:34,221 --> 00:02:35,489 line:-1
其被称为起始索引


52
00:02:35,556 --> 00:02:36,723 line:-1
（起始索引）


53
00:02:36,790 --> 00:02:39,726 line:-1
它可以用来访问集合的初始元素


54
00:02:40,561 --> 00:02:41,562 line:-1
它还有一个结束索引


55
00:02:41,628 --> 00:02:43,230 line:-1
其标识集合的结束


56
00:02:43,297 --> 00:02:44,131 line:-1
（结束索引）


57
00:02:44,198 --> 00:02:45,999 line:-1
集合支持从其起始索引


58
00:02:46,133 --> 00:02:48,302 line:-1
到结束索引之间遍历元素的能力


59
00:02:49,436 --> 00:02:51,038 line:-1
它们可以多次进行这种遍历


60
00:02:51,438 --> 00:02:54,474 line:-1
它们也支持使用下标来获取


61
00:02:54,541 --> 00:02:56,043 line:-1
集合中的元素


62
00:02:56,109 --> 00:02:57,377 line:-1
（SUBSCRIPT[INDEX]）


63
00:02:57,444 --> 00:02:58,812 line:-1
我们看看它在代码中的样子


64
00:02:59,680 --> 00:03:01,715 line:-1
的确 如果我们看一下集合的定义


65
00:03:01,949 --> 00:03:03,750 line:-1
它被声明为一个元素序列


66
00:03:04,852 --> 00:03:07,688 line:-1
它还有一个关联类型称为Index


67
00:03:07,788 --> 00:03:08,989 line:-2
其必须遵守
Comparable协议


68
00:03:10,490 --> 00:03:12,659 line:-1
它提供了一个下标来检索元素


69
00:03:12,793 --> 00:03:13,961 line:-1
或使用该索引


70
00:03:14,695 --> 00:03:16,330 line:-1
我们定义一个起始和结束索引


71
00:03:16,563 --> 00:03:18,498 line:-1
以确定集合的范围


72
00:03:18,932 --> 00:03:22,202 line:-2
最后 这里有一个
index(after)函数


73
00:03:22,269 --> 00:03:24,638 line:-2
可以让我们从一个索引
到达另一个索引


74
00:03:25,572 --> 00:03:27,508 line:-1
最后这个函数非常重要


75
00:03:27,875 --> 00:03:30,077 line:-1
因为它允许标准库


76
00:03:30,410 --> 00:03:32,679 line:-1
通过强大的协议扩展来定义


77
00:03:32,946 --> 00:03:35,215 line:-1
许多有用且强大的默认行为


78
00:03:35,415 --> 00:03:36,650 line:-1
让我们看看其中的一些


79
00:03:37,518 --> 00:03:38,352 line:-1
（协议扩展）


80
00:03:38,418 --> 00:03:39,820 line:-2
当你遵守
Collection协议时


81
00:03:39,887 --> 00:03:42,422 line:-1
你可以访问各种丰富的功能


82
00:03:42,656 --> 00:03:46,059 line:-1
如能够让你获取首尾元素的属性


83
00:03:46,360 --> 00:03:47,394 line:-1
或识别集合大小


84
00:03:48,195 --> 00:03:49,963 line:-1
或检查集合是否为空


85
00:03:50,397 --> 00:03:52,666 line:-2
你还可以通过API
使用forEach语法


86
00:03:52,733 --> 00:03:54,234 line:-1
来遍历集合元素


87
00:03:55,369 --> 00:03:58,172 line:-2
及超有用的函数 如map
filter和reduce


88
00:03:59,206 --> 00:04:01,108 line:-1
我们还可以通过添加自己的扩展


89
00:04:01,175 --> 00:04:02,576 line:-1
来让集合更加强大


90
00:04:03,043 --> 00:04:03,911 line:-1
（间隔元素）


91
00:04:03,977 --> 00:04:06,713 line:-1
集合已经提供了遍历每个元素的方法


92
00:04:06,780 --> 00:04:10,584 line:-2
但我想要一个函数
能够让我遍历间隔元素


93
00:04:10,651 --> 00:04:12,519 line:-1
即在遍历过程中跳过一些值


94
00:04:13,587 --> 00:04:15,989 line:-2
我们将通过向集合添加扩展
来实现这点


95
00:04:16,055 --> 00:04:17,858 line:-1
我们从方法签名开始


96
00:04:18,158 --> 00:04:19,793 line:-2
我们称该函数为
everyOther


97
00:04:19,860 --> 00:04:23,397 line:-2
并且它将采用一个闭包
来调用我们想要的每个元素


98
00:04:24,064 --> 00:04:25,766 line:-1
我们得到迭代的边界


99
00:04:26,500 --> 00:04:29,403 line:-2
并定义一个初始值为
start的值的变量


100
00:04:29,469 --> 00:04:30,904 line:-1
该变量值将随运行而改变


101
00:04:32,105 --> 00:04:34,174 line:-1
我们在当前元素上调用闭包


102
00:04:34,441 --> 00:04:37,177 line:-1
并递增我们的索引


103
00:04:37,911 --> 00:04:39,646 line:-1
此时我们的索引可能已经无效


104
00:04:39,713 --> 00:04:40,848 line:-1
即我们已到集合的最后


105
00:04:40,914 --> 00:04:42,916 line:-1
因此我们需要确保检查它


106
00:04:43,250 --> 00:04:45,819 line:-2
如果还没越界
那么我们可以再次增加索引


107
00:04:46,353 --> 00:04:47,888 line:-1
从而跳过间隔元素


108
00:04:48,355 --> 00:04:51,825 line:0
如果我们在1到10的封闭范围内
调用这个函数


109
00:04:52,092 --> 00:04:54,261 line:0
可以看到我们跳过了偶数元素


110
00:04:55,929 --> 00:04:59,366 line:-2
我们看到集合可以让我们
描述一些非常强大的行为


111
00:05:00,200 --> 00:05:02,102 line:-1
但实际上集合并不孤单


112
00:05:02,436 --> 00:05:03,971 line:-1
其实集合不是我们唯一的协议


113
00:05:04,037 --> 00:05:05,205 line:-1
在Swift中 我们可以访问


114
00:05:05,272 --> 00:05:07,674 line:-1
丰富的集合协议层次结构


115
00:05:07,741 --> 00:05:09,676 line:-1
其中每个都对我们提供的类型假设


116
00:05:09,743 --> 00:05:11,345 line:-1
做了极大改善


117
00:05:11,678 --> 00:05:13,247 line:-1
让我们继续讨论其中一些协议


118
00:05:13,313 --> 00:05:14,615 line:-1
（集合协议层次结构）


119
00:05:14,681 --> 00:05:18,318 line:-2
我们知道集合可以让你
从给定的索引向前移动


120
00:05:18,385 --> 00:05:19,586 line:-1
（集合）


121
00:05:19,653 --> 00:05:21,455 line:-1
但也存在双向集合


122
00:05:21,522 --> 00:05:23,323 line:-1
它可以让你沿着另一个方向移动


123
00:05:23,390 --> 00:05:24,791 line:-1
（双向集合）


124
00:05:24,858 --> 00:05:27,995 line:-1
当然 双向集合也是集合


125
00:05:28,061 --> 00:05:29,997 line:-1
所以我们仍然可以向前迭代


126
00:05:31,565 --> 00:05:33,367 line:-1
下一个最灵活的集合形式


127
00:05:33,433 --> 00:05:35,302 line:-1
就是所谓的随机访问集合


128
00:05:35,369 --> 00:05:39,239 line:-1
它要求当根据某个索引计算另一个


129
00:05:39,306 --> 00:05:41,909 line:-1
或计算两个索引之间的距离的时候


130
00:05:41,975 --> 00:05:44,111 line:-1
所需的时间是常量


131
00:05:44,411 --> 00:05:46,346 line:-1
编译器无法保证这一点


132
00:05:46,413 --> 00:05:48,515 line:-1
所以当你使用随机访问集合时


133
00:05:48,582 --> 00:05:49,750 line:-1
你正在作出一项承诺


134
00:05:50,517 --> 00:05:52,786 line:-2
但如果你满足这个承诺
如果你能兑现承诺


135
00:05:52,853 --> 00:05:54,021 line:-1
这个协议就可以让你


136
00:05:54,087 --> 00:05:57,090 line:-1
在常量时间内访问集合中的任何索引


137
00:05:57,991 --> 00:06:00,327 line:-1
当然 随机访问集合仍然是集合


138
00:06:00,394 --> 00:06:02,663 line:-1
所以你仍然可以向前和向后迭代


139
00:06:02,729 --> 00:06:04,264 line:-1
（随机访问集合）


140
00:06:04,331 --> 00:06:07,401 line:-2
作为Swift开发人员
我们可以访问遵守这些协议的


141
00:06:07,467 --> 00:06:08,702 line:-1
许多有用的集合


142
00:06:10,237 --> 00:06:12,406 line:-2
这类集合包括Array
Set和Dictionary等


143
00:06:12,506 --> 00:06:14,007 line:-2
（SWIFT中的集合
ARRAY - SET- DICTIONARY）


144
00:06:14,074 --> 00:06:15,943 line:-1
但由于这些协议的通用目的


145
00:06:16,009 --> 00:06:19,413 line:-1
许多其它类型也遵守这些集合协议


146
00:06:19,479 --> 00:06:21,582 line:-2
如Data
Range和String


147
00:06:21,648 --> 00:06:22,783 line:-1
（DATA - RANGE - STRING）


148
00:06:22,850 --> 00:06:24,051 line:-1
或是索引集合


149
00:06:24,284 --> 00:06:26,553 line:-1
它们都可以访问所有这些丰富的功能


150
00:06:26,620 --> 00:06:29,189 line:-1
只要它们以自己的方式遵守集合协议


151
00:06:29,389 --> 00:06:31,959 line:-2
确实 一旦你知道其中任意一种类型
的工作原理


152
00:06:32,025 --> 00:06:34,228 line:-2
你就可以将该知识
应用于任何其它类型


153
00:06:34,795 --> 00:06:35,963 line:-1
并且这些类型还不少


154
00:06:37,231 --> 00:06:40,667 line:-2
我将谈谈类型如何
遵守集合协议的细节


155
00:06:40,934 --> 00:06:44,171 line:-1
这一切都从描述如何索引开始


156
00:06:44,838 --> 00:06:46,306 line:-1
（索引）


157
00:06:46,373 --> 00:06:48,308 line:-1
每个集合都有自己的索引


158
00:06:49,843 --> 00:06:51,378 line:-2
该索引必须遵守
Comparable协议


159
00:06:52,246 --> 00:06:56,483 line:-2
在某些情况下 索引可能是整数
如数组中的索引


160
00:06:56,683 --> 00:06:58,819 line:-1
但仅仅因为索引碰巧是一个整数


161
00:06:58,886 --> 00:07:00,854 line:-1
并不意味着你只能这样用


162
00:07:01,421 --> 00:07:04,458 line:-2
现在我想问几个问题
其答案可能出乎预料


163
00:07:05,125 --> 00:07:07,194 line:-2
第一个是
我们如何获得数组的第一个元素


164
00:07:08,595 --> 00:07:12,499 line:-2
你可能马上会想“这个简单
我只需调用array[0]”


165
00:07:12,966 --> 00:07:14,635 line:-1
数组的索引恰好是整数


166
00:07:14,701 --> 00:07:17,604 line:-2
所以你有时可以这样说
并得到你想要的结果


167
00:07:17,971 --> 00:07:19,540 line:-1
但这不是最好的办法


168
00:07:19,640 --> 00:07:21,341 line:-1
我要继续问同样的问题


169
00:07:21,408 --> 00:07:23,410 line:-1
但这次是关于另一种集合


170
00:07:25,078 --> 00:07:26,547 line:-1
Set的第一个元素是什么？


171
00:07:26,947 --> 00:07:29,416 line:-1
听起来像一个很奇怪的问题 对吧？


172
00:07:29,483 --> 00:07:30,484 line:-1
Set是无序的


173
00:07:30,984 --> 00:07:32,319 line:-1
然而它们的确是集合


174
00:07:32,386 --> 00:07:34,388 line:-1
并且作为集合 你可以遍历它们


175
00:07:34,454 --> 00:07:35,522 line:-1
当遍历一个Set时


176
00:07:35,589 --> 00:07:37,724 line:-1
你将首先遍历一个元素


177
00:07:37,791 --> 00:07:40,127 line:-1
所以这正是我们刚才问的问题


178
00:07:40,827 --> 00:07:42,062 line:-1
我能用set[0]吗？


179
00:07:42,896 --> 00:07:44,631 line:-1
编译器会说不


180
00:07:45,132 --> 00:07:48,235 line:-1
这是因为Set的索引类型不是整数


181
00:07:48,969 --> 00:07:51,471 line:-2
类型系统希望我们
使用正确的索引类型


182
00:07:52,940 --> 00:07:54,675 line:-1
幸运的是 我们已知如何做到这点


183
00:07:54,741 --> 00:07:57,778 line:-2
我们知道集合协议告诉我们所有集合
都有一个startIndex


184
00:07:57,845 --> 00:07:58,712 line:-1
让我们继续并使用它


185
00:07:58,779 --> 00:07:59,646 line:-1
如果我们这样做


186
00:07:59,713 --> 00:08:01,448 line:-1
这实际上适用于所有集合


187
00:08:01,515 --> 00:08:05,185 line:-2
startIndex
将始终代表你在遍历时


188
00:08:05,252 --> 00:08:06,887 line:-1
看到的第一个元素


189
00:08:06,954 --> 00:08:08,522 line:-1
但在任何集合中使用下标索引时


190
00:08:08,589 --> 00:08:11,458 line:-1
有一个细微之处需要注意


191
00:08:12,960 --> 00:08:15,095 line:-1
那就是 它可能会崩溃


192
00:08:16,063 --> 00:08:18,565 line:-2
我实际上还没有断言
这些集合中有内容


193
00:08:18,632 --> 00:08:22,836 line:-2
我直接使用了startIndex
然而这些集合可能是空的


194
00:08:23,570 --> 00:08:26,306 line:-1
事实证明 访问集合中的第一个元素


195
00:08:26,373 --> 00:08:29,276 line:-2
是一个很普遍的任务
所以我们有更好的方法


196
00:08:29,343 --> 00:08:30,944 line:-1
（致命错误：索引超出范围）


197
00:08:31,011 --> 00:08:32,246 line:-1
即只需调用first


198
00:08:32,880 --> 00:08:35,015 line:-2
如果你调用first
这会更安全


199
00:08:35,082 --> 00:08:37,116 line:-1
因为其返回类型为可选的


200
00:08:37,417 --> 00:08:40,386 line:-2
回忆一下并非所有集合
都具有第一个元素的事实


201
00:08:42,456 --> 00:08:43,724 line:-1
我还有另一个问题


202
00:08:44,591 --> 00:08:48,028 line:-2
集合的第二个元素是什么
我想在这里强调集合本身


203
00:08:48,262 --> 00:08:49,263 line:-1
它可以是任何集合


204
00:08:49,329 --> 00:08:51,865 line:-2
一个数组、一个Set
或者甚至还不存在的东西


205
00:08:52,866 --> 00:08:55,636 line:-2
我们通过协议扩展向集合
添加一个新属性


206
00:08:55,702 --> 00:08:56,870 line:-1
我们称其为second


207
00:08:56,937 --> 00:08:58,739 line:-2
和first一样
它的返回类型为可选的


208
00:08:58,805 --> 00:09:00,908 line:-1
因为并非所有集合都有两个元素


209
00:09:02,176 --> 00:09:06,547 line:-1
我们试试这样写 self[1]


210
00:09:06,780 --> 00:09:10,017 line:-2
但这里我们的基于0的索引直觉
会将我们带入歧途


211
00:09:10,317 --> 00:09:12,386 line:-1
然后我们会再次被编译器抓个正着


212
00:09:13,854 --> 00:09:15,756 line:-1
我们希望此代码能够适用于每种集合


213
00:09:15,822 --> 00:09:18,091 line:-1
而不只是使用整数作为索引的集合


214
00:09:18,959 --> 00:09:20,561 line:-1
所以我们尝试一种不同的方法


215
00:09:21,195 --> 00:09:23,864 line:-2
我真正想要的是
比startIndex大1的索引


216
00:09:23,931 --> 00:09:25,566 line:-1
（找到一个集合的第二个元素）


217
00:09:25,632 --> 00:09:27,968 line:-1
但编译器仍不依不饶


218
00:09:29,102 --> 00:09:31,471 line:-1
你不能将对任意索引类型加一


219
00:09:31,572 --> 00:09:34,107 line:-2
索引类型应该是不透明的
或者可以是不透明的


220
00:09:35,576 --> 00:09:36,777 line:-1
我们在这里真正要做的


221
00:09:36,844 --> 00:09:39,513 line:-2
是我们需要使用
集合协议提供的API


222
00:09:39,580 --> 00:09:40,447 line:-1
来做到这一点


223
00:09:40,514 --> 00:09:41,849 line:-1
我们来试试


224
00:09:42,683 --> 00:09:45,519 line:-1
我注释了为了找到第二个元素


225
00:09:45,586 --> 00:09:46,854 line:-1
需要做的事情的框架


226
00:09:47,187 --> 00:09:48,422 line:-1
我们需要做的第一件事是


227
00:09:48,488 --> 00:09:50,691 line:-1
我们需要检查集合是否为空


228
00:09:51,024 --> 00:09:52,526 line:-1
集合在其startIndex


229
00:09:52,593 --> 00:09:54,561 line:-1
等于endIndex时为空


230
00:09:54,862 --> 00:09:56,763 line:-1
所以我们来检查一下并返回nil


231
00:09:57,431 --> 00:10:00,901 line:-1
因为这样的集合没有第二个元素


232
00:10:03,136 --> 00:10:06,139 line:0
现在可以假设我们的集合有一个元素


233
00:10:07,774 --> 00:10:11,144 line:-2
我们可以使用index(after)函数
来获取第二个元素或第二个索引


234
00:10:11,612 --> 00:10:13,714 line:-1
但我们需要确保该索引是有效的


235
00:10:14,147 --> 00:10:15,182 line:-1
我们直观地来看一下


236
00:10:15,282 --> 00:10:17,985 line:-2
我们向前移动了一个元素
但如果集合中只有一个元素


237
00:10:18,051 --> 00:10:19,786 line:-1
我们现在的索引实际上是无效的


238
00:10:19,853 --> 00:10:21,288 line:-1
如果我们试图用下标索引它


239
00:10:21,355 --> 00:10:23,557 line:-1
我们就会得到刚才看到的严重错误


240
00:10:23,624 --> 00:10:24,691 line:-1
所以我们检查它是否有效


241
00:10:24,758 --> 00:10:26,159 line:-1
这与空链非常相似


242
00:10:26,226 --> 00:10:27,961 line:-1
我们只需要确保我们的索引


243
00:10:28,028 --> 00:10:30,163 line:-2
不等于endIndex
否则返回nil


244
00:10:30,564 --> 00:10:35,102 line:-2
同样 因为单元素集合
没有第二个元素


245
00:10:35,969 --> 00:10:37,838 line:0
这时我们确认了所有假设都成立


246
00:10:37,905 --> 00:10:40,107 line:0
并知道我们的集合至少有两个元素


247
00:10:40,407 --> 00:10:42,743 line:0
所以我们可以安全地
为该索引使用下标运算符


248
00:10:43,877 --> 00:10:45,279 line:0
从而检索我们想要的值


249
00:10:47,181 --> 00:10:49,883 line:-1
这些代码看起来很多


250
00:10:50,150 --> 00:10:52,753 line:-2
但值得指出的是
这个通用目的索引


251
00:10:52,819 --> 00:10:55,322 line:-2
将可以处理任何集合
这非常棒


252
00:10:55,889 --> 00:10:58,425 line:-2
但其实Swift有更好的方法
来做到这一点


253
00:10:58,859 --> 00:11:00,394 line:-1
即一个叫做切片的东西


254
00:11:00,627 --> 00:11:02,229 line:-2
但在展示如何使用切片
做到这点之前


255
00:11:02,296 --> 00:11:05,365 line:-2
我想谈谈什么是切片
以及它们如何工作


256
00:11:06,934 --> 00:11:08,202 line:-1
（构造一个切片）


257
00:11:08,268 --> 00:11:11,872 line:-1
切片是仅描述集合的一部分的类型


258
00:11:13,207 --> 00:11:16,376 line:-1
每个切片都有自己的起始和结束索引


259
00:11:17,077 --> 00:11:20,881 line:-1
并且切片与其原始集合分开存在


260
00:11:21,481 --> 00:11:24,484 line:-2
切片如此高效的原因是
它们不占用额外的存储空间


261
00:11:24,551 --> 00:11:26,854 line:-1
它们只是引用原始集合


262
00:11:27,788 --> 00:11:31,592 line:0
当使用切片下标时
它将读出原始缓冲区中的数据


263
00:11:32,726 --> 00:11:33,994 line:-1
它们可以这样做是因为


264
00:11:34,728 --> 00:11:37,264 line:-1
它们与其原始集合共享同样的索引


265
00:11:37,497 --> 00:11:39,833 line:-2
我们来看看这是如何工作的
我们可以证明这一点


266
00:11:40,133 --> 00:11:41,335 line:-1
我们将从一个数组开始


267
00:11:41,869 --> 00:11:43,704 line:0
我们丢弃该数组的第一个元素


268
00:11:43,770 --> 00:11:46,273 line:0
以生成一个少了一个元素的切片


269
00:11:47,107 --> 00:11:49,309 line:0
由于我们想要证明索引


270
00:11:49,376 --> 00:11:51,411 line:0
我们需要得到数组的第二个索引


271
00:11:51,745 --> 00:11:54,281 line:0
即得到起始索引之后的一个索引


272
00:11:54,515 --> 00:11:55,415 line:0
然后比较它们


273
00:11:55,482 --> 00:11:57,184 line:0
它们的确是一样的


274
00:11:58,485 --> 00:11:59,620 line:-1
这个dropFirst函数


275
00:11:59,686 --> 00:12:02,890 line:-2
看起来就是我们得到集合中
第二个元素的简便方法


276
00:12:03,724 --> 00:12:05,125 line:-1
让我们回到之前的解决方案


277
00:12:05,192 --> 00:12:07,561 line:-1
看看切片的表达能力有多强


278
00:12:08,629 --> 00:12:10,597 line:-1
还记得我们之前写的复杂的


279
00:12:10,664 --> 00:12:11,765 line:-1
索引检查代码吗


280
00:12:12,799 --> 00:12:15,235 line:-2
通过使用dropFirst
我们将让切片


281
00:12:15,302 --> 00:12:17,371 line:-2
替我们处理那些复杂的
索引边界检查过程


282
00:12:18,005 --> 00:12:19,706 line:-1
由于第一个返回值是可选的


283
00:12:20,941 --> 00:12:24,444 line:-2
这在集合为空或只有一个元素时
也能按预期工作


284
00:12:25,078 --> 00:12:26,880 line:-1
让我们将发生的事情可视化出来


285
00:12:27,614 --> 00:12:28,615 line:-1
我们从一个数组开始


286
00:12:28,682 --> 00:12:31,185 line:0
我们通过丢弃第一个元素
来构造一个切片


287
00:12:32,352 --> 00:12:37,624 line:0
然后我们使用first属性
对切片进行下标运算


288
00:12:37,691 --> 00:12:39,760 line:0
并从原始集合中获取元素


289
00:12:39,927 --> 00:12:42,863 line:-2
我不知道你怎么想
但我更愿意维护这样的代码


290
00:12:44,898 --> 00:12:47,034 line:-2
每种类型都可以
自由描述自己的切片类型


291
00:12:47,100 --> 00:12:48,101 line:-1
很多也正是这样做的


292
00:12:48,669 --> 00:12:51,038 line:-2
例如 Array
定义了ArraySlice


293
00:12:51,104 --> 00:12:53,240 line:-1
它们是为了数组最经常处理的情况


294
00:12:53,307 --> 00:12:54,508 line:-1
所特别定制的


295
00:12:54,908 --> 00:12:58,378 line:-2
类似地 String定义了
Substring切片类型


296
00:12:58,946 --> 00:13:00,147 line:-1
而Substring也是为了


297
00:13:00,214 --> 00:13:02,616 line:-1
处理最常见的字符串行为而定制的


298
00:13:03,350 --> 00:13:04,785 line:-1
一些类型 如Set


299
00:13:05,953 --> 00:13:07,855 line:-1
将使用标准库中定义的


300
00:13:07,921 --> 00:13:09,189 line:-1
广义切片类型


301
00:13:09,289 --> 00:13:10,390 line:-1
因为Set是无序的


302
00:13:10,457 --> 00:13:11,758 line:-1
它们能做的事情并不多


303
00:13:11,825 --> 00:13:14,161 line:-2
它们基本上只需要维护
一个起始和一个结束索引


304
00:13:14,228 --> 00:13:16,230 line:-1
以及一个指向原始集合的指针


305
00:13:16,864 --> 00:13:19,800 line:-2
另一方面 Data和Range是
它们自己的切片类型


306
00:13:20,300 --> 00:13:22,469 line:-1
所以这里有很多选项


307
00:13:22,970 --> 00:13:25,172 line:-1
在继续之前我还想谈一件


308
00:13:25,239 --> 00:13:26,240 line:-1
关于切片的事情


309
00:13:27,708 --> 00:13:29,743 line:-1
假设我们有一个非常大的集合


310
00:13:29,810 --> 00:13:32,079 line:-1
比如有上亿个元素


311
00:13:33,180 --> 00:13:35,816 line:-2
然后我们为该集合的一部分
创建几个小切片


312
00:13:36,650 --> 00:13:38,418 line:-1
重要的是要记住切片


313
00:13:38,485 --> 00:13:41,455 line:-1
使整个原始集合保持活跃状态


314
00:13:41,688 --> 00:13:43,423 line:-1
只要切片还存在


315
00:13:43,524 --> 00:13:45,092 line:-1
而这可能导致令人惊讶的问题


316
00:13:45,158 --> 00:13:46,527 line:-1
我们看看这在代码中是什么样的


317
00:13:48,095 --> 00:13:49,963 line:-1
假设我在数组上有一个扩展


318
00:13:50,030 --> 00:13:51,465 line:-1
允许我返回其前半部分


319
00:13:51,532 --> 00:13:55,269 line:-2
我在这里使用dropLast函数
来做到这一点


320
00:13:55,836 --> 00:13:57,504 line:-1
我们有一个包含8个数字的数组


321
00:13:57,571 --> 00:13:58,739 line:-1
我们调用扩展


322
00:13:59,773 --> 00:14:00,774 line:-1
生成切片


323
00:14:01,008 --> 00:14:03,977 line:-2
然后尝试释放这8个数字的
原始存储空间


324
00:14:04,178 --> 00:14:06,346 line:-1
我将该数组设为一个空数组


325
00:14:07,514 --> 00:14:10,050 line:-1
第一件趣事的线索是


326
00:14:10,117 --> 00:14:12,786 line:-1
发生在我们访问切片的第一个元素时


327
00:14:13,520 --> 00:14:14,788 line:-1
我们竟然能够得到1


328
00:14:14,855 --> 00:14:19,126 line:-2
尽管我们已经释放了
原始数组的存储空间


329
00:14:19,526 --> 00:14:22,229 line:-2
要么它有一个副本
要么发生了一些不可思议的事情


330
00:14:23,330 --> 00:14:26,533 line:0
如果我们想要消除那个缓冲区


331
00:14:27,100 --> 00:14:30,003 line:0
这里发生的神奇的事
是我们还能访问那个缓冲区


332
00:14:30,103 --> 00:14:31,471 line:0
所以如果我们想清除它


333
00:14:31,538 --> 00:14:32,773 line:0
我们可以做的是


334
00:14:33,073 --> 00:14:35,042 line:0
从切片创建一个
数组的真实副本


335
00:14:35,809 --> 00:14:38,445 line:0
然后如果我们将该切片
设置为一个空数组


336
00:14:39,079 --> 00:14:40,480 line:0
那个副本仍然有效


337
00:14:41,415 --> 00:14:43,050 line:-1
让我们看看发生了什么


338
00:14:43,250 --> 00:14:44,384 line:-1
我们从一个数组开始


339
00:14:45,018 --> 00:14:47,387 line:-2
然后我们根据该数组的前半部分
构造了一个切片


340
00:14:47,454 --> 00:14:49,756 line:-1
（复制切片）


341
00:14:49,823 --> 00:14:51,758 line:-1
然后我们创建了它的一个副本


342
00:14:52,426 --> 00:14:54,928 line:-2
将数组设置为空
并将该切片也设置为空


343
00:14:54,995 --> 00:14:59,032 line:-2
只有在我们这样做后
底层存储才会真正消失


344
00:15:01,201 --> 00:15:03,837 line:-1
就这点而言 切片有点像延迟拷贝


345
00:15:04,204 --> 00:15:05,205 line:-1
你可以选择


346
00:15:05,572 --> 00:15:07,574 line:-1
何时自己创建元素的副本


347
00:15:08,242 --> 00:15:11,478 line:-2
事实证明 这种“懒”行为
和延迟做某事的概念


348
00:15:12,179 --> 00:15:14,114 line:-1
在其他情况下也非常有用


349
00:15:15,516 --> 00:15:17,684 line:-1
其中一种情况是函数调用


350
00:15:17,751 --> 00:15:18,719 line:-1
（“急切的”函数）


351
00:15:18,785 --> 00:15:21,321 line:-2
默认情况下 Swift中的
函数调用是"急切的"


352
00:15:22,022 --> 00:15:26,126 line:-2
也就是说 它们接收了输入
并按照要求返回它们的输出


353
00:15:27,261 --> 00:15:28,328 line:-1
考虑这个例子


354
00:15:28,529 --> 00:15:30,397 line:-2
我们从一个1到4,000
的Range开始


355
00:15:30,664 --> 00:15:33,767 line:-2
Range是代表大量数字的
一种非常简洁的方式


356
00:15:33,867 --> 00:15:36,637 line:-2
它只需要首和尾
就能够知道如何生成它们


357
00:15:37,271 --> 00:15:39,706 line:-1
我们将其映射为每个值乘以2


358
00:15:39,773 --> 00:15:42,543 line:-2
所以我们现在已经分配了
包含4000个元素的数组


359
00:15:42,743 --> 00:15:45,612 line:-2
并在它们中的每一个上
执行我们的映射函数


360
00:15:46,413 --> 00:15:48,282 line:-1
然后我们将过滤出四个元素


361
00:15:48,815 --> 00:15:50,317 line:-1
迄今为止 我们已经


362
00:15:50,384 --> 00:15:54,988 line:-1
分配了4,004个元素的空间


363
00:15:56,156 --> 00:15:57,991 line:-1
但我们只需要最后四个


364
00:16:00,427 --> 00:16:02,529 line:-1
这其中具有大量的中间计算


365
00:16:02,596 --> 00:16:04,198 line:-1
而我们并不总是希望这样


366
00:16:04,731 --> 00:16:06,934 line:-2
如果有办法不进行这些计算
除非绝对需要


367
00:16:07,000 --> 00:16:08,502 line:-1
那就太好了


368
00:16:10,337 --> 00:16:13,440 line:-2
Swift对此的回答称为“懒惰”
就像在现实生活中一样


369
00:16:13,507 --> 00:16:14,675 line:-1
（惰性函数）


370
00:16:14,741 --> 00:16:17,511 line:-1
我们仍然从Range开始


371
00:16:17,978 --> 00:16:19,813 line:-2
我们会告诉该Range
让它"懒惰"一点


372
00:16:19,913 --> 00:16:21,582 line:-2
当我们这样做时
所发生的事是


373
00:16:21,648 --> 00:16:25,452 line:-2
我们用LazyCollection
包装了原始集合


374
00:16:25,919 --> 00:16:28,455 line:-2
当我们对这个LazyCollection
执行操作时


375
00:16:28,622 --> 00:16:30,824 line:-2
所发生的事是
我们要再次包装它


376
00:16:30,891 --> 00:16:34,127 line:-2
所以当我们在它上面调用map时
我们实际上并没有映射


377
00:16:34,328 --> 00:16:35,429 line:-1
我们没对该闭包做任何事


378
00:16:35,495 --> 00:16:38,232 line:-1
除了将其存储以便我们将来需要它


379
00:16:38,532 --> 00:16:41,068 line:-2
如果我进一步过滤了
LazyMapCollection


380
00:16:41,335 --> 00:16:43,470 line:-1
过滤器只是简单地包装该映射集合


381
00:16:43,770 --> 00:16:45,639 line:-1
请注意它会在将来按需过滤


382
00:16:45,706 --> 00:16:46,707 line:-1
而不是现在


383
00:16:47,841 --> 00:16:49,176 line:-1
现在让我们继续并请求


384
00:16:49,243 --> 00:16:51,478 line:-2
LazyFilterCollection
的第一个元素


385
00:16:55,516 --> 00:16:56,517 line:0
当我们这样做时


386
00:16:57,117 --> 00:16:59,253 line:0
我们将首先请求
LazyFilterCollection的


387
00:16:59,319 --> 00:17:00,320 line:0
第一个元素


388
00:17:00,687 --> 00:17:02,723 line:0
但LazyFilterCollection
并不知道


389
00:17:02,956 --> 00:17:04,724 line:0
然而它包装了可能知道它的东西


390
00:17:05,025 --> 00:17:06,492 line:0
因此它将询问
MapCollection


391
00:17:06,627 --> 00:17:09,663 line:0
而MapCollection
也不知道它的第一个元素


392
00:17:10,163 --> 00:17:11,632 line:0
但它包装了一个可能知道的集合


393
00:17:11,832 --> 00:17:13,934 line:0
的确 Range知道
它的第一个元素


394
00:17:14,935 --> 00:17:17,171 line:0
Range的第一个元素是值1


395
00:17:17,538 --> 00:17:19,473 line:0
它被返回到
LazyMapCollection


396
00:17:19,705 --> 00:17:23,109 line:0
现在LazyMapCollection
可以实际执行它的闭包


397
00:17:23,877 --> 00:17:25,012 line:0
计算出值为2


398
00:17:25,444 --> 00:17:27,214 line:0
该值被返回到
LazyFilterCollection


399
00:17:27,281 --> 00:17:28,782 line:0
并作为候选的第一个元素


400
00:17:29,283 --> 00:17:32,319 line:0
在这种情况下 我们很幸运
因为2恰好比10小


401
00:17:32,419 --> 00:17:35,656 line:0
所以LazyFilterCollection
在第一次尝试中就找到了它的第一个元素


402
00:17:36,256 --> 00:17:37,891 line:0
并将其返回给调用者


403
00:17:38,992 --> 00:17:40,961 line:-1
这是很不同的计算方式


404
00:17:41,328 --> 00:17:45,499 line:-2
我提到懒惰的目的是
只根据需要进行计算


405
00:17:46,033 --> 00:17:49,036 line:-1
但它避免的另一件事是创建中间存储


406
00:17:49,203 --> 00:17:50,737 line:-1
所以我想向你展示一个例子


407
00:17:52,339 --> 00:17:54,842 line:-2
假设我们有一个
包含不同类型的熊的数组


408
00:17:55,242 --> 00:17:58,879 line:-2
然而我想指出的是
其中一些熊是多余的


409
00:17:59,379 --> 00:18:00,914 line:-1
我们已经知道他们是熊


410
00:18:00,981 --> 00:18:02,449 line:-1
它们不必再告诉我们


411
00:18:03,350 --> 00:18:06,119 line:-2
所以让我们编写一些代码
来找到那些愚蠢的冗余熊


412
00:18:06,286 --> 00:18:08,455 line:-2
我们将像刚才一样用惰性过滤器
执行此操作


413
00:18:08,689 --> 00:18:09,690 line:-1
在这个例子中


414
00:18:10,824 --> 00:18:14,261 line:-2
所生成的惰性过滤器将是一个
LazyFilterCollection


415
00:18:14,494 --> 00:18:16,063 line:-1
包装的一个字符串数组


416
00:18:16,697 --> 00:18:17,698 line:-1
在我们的闭包中


417
00:18:17,764 --> 00:18:20,501 line:-2
我们将在做断言检查之前
打印出我们目前


418
00:18:20,567 --> 00:18:22,069 line:-1
正在迭代的那只熊


419
00:18:22,302 --> 00:18:23,637 line:-1
这样做是因为我想


420
00:18:23,704 --> 00:18:26,273 line:-2
更好理解过滤器工作原理
然后我们将调用first


421
00:18:26,340 --> 00:18:29,142 line:-2
当我们这样做时 执行过程将被交给
LazyFilterCollection


422
00:18:30,210 --> 00:18:34,515 line:-2
随后LazyFilterCollection
将调用原始存储


423
00:18:36,450 --> 00:18:37,985 line:-2
这时我们将打印出
“Grizzly”


424
00:18:40,621 --> 00:18:43,390 line:-2
并检查断言
在这种情况下结果为false


425
00:18:43,457 --> 00:18:44,892 line:-2
因为“Grizzly”
不包含“Bear”


426
00:18:44,958 --> 00:18:46,159 line:-1
并移动到下一个“Panda”


427
00:18:47,294 --> 00:18:48,462 line:-1
当我们到达“Panda”时…


428
00:18:50,764 --> 00:18:53,166 line:-2
当我们到达“Panda”时
我们会再次打印出“Panda”


429
00:18:53,867 --> 00:18:55,769 line:-1
检查它是否包含单词“Bear”


430
00:18:55,836 --> 00:18:57,304 line:-1
并移动到“Spectacled”


431
00:18:57,938 --> 00:19:01,008 line:-2
“Spectacled”被打印
它也不包含“Bear”一词


432
00:19:01,074 --> 00:19:02,976 line:-2
最后我们移动到
“Gummy Bears”


433
00:19:03,610 --> 00:19:05,612 line:-1
它包含“Bear”这个词


434
00:19:06,680 --> 00:19:10,651 line:-2
LazyFilterCollection
现在可以将其返回给它的调用者


435
00:19:12,085 --> 00:19:14,154 line:-2
若我们再次调用first
会发生什么？


436
00:19:15,255 --> 00:19:18,492 line:-1
其实还是一样的过程


437
00:19:18,892 --> 00:19:22,396 line:-2
我们询问LazyFilterCollection
它将再次询问底层集合


438
00:19:22,462 --> 00:19:25,866 line:-2
底层集合重复刚才的计算
并将结果返回给调用者


439
00:19:27,935 --> 00:19:29,970 line:-1
现在这可能不是你想要的


440
00:19:30,237 --> 00:19:32,806 line:-2
所以如果你发现自己需要
反复调用惰性集合


441
00:19:32,873 --> 00:19:34,107 line:-1
来计算其结果


442
00:19:34,541 --> 00:19:36,910 line:-2
有一种方法可以确保
该计算只发生一次


443
00:19:37,911 --> 00:19:40,380 line:-2
我们可以通过从惰性集合
创建一个新的非惰性集合


444
00:19:40,447 --> 00:19:43,684 line:-1
来确保惰性集合只迭代一次


445
00:19:44,384 --> 00:19:45,385 line:-1
当你这样做时


446
00:19:45,752 --> 00:19:47,654 line:-1
它仍然会将计算委托给惰性集合


447
00:19:47,721 --> 00:19:48,555 line:-1
但现在迭代过程


448
00:19:48,622 --> 00:19:51,658 line:-1
将处理完整个底层集合


449
00:19:53,760 --> 00:19:55,028 line:-1
从而产生


450
00:19:55,095 --> 00:19:57,331 line:-1
该惰性计算的非惰性版本


451
00:19:57,865 --> 00:20:00,934 line:-2
这例子中 我们得到一个包含字符串
“Gummy Bears”的数组


452
00:20:01,535 --> 00:20:03,570 line:-1
如果我们打印该数组的第一个元素


453
00:20:03,637 --> 00:20:06,106 line:-2
我们根本不需要咨询闭包
或者惰性集合


454
00:20:06,173 --> 00:20:09,276 line:-2
我们基本消除了其惰性
并得到一个“急切的”数组


455
00:20:11,879 --> 00:20:13,046 line:-1
我们何时该懒惰呢？


456
00:20:14,081 --> 00:20:16,517 line:-1
惰性集合是一种非常好的能够消除


457
00:20:16,583 --> 00:20:18,485 line:-1
链式映射和过滤器的开销的方法


458
00:20:18,585 --> 00:20:19,786 line:-1
当你发现你只需要


459
00:20:19,853 --> 00:20:22,556 line:-2
集合运算的部分结果时
它们就非常有用


460
00:20:23,257 --> 00:20:27,027 line:-2
但如果你的闭包有副作用
你就应该避免使用懒惰策略


461
00:20:27,127 --> 00:20:29,396 line:-1
你的闭包应该鲜有副作用


462
00:20:29,830 --> 00:20:31,765 line:-2
并且记得一定要恢复…
或者应该说


463
00:20:31,832 --> 00:20:34,234 line:-1
一定要考虑重新恢复到普通集合


464
00:20:34,301 --> 00:20:35,736 line:-1
当你跨越API边界时


465
00:20:36,069 --> 00:20:38,172 line:-1
惰性通常应该是一个实现细节


466
00:20:38,238 --> 00:20:39,940 line:-1
（建议：何时使用惰性？）


467
00:20:40,007 --> 00:20:42,142 line:-1
到目前为止 我们已经使用可变集合


468
00:20:42,209 --> 00:20:43,677 line:-1
做了很多很酷的事情


469
00:20:44,978 --> 00:20:47,681 line:-2
但Swift也允许我们
改变我们的集合


470
00:20:47,748 --> 00:20:48,982 line:-1
（集合协议层次结构）


471
00:20:49,049 --> 00:20:50,751 line:-1
让我们来谈谈


472
00:20:50,817 --> 00:20:52,319 line:-1
这两种尚未讨论过的集合


473
00:20:53,187 --> 00:20:55,088 line:-1
其中第一个是可变集合


474
00:20:55,989 --> 00:20:57,191 line:-1
它为下标添加了一个setter


475
00:20:57,257 --> 00:20:59,092 line:-1
以便你可以更改集合的内容


476
00:20:59,159 --> 00:21:00,160 line:-1
但不能更改它的长度


477
00:21:00,427 --> 00:21:02,596 line:-2
你必须能够
在常数时间内完成这项任务


478
00:21:02,663 --> 00:21:04,031 line:-1
（可变集合）


479
00:21:05,632 --> 00:21:08,502 line:-1
下一个被称为范围可替换集合


480
00:21:08,569 --> 00:21:10,504 line:-1
你可以在这种集合中


481
00:21:10,571 --> 00:21:14,308 line:-1
删除元素或插入元素


482
00:21:16,076 --> 00:21:18,779 line:-2
现在我想谈谈
我一直被问到的一个问题


483
00:21:20,347 --> 00:21:22,916 line:-2
为什么我的完全合理的
集合代码会崩溃？


484
00:21:23,784 --> 00:21:25,185 line:-1
像所有好问题的答案一样


485
00:21:25,252 --> 00:21:27,688 line:-1
一般我会反问他们我自己的一些问题


486
00:21:28,355 --> 00:21:31,425 line:-2
有时候我会从经典问题开始
“你想做什么？”


487
00:21:31,692 --> 00:21:33,293 line:-1
接下来我马上会问


488
00:21:33,360 --> 00:21:35,262 line:-1
“你是怎么使用集合的？”


489
00:21:35,362 --> 00:21:36,363 line:-1
“你在尝试改变它们吗？”


490
00:21:36,430 --> 00:21:38,866 line:-2
“你确定没有从多个线程
访问你的集合吗？”


491
00:21:38,932 --> 00:21:41,401 line:-1
我问这些问题是因为其答案


492
00:21:42,436 --> 00:21:45,038 line:-1
常常能引出导致问题的根本原因


493
00:21:46,039 --> 00:21:48,141 line:-1
首先让我们先假设跟线程没关系


494
00:21:48,208 --> 00:21:50,878 line:-2
我还没准备好考虑线程
现在9:30都还没到呢


495
00:21:50,944 --> 00:21:52,079 line:-1
（崩溃的集合代码）


496
00:21:52,145 --> 00:21:53,280 line:-1
假设我们有一个数组


497
00:21:53,780 --> 00:21:56,350 line:-1
我们获取一个已知元素的索引


498
00:21:57,184 --> 00:21:58,418 line:-1
这个例子中 值为“E”


499
00:21:58,652 --> 00:22:01,755 line:-2
然后我们通过删除它的第一个元素
来改变集合


500
00:22:02,656 --> 00:22:05,526 line:-1
我们继续并打印与该索引关联的元素


501
00:22:06,360 --> 00:22:07,995 line:-2
当我们这样做时
不幸的是


502
00:22:08,996 --> 00:22:10,430 line:-1
这会产生一个严重错误


503
00:22:12,032 --> 00:22:13,166 line:-1
索引不再有效


504
00:22:13,233 --> 00:22:16,904 line:-2
实际上当我们改变集合时
索引立即变得无效了


505
00:22:18,939 --> 00:22:20,040 line:-1
更安全的方法


506
00:22:20,340 --> 00:22:24,411 line:-2
是首先改变我们的集合
然后计算索引


507
00:22:24,511 --> 00:22:26,446 line:-1
（避免索引失效）


508
00:22:26,513 --> 00:22:28,949 line:-2
值得指出的是
集合改变总会使索引无效


509
00:22:29,016 --> 00:22:30,651 line:-1
这不仅适用于数组


510
00:22:31,118 --> 00:22:34,321 line:-2
我们来看看这个问题
如何在字典中体现出来


511
00:22:34,988 --> 00:22:38,225 line:-2
我们假设有一个字典
其存储了一些熊最喜欢的东西


512
00:22:39,092 --> 00:22:41,195 line:-1
我们获取熊最喜爱的食物的索引


513
00:22:41,361 --> 00:22:44,031 line:-2
并打印出来
它的确是“salmon”


514
00:22:45,199 --> 00:22:47,835 line:0
接下来我们将添加更多
这只熊喜欢的东西


515
00:22:48,602 --> 00:22:50,938 line:0
然后我们会确保熊最喜欢的食物
仍然是“salmon”


516
00:22:51,104 --> 00:22:52,639 line:0
我们会看到…等一下


517
00:22:52,706 --> 00:22:55,209 line:0
熊最喜欢的食物不是“hibernation”
而是"salmon"


518
00:22:57,077 --> 00:22:58,078 line:0
就像数组一样


519
00:22:58,145 --> 00:23:00,948 line:0
在我们改变字典的那一刻
我们使索引无效了


520
00:23:01,448 --> 00:23:03,851 line:0
值得指出的是
这段代码可能会崩溃


521
00:23:05,085 --> 00:23:06,553 line:0
我们该如何解决这个问题呢？


522
00:23:07,688 --> 00:23:10,524 line:0
其实这与我们在数组中
使用的修复方法完全一样


523
00:23:11,225 --> 00:23:13,493 line:-2
我们只需要在发生改变后
重新计算索引


524
00:23:14,328 --> 00:23:15,429 line:-1
请记住一件事


525
00:23:15,562 --> 00:23:16,997 line:-1
当你重新计算索引时


526
00:23:17,297 --> 00:23:18,899 line:-1
这有时会造成很大的开销


527
00:23:18,966 --> 00:23:21,768 line:-1
一些索引搜索方法需要线性时间


528
00:23:22,336 --> 00:23:25,205 line:-1
而且你只关心你所需要的那个索引


529
00:23:26,874 --> 00:23:27,708 line:-1
所以如果你想


530
00:23:27,774 --> 00:23:30,344 line:-2
避免陷入这种情况
以下是我的建议


531
00:23:30,410 --> 00:23:33,580 line:-2
请记住 改变集合几乎
总是使你的索引无效


532
00:23:33,914 --> 00:23:35,983 line:-1
你有时可能会侥幸成功


533
00:23:36,049 --> 00:23:38,385 line:-1
但最好将这视为一条硬性规则


534
00:23:38,585 --> 00:23:39,953 line:-1
你最终会为此感到高兴


535
00:23:40,854 --> 00:23:42,422 line:-1
还要记住切片依赖于


536
00:23:42,489 --> 00:23:45,058 line:-1
其底层的原始集合的状态


537
00:23:45,125 --> 00:23:46,493 line:-1
即使是在它发生了改变之后


538
00:23:46,894 --> 00:23:50,831 line:-2
因此当底层集合是可变的时
如果你还想继续使用索引或切片


539
00:23:51,164 --> 00:23:53,133 line:-1
请务必三思而后行


540
00:23:53,767 --> 00:23:55,502 line:-1
并记住索引计算


541
00:23:55,636 --> 00:23:57,771 line:-1
有时可能花费大量的时间


542
00:23:57,838 --> 00:23:59,139 line:-1
（建议：索引和切片）


543
00:23:59,206 --> 00:24:01,441 line:-1
所以注意只在必要时才进行索引计算


544
00:24:02,910 --> 00:24:05,746 line:-1
现在让我们来讨论一下线程


545
00:24:05,812 --> 00:24:07,481 line:-1
我提到我问的其中一个问题是


546
00:24:07,548 --> 00:24:10,317 line:-2
“你的线程是否可以
由多个线程访问？”


547
00:24:11,618 --> 00:24:12,853 line:-1
我之所以这样问


548
00:24:13,053 --> 00:24:14,555 line:-1
是因为我们的集合假设


549
00:24:14,621 --> 00:24:16,723 line:-1
你将从单个线程访问它们


550
00:24:17,691 --> 00:24:20,294 line:-1
这对性能来说是一件好事


551
00:24:20,694 --> 00:24:22,429 line:-1
这是因为单线程用例


552
00:24:22,496 --> 00:24:26,300 line:-2
不需要花费大量资源在锁
或任何其它你用来


553
00:24:26,366 --> 00:24:29,069 line:-1
确保互斥的原语上面


554
00:24:30,237 --> 00:24:33,140 line:-2
当涉及到线程时
只有使用集合的开发人员


555
00:24:33,207 --> 00:24:35,375 line:-1
才拥有以适当的锁或串行队列


556
00:24:35,442 --> 00:24:37,578 line:-1
限制访问所需的所有信息


557
00:24:37,644 --> 00:24:38,912 line:-1
这些信息的抽象层次要比


558
00:24:38,979 --> 00:24:41,381 line:-2
我们这些底层框架开发人员
所能提供的层次高


559
00:24:42,683 --> 00:24:45,285 line:-1
我们看看这些问题会是什么样子的


560
00:24:45,385 --> 00:24:46,486 line:-1
假设我们有一个数组


561
00:24:46,553 --> 00:24:48,488 line:-1
我们想将睡着的熊添加进去


562
00:24:49,256 --> 00:24:51,892 line:-1
为了模拟每只熊都是独立的


563
00:24:51,959 --> 00:24:52,793 line:-1
并能够管理自己


564
00:24:52,860 --> 00:24:55,362 line:-1
我们将访问并发调度队列


565
00:24:56,230 --> 00:24:58,232 line:-1
我们将用它来告诉每只熊去睡觉


566
00:24:58,899 --> 00:25:00,534 line:-1
并且由于这是一个并发调度队列


567
00:25:00,601 --> 00:25:03,637 line:-1
想象代码同时运行是很有帮助的


568
00:25:03,904 --> 00:25:06,240 line:-2
我将它们放在同一行上
以代表并发执行的情况


569
00:25:07,007 --> 00:25:08,108 line:-1
稍后在app中


570
00:25:08,175 --> 00:25:10,043 line:-1
让我们检查一下那些睡觉的熊


571
00:25:11,245 --> 00:25:14,548 line:0
有时我们会看到Grandpa
和Cub在快乐地打盹


572
00:25:15,048 --> 00:25:18,752 line:0
其他时候 Cub会先睡觉
然后才是Grandpa


573
00:25:19,419 --> 00:25:22,389 line:0
有时 非常神秘
只有Grandpa在睡觉


574
00:25:23,790 --> 00:25:25,425 line:0
其他时候
则是只有Cub在睡觉


575
00:25:26,560 --> 00:25:28,962 line:0
有时候 我们的程序崩溃了


576
00:25:29,029 --> 00:25:30,497 line:0
并且没有熊能够睡觉


577
00:25:32,132 --> 00:25:33,166 line:-1
所有这些可能性


578
00:25:33,233 --> 00:25:35,068 line:-1
表明存在可能的竞争条件


579
00:25:35,135 --> 00:25:36,770 line:-1
其实考虑到这个例子中的线程


580
00:25:36,837 --> 00:25:40,140 line:-1
这的确有可能发生


581
00:25:41,074 --> 00:25:42,176 line:-1
我们可以使用Xcode中的


582
00:25:42,242 --> 00:25:45,179 line:-2
ThreadSanitizer
或TSan来证明这一点


583
00:25:45,646 --> 00:25:46,647 line:-1
假设我们这样做的话


584
00:25:47,214 --> 00:25:49,216 line:-1
我们将得到这样的输出


585
00:25:49,783 --> 00:25:51,585 line:-1
TSan的确发现了竞争


586
00:25:51,652 --> 00:25:54,121 line:-2
它告诉我们当前存在
Swift访问竞争


587
00:25:54,655 --> 00:25:56,590 line:-1
它会告诉我们涉及哪些线程


588
00:25:57,491 --> 00:25:58,625 line:-1
并在最后给个总结


589
00:25:58,692 --> 00:26:01,695 line:-2
告诉我们应该从哪一行代码开始
寻找我们的问题


590
00:26:02,329 --> 00:26:06,700 line:-2
所有这些证据对于我们发现错误
都非常有帮助


591
00:26:06,934 --> 00:26:08,268 line:-1
我们已证明这里有一个漏洞


592
00:26:08,335 --> 00:26:11,238 line:-2
在我的经历中
TSan从未撒过谎


593
00:26:12,606 --> 00:26:13,607 line:-1
我们可以


594
00:26:13,841 --> 00:26:16,710 line:-2
通过解除熊的同时入睡能力
来解决这个问题


595
00:26:16,910 --> 00:26:18,979 line:-1
我们将使用串行调度队列来实现这点


596
00:26:19,746 --> 00:26:21,715 line:-1
现在一次只有一只熊可以入睡


597
00:26:21,949 --> 00:26:24,184 line:-2
所以如果我们现在再次查看
sleepingBears变量


598
00:26:24,885 --> 00:26:26,887 line:-1
并在适当的队列上小心操作


599
00:26:27,988 --> 00:26:29,122 line:-1
我们可以看到 果然


600
00:26:29,189 --> 00:26:31,959 line:-2
Grandpa和Cub
如预期的那样 平静地打瞌睡


601
00:26:34,194 --> 00:26:36,830 line:-2
所以对于在多线程环境下使用集合
我的建议是


602
00:26:36,897 --> 00:26:40,133 line:-2
尝试隔离你的数据
以便它只能被单个线程访问


603
00:26:40,300 --> 00:26:41,635 line:-1
当你不能这样做时


604
00:26:42,436 --> 00:26:44,705 line:-1
确保你实现适当形式的互斥


605
00:26:44,771 --> 00:26:47,040 line:-1
如串行调度队列或锁


606
00:26:47,741 --> 00:26:50,511 line:-2
并总是使用ThreadSanitizer
来检查你的工作


607
00:26:50,844 --> 00:26:54,248 line:-2
在app发布之前发现错误
要比之后好得多


608
00:26:54,314 --> 00:26:55,716 line:-1
（建议：多线程）


609
00:26:55,782 --> 00:26:58,519 line:-1
我对使用可变集合还有更多的建议


610
00:26:59,753 --> 00:27:03,490 line:-2
第一个是如果你可以避免它
就尽量不要使用可变状态


611
00:27:04,391 --> 00:27:06,193 line:-1
到目前为止我所描述的所有困难


612
00:27:06,260 --> 00:27:08,562 line:-1
都是因为我们一直在使用可变状态


613
00:27:08,862 --> 00:27:10,697 line:-1
你可以通过避免使用可变集合


614
00:27:10,764 --> 00:27:13,133 line:-1
来从一开始就杜绝各种可能的复杂性


615
00:27:13,834 --> 00:27:16,803 line:-2
很多时候 你可以通过使用切片
或惰性包装器


616
00:27:17,004 --> 00:27:20,207 line:-1
来模拟你想要执行的改变


617
00:27:20,641 --> 00:27:23,744 line:-1
而且理解不可变数据几乎总是更容易


618
00:27:24,178 --> 00:27:26,380 line:-1
多亏Swift内置的可变性


619
00:27:26,513 --> 00:27:27,648 line:-1
若在你没有改变状态时


620
00:27:27,714 --> 00:27:30,551 line:-2
却试图留下可变的状态
则编译器会帮助你进行处理


621
00:27:30,617 --> 00:27:32,619 line:-1
（建议：首选不可变集合）


622
00:27:32,686 --> 00:27:34,288 line:-1
现在我还有一条建议


623
00:27:34,788 --> 00:27:37,858 line:-2
关于如何在必要时
最好地使用可变状态


624
00:27:38,825 --> 00:27:40,494 line:-1
那就是当你正在构造新的集合时


625
00:27:40,561 --> 00:27:41,495 line:-1
你可以改善性能


626
00:27:41,562 --> 00:27:43,964 line:-2
如果你碰巧知道
你所需要元素的


627
00:27:44,531 --> 00:27:45,699 line:-1
确切数量


628
00:27:45,766 --> 00:27:47,634 line:-1
或者非常好的近似值的话


629
00:27:47,734 --> 00:27:50,804 line:-2
大多数集合API都能够
提供这种提示


630
00:27:51,171 --> 00:27:52,973 line:-2
当你这样做时
会得到所需的确切大小


631
00:27:53,040 --> 00:27:54,041 line:-1
而且没有额外开销


632
00:27:54,441 --> 00:27:57,344 line:-2
如果你不这样做
我们的集合就是通用工具


633
00:27:57,978 --> 00:27:59,713 line:-1
它们可以在各种情况下工作


634
00:27:59,780 --> 00:28:01,448 line:-1
随着你逐步添加元素


635
00:28:01,515 --> 00:28:05,319 line:-2
你最终可能会分配比你所需要的
更多的存储空间


636
00:28:06,186 --> 00:28:09,289 line:-2
但请注意 在提供此类提示时
请不要高估


637
00:28:09,489 --> 00:28:11,391 line:-1
否则你会发现自己处于同样的情况


638
00:28:11,458 --> 00:28:14,061 line:-1
即你使用的存储空间比实际需要的多


639
00:28:15,028 --> 00:28:17,364 line:-1
现在我想继续今天的最后一个话题


640
00:28:18,832 --> 00:28:21,969 line:-2
当你导入foundation
集合时 你可以使用的


641
00:28:22,536 --> 00:28:25,472 line:-2
各种各样的集合
以及你何时应该考虑使用它们


642
00:28:27,307 --> 00:28:28,876 line:-1
除了标准库集合之外


643
00:28:28,942 --> 00:28:30,143 line:-1
当你导入foundation时


644
00:28:30,210 --> 00:28:32,513 line:-1
你可以访问很棒的引用类型集合


645
00:28:32,579 --> 00:28:35,315 line:-2
它们已被Objective-C
开发人员用了几十年


646
00:28:36,350 --> 00:28:39,253 line:-1
其中许多都可以兼容Swift


647
00:28:39,319 --> 00:28:42,222 line:-2
因此它们与我们一直在谈论的
集合行为一致


648
00:28:42,289 --> 00:28:44,558 line:-2
也就是说 有几件重要的事情
需要记住


649
00:28:45,993 --> 00:28:49,296 line:-1
首先要记住的是这些NS类集合


650
00:28:49,363 --> 00:28:50,464 line:-1
是引用类型


651
00:28:50,564 --> 00:28:52,900 line:-1
我们通过一个例子来更好的理解这点


652
00:28:53,634 --> 00:28:55,302 line:-1
我们将定义值类型和引用类型


653
00:28:55,369 --> 00:28:57,604 line:-1
并在两边对它们做同样的事情


654
00:28:58,338 --> 00:29:00,240 line:-2
对于我们的值类型
我们将它称为x


655
00:29:00,307 --> 00:29:01,542 line:-1
它将是一个字符串数组


656
00:29:02,409 --> 00:29:04,711 line:-1
我们得到一个名为x的空数组


657
00:29:05,012 --> 00:29:07,047 line:-2
对于引用类型
我们得到一个空数组


658
00:29:07,381 --> 00:29:08,549 line:-1
但x只是指向它


659
00:29:09,983 --> 00:29:12,719 line:-1
然后我们用数值类型来改变这个数组


660
00:29:12,886 --> 00:29:14,288 line:-1
该数组内联地发生改变


661
00:29:14,755 --> 00:29:15,923 line:-1
对于引用类型


662
00:29:16,123 --> 00:29:20,494 line:-1
正在被引用的数组内联地发生改变


663
00:29:21,328 --> 00:29:22,496 line:-1
我们创建另一个变量


664
00:29:23,130 --> 00:29:25,432 line:-2
使用值类型时
会发生一些非常特殊的事情


665
00:29:25,499 --> 00:29:27,301 line:-1
这时我们实际上并不复制存储


666
00:29:27,367 --> 00:29:31,471 line:-2
y是一个数组
但它知道它的存储实际上由x所有


667
00:29:32,539 --> 00:29:34,208 line:-1
并且y实际上不会进行复制


668
00:29:34,274 --> 00:29:36,343 line:-1
除非这些集合中的任何一个发生变化


669
00:29:36,610 --> 00:29:38,679 line:-1
引用类型有点不同


670
00:29:38,912 --> 00:29:41,782 line:-2
y只是另一个
指向同一个底层数组的指针


671
00:29:43,016 --> 00:29:46,019 line:-2
所以让我们继续并改变y
我们会在该数组中再放一只熊


672
00:29:46,086 --> 00:29:47,421 line:-1
对于值类型 所发生的事是


673
00:29:47,487 --> 00:29:49,423 line:-1
我们首先进行复制


674
00:29:49,489 --> 00:29:51,825 line:-2
我们正在对y写入值
所以我们需要复制它


675
00:29:53,260 --> 00:29:54,895 line:-1
然后我们就可以插入下一个熊


676
00:29:56,363 --> 00:29:57,931 line:-1
对于引用 情况较为简单


677
00:29:57,998 --> 00:30:01,068 line:-2
只存在一个数组
我们只是把熊猫放到数组中


678
00:30:01,134 --> 00:30:03,303 line:-1
（值和引用集合）


679
00:30:03,537 --> 00:30:05,038 line:-2
在Swift中
使用foundation集合时


680
00:30:05,105 --> 00:30:08,675 line:-1
你需要记住的第二件事


681
00:30:09,476 --> 00:30:12,446 line:-2
是Swift中的所有
Objective-C API


682
00:30:12,513 --> 00:30:14,581 line:-1
都以Swift原生值类型出现


683
00:30:15,048 --> 00:30:17,951 line:-2
这实际上非常棒
因为它允许每种语言的代码


684
00:30:18,018 --> 00:30:20,554 line:-1
自然而然使用它们各自最擅长的类型


685
00:30:20,988 --> 00:30:22,022 line:-1
但是这如何实现呢？


686
00:30:22,155 --> 00:30:24,024 line:-1
这两种语言对这些集合


687
00:30:24,091 --> 00:30:25,192 line:-1
有完全不同的实现


688
00:30:25,259 --> 00:30:26,360 line:-2
（SWIFT中的
OBJECTIVE-C API）


689
00:30:26,426 --> 00:30:29,062 line:-1
这能起作用的原因就是所谓的桥接


690
00:30:29,496 --> 00:30:33,033 line:-2
桥接是我们如何在两种不同的
运行时表示之间进行转换


691
00:30:33,100 --> 00:30:36,203 line:-2
这是必要的 因为Swift
和Objective-C


692
00:30:36,270 --> 00:30:38,739 line:-2
我相信你已经注意到
是非常不同的语言


693
00:30:38,906 --> 00:30:41,208 line:-2
它们具有完全不同的
编译和运行时特性


694
00:30:41,275 --> 00:30:42,309 line:-1
（桥接）


695
00:30:42,376 --> 00:30:46,213 line:-2
尽管我们已经优化了桥接速度
但这并不是免费的


696
00:30:46,480 --> 00:30:49,516 line:-1
在两种语言之间桥接时总会产生开销


697
00:30:50,884 --> 00:30:52,252 line:-1
当我们桥接时会发生什么？


698
00:30:52,920 --> 00:30:54,555 line:-1
当我们在语言之间桥接时


699
00:30:54,621 --> 00:30:57,357 line:-2
我们必须先建立新的存储空间
对等的存储空间


700
00:30:57,424 --> 00:30:59,059 line:-1
如果你用一种语言占用N个单位


701
00:30:59,126 --> 00:31:00,827 line:-1
在另一种语言中这也将占用N个


702
00:31:01,128 --> 00:31:05,032 line:-2
然后我们需要逐个元素地
在它们之间进行转换


703
00:31:05,098 --> 00:31:07,568 line:-2
并且这种按元素桥接
有时可以递归执行


704
00:31:07,634 --> 00:31:09,536 line:-1
比如我有一个字符串数组


705
00:31:09,603 --> 00:31:10,704 line:-1
首先我们将桥接数组


706
00:31:10,771 --> 00:31:12,840 line:-1
然后我们将桥接每个单独的字符串


707
00:31:13,941 --> 00:31:16,176 line:-1
当这发生在两种语言的边界时


708
00:31:16,243 --> 00:31:17,411 line:-1
称之为“急切桥接”


709
00:31:18,812 --> 00:31:20,681 line:-1
当集合中的元素也需要桥接时


710
00:31:20,747 --> 00:31:23,584 line:-1
集合本身将总是“急切”进行桥接


711
00:31:24,151 --> 00:31:27,321 line:-2
这种情况最常出现在
以字符串作为键的字典中


712
00:31:28,789 --> 00:31:31,325 line:-2
当集合桥接并不急切时
我们称之为惰性


713
00:31:31,658 --> 00:31:33,627 line:-1
当集合元素的类型并不是桥接时


714
00:31:33,694 --> 00:31:36,230 line:-2
就会发生这种情况
比如NSView


715
00:31:36,463 --> 00:31:38,298 line:-2
在这种情况下
桥接将被推迟


716
00:31:38,365 --> 00:31:40,701 line:-1
直到首次使用该集合


717
00:31:41,435 --> 00:31:43,437 line:-1
让我们用一些例子来说明这个问题


718
00:31:43,637 --> 00:31:47,074 line:-2
我们首先考虑一个Objective-C API
即NSArray


719
00:31:47,808 --> 00:31:49,643 line:-1
NSArray被桥接到数组


720
00:31:49,710 --> 00:31:51,845 line:-2
而NSData
被桥接到值类型的数据


721
00:31:51,979 --> 00:31:54,381 line:-1
所以这样的集合将会被急切的桥接


722
00:31:54,448 --> 00:31:55,649 line:-1
（桥接示例）


723
00:31:55,716 --> 00:31:58,352 line:-2
我刚才提到NSView
没有在Swift中被桥接


724
00:31:58,418 --> 00:32:00,554 line:-1
它们在Swift中仍然是引用类型


725
00:32:00,621 --> 00:32:04,157 line:-1
所以NSArray将被延迟桥接


726
00:32:04,258 --> 00:32:05,259 line:-1
桥接不会发生


727
00:32:05,325 --> 00:32:08,228 line:-1
直到你第一次访问或尝试使用该数组


728
00:32:10,831 --> 00:32:15,269 line:-2
最后 键类型为NSString的
NSDictionary


729
00:32:15,335 --> 00:32:16,537 line:-1
将被急切桥接


730
00:32:17,070 --> 00:32:19,439 line:-1
因为字符串需在Swift中转换为


731
00:32:19,506 --> 00:32:21,308 line:-1
值类型的字符串


732
00:32:22,242 --> 00:32:25,312 line:-2
现在我们知道了桥接是什么
它的原理以及何时发生


733
00:32:25,579 --> 00:32:27,648 line:-1
我们可以继续讨论最重要的问题


734
00:32:27,748 --> 00:32:29,550 line:-1
即你何时应该关心它


735
00:32:29,716 --> 00:32:31,285 line:-1
答案非常简单


736
00:32:31,351 --> 00:32:33,654 line:-2
当你估计它会对你的app
产生负面影响时


737
00:32:35,889 --> 00:32:38,392 line:-2
具体而言 当你使用时间分析器
或追踪仪器时


738
00:32:38,559 --> 00:32:41,795 line:-2
要特别注意你的代码
在不同语言之间的交叉部分


739
00:32:41,862 --> 00:32:44,097 line:-1
特别是当这发生在循环内时


740
00:32:44,898 --> 00:32:47,434 line:-1
少量的桥接完全没问题


741
00:32:47,501 --> 00:32:48,836 line:-1
你所关心的是


742
00:32:48,902 --> 00:32:51,872 line:-2
不成比例的时间
或者一个惊人的时间


743
00:32:52,072 --> 00:32:55,042 line:-2
被花费在不是你写的代码中
并且其中包含单词“bridge”


744
00:32:56,476 --> 00:32:57,978 line:-1
我们来看一个具体的例子


745
00:32:58,846 --> 00:33:01,215 line:-2
假设我正在写一本
关于儿童故事的手稿


746
00:33:01,515 --> 00:33:02,749 line:-1
但它非常长


747
00:33:02,816 --> 00:33:04,351 line:-1
所以我只会在这里展示一部分


748
00:33:04,418 --> 00:33:05,953 line:-1
但为了让它受欢迎


749
00:33:07,154 --> 00:33:10,324 line:-1
我想让每个单词“brown”


750
00:33:10,390 --> 00:33:11,725 line:-1
都真的显示为棕色


751
00:33:12,092 --> 00:33:13,126 line:-1
为了节省空间


752
00:33:13,193 --> 00:33:15,495 line:-1
我将只突出显示第一个单词


753
00:33:16,330 --> 00:33:18,732 line:-2
为此 我将使用
NSMutableAttributedString


754
00:33:18,799 --> 00:33:20,067 line:-1
我把我的故事传进去


755
00:33:20,968 --> 00:33:24,738 line:-2
然后使用属性字符串的
string属性


756
00:33:25,005 --> 00:33:27,274 line:-2
我要得到Swift字符串
“Brown”的范围


757
00:33:27,541 --> 00:33:30,077 line:-2
这将产生一个
字符串本地索引类型范围


758
00:33:31,311 --> 00:33:32,980 line:-2
因为可变字符串
能与NSRange协同工作


759
00:33:33,046 --> 00:33:34,515 line:-1
所以我会使用我们去年


760
00:33:34,581 --> 00:33:35,816 line:-1
推出的便捷初始化器


761
00:33:36,216 --> 00:33:38,151 line:-1
来将其转换为NSRange


762
00:33:38,218 --> 00:33:42,489 line:-2
在这里我再次调用
属性字符串的string属性


763
00:33:43,090 --> 00:33:44,091 line:-1
来进行转换


764
00:33:44,391 --> 00:33:47,060 line:-2
然后我们将为“brown”
这个词的第一个实例着色


765
00:33:47,194 --> 00:33:49,696 line:-2
当我运行这段代码时
我发现它有点慢


766
00:33:50,898 --> 00:33:51,899 line:-1
所以我对其进行分析


767
00:33:52,266 --> 00:33:54,468 line:-1
我看到 令我惊讶的是


768
00:33:54,535 --> 00:33:56,336 line:-2
我以为大部分时间都会花在
为单词“brown”着色上


769
00:33:56,403 --> 00:33:57,938 line:-1
但它实际上是在计算索引


770
00:33:58,005 --> 00:33:59,006 line:-1
为什么会这样


771
00:34:00,707 --> 00:34:02,509 line:-1
其中的原因是我们实际上正在


772
00:34:02,576 --> 00:34:04,244 line:-1
两种语言间多次桥接字符串


773
00:34:04,511 --> 00:34:08,014 line:-2
MutableAttributedString是一个
Objective-C引用类型


774
00:34:08,081 --> 00:34:10,284 line:-1
所以当我们访问string属性时


775
00:34:10,350 --> 00:34:13,120 line:-2
我们实际上需要从NSString
转换为string


776
00:34:13,554 --> 00:34:16,657 line:-2
当我们计算第一个范围时
我们在这里进行一次桥接


777
00:34:16,956 --> 00:34:19,659 line:-2
我们在转换为NSRange时
进行第二次桥接


778
00:34:20,694 --> 00:34:22,329 line:-1
你可以想象这样的开销有多大


779
00:34:22,396 --> 00:34:24,864 line:-2
如果我们在一个循环中
查找所有文本以进行着色


780
00:34:25,465 --> 00:34:27,367 line:-2
现在我们来看看为什么
会发生这种情况


781
00:34:27,434 --> 00:34:31,071 line:-2
每次调用text.string时
都会在Swift执行上下文中启动


782
00:34:31,737 --> 00:34:34,908 line:-2
然而NSMutableAttributedString
是用Objective-C实现的


783
00:34:34,975 --> 00:34:36,577 line:-1
所以为了提供结果


784
00:34:36,643 --> 00:34:39,279 line:-1
我们实际上必须咨询其原始实现


785
00:34:39,346 --> 00:34:40,614 line:-1
（桥接发生时）


786
00:34:40,681 --> 00:34:44,284 line:-2
原始实现返回NSString
它是引用类型


787
00:34:44,451 --> 00:34:46,820 line:-2
所以当返回到字符串时
它需要被桥接


788
00:34:47,521 --> 00:34:49,755 line:-1
逐个图像集


789
00:34:50,824 --> 00:34:51,992 line:-1
逐个字符


790
00:34:52,826 --> 00:34:58,098 line:-2
无论是返回类型还是参数
都会发生桥接


791
00:35:01,268 --> 00:35:03,237 line:-1
现在我们知道了这些细节


792
00:35:03,470 --> 00:35:06,306 line:-1
我们可以做得更好一些


793
00:35:06,373 --> 00:35:07,474 line:-1
我们只需桥接一次


794
00:35:08,709 --> 00:35:10,010 line:-1
让我们重新测量代码


795
00:35:10,944 --> 00:35:13,614 line:-1
并看到我们的确已将性能提高了一半


796
00:35:13,680 --> 00:35:15,949 line:-1
但今年我们可以做得更好一点


797
00:35:16,650 --> 00:35:18,986 line:-1
哦 现在我们在这里不再进行桥接


798
00:35:19,486 --> 00:35:21,421 line:-1
但今年我们可以做得更好一点


799
00:35:21,722 --> 00:35:23,991 line:-2
今年当我们获取
text.string属性时


800
00:35:24,057 --> 00:35:25,659 line:-2
如果我们使用as语法
转换为NSString


801
00:35:25,726 --> 00:35:29,263 line:-2
当我们得到变量时
实际上不会发生任何桥接


802
00:35:30,564 --> 00:35:34,868 line:-2
并且通过这样做
该字符串现是一个NSString


803
00:35:35,035 --> 00:35:36,336 line:-2
当我们调用
range(of)属性时


804
00:35:36,403 --> 00:35:39,873 line:-2
我们实际上
会自动获得NSRange


805
00:35:39,940 --> 00:35:41,642 line:-1
我们不需要在Swift原生类型


806
00:35:41,708 --> 00:35:45,379 line:-2
和NSRange之间
做任何范围转换


807
00:35:45,612 --> 00:35:46,613 line:-1
这非常棒


808
00:35:46,680 --> 00:35:49,082 line:-1
我们来看看这段代码的效率


809
00:35:49,149 --> 00:35:50,150 line:-1
这看起来很不错


810
00:35:50,217 --> 00:35:52,686 line:-1
这比我们刚才耗费的


811
00:35:52,753 --> 00:35:54,354 line:-1
几乎800毫秒的时间要快得多


812
00:35:55,489 --> 00:35:57,658 line:-2
然而我想指出的是
这里仍然发生了桥接


813
00:35:57,724 --> 00:35:59,026 line:-1
这是很小的桥


814
00:35:59,660 --> 00:36:00,827 line:-1
但我们仍进行了桥接


815
00:36:01,328 --> 00:36:03,830 line:-2
这里的“brown”是一个
Swift值类型的字符串


816
00:36:05,032 --> 00:36:10,938 line:-2
每当我们调用Objective-C API
中NSString的range(of)属性时


817
00:36:11,004 --> 00:36:13,774 line:-2
我们实际上会将这个小小的
字符串桥接回NSString


818
00:36:14,908 --> 00:36:17,144 line:-2
在这种情况下它的开销不大
我只进行了一次


819
00:36:17,211 --> 00:36:18,946 line:-2
但你可以想象
如果这是一个循环


820
00:36:19,079 --> 00:36:20,948 line:-2
随着时间推移
这些小开销会积少成多


821
00:36:21,014 --> 00:36:22,549 line:-1
所以你要注意


822
00:36:22,616 --> 00:36:25,219 line:-1
避免重复桥接相同的小字符串


823
00:36:25,485 --> 00:36:28,222 line:-2
但在你做这样的优化之前
总是要进行测量


824
00:36:29,723 --> 00:36:31,258 line:-1
现在我们看过了桥接的细节


825
00:36:31,358 --> 00:36:34,294 line:-2
我想提供些关于何时使用
foundation集合的建议


826
00:36:35,662 --> 00:36:37,564 line:-1
当你需要具有引用语义的集合时


827
00:36:37,631 --> 00:36:39,800 line:-1
你应该考虑明确使用它们


828
00:36:40,467 --> 00:36:42,102 line:-1
你不需要自己写一个


829
00:36:42,169 --> 00:36:43,637 line:-1
我们已经有很多很棒的集合了


830
00:36:44,238 --> 00:36:45,706 line:-1
当你知道你在处理引用类型时


831
00:36:45,772 --> 00:36:46,974 line:-1
也应该使用它


832
00:36:47,040 --> 00:36:49,743 line:-2
像NS代理或核心数据托管对象
之类的东西


833
00:36:51,078 --> 00:36:52,679 line:-1
最后应该考虑使用它们的情景是


834
00:36:52,746 --> 00:36:54,848 line:-2
当你在与Objective-C
代码之间来回切换时


835
00:36:55,148 --> 00:36:56,884 line:-2
但我强烈建议你
只有在测量并确定


836
00:36:57,351 --> 00:37:00,053 line:-1
桥接确实是性能问题的罪魁祸首后


837
00:37:00,120 --> 00:37:02,556 line:-1
你才这样做


838
00:37:03,690 --> 00:37:06,026 line:-1
现在我们对Swift中强大的


839
00:37:06,093 --> 00:37:08,929 line:-1
集合世界的探索已经接近尾声


840
00:37:09,630 --> 00:37:11,598 line:-1
我希望你能够使用这种新视角


841
00:37:11,698 --> 00:37:13,667 line:-1
来检视你现有的集合使用情况


842
00:37:13,967 --> 00:37:15,903 line:-1
寻找可以通过更有效地


843
00:37:15,969 --> 00:37:18,272 line:-1
使用索引和切片来改进代码的地方


844
00:37:18,839 --> 00:37:19,840 line:-1
测量你的代码


845
00:37:20,574 --> 00:37:23,110 line:-2
寻找你可以因惰性
或通过调整桥接方式


846
00:37:24,411 --> 00:37:25,779 line:-1
而受益的地方


847
00:37:26,947 --> 00:37:29,616 line:-2
用ThreadSanitizer
辅助审计可变状态


848
00:37:30,517 --> 00:37:32,252 line:-1
并通过应用今天讨论的所有概念


849
00:37:32,319 --> 00:37:34,054 line:-2
在Playground
或你自己的app中


850
00:37:34,121 --> 00:37:36,623 line:-1
进一步锻炼你对集合的掌握


851
00:37:37,824 --> 00:37:39,326 line:-1
如果你对集合有任何疑问


852
00:37:39,393 --> 00:37:41,094 line:-1
请到访我们今天最后几个实验室


853
00:37:41,161 --> 00:37:42,162 line:-1
我们将在那里提供帮助


854
00:37:42,629 --> 00:37:45,232 line:-2
非常感谢
在实践中变得更高效吧

