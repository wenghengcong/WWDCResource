1
00:00:07,516 --> 00:00:18,516
［ 音乐 ］


2
00:00:19,516 --> 00:00:25,416
［ 掌声 ］


3
00:00:25,916 --> 00:00:26,946
>> 大家下午好


4
00:00:27,406 --> 00:00:28,456
我是 John Hess


5
00:00:28,456 --> 00:00:30,586
今天我将和 Matthew Lucas 一起


6
00:00:30,586 --> 00:00:31,606
与在座的各位


7
00:00:31,606 --> 00:00:33,166
谈谈提高 App 性能的


8
00:00:33,166 --> 00:00:34,506
一些实用的方法


9
00:00:35,406 --> 00:00:36,906
我现在是一名 Xcode 团队的工程师


10
00:00:36,906 --> 00:00:38,286
在过去的七年


11
00:00:38,346 --> 00:00:39,796
我有幸一直专注于


12
00:00:39,796 --> 00:00:42,236
提高性能的工作


13
00:00:42,736 --> 00:00:44,226
首先是在 Xcode 的两个领域


14
00:00:44,226 --> 00:00:47,186
“Project Find” 和 “Open Quickly”


15
00:00:47,826 --> 00:00:49,896
二者的主要功能 都是提高性能


16
00:00:50,766 --> 00:00:52,056
最近 我有机会去


17
00:00:52,056 --> 00:00:54,136
做一项关于


18
00:00:54,136 --> 00:00:55,846
Xcode GY 响应性的调查


19
00:00:55,846 --> 00:00:57,126
我想与你们分享的是


20
00:00:57,126 --> 00:00:58,326
在进行性能工作时


21
00:00:58,326 --> 00:01:00,296
我所使用的方法


22
00:01:00,296 --> 00:01:01,376
其中包括我十分熟悉的代码


23
00:01:01,376 --> 00:01:03,136
也包括我


24
00:01:03,136 --> 00:01:04,596
第一次接触到的代码


25
00:01:05,936 --> 00:01:07,716
那么 如果各位想从今天的演讲中有所收获


26
00:01:07,716 --> 00:01:09,496
我希望各位至少能


27
00:01:09,496 --> 00:01:11,886
记住一点 那就是


28
00:01:11,946 --> 00:01:13,276
你们所有提高性能的工作


29
00:01:13,276 --> 00:01:14,716
都要基于测量的结果


30
00:01:15,696 --> 00:01:17,096
在开始解决一个性能问题时


31
00:01:17,096 --> 00:01:18,816
你需要进行测量


32
00:01:18,816 --> 00:01:21,126
来建立一个基线


33
00:01:21,366 --> 00:01:22,536
让你知道自己所处的位置


34
00:01:23,666 --> 00:01:25,196
当你重复解决


35
00:01:25,196 --> 00:01:26,716
同一个性能问题时


36
00:01:26,716 --> 00:01:28,146
你应该测量每一步所使用的方法


37
00:01:28,576 --> 00:01:29,826
以确保性能的改变


38
00:01:29,826 --> 00:01:32,026
能够带来你所期待的效果


39
00:01:33,336 --> 00:01:34,346
当你解决了一个性能问题


40
00:01:34,346 --> 00:01:35,916
你还需要再测量一遍


41
00:01:35,916 --> 00:01:37,656
这样你可以与原先的基线


42
00:01:37,656 --> 00:01:38,846
进行对比


43
00:01:38,846 --> 00:01:41,046
从而给出一个量化的结果


44
00:01:41,046 --> 00:01:43,166
关于你将 App 的性能


45
00:01:43,166 --> 00:01:44,746
真正提高了多少


46
00:01:45,196 --> 00:01:46,766
你想要将成果报告给你的老板


47
00:01:46,766 --> 00:01:49,506
分享给你的同事和用户


48
00:01:50,566 --> 00:01:52,966
那么 当你想要为你的用户提高性能时


49
00:01:52,966 --> 00:01:55,166
你需要考虑这一点


50
00:01:55,166 --> 00:01:56,826
我喜欢称它为


51
00:01:56,826 --> 00:01:57,786
总体性能影响


52
00:01:58,656 --> 00:02:01,246
如果你将 App 的


53
00:02:01,246 --> 00:02:03,216
一个领域的性能


54
00:02:03,216 --> 00:02:06,706
提高了 50%


55
00:02:06,706 --> 00:02:08,136
但你的用户 


56
00:02:08,136 --> 00:02:10,006
只体验到了其中的 1%


57
00:02:10,006 --> 00:02:11,456
那么这种提升的影响广度


58
00:02:11,456 --> 00:02:13,286
还不及你只提高了其他领域的 10% 


59
00:02:13,286 --> 00:02:15,526
但所有用户都能体验到


60
00:02:15,526 --> 00:02:16,806
这全部的 10%


61
00:02:17,336 --> 00:02:19,676
所以一定不要去优化边缘的案例


62
00:02:19,676 --> 00:02:20,816
要确保你的性能的优化


63
00:02:20,816 --> 00:02:22,596
能够为全部的用户所体验


64
00:02:24,536 --> 00:02:27,736
那么我们如何修复


65
00:02:27,736 --> 00:02:28,086
性能漏洞呢


66
00:02:28,086 --> 00:02:29,526
如何修复常规的漏洞呢


67
00:02:29,966 --> 00:02:31,586
一般来说 最开始用户反馈给我们


68
00:02:31,586 --> 00:02:33,036
某方面的缺陷报告


69
00:02:33,036 --> 00:02:35,026
我们接收到这个报告


70
00:02:35,026 --> 00:02:36,466
了解到用户对 App 的性能


71
00:02:36,466 --> 00:02:38,216
有一些不满意的地方 


72
00:02:38,216 --> 00:02:39,946
于是我们会设法


73
00:02:40,066 --> 00:02:41,696
来综合步骤进行故障重现


74
00:02:41,696 --> 00:02:42,866
以便我们可以随意地使程序出错


75
00:02:43,646 --> 00:02:45,346
一旦我们成功的做到 我们就给


76
00:02:45,346 --> 00:02:46,526
程序附加一个调试器


77
00:02:46,526 --> 00:02:48,826
以便我们看到我们的程序出错的时候


78
00:02:48,826 --> 00:02:49,376
在做什么


79
00:02:50,866 --> 00:02:51,706
再结合我们的知识


80
00:02:51,706 --> 00:02:52,656
想想代码应该如何工作


81
00:02:52,656 --> 00:02:54,576
在必要时修改它


82
00:02:54,576 --> 00:02:56,176
来消除那些


83
00:02:56,176 --> 00:02:57,156
不如意的部分


84
00:02:57,936 --> 00:02:58,966
我们要确保我们没有


85
00:02:58,966 --> 00:03:00,516
带来任何不想要的副作用


86
00:03:00,516 --> 00:03:02,046
同时 要进行必要的重复


87
00:03:02,046 --> 00:03:03,546
直到我们完全地


88
00:03:03,546 --> 00:03:04,186
解决了这个漏洞


89
00:03:05,736 --> 00:03:07,686
我已经用相同的方法


90
00:03:07,686 --> 00:03:08,996
修复了许多性能漏洞


91
00:03:10,086 --> 00:03:11,136
只不过我并没有使用调试器


92
00:03:11,136 --> 00:03:13,766
而是使用了一个分析器


93
00:03:13,826 --> 00:03:16,246
分析器就是一个很好的测量工具


94
00:03:16,996 --> 00:03:18,666
我用一些步骤


95
00:03:18,666 --> 00:03:20,806
来重现运行很慢的


96
00:03:20,806 --> 00:03:21,216
程序


97
00:03:21,966 --> 00:03:23,386
我用一个附加的分析器 


98
00:03:23,386 --> 00:03:25,106
来执行这些步骤


99
00:03:25,106 --> 00:03:26,606
因此我可以深入地了解


100
00:03:26,606 --> 00:03:27,656
当我的代码运行缓慢时


101
00:03:27,656 --> 00:03:28,106
它发生了什么


102
00:03:29,226 --> 00:03:31,016
然后再结合


103
00:03:31,016 --> 00:03:32,556
我的程序必须要如何运行


104
00:03:32,556 --> 00:03:34,206
才能完成手边的任务


105
00:03:34,266 --> 00:03:36,056
我找到其中正在进行的步骤


106
00:03:36,236 --> 00:03:37,606
并删除了它们


107
00:03:37,606 --> 00:03:39,926
因为想让你的代码变快的


108
00:03:39,926 --> 00:03:42,286
首要方法就是删除多余的步骤


109
00:03:42,286 --> 00:03:44,326
无论它正在计算的是什么


110
00:03:45,736 --> 00:03:47,456
现在 我修改了源代码


111
00:03:47,456 --> 00:03:49,136
在必要时进行反复测量


112
00:03:49,136 --> 00:03:50,486
直到我对整体的结果


113
00:03:50,486 --> 00:03:52,886
感到满意为止


114
00:03:54,936 --> 00:03:57,666
当我通过这种方法提高性能时


115
00:03:57,666 --> 00:03:59,486
我发现自己常常处于


116
00:03:59,486 --> 00:04:00,176
一些场景当中


117
00:04:00,736 --> 00:04:02,026
这些不同的场景


118
00:04:02,056 --> 00:04:03,406
改变了我测试有问题代码的方式


119
00:04:03,496 --> 00:04:05,166
以及复制这些


120
00:04:05,196 --> 00:04:06,126
漏洞的方法


121
00:04:06,776 --> 00:04:09,046
有时我会遇到


122
00:04:09,096 --> 00:04:10,926
严重的性能衰退问题 对吗


123
00:04:11,006 --> 00:04:12,086
开始一切都在平稳地运行


124
00:04:12,086 --> 00:04:14,116
然后我们的团队里


125
00:04:14,116 --> 00:04:15,396
有人对其进行了检测


126
00:04:15,446 --> 00:04:17,086
这个人也许是我


127
00:04:17,086 --> 00:04:18,226
然后发现性能出现了严重的衰退


128
00:04:18,226 --> 00:04:19,495
那么我们就需要回去


129
00:04:19,495 --> 00:04:21,296
找出这种衰退的原因


130
00:04:22,065 --> 00:04:23,246
如果这种衰退十分明显


131
00:04:23,246 --> 00:04:25,986
或者是它出现在一个


132
00:04:25,986 --> 00:04:27,186
我认为近期


133
00:04:27,186 --> 00:04:28,086
不可能再次衰退的地方


134
00:04:28,086 --> 00:04:29,576
我也许会自己手动地


135
00:04:29,676 --> 00:04:31,966
运用附加的分析器 


136
00:04:32,086 --> 00:04:33,216
对它进行测试


137
00:04:34,386 --> 00:04:36,116
但是 想提高你的性能


138
00:04:36,116 --> 00:04:37,376
这是一个不大容易的过程


139
00:04:37,376 --> 00:04:40,056
因为很可能


140
00:04:40,056 --> 00:04:42,126
只是一系列轻微的衰退


141
00:04:42,126 --> 00:04:43,196
就会让你功亏一篑


142
00:04:43,986 --> 00:04:45,806
我建议你们所有人


143
00:04:45,806 --> 00:04:46,926
创建自动化的性能测试


144
00:04:46,926 --> 00:04:48,986
来捕捉你的 App 的性能


145
00:04:48,986 --> 00:04:50,356
这样你就可以


146
00:04:50,356 --> 00:04:52,316
保证它不会随着时间而衰退


147
00:04:55,256 --> 00:04:56,596
我经常所处的另一个场景是


148
00:04:56,596 --> 00:04:58,726
App 的性能


149
00:04:58,726 --> 00:05:00,326
在很长一段时间后


150
00:05:00,326 --> 00:05:01,246
还能保持不变吗


151
00:05:01,656 --> 00:05:03,356
也许在一些绘图测试中


152
00:05:03,356 --> 00:05:04,666
它运行的速度是 45 帧每秒


153
00:05:05,156 --> 00:05:06,826
但是我们希望的运行速度是 60 每秒


154
00:05:06,826 --> 00:05:07,886
所以我们需要小幅地提高它


155
00:05:07,886 --> 00:05:09,426
并且我们有理由相信


156
00:05:09,426 --> 00:05:10,986
通过我们先前的性能工作


157
00:05:10,986 --> 00:05:12,736
我们可以利用现场修复


158
00:05:12,736 --> 00:05:14,126
以及增量式变化


159
00:05:14,126 --> 00:05:15,546
来对它进行提高


160
00:05:16,326 --> 00:05:17,726
在这种场景下


161
00:05:17,726 --> 00:05:19,186
我或许也已经自动地


162
00:05:19,186 --> 00:05:20,876
开始进行测试了 


163
00:05:20,876 --> 00:05:22,216
因为随着时间的推移 


164
00:05:24,796 --> 00:05:24,896
我已经很了解我的性能了


165
00:05:25,106 --> 00:05:26,856
还有第三种场景 


166
00:05:26,856 --> 00:05:28,176
我们的 App


167
00:05:28,176 --> 00:05:29,336
因为设计不良而受到损害


168
00:05:29,446 --> 00:05:30,666
性能也远远比不上


169
00:05:30,666 --> 00:05:32,226
它原应达到的效果


170
00:05:33,516 --> 00:05:34,726
我们知道我们不能用


171
00:05:34,726 --> 00:05:36,626
简单的场地修复来提高性能


172
00:05:36,626 --> 00:05:37,666
因为过去我们这么尝试过


173
00:05:37,906 --> 00:05:39,356
但并没有成功


174
00:05:39,606 --> 00:05:41,416
无法提高性能


175
00:05:42,006 --> 00:05:43,856
在这样的情况下


176
00:05:43,856 --> 00:05:45,986
你会想要做一次彻底的性能检修


177
00:05:45,986 --> 00:05:47,446
你会想重新设计一些特性的核心部分


178
00:05:47,446 --> 00:05:48,716
或是有问题的算法


179
00:05:48,716 --> 00:05:50,516
以使性能成为一个


180
00:05:50,786 --> 00:05:51,916
首要的约束条件


181
00:05:52,456 --> 00:05:53,746
在这些情况里


182
00:05:53,906 --> 00:05:55,216
你必然要对性能进行检测


183
00:05:55,536 --> 00:05:56,686
以测量你确实


184
00:05:56,686 --> 00:05:58,136
达到了你的性能目标


185
00:05:59,246 --> 00:06:01,936
知道你要测试什么 很重要


186
00:06:02,346 --> 00:06:03,686
我想要提醒你的是


187
00:06:03,686 --> 00:06:05,096
我从来都不会立刻投入


188
00:06:05,096 --> 00:06:06,086
这些性能检修


189
00:06:06,086 --> 00:06:08,106
将其视为解决


190
00:06:08,106 --> 00:06:08,896
某种性能问题的方法


191
00:06:09,296 --> 00:06:10,816
我喜欢这么做


192
00:06:10,816 --> 00:06:12,046
这是一种未曾开发的工程


193
00:06:12,046 --> 00:06:14,326
你能够从头开始 设计这些东西


194
00:06:14,326 --> 00:06:16,126
但这也颇具风险


195
00:06:16,556 --> 00:06:17,346
你最终要的是


196
00:06:17,346 --> 00:06:18,666
一个性能更好的产品


197
00:06:18,666 --> 00:06:19,686
但这却是一个曲折的过程


198
00:06:19,686 --> 00:06:21,376
因为你需要重新设计


199
00:06:21,376 --> 00:06:23,976
整个特性


200
00:06:24,116 --> 00:06:25,186
当你做这种工作的时候


201
00:06:25,186 --> 00:06:26,666
你不仅需要知道


202
00:06:26,666 --> 00:06:28,156
这些代码的 


203
00:06:28,286 --> 00:06:29,436
功能约束条件


204
00:06:29,436 --> 00:06:31,336
你还要知道


205
00:06:31,336 --> 00:06:32,986
性能约束条件 


206
00:06:32,986 --> 00:06:34,356
以及你的用户应用这一特性时


207
00:06:34,356 --> 00:06:35,616
最常使用的


208
00:06:35,616 --> 00:06:37,386
典型的模式


209
00:06:37,386 --> 00:06:39,106
而你只能从 


210
00:06:39,256 --> 00:06:40,276
过去这方面的性能工作中


211
00:06:40,276 --> 00:06:40,736
获得这方面信息


212
00:06:41,636 --> 00:06:43,326
我想和你们分享一件轶事


213
00:06:43,326 --> 00:06:45,046
是我们的一个


214
00:06:45,046 --> 00:06:46,216
在 Xcode 里工作的案例


215
00:06:47,216 --> 00:06:49,406
在 Xcode 9 中 我们重做了 “Project Find”


216
00:06:49,406 --> 00:06:50,606
将性能作为一个


217
00:06:50,606 --> 00:06:51,406
首要的目标


218
00:06:52,366 --> 00:06:53,716
我们的目标就是要


219
00:06:53,716 --> 00:06:55,376
在短短几十毫秒中


220
00:06:55,376 --> 00:06:56,076
传递出搜索结果


221
00:06:56,926 --> 00:06:59,156
当我们与同事


222
00:06:59,156 --> 00:07:00,006
讨论这个特性时


223
00:07:00,006 --> 00:07:01,366
我们常常遇到一些挑战


224
00:07:01,366 --> 00:07:03,536
比如让我们在一些大的项目上


225
00:07:03,536 --> 00:07:05,286
搜索一些类似于字符串


226
00:07:05,286 --> 00:07:07,106
或者甚至是字母 E 


227
00:07:07,106 --> 00:07:07,336
这样的东西


228
00:07:07,446 --> 00:07:08,976
这些东西能搜索出成千上万种结果


229
00:07:08,976 --> 00:07:10,446
不是吗


230
00:07:10,446 --> 00:07:12,106
当然如果你的 App


231
00:07:12,216 --> 00:07:13,426
能够迅速生产出成千上万的结果


232
00:07:13,426 --> 00:07:14,866
它搜索任何东西


233
00:07:14,866 --> 00:07:15,776
都会很快


234
00:07:16,476 --> 00:07:17,896
但是如果你思考一下


235
00:07:17,896 --> 00:07:20,516
什么是典型的模式


236
00:07:20,516 --> 00:07:22,046
我们搜索我们使用的 API


237
00:07:22,046 --> 00:07:24,336
我们自己的类名称


238
00:07:24,496 --> 00:07:25,616
还有我们引用的图片名称


239
00:07:25,616 --> 00:07:26,286
诸如此类的东西


240
00:07:26,346 --> 00:07:27,546
它能搜索出很多结果


241
00:07:27,546 --> 00:07:28,606
也许上百种结果


242
00:07:28,936 --> 00:07:30,276
当然十分重要的是 当有一百万种搜索结果时 


243
00:07:30,276 --> 00:07:32,076
你的 App 能够


244
00:07:32,076 --> 00:07:33,236
正常地工作运转


245
00:07:33,496 --> 00:07:35,086
但是通常的使用情况是


246
00:07:35,156 --> 00:07:36,026
有数百种搜索结果


247
00:07:36,806 --> 00:07:38,486
那么 在进行搜索这样的任务时


248
00:07:38,486 --> 00:07:40,186
你所做的一些工作 


249
00:07:40,186 --> 00:07:41,396
要与生成原始结果


250
00:07:41,746 --> 00:07:43,816
这样的东西相对应


251
00:07:43,816 --> 00:07:45,326
而其余的工作则要基于


252
00:07:45,326 --> 00:07:46,916
你能多有效地索引


253
00:07:46,916 --> 00:07:48,296
项目中的文本


254
00:07:48,296 --> 00:07:49,666
并预先避免工作


255
00:07:50,156 --> 00:07:51,996
在这两种场景中


256
00:07:51,996 --> 00:07:53,976
你可能会有完全


257
00:07:53,976 --> 00:07:55,286
不同的优化目标


258
00:07:55,286 --> 00:07:56,826
让其中一个目标的搜索速度


259
00:07:56,826 --> 00:07:59,046
快于其他的目标 对吗


260
00:07:59,046 --> 00:08:00,156
因而你有必要了解


261
00:08:00,156 --> 00:08:02,426
你的用户将要


262
00:08:02,426 --> 00:08:03,316
如何使用该产品


263
00:08:03,506 --> 00:08:04,696
这样你就可以优化


264
00:08:04,726 --> 00:08:05,536
应该优化的案例


265
00:08:07,956 --> 00:08:09,696
在所有的这些案例中


266
00:08:09,696 --> 00:08:11,206
我需要进行一些形式的测试


267
00:08:11,686 --> 00:08:13,556
无论是手动地 还是自动地


268
00:08:16,246 --> 00:08:17,556
我想要与你分享


269
00:08:17,556 --> 00:08:18,886
两类典型的性能测试


270
00:08:18,886 --> 00:08:20,196
我通常用它们


271
00:08:20,196 --> 00:08:22,186
来测量 Xcode 的性能


272
00:08:23,436 --> 00:08:25,436
我们或者进行单元测试


273
00:08:25,436 --> 00:08:26,376
或者进行综合测试


274
00:08:26,956 --> 00:08:28,176
我们来对比一下这两种测试


275
00:08:29,376 --> 00:08:31,306
在性能的单元测试中


276
00:08:31,306 --> 00:08:33,616
你的目标就是对你的 App 的


277
00:08:33,616 --> 00:08:35,096
某些特征进行隔离


278
00:08:35,096 --> 00:08:36,356
并单独地对其进行测量


279
00:08:36,966 --> 00:08:37,726
你也许会抹去它的相关性


280
00:08:37,756 --> 00:08:39,236
然后在一个


281
00:08:39,236 --> 00:08:41,126
隔离的环境中


282
00:08:41,126 --> 00:08:42,736
启动它


283
00:08:43,496 --> 00:08:45,666
如果我要为 Xcode 的代码完成 


284
00:08:45,666 --> 00:08:47,266
性能的单元测试


285
00:08:47,266 --> 00:08:48,676
那我也许会编写


286
00:08:48,676 --> 00:08:50,406
一系列的三个小测试


287
00:08:51,076 --> 00:08:52,896
其中一个测试会测量


288
00:08:53,256 --> 00:08:54,616
与编译器的对话


289
00:08:54,616 --> 00:08:56,426
并得到原始的结果


290
00:08:56,426 --> 00:08:57,876
和原始的代码完成候选的结果


291
00:08:58,946 --> 00:09:01,056
另一个性能测试则会测量


292
00:09:01,056 --> 00:09:02,906
那些结果的相互关联


293
00:09:02,906 --> 00:09:04,386
对它们进行排列以及评分


294
00:09:04,386 --> 00:09:05,406
以便我们知道要将哪些结果


295
00:09:05,406 --> 00:09:05,806
显示给用户


296
00:09:06,926 --> 00:09:08,896
第三个测试会选取


297
00:09:08,926 --> 00:09:10,636
那些已经准备好的结果


298
00:09:10,636 --> 00:09:11,636
并测量将它们放入 UI 元素


299
00:09:11,636 --> 00:09:13,156
后最终展示出来的情况


300
00:09:13,156 --> 00:09:15,016
为了涉及到全部三个方面


301
00:09:15,016 --> 00:09:17,986
我会很好地覆盖 IDE 中


302
00:09:17,986 --> 00:09:20,546
代码完成的主要的组件


303
00:09:23,136 --> 00:09:24,796
这些性能单元测试


304
00:09:24,886 --> 00:09:26,976
有一些很好的方面


305
00:09:27,596 --> 00:09:28,326
我们将高度聚焦这些方面


306
00:09:28,326 --> 00:09:30,026
这意味着如果它们


307
00:09:30,026 --> 00:09:31,276
在将来出现衰退


308
00:09:31,276 --> 00:09:32,706
我会很清楚地知道


309
00:09:32,706 --> 00:09:33,986
这些衰退出现在哪里


310
00:09:34,026 --> 00:09:35,066
因为这些正在运行的代码


311
00:09:35,066 --> 00:09:36,086
已经处于检查之中了


312
00:09:36,706 --> 00:09:38,976
而它们也将在不断地运行过程中 


313
00:09:39,286 --> 00:09:40,626
产生出更多的


314
00:09:40,626 --> 00:09:41,336
可重复的结果


315
00:09:41,466 --> 00:09:42,436
而它们产生的时间 


316
00:09:42,436 --> 00:09:45,036
也不会有太大的波动


317
00:09:45,426 --> 00:09:46,676
因为这些代码


318
00:09:46,676 --> 00:09:47,156
是高度聚焦的


319
00:09:48,176 --> 00:09:49,186
现在 我们来将单元测试与


320
00:09:49,186 --> 00:09:50,056
综合测试进行对比


321
00:09:51,076 --> 00:09:52,936
在综合测试中


322
00:09:52,936 --> 00:09:54,796
你要做的是


323
00:09:54,796 --> 00:09:56,616
在用户使用 App 时


324
00:09:56,616 --> 00:09:59,016
对其性能进行全面地测量


325
00:09:59,866 --> 00:10:01,506
所以 如果我为 Xcode 编写


326
00:10:01,506 --> 00:10:03,106
代码完成单元测试


327
00:10:03,756 --> 00:10:05,996
哦不对 是综合测试


328
00:10:05,996 --> 00:10:08,466
我会启动全部的 Xcode App


329
00:10:08,466 --> 00:10:09,566
我会打开一个源文件


330
00:10:09,566 --> 00:10:11,136
我会定位到该源文件


331
00:10:11,136 --> 00:10:13,366
然后进行书写


332
00:10:13,366 --> 00:10:15,306
再反复地进行代码完成


333
00:10:16,076 --> 00:10:17,636
当我执行这些步骤的时候 


334
00:10:17,636 --> 00:10:18,686
看看 Xcode 在做什么


335
00:10:18,686 --> 00:10:20,316
看看它花了多少时间


336
00:10:20,316 --> 00:10:22,956
我会发现这个测试 一点也不聚焦


337
00:10:24,006 --> 00:10:25,476
Xcode 会在我书写的时候


338
00:10:25,476 --> 00:10:26,986
进行绘制和布局


339
00:10:26,986 --> 00:10:29,906
当我归类时 它还会同时进行语法着色


340
00:10:30,556 --> 00:10:31,536
在后台 Xcode 也许正在进行索引


341
00:10:31,536 --> 00:10:33,636
读取获取状态 并决定把新的文件 


342
00:10:34,086 --> 00:10:35,976
显示在 Assistant Editor 中


343
00:10:36,056 --> 00:10:36,866
而所有的这些


344
00:10:37,166 --> 00:10:40,056
都将与代码完成一起


345
00:10:40,116 --> 00:10:42,246
来竞争 CPU 的资源


346
00:10:43,086 --> 00:10:44,046
也许当我查看 Profiler 时


347
00:10:44,046 --> 00:10:45,786
我会看到我们花费了


348
00:10:45,786 --> 00:10:47,636
80% 的时间在做语法着色


349
00:10:47,916 --> 00:10:50,626
而剩下的 20% 则用在了代码完成上


350
00:10:51,086 --> 00:10:52,636
从这个数据我可以知道


351
00:10:52,636 --> 00:10:54,776
要提高代码完成性能


352
00:10:54,816 --> 00:10:55,976
最好的方法就是


353
00:10:56,256 --> 00:10:58,076
推迟语法着色


354
00:10:58,686 --> 00:11:00,256
这样的知识


355
00:11:00,256 --> 00:11:01,946
是我在高度聚焦的单元测试中


356
00:11:01,946 --> 00:11:02,546
所无法获得的


357
00:11:02,546 --> 00:11:04,366
所以如果今天各位听完这个演讲


358
00:11:04,366 --> 00:11:05,606
只能带走两样东西的话


359
00:11:05,606 --> 00:11:07,476
第二样就是


360
00:11:07,746 --> 00:11:08,866
要调查你的性能


361
00:11:08,866 --> 00:11:10,936
必然应该从这些


362
00:11:10,936 --> 00:11:12,506
广泛的综合测试开始


363
00:11:12,506 --> 00:11:14,226
它们会测量你的用户


364
00:11:14,226 --> 00:11:16,406
使用 App 时的用户体验


365
00:11:18,026 --> 00:11:19,296
对 我说的就是测试


366
00:11:19,626 --> 00:11:21,026
测量以及分析


367
00:11:21,456 --> 00:11:22,346
现在我想向你们


368
00:11:22,346 --> 00:11:24,166
介绍一下用工具


369
00:11:24,216 --> 00:11:25,546
在 Xcode 中进行分析


370
00:11:25,786 --> 00:11:26,646
让我们来看一下


371
00:11:26,646 --> 00:11:27,166
demo machine


372
00:11:35,056 --> 00:11:35,926
今天我们要看的是一个


373
00:11:35,926 --> 00:11:37,146
我们在 Xcode 9 和


374
00:11:37,146 --> 00:11:39,516
Xcode 10 之间修复了的性能问题


375
00:11:39,516 --> 00:11:41,216
我想展示给你们


376
00:11:41,696 --> 00:11:44,436
下面我先启动 Xcode 9


377
00:11:44,436 --> 00:11:45,856
打开我们的 Solar System App 


378
00:11:47,056 --> 00:11:47,766
那么 我们所


379
00:11:47,766 --> 00:11:49,796
面临的问题就是创建标记


380
00:11:50,456 --> 00:11:51,486
接着我要快速地


381
00:11:51,486 --> 00:11:52,956
按几下快捷键 “Command-T”


382
00:11:52,956 --> 00:11:54,996
如你所见


383
00:11:54,996 --> 00:11:56,896
整个屏幕闪现了黑色


384
00:11:56,896 --> 00:11:58,166
并且创建这些标记


385
00:11:58,166 --> 00:11:58,996
花了好几秒的时间


386
00:11:59,626 --> 00:12:01,116
这肯定达不到


387
00:12:01,116 --> 00:12:02,216
我对性能的预期


388
00:12:02,216 --> 00:12:04,596
我们需要来对它进行修复


389
00:12:04,956 --> 00:12:06,376
那么我们来看看


390
00:12:06,376 --> 00:12:06,826
如何进行修复


391
00:12:08,266 --> 00:12:09,566
首先 我将启动 Instruments


392
00:12:09,606 --> 00:12:10,716
这是我们的分析工具


393
00:12:11,436 --> 00:12:12,686
你可以从 Xcode 菜单中打开它


394
00:12:12,686 --> 00:12:14,586
在 Instruments 中的


395
00:12:14,886 --> 00:12:15,506
Open Developer Tool 里面


396
00:12:15,976 --> 00:12:17,766
现在 我在 Xcode 9 里面


397
00:12:18,106 --> 00:12:19,146
所以如果我选择这个选项


398
00:12:19,146 --> 00:12:20,036
那我启动的是


399
00:12:20,036 --> 00:12:21,476
Xcode 9 中的 Instruments


400
00:12:21,476 --> 00:12:22,606
当然我想要从 Xcode 10 中启动 Instruments


401
00:12:22,706 --> 00:12:23,766
我已经把我的文件放在这里了


402
00:12:24,066 --> 00:12:26,066
我将隐藏 Xcode


403
00:12:26,066 --> 00:12:28,956
打开 Instruments


404
00:12:29,146 --> 00:12:30,366
当 Instruments 启动时


405
00:12:31,796 --> 00:12:33,026
就会出现一系列的分析工具


406
00:12:33,026 --> 00:12:34,226
我们可以用它们


407
00:12:34,226 --> 00:12:35,546
测量我们的 App


408
00:12:36,356 --> 00:12:37,426
这里是各种各样的工具


409
00:12:37,786 --> 00:12:38,736
它们能够测量


410
00:12:38,736 --> 00:12:41,186
图形的利用率 内存消耗


411
00:12:41,836 --> 00:12:44,006
IO 以及整体的时间


412
00:12:45,726 --> 00:12:47,096
你们也许会对从哪个工具


413
00:12:47,096 --> 00:12:48,406
先开始学习


414
00:12:48,406 --> 00:12:49,676
而感到不安


415
00:12:51,236 --> 00:12:53,936
那么我对你们的建议是


416
00:12:53,936 --> 00:12:55,596
如果只学习其中的一个工具


417
00:12:55,596 --> 00:12:56,976
那么你们应该学习


418
00:12:56,976 --> 00:12:57,516
Time Profiler


419
00:12:58,296 --> 00:13:00,426
在我的性能工作中


420
00:13:00,426 --> 00:13:01,166
有 95% 甚至更多的情况下都在使用它


421
00:13:01,736 --> 00:13:03,246
当你的用户抱怨


422
00:13:03,246 --> 00:13:04,546
你的 App 运行很慢时


423
00:13:04,546 --> 00:13:05,726
他们是在抱怨


424
00:13:05,726 --> 00:13:07,796
它花费了太多的时间


425
00:13:08,746 --> 00:13:10,116
假如你的 App 太慢了


426
00:13:10,116 --> 00:13:10,926
是因为你运行了太多的 IO


427
00:13:10,926 --> 00:13:12,636
从而花费了太多的时间


428
00:13:12,636 --> 00:13:13,706
那么你就能在 Time Profiler


429
00:13:13,706 --> 00:13:15,036
上看到这一点


430
00:13:15,036 --> 00:13:17,146
所以如果你只学习一个工具


431
00:13:17,146 --> 00:13:19,126
那就学 Time Profiler


432
00:13:20,276 --> 00:13:22,636
我们来看看它是如何工作的


433
00:13:25,346 --> 00:13:26,646
我要启动 Time Profiler 


434
00:13:26,646 --> 00:13:28,496
只需要双击这里


435
00:13:28,496 --> 00:13:31,246
然后将 Instruments


436
00:13:31,336 --> 00:13:32,226
全屏显示


437
00:13:33,646 --> 00:13:35,396
下面 我想要记录 Xcode


438
00:13:36,416 --> 00:13:38,086
在 Instruments 视窗的左上角


439
00:13:38,256 --> 00:13:39,836
你可以控制


440
00:13:39,836 --> 00:13:42,466
你想要附加和记录的进程


441
00:13:43,096 --> 00:13:45,236
在默认情况下 只要按下这个记录按钮


442
00:13:45,236 --> 00:13:46,726
我的 Mac 上的所有进程


443
00:13:46,726 --> 00:13:47,636
都会被记录


444
00:13:48,286 --> 00:13:50,926
而我只想锁定到 Xcode


445
00:13:54,856 --> 00:13:56,866
我会将这个弹出框


446
00:13:56,956 --> 00:13:59,046
切换到 Xcode 然后点击记录


447
00:13:59,536 --> 00:14:00,786
现在 当我记录的时候


448
00:14:00,786 --> 00:14:02,256
我就要关注视窗中的这个区域


449
00:14:02,256 --> 00:14:03,396
来追踪轨迹视图


450
00:14:03,786 --> 00:14:05,216
我要调整 Xcode 视窗的大小


451
00:14:05,216 --> 00:14:06,866
将它调小一点


452
00:14:06,866 --> 00:14:08,026
我就能看到那个区域


453
00:14:08,256 --> 00:14:09,896
然后我就要进行让它变慢的操作


454
00:14:09,896 --> 00:14:11,316
我要多创建几个标记


455
00:14:12,726 --> 00:14:15,826
你可以看到这里的图表 发生了变化


456
00:14:15,826 --> 00:14:17,016
现在 我要退出 App


457
00:14:17,086 --> 00:14:19,636
然后回到 Instruments


458
00:14:21,316 --> 00:14:23,056
所以刚刚发生了什么


459
00:14:23,936 --> 00:14:25,266
当分析器在运行时


460
00:14:26,126 --> 00:14:27,476
它被附加在我们的进程之中


461
00:14:27,476 --> 00:14:28,076
像一个调试器


462
00:14:28,076 --> 00:14:30,586
这个分析器每秒钟


463
00:14:30,586 --> 00:14:32,816
都数千次地停止


464
00:14:32,816 --> 00:14:34,936
我们的进程 并且它采集了跟踪轨迹


465
00:14:35,236 --> 00:14:37,026
那么 提醒一下


466
00:14:37,026 --> 00:14:38,546
跟踪轨迹描述了


467
00:14:38,546 --> 00:14:39,706
你的程序如何到达


468
00:14:39,706 --> 00:14:40,386
它目前所处的位置


469
00:14:40,876 --> 00:14:42,006
所以如果你现在


470
00:14:42,006 --> 00:14:43,716
处于 C 函数的第 6 行


471
00:14:43,716 --> 00:14:45,286
你到达那里的原因是因为 Main 函数调用了 A B C


472
00:14:45,326 --> 00:14:48,256
那么你的跟踪轨迹就是 Main A B C


473
00:14:49,006 --> 00:14:50,346
当 Instruments 捕捉到


474
00:14:50,346 --> 00:14:51,946
这些跟踪轨迹中的其中一个时


475
00:14:52,226 --> 00:14:53,356
它会说 嘿 我们刚刚在 C 函数中 


476
00:14:53,356 --> 00:14:54,686
花了一毫秒


477
00:14:54,686 --> 00:14:56,916
它说一毫秒


478
00:14:56,916 --> 00:14:58,056
是因为我们的


479
00:14:58,056 --> 00:14:59,016
记录采样间隔为


480
00:14:59,016 --> 00:14:59,546
一毫秒每次


481
00:15:01,016 --> 00:15:02,696
那么 在主线程上


482
00:15:02,696 --> 00:15:03,626
所有的这些跟踪轨迹都要


483
00:15:03,626 --> 00:15:04,556
从 Main 函数开始


484
00:15:04,556 --> 00:15:05,596
它们也许将要调用


485
00:15:05,596 --> 00:15:06,666
Application Main


486
00:15:06,796 --> 00:15:08,356
之后它们将会通过你的源代码


487
00:15:08,356 --> 00:15:09,536
不断地进行扩展


488
00:15:10,206 --> 00:15:11,896
我们可以将这些跟踪轨迹


489
00:15:11,956 --> 00:15:13,266
折叠在一起


490
00:15:13,266 --> 00:15:15,316
将它们覆盖放进一个前缀树


491
00:15:15,316 --> 00:15:16,983
以便它们从 Main 开始 进行下去


492
00:15:17,156 --> 00:15:18,646
我们可以将我们


493
00:15:18,646 --> 00:15:19,836
捕捉到的这些毫秒计数器


494
00:15:19,836 --> 00:15:21,386
放在顶端 这样我们就能够


495
00:15:21,386 --> 00:15:23,416
看到在我们源代码的


496
00:15:23,486 --> 00:15:24,716
所有不同层级的区域上


497
00:15:24,716 --> 00:15:26,126
我们都花费了多少时间


498
00:15:26,686 --> 00:15:27,636
我们要看看这个数据


499
00:15:27,636 --> 00:15:29,416
试着找出多余的


500
00:15:29,416 --> 00:15:31,066
和不必要的操作


501
00:15:31,066 --> 00:15:32,696
这样我们就可以提高速度


502
00:15:32,696 --> 00:15:33,836
这是我们提高


503
00:15:33,836 --> 00:15:34,916
App 性能的


504
00:15:34,916 --> 00:15:36,076
首要方法


505
00:15:37,026 --> 00:15:39,316
现在 正如你能想象到那样


506
00:15:39,316 --> 00:15:40,606
我们每秒能捕捉


507
00:15:40,606 --> 00:15:41,456
上千的跟踪轨迹


508
00:15:41,456 --> 00:15:43,326
在 Instruments 里


509
00:15:43,326 --> 00:15:45,246
有大量的数据需要你去处理


510
00:15:46,146 --> 00:15:48,356
我首先要给你的建议就是


511
00:15:48,356 --> 00:15:49,946
你想要尽可能多地


512
00:15:49,946 --> 00:15:51,596
过滤这里的数据 


513
00:15:51,596 --> 00:15:53,166
你需要看整个过程的性能 


514
00:15:53,166 --> 00:15:55,616
不要把精力集中在细节点上


515
00:15:55,616 --> 00:15:56,376
好吧


516
00:15:56,376 --> 00:15:57,786
我想要给你演示


517
00:15:57,786 --> 00:16:00,086
如何应用一堆强大的过滤器和工具


518
00:16:04,276 --> 00:16:06,196
因为我之前做了记录


519
00:16:06,196 --> 00:16:07,806
还记得吧 我让轨迹视图显示了出来


520
00:16:09,356 --> 00:16:10,476
我这么做是因为我想要


521
00:16:10,476 --> 00:16:12,296
看看当我创建标记的时候 


522
00:16:12,296 --> 00:16:13,766
CPU 的利用率是如何变化的


523
00:16:13,766 --> 00:16:15,836
以及在哪里发生了变化


524
00:16:15,836 --> 00:16:18,156
然后我告诉自己


525
00:16:18,156 --> 00:16:19,416
就在这儿


526
00:16:20,186 --> 00:16:21,786
我只是拖动鼠标并选中了


527
00:16:21,856 --> 00:16:26,076
轨迹所在的区域


528
00:16:26,076 --> 00:16:27,786
我让 Instruments


529
00:16:27,786 --> 00:16:31,666
将它的跟踪轨迹数据只专注于


530
00:16:31,666 --> 00:16:32,706
那里的时间间隔上


531
00:16:33,126 --> 00:16:34,356
所有在这里的东西


532
00:16:34,356 --> 00:16:35,556
都是我创建标记之前的


533
00:16:36,026 --> 00:16:37,516
而所有这里的东西


534
00:16:37,626 --> 00:16:38,666
都是我创建了标记 


535
00:16:38,666 --> 00:16:39,786
退出 App 之后的


536
00:16:40,056 --> 00:16:40,976
那不是我现在要优化的地方


537
00:16:40,976 --> 00:16:42,576
所以我不需要


538
00:16:42,676 --> 00:16:45,016
看那里的数据


539
00:16:45,196 --> 00:16:48,376
现在 在 Instruments 视窗的底部区域


540
00:16:48,376 --> 00:16:49,836
Instruments 会显示出所有它


541
00:16:49,836 --> 00:16:51,366
所采集到的轨迹


542
00:16:51,786 --> 00:16:55,376
默认情况下


543
00:16:55,446 --> 00:16:56,206
每个线程上只有一行在运作


544
00:16:56,646 --> 00:16:57,756
在这个例子里


545
00:16:57,756 --> 00:16:59,126
看起来只有四个线程在运作


546
00:16:59,386 --> 00:17:00,556
而有时候则会更多


547
00:17:00,626 --> 00:17:01,716
这取决于你的 App


548
00:17:01,716 --> 00:17:02,436
是如何并行的


549
00:17:03,306 --> 00:17:04,796
我通常喜欢以聚焦的名义


550
00:17:06,276 --> 00:17:07,756
我也喜欢折叠它们


551
00:17:07,756 --> 00:17:10,356
让他们建立在每个线程中的


552
00:17:10,356 --> 00:17:11,976
函数执行的最顶层上


553
00:17:11,976 --> 00:17:13,346
而不是线程 ID 上


554
00:17:13,346 --> 00:17:14,636
因为前者与我使用 


555
00:17:14,636 --> 00:17:16,165
Grand Central Dispatch 的方式


556
00:17:16,165 --> 00:17:17,406
更为契合


557
00:17:18,616 --> 00:17:19,715
接下来我们看看


558
00:17:19,715 --> 00:17:21,076
Instruments 视窗的底部


559
00:17:21,076 --> 00:17:22,236
我要点击这个叫 Call Tree 的按钮


560
00:17:22,266 --> 00:17:24,576
然后放大它


561
00:17:24,576 --> 00:17:25,536
这样你就能看到


562
00:17:25,536 --> 00:17:26,076
我要做什么了


563
00:17:26,806 --> 00:17:28,556
这里有几个可用的过滤器


564
00:17:28,906 --> 00:17:30,516
其中一个被线程分开了


565
00:17:30,516 --> 00:17:31,756
默认情况下它就已经开启了


566
00:17:31,886 --> 00:17:33,176
接下来我要禁用它


567
00:17:33,176 --> 00:17:36,326
相反地 所有的线程都将按照


568
00:17:36,326 --> 00:17:37,586
它们的最顶层入口点来分组


569
00:17:37,586 --> 00:17:39,666
而不是它们的线程 ID


570
00:17:42,356 --> 00:17:45,646
现在 来看这个轨迹


571
00:17:45,646 --> 00:17:46,946
可以看到所有这些


572
00:17:46,946 --> 00:17:49,336
正在运作的线程 顺便提一下


573
00:17:49,336 --> 00:17:50,816
在主要轨迹的下面


574
00:17:50,816 --> 00:17:53,126
是总的 CPU 使用率


575
00:17:53,126 --> 00:17:54,416
CPU 使用率被分解到每一个线程上


576
00:17:54,416 --> 00:17:56,086
我们可以看到在这个轨迹中


577
00:17:56,086 --> 00:17:57,046
几乎其他所有的线程


578
00:17:57,176 --> 00:17:58,826
大部分都是闲置的


579
00:17:59,416 --> 00:18:00,836
我可以只聚焦主线程


580
00:18:00,836 --> 00:18:03,036
从这里选择它


581
00:18:03,036 --> 00:18:04,626
现在我们就可以只看 


582
00:18:04,776 --> 00:18:06,476
在这个时间段内


583
00:18:06,526 --> 00:18:07,046
主线程的轨迹


584
00:18:08,086 --> 00:18:09,606
我准备开始深入到


585
00:18:09,606 --> 00:18:11,336
这个调用层级当中


586
00:18:11,336 --> 00:18:12,376
这样就能看到我的 App


587
00:18:12,416 --> 00:18:12,676
在做什么


588
00:18:13,606 --> 00:18:15,106
通常我会键入这一过程


589
00:18:15,106 --> 00:18:17,116
只要按下向右箭头和向下箭头


590
00:18:17,116 --> 00:18:18,666
然后不断地进行重复就可以了


591
00:18:19,366 --> 00:18:21,026
但是我想要给你们演示


592
00:18:21,026 --> 00:18:22,526
Instruments 提供的 


593
00:18:22,526 --> 00:18:24,136
最密集的跟踪轨迹检测


594
00:18:24,496 --> 00:18:25,416
如果你的检测是不可见的


595
00:18:25,416 --> 00:18:26,886
你可以用这个按钮


596
00:18:26,886 --> 00:18:28,756
进行切换


597
00:18:28,756 --> 00:18:29,746
最密集的追踪轨迹就都会在这


598
00:18:29,836 --> 00:18:31,706
在这个标记里


599
00:18:31,706 --> 00:18:32,046
“Extended Detail”


600
00:18:32,866 --> 00:18:34,296
那么 最密集的追踪轨迹


601
00:18:34,296 --> 00:18:35,496
正是出现得最频繁的


602
00:18:35,496 --> 00:18:36,566
那个轨迹


603
00:18:36,566 --> 00:18:37,486
当我们在当前选择下


604
00:18:37,486 --> 00:18:39,196
进行记录的时候


605
00:18:39,196 --> 00:18:41,476
追踪轨迹出现得最为频繁


606
00:18:42,116 --> 00:18:43,516
你可以利用这个


607
00:18:43,516 --> 00:18:45,556
在一段时间内 快速浏览许多帧


608
00:18:46,496 --> 00:18:47,846
我通常会浏览这里


609
00:18:48,096 --> 00:18:49,366
寻找我自己的 API 


610
00:18:49,656 --> 00:18:50,816
还有值得我花这么多时间


611
00:18:50,816 --> 00:18:51,856
来寻找的东西


612
00:18:51,856 --> 00:18:54,336
或者是寻找


613
00:18:54,336 --> 00:18:56,036
我们在样本数中


614
00:18:56,036 --> 00:18:57,306
有重要分支点的地方


615
00:18:58,356 --> 00:18:59,996
现在我们看这里


616
00:18:59,996 --> 00:19:02,036
我看到这个给 IDE 的调用


617
00:19:02,036 --> 00:19:04,636
Navigator Replacement View


618
00:19:04,636 --> 00:19:05,576
Did Install View Controller


619
00:19:05,936 --> 00:19:07,106
我十分熟悉这个 API 


620
00:19:07,106 --> 00:19:09,176
因为这是一个 Xcode 内部的 API


621
00:19:10,156 --> 00:19:12,686
在这个轨迹中 我可以查看这里


622
00:19:12,686 --> 00:19:13,636
在视窗的左手边


623
00:19:13,636 --> 00:19:14,686
这里负责的是


624
00:19:14,686 --> 00:19:18,656
我们记录的总时间中的


625
00:19:18,656 --> 00:19:21,596
或者 45% 的时间中的 1.19 秒


626
00:19:22,176 --> 00:19:24,196
这种方法要花费的时间


627
00:19:24,196 --> 00:19:27,756
远远超出了我的预期


628
00:19:27,936 --> 00:19:29,526
但是 我们很难聚焦在这里


629
00:19:29,526 --> 00:19:30,386
看看究竟发生了什么


630
00:19:30,586 --> 00:19:32,336
对吗 这是这个轨迹下面的


631
00:19:32,336 --> 00:19:33,346
其他所有的东西


632
00:19:33,346 --> 00:19:35,926
那么 它看起来就好像


633
00:19:35,926 --> 00:19:37,736
30 到 40 的堆线范围深度


634
00:19:38,056 --> 00:19:39,096
这是很吓人的


635
00:19:39,456 --> 00:19:40,726
我要给你演示如何聚焦这里


636
00:19:41,276 --> 00:19:43,006
第一种方法就在这里


637
00:19:43,006 --> 00:19:46,976
我们又要使用 “Call Tree” 弹出框


638
00:19:47,176 --> 00:19:49,126
我要在这个弹出框里


639
00:19:49,126 --> 00:19:50,516
选择 “flattened recursion”


640
00:19:51,756 --> 00:19:55,126
让我们来继续完成这步


641
00:19:55,196 --> 00:19:56,326
现在你就可以看到


642
00:19:56,326 --> 00:19:57,526
就在这里


643
00:19:57,526 --> 00:20:00,466
一组重复的方法调用


644
00:20:00,466 --> 00:20:01,086
被折叠了


645
00:20:02,396 --> 00:20:04,536
不好意思 让我滑下来


646
00:20:05,586 --> 00:20:06,466
它被折叠了


647
00:20:06,816 --> 00:20:08,436
事实上 我就是想要


648
00:20:08,436 --> 00:20:09,586
继续我的性能测试


649
00:20:09,586 --> 00:20:11,556
在这个 IDE Navigator 范围里


650
00:20:11,556 --> 00:20:14,506
在这个 API 调用中


651
00:20:14,506 --> 00:20:16,336
我可以根据上下文


652
00:20:17,216 --> 00:20:19,376
重新聚焦整个 Call Tree 点击这里


653
00:20:19,376 --> 00:20:20,746
然后选择 “Focus on Subtree”


654
00:20:21,516 --> 00:20:22,446
之后 Instruments 就会


655
00:20:22,446 --> 00:20:23,896
将这个符号放到


656
00:20:23,896 --> 00:20:25,386
整个调用图的最顶层


657
00:20:25,386 --> 00:20:26,556
其他的所有东西都会被删除


658
00:20:26,556 --> 00:20:28,456
它会重新将百分比设置为 100%


659
00:20:28,726 --> 00:20:30,166
因此我可以就聚焦在这里


660
00:20:30,796 --> 00:20:33,096
现在 我可以用键盘上的箭头键


661
00:20:33,096 --> 00:20:35,686
来继续运行这个样本


662
00:20:35,686 --> 00:20:36,486
看看我们在做什么


663
00:20:36,686 --> 00:20:38,906
我很熟悉这些 API


664
00:20:38,906 --> 00:20:40,046
看起来我们好像正在进行


665
00:20:40,206 --> 00:20:41,196
状态恢复


666
00:20:41,766 --> 00:20:43,136
当我继续扩大这个


667
00:20:43,136 --> 00:20:45,936
我可以看到我们几乎


668
00:20:45,936 --> 00:20:47,176
深入了这个表格视图


669
00:20:47,466 --> 00:20:49,696
除了有这种


670
00:20:49,696 --> 00:20:51,476
热调用路径以外


671
00:20:51,476 --> 00:20:52,986
你知道 这种调用路径占了


672
00:20:52,986 --> 00:20:54,116
大部分的总百分比


673
00:20:54,436 --> 00:20:56,566
同时还有其他的这些附带样本


674
00:20:58,266 --> 00:20:59,896
它们很容易分散


675
00:20:59,896 --> 00:21:00,236
我们的注意力


676
00:21:01,286 --> 00:21:03,766
它们的其中之一就是


677
00:21:03,766 --> 00:21:04,076
OPC Message Send


678
00:21:04,646 --> 00:21:06,926
它可以遍布你的追踪器


679
00:21:06,926 --> 00:21:08,296
只要你在写 Objective C


680
00:21:08,606 --> 00:21:09,916
即使你在写 Swift 代码


681
00:21:09,916 --> 00:21:10,936
当你按照你的方式


682
00:21:10,936 --> 00:21:11,966
进入系统库时


683
00:21:11,966 --> 00:21:12,296
你也会看到这个


684
00:21:12,636 --> 00:21:13,856
你会经常看到它的对应函数


685
00:21:13,856 --> 00:21:15,916
OPC LoadStrong LoadWeak


686
00:21:15,916 --> 00:21:18,726
Retain 等等 你可以


687
00:21:18,726 --> 00:21:20,936
将所有的内容从调用关系树里删除


688
00:21:20,936 --> 00:21:23,826
根据上下文点开这里


689
00:21:23,866 --> 00:21:28,706
选择 “Charge OPC to Callers”


690
00:21:29,406 --> 00:21:30,436
它就会告诉 Instruments


691
00:21:30,466 --> 00:21:31,886
来选取所有


692
00:21:31,886 --> 00:21:33,686
来自于 OPC 库的样本


693
00:21:33,686 --> 00:21:35,176
然后将它们从调用数据中删除


694
00:21:35,176 --> 00:21:36,456
但是要将时间的属性归于


695
00:21:36,456 --> 00:21:37,846
调用它们的父框架


696
00:21:38,176 --> 00:21:39,776
我倾向于将那些


697
00:21:39,776 --> 00:21:41,126
Objective C 运行时的函数


698
00:21:41,126 --> 00:21:42,266
视为在书写 Objective C 代码时


699
00:21:42,266 --> 00:21:43,306
的代价成本


700
00:21:43,706 --> 00:21:46,136
我很少会去试图优化它们


701
00:21:46,136 --> 00:21:48,396
所以我只会


702
00:21:48,456 --> 00:21:49,596
将它们从数据中删除


703
00:21:49,596 --> 00:21:50,886
这样我就可以聚焦在


704
00:21:50,886 --> 00:21:51,916
我可能要处理的地方


705
00:21:53,176 --> 00:21:55,466
还有一个你们可以应用的


706
00:21:55,466 --> 00:21:56,866
强大的过滤器


707
00:21:56,866 --> 00:21:59,076
我要用它来删除所有


708
00:21:59,076 --> 00:22:00,356
出现在这一组帧中的小样本


709
00:22:00,356 --> 00:22:02,186
它就在这里


710
00:22:02,226 --> 00:22:05,596
Call Tree 约束条件的部分


711
00:22:06,126 --> 00:22:07,646
让我来给你演示


712
00:22:11,146 --> 00:22:12,716
我将要告诉 Instruments


713
00:22:12,716 --> 00:22:14,006
我想要看到的轨迹范围


714
00:22:14,486 --> 00:22:16,236
只包括我们所说的


715
00:22:16,236 --> 00:22:18,966
20 或者更多的样本


716
00:22:19,256 --> 00:22:20,566
我选择 20 是因为


717
00:22:20,566 --> 00:22:21,606
我知道我已经选择了


718
00:22:21,606 --> 00:22:23,066
一个两秒的间隔


719
00:22:23,066 --> 00:22:24,376
那么 20 毫秒


720
00:22:24,376 --> 00:22:26,076
将会呈现出整个工作的大约 1%


721
00:22:26,076 --> 00:22:27,036
而就包含了


722
00:22:27,036 --> 00:22:29,846
在默认情况下 我想进行工作的粒度


723
00:22:31,336 --> 00:22:32,926
因此将 Call Tree 约束条件


724
00:22:33,986 --> 00:22:37,206
设置为一个最小值 20


725
00:22:37,206 --> 00:22:39,516
我就能更有效地聚焦在这里


726
00:22:40,456 --> 00:22:41,346
那么 我在这里提到过


727
00:22:41,346 --> 00:22:43,296
我们在扩展我的视图项目


728
00:22:43,336 --> 00:22:45,026
我看到在这里


729
00:22:45,026 --> 00:22:46,446
我们其实在调用 NS 大纲视图


730
00:22:46,446 --> 00:22:47,836
扩展项目 扩展子项


731
00:22:48,436 --> 00:22:51,816
在这里 很多人都会将调用图


732
00:22:51,876 --> 00:22:52,146
停在这里


733
00:22:52,556 --> 00:22:55,226
我们会看到 我正在调用一个系统框架


734
00:22:55,226 --> 00:22:56,346
我在那里花了很多时间


735
00:22:56,706 --> 00:22:58,086
这不是我的错 对吗


736
00:22:58,086 --> 00:22:58,926
那么我能做什么呢


737
00:22:58,926 --> 00:23:00,486
我不能优化 NS 大纲视图


738
00:23:00,486 --> 00:23:01,976
扩大项目


739
00:23:03,126 --> 00:23:04,606
但你肯定有能力


740
00:23:04,606 --> 00:23:05,806
改变这些情况


741
00:23:06,336 --> 00:23:07,706
例如 花费在系统框架上的


742
00:23:07,706 --> 00:23:08,936
所有这些时间


743
00:23:08,936 --> 00:23:10,976
都是因为


744
00:23:10,976 --> 00:23:12,526
它在运算你提供给它的数据


745
00:23:13,366 --> 00:23:14,546
这需要花费很多的时间


746
00:23:14,616 --> 00:23:15,496
因为你在成千上万次地


747
00:23:15,496 --> 00:23:17,476
调用这个方法


748
00:23:18,366 --> 00:23:19,526
它会花这么多时间


749
00:23:19,526 --> 00:23:20,666
还因为它还要通过授权


750
00:23:20,666 --> 00:23:22,376
回调你的代码


751
00:23:22,376 --> 00:23:24,566
而最重要的是


752
00:23:24,566 --> 00:23:25,906
你可以深入地了解


753
00:23:25,906 --> 00:23:27,836
系统框架在做什么


754
00:23:27,836 --> 00:23:28,886
只要沿着 Instruments 树


755
00:23:28,886 --> 00:23:30,186
不断地进行扩展


756
00:23:30,186 --> 00:23:31,816
并查看这些被调用的函数的名称


757
00:23:32,216 --> 00:23:33,766
其实 我就是这样学会


758
00:23:33,766 --> 00:23:36,966
修复这个漏洞的


759
00:23:37,166 --> 00:23:39,166
当我将这个轨迹


760
00:23:39,166 --> 00:23:41,406
扩展到大纲视图中


761
00:23:41,406 --> 00:23:42,966
我能看到 它正在调用这里的两种方法


762
00:23:44,716 --> 00:23:47,106
用项目入口来


763
00:23:47,106 --> 00:23:49,266
批量处理扩展项目和子项


764
00:23:49,266 --> 00:23:50,686
然后再进行最后更新后的工作


765
00:23:51,756 --> 00:23:53,356
现在 那些对我来说都是重要的线索


766
00:23:53,356 --> 00:23:54,366
说明我们或许


767
00:23:54,366 --> 00:23:56,226
有可能通过批量处理来提高效率


768
00:23:56,226 --> 00:23:58,326
正如你能想象的那样


769
00:23:58,326 --> 00:24:00,886
大纲视图从一小组项目开始


770
00:24:00,886 --> 00:24:02,386
然后我们试着


771
00:24:02,386 --> 00:24:03,906
在我们代码的这个区域内


772
00:24:03,906 --> 00:24:05,676
不断修复扩展状态


773
00:24:05,676 --> 00:24:06,666
我们会告诉它打开


774
00:24:06,666 --> 00:24:08,256
比如说顶部的项目


775
00:24:08,506 --> 00:24:09,436
而当我告诉它打开顶部的项目时


776
00:24:09,436 --> 00:24:11,406
你能够想象


777
00:24:11,406 --> 00:24:12,576
它同时将里面的其他项目


778
00:24:12,576 --> 00:24:13,296
都向下移了


779
00:24:14,056 --> 00:24:15,716
然后我继续扩展第二个项目


780
00:24:16,106 --> 00:24:17,516
它就会再次下移其他项目


781
00:24:17,906 --> 00:24:19,386
接着是第三个项目 以此类推


782
00:24:19,386 --> 00:24:20,666
而等到你做完这些


783
00:24:20,966 --> 00:24:22,546
你已经将这些底部的项目


784
00:24:22,586 --> 00:24:24,246
向下移动了数千次


785
00:24:25,166 --> 00:24:26,396
那这些都是多余的工作


786
00:24:26,396 --> 00:24:27,626
而它们正是


787
00:24:27,656 --> 00:24:28,976
我在提高性能时


788
00:24:29,206 --> 00:24:30,736
想要消除的东西


789
00:24:31,406 --> 00:24:32,596
现在 这些方法调用


790
00:24:32,596 --> 00:24:35,376
谈到的批量处理


791
00:24:35,376 --> 00:24:36,666
让我觉得或许


792
00:24:36,666 --> 00:24:38,006
在一些 API 中我可以


793
00:24:38,006 --> 00:24:39,416
让大纲视图批量地进行工作


794
00:24:39,416 --> 00:24:41,436
因此它就可以对所有的位置


795
00:24:41,436 --> 00:24:43,336
只进行一次计算


796
00:24:43,336 --> 00:24:44,386
而不是在我进行调用的时候


797
00:24:44,426 --> 00:24:44,986
反复地计算


798
00:24:46,236 --> 00:24:48,256
我还看到一个调用


799
00:24:48,256 --> 00:24:50,056
用来进行最后更新之后的工作


800
00:24:50,406 --> 00:24:52,616
那么 有时 API 会提供那种


801
00:24:52,726 --> 00:24:53,956
在一组列阵上进行运算的


802
00:24:53,956 --> 00:24:55,696
整体方法


803
00:24:55,696 --> 00:24:57,416
而有时它则会提供一种


804
00:24:57,416 --> 00:24:59,456
事务型 API 


805
00:24:59,456 --> 00:25:00,806
它会说我要开始进行更改


806
00:25:01,046 --> 00:25:01,716
然后就做了一系列的变化


807
00:25:01,716 --> 00:25:02,996
然后你说你完成了


808
00:25:02,996 --> 00:25:05,856
之后它会对你变化的全程 


809
00:25:05,856 --> 00:25:07,356
进行计算


810
00:25:07,356 --> 00:25:08,656
这比它自己独自完成这些


811
00:25:08,656 --> 00:25:10,116
要更有效率


812
00:25:11,126 --> 00:25:12,306
那么这时候 我会前往


813
00:25:12,306 --> 00:25:14,336
NS 大纲视图或者


814
00:25:14,336 --> 00:25:15,996
NS 表格视图 API


815
00:25:15,996 --> 00:25:17,296
我会找一些这样的方法


816
00:25:17,686 --> 00:25:19,646
那里确实有一个


817
00:25:19,646 --> 00:25:20,936
在 NS 表格视图里


818
00:25:20,936 --> 00:25:22,176
有一些开始和结束更新


819
00:25:22,176 --> 00:25:23,546
所使用的方法


820
00:25:23,546 --> 00:25:25,096
它们允许合并表格视图


821
00:25:25,096 --> 00:25:26,666
并能够大大提高这些工作的效率


822
00:25:27,426 --> 00:25:29,606
当然 我们要在 Xcode 10 中使用它


823
00:25:30,246 --> 00:25:32,966
让我来给你演示


824
00:25:33,046 --> 00:25:34,376
我要启动 Xcode 10


825
00:25:38,056 --> 00:25:39,136
我要把 Source


826
00:25:39,136 --> 00:25:43,086
作为一个 App 打开


827
00:25:43,086 --> 00:25:44,056
然后我来创建一些标记


828
00:25:44,586 --> 00:25:46,116
你可以看到


829
00:25:46,116 --> 00:25:47,666
这里屏幕没有出现闪黑


830
00:25:47,666 --> 00:25:48,626
标记也打开得更快了


831
00:25:49,506 --> 00:25:52,686
现在 我想让标记打开的速度


832
00:25:52,876 --> 00:25:54,846
比这个更快 对吗


833
00:25:54,846 --> 00:25:55,916
那么我接下来应该怎么做呢


834
00:25:56,596 --> 00:25:57,586
我很幸运


835
00:25:58,536 --> 00:25:59,496
因为你不是每天


836
00:25:59,496 --> 00:26:00,956
都需要进入轨迹中去寻找


837
00:26:00,956 --> 00:26:02,406
一些如此明显且容易修复的东西


838
00:26:02,406 --> 00:26:03,996
而这样的东西在样本里


839
00:26:03,996 --> 00:26:05,156
占到了 50%


840
00:26:05,916 --> 00:26:08,456
对吗 其实并没有


841
00:26:08,456 --> 00:26:09,896
什么巨大的严重问题


842
00:26:09,896 --> 00:26:10,806
等待我来解决


843
00:26:11,686 --> 00:26:12,746
相反 我要做的其实就是


844
00:26:12,746 --> 00:26:14,626
检查整个样本


845
00:26:14,626 --> 00:26:15,656
并在此过程中应用过滤器


846
00:26:15,656 --> 00:26:17,616
所以我只是寻找


847
00:26:17,616 --> 00:26:20,286
一些只占到 1% 或者更多时间的操作


848
00:26:20,286 --> 00:26:21,816
我要寻找每一个


849
00:26:21,816 --> 00:26:23,436
我认为能够运用一些方法


850
00:26:23,436 --> 00:26:24,836
来将其速度


851
00:26:24,836 --> 00:26:26,536
提高一点的东西


852
00:26:28,056 --> 00:26:29,016
我会将它们都记下来


853
00:26:29,016 --> 00:26:30,496
放在一张纸上或一个文档里


854
00:26:30,496 --> 00:26:32,216
或者其他什么东西上


855
00:26:32,216 --> 00:26:33,436
然后我就会着手解决它们


856
00:26:33,746 --> 00:26:34,736
现在 我需要选择一个


857
00:26:34,736 --> 00:26:35,656
解决它们的顺序 对吗


858
00:26:35,656 --> 00:26:37,326
因为有的时候


859
00:26:37,326 --> 00:26:38,716
用修复第二件事情时


860
00:26:38,716 --> 00:26:40,016
所用的方法来修复


861
00:26:40,016 --> 00:26:40,816
列表中的第五件事情


862
00:26:40,816 --> 00:26:42,516
这方法可能会是过时的


863
00:26:42,516 --> 00:26:43,646
如果没有排好顺序


864
00:26:43,646 --> 00:26:44,516
你就会做多余的工作


865
00:26:44,516 --> 00:26:45,536
这是十分糟糕的


866
00:26:45,586 --> 00:26:47,506
因为我们首先要删除的就是


867
00:26:47,506 --> 00:26:48,116
多余的工作


868
00:26:48,746 --> 00:26:50,476
但是这些工作都是如何进行的


869
00:26:50,476 --> 00:26:51,826
我们又很难去预测


870
00:26:52,066 --> 00:26:54,316
你通常无法事先知道这些


871
00:26:54,746 --> 00:26:57,746
所以不要因为这个


872
00:26:57,746 --> 00:26:59,446
停下你开始的脚步


873
00:26:59,446 --> 00:27:00,956
因为你想要把速度提高 30%


874
00:27:00,956 --> 00:27:03,536
就得进行 103% 的


875
00:27:03,536 --> 00:27:04,186
改善工作


876
00:27:05,706 --> 00:27:05,976
明白吗


877
00:27:07,316 --> 00:27:10,756
现在 回到我们的幻灯片


878
00:27:10,756 --> 00:27:13,516
我要给你演示


879
00:27:13,516 --> 00:27:14,766
一些我们常用的方法


880
00:27:14,766 --> 00:27:16,126
用来持续改善我们的性能


881
00:27:21,346 --> 00:27:22,326
毫无疑问


882
00:27:22,326 --> 00:27:23,896
我们最常见的就是


883
00:27:23,896 --> 00:27:25,246
使用那些与大纲视觉里


884
00:27:25,246 --> 00:27:26,236
相同的方法


885
00:27:26,396 --> 00:27:28,276
批量处理和推迟处理 对吗


886
00:27:28,276 --> 00:27:29,736
你有一个 API 


887
00:27:29,736 --> 00:27:31,526
而当这个 API 被调用时


888
00:27:31,526 --> 00:27:31,836
会出现一些副作用


889
00:27:32,196 --> 00:27:33,226
然后你用一些代码


890
00:27:33,226 --> 00:27:34,426
调用你在循环中的 API 


891
00:27:34,426 --> 00:27:35,396
这就是你在做的


892
00:27:35,586 --> 00:27:36,536
被请求的首要工作


893
00:27:36,536 --> 00:27:38,566
这其中有一个副作用


894
00:27:39,206 --> 00:27:40,986
好 如果没有人读取


895
00:27:40,986 --> 00:27:42,516
这个副作用的结果


896
00:27:42,516 --> 00:27:43,416
那你就是在反复地


897
00:27:43,416 --> 00:27:44,916
进行多余的工作


898
00:27:45,736 --> 00:27:47,016
你通常可以


899
00:27:47,016 --> 00:27:48,696
通过使用成批的接口


900
00:27:48,696 --> 00:27:50,366
得到一个更加有效的接口


901
00:27:50,366 --> 00:27:52,376
在这里客户端会给你一系列的


902
00:27:52,376 --> 00:27:53,476
或者某种集合 包括所有要完成的工作


903
00:27:53,476 --> 00:27:54,796
以便你能够一次性地


904
00:27:54,796 --> 00:27:56,056
计算那个副作用


905
00:27:57,156 --> 00:27:59,526
那么 有时你有很多个客户端 对吗


906
00:27:59,526 --> 00:28:00,766
你无法对它们进行


907
00:28:00,766 --> 00:28:02,186
批量处理 那也没关系


908
00:28:02,596 --> 00:28:03,606
你仍然可以通过推迟工作


909
00:28:03,606 --> 00:28:04,946
以及缓慢地进行工作


910
00:28:04,946 --> 00:28:06,796
来获得一样的性能风格


911
00:28:09,196 --> 00:28:10,996
第三种提高你的性能的


912
00:28:10,996 --> 00:28:11,966
简单的方法


913
00:28:11,966 --> 00:28:14,026
是检查整个 Instruments 的轨迹


914
00:28:14,026 --> 00:28:15,156
来寻找你看到它


915
00:28:15,156 --> 00:28:17,016
对同样的东西进行反复计算


916
00:28:17,016 --> 00:28:17,656
的地方


917
00:28:18,236 --> 00:28:19,556
比如说 有一个方法


918
00:28:19,676 --> 00:28:20,856
在它计算某个文档的大小的过程中


919
00:28:20,856 --> 00:28:22,526
你看到同样的事情


920
00:28:22,526 --> 00:28:24,156
在之后的几帧中也出现了


921
00:28:24,156 --> 00:28:25,946
对于相同的文档


922
00:28:25,946 --> 00:28:27,006
不断地重复


923
00:28:27,436 --> 00:28:28,426
好 在这样的情况下


924
00:28:28,496 --> 00:28:29,536
当然 你肯定想


925
00:28:29,536 --> 00:28:31,076
一次性计算出该值


926
00:28:32,076 --> 00:28:33,226
在最顶端计算它


927
00:28:33,226 --> 00:28:35,406
让它不断地传下去 或者缓存它


928
00:28:36,476 --> 00:28:37,846
另一个你可以在你的


929
00:28:37,846 --> 00:28:38,876
UI App 中使用的方法


930
00:28:38,876 --> 00:28:41,166
就是考虑


931
00:28:41,166 --> 00:28:42,296
你使用了多少视图


932
00:28:42,296 --> 00:28:43,146
来渲染你的 UI


933
00:28:43,146 --> 00:28:46,466
使用一些带有小的


934
00:28:46,466 --> 00:28:48,106
函数集的很小的视图


935
00:28:48,106 --> 00:28:50,216
然后再将它们一起


936
00:28:50,216 --> 00:28:51,306
生成大的函数


937
00:28:51,306 --> 00:28:52,286
以此来组织你的源代码


938
00:28:52,286 --> 00:28:53,066
这是很好的


939
00:28:53,516 --> 00:28:55,216
但是你使用的视图越多


940
00:28:55,216 --> 00:28:57,516
你就越难负担绘图


941
00:28:57,516 --> 00:28:58,276
进行系统的布局


942
00:28:59,306 --> 00:29:01,066
现在 这是一条双向道


943
00:29:01,336 --> 00:29:02,776
因为更小的视图通常会


944
00:29:02,776 --> 00:29:04,086
让你有更多精密的捕捉


945
00:29:04,086 --> 00:29:06,156
它们也可以提高你的性能


946
00:29:07,266 --> 00:29:08,896
但是一般来说 你可以微调


947
00:29:08,896 --> 00:29:10,446
你拥有的视图的数量


948
00:29:10,446 --> 00:29:11,606
以对性能产生


949
00:29:11,606 --> 00:29:12,666
显著的影响


950
00:29:12,786 --> 00:29:14,596
但视图更少的话


951
00:29:14,596 --> 00:29:16,556
也并不都是最好的


952
00:29:16,556 --> 00:29:17,606
否则我们所有的 App


953
00:29:17,686 --> 00:29:18,866
都会只有一个包括所有内容的


954
00:29:18,866 --> 00:29:19,116
巨大视图了


955
00:29:21,266 --> 00:29:22,396
另一个经常


956
00:29:22,396 --> 00:29:24,806
用到的方法就是直接观察


957
00:29:25,356 --> 00:29:26,916
我们的源代码中通常


958
00:29:26,916 --> 00:29:30,136
有两个松散耦合的方面


959
00:29:30,286 --> 00:29:31,466
也许它们彼此知道对方


960
00:29:31,466 --> 00:29:33,296
而它们是通过一些


961
00:29:33,296 --> 00:29:34,996
间接的机制


962
00:29:34,996 --> 00:29:36,016
进行交流的


963
00:29:36,456 --> 00:29:37,796
也许它们用


964
00:29:37,796 --> 00:29:39,916
NS Notification Center


965
00:29:39,966 --> 00:29:41,316
一些基于代码块的回调


966
00:29:41,516 --> 00:29:43,606
授权或者关键值观察


967
00:29:45,006 --> 00:29:46,156
我常常见到


968
00:29:46,216 --> 00:29:47,326
我们会有一些模型代码


969
00:29:47,326 --> 00:29:49,076
它们在一个循环中


970
00:29:49,076 --> 00:29:50,946
被不断地改变


971
00:29:50,946 --> 00:29:51,856
而每次它走向循环


972
00:29:52,206 --> 00:29:55,136
就会引起许多 KVO 通告机制


973
00:29:55,386 --> 00:29:56,286
当然 你其实并不能


974
00:29:56,286 --> 00:29:57,876
在模块代码中看到它


975
00:29:57,956 --> 00:29:59,236
但是在一些其他的控件里


976
00:29:59,526 --> 00:30:00,946
它会十分活跃地作出回应


977
00:30:00,946 --> 00:30:01,966
并试图与模块里的变化


978
00:30:01,966 --> 00:30:03,126
保持一致


979
00:30:03,126 --> 00:30:04,786
这时你就花费了许多 CPU 时间


980
00:30:04,786 --> 00:30:06,636
最终当你考虑整个的


981
00:30:06,636 --> 00:30:07,656
变化的时候


982
00:30:07,656 --> 00:30:08,806
这些都是多余的工作


983
00:30:09,496 --> 00:30:12,306
那么 如果这是模块代码中的


984
00:30:12,776 --> 00:30:13,826
直接调用 那么


985
00:30:13,826 --> 00:30:14,866
不论是通过通告机制或授权


986
00:30:15,416 --> 00:30:17,106
还是手动进行基于代码块的回调


987
00:30:17,106 --> 00:30:19,506
改变都会发生地更加明显


988
00:30:19,506 --> 00:30:20,936
当你编辑该模块代码时


989
00:30:21,396 --> 00:30:22,556
你也许认为


990
00:30:22,556 --> 00:30:24,366
将一些通告机制从循环中


991
00:30:24,366 --> 00:30:26,126
拖出到循环之外


992
00:30:26,126 --> 00:30:27,916
以对性能产生


993
00:30:27,916 --> 00:30:29,906
较大的影响 是完全合适的


994
00:30:30,556 --> 00:30:31,856
那么 或者


995
00:30:31,856 --> 00:30:33,476
在控件这边 你可以用这些


996
00:30:33,476 --> 00:30:35,206
推迟和批量处理方法中的一个


997
00:30:35,206 --> 00:30:36,946
来避免多余的工作


998
00:30:36,946 --> 00:30:38,336
只是它们的回应


999
00:30:38,336 --> 00:30:39,246
是不同步的


1000
00:30:41,136 --> 00:30:42,216
最后 这是最简单的一个


1001
00:30:42,836 --> 00:30:44,716
一旦你的代码已经在


1002
00:30:45,046 --> 00:30:46,386
一个很好的路径上了


1003
00:30:46,386 --> 00:30:47,586
你知道 它已经是线性的了


1004
00:30:47,586 --> 00:30:49,366
而且不会有比线性更好的了


1005
00:30:49,366 --> 00:30:50,346
这是一种你要


1006
00:30:51,796 --> 00:30:52,966
获得的最低性能


1007
00:30:53,626 --> 00:30:54,876
毕竟 你要尽可能地


1008
00:30:54,876 --> 00:30:57,186
改进常数时间


1009
00:30:57,246 --> 00:30:58,676
那么 很简单


1010
00:30:58,676 --> 00:31:00,096
如果你将词典


1011
00:31:00,096 --> 00:31:01,366
作为对象使用


1012
00:31:01,366 --> 00:31:02,636
那你或许已经看到这点


1013
00:31:02,926 --> 00:31:04,216
如果你有一堆为秘钥准备的


1014
00:31:04,216 --> 00:31:06,166
字符串常数


1015
00:31:06,166 --> 00:31:07,466
那么你就可以大幅度提高


1016
00:31:07,466 --> 00:31:09,186
代码的清晰性


1017
00:31:09,186 --> 00:31:11,396
提高代码完成和重构


1018
00:31:11,396 --> 00:31:12,396
以及源代码验证


1019
00:31:12,396 --> 00:31:14,966
通过使用特定的形式


1020
00:31:15,076 --> 00:31:16,136
用它们的 strucks 和 swift


1021
00:31:16,136 --> 00:31:18,066
用它们隐含的初始化器和一致性


1022
00:31:18,066 --> 00:31:19,196
来平等哈希值


1023
00:31:19,196 --> 00:31:20,816
这再简单不过了


1024
00:31:21,336 --> 00:31:23,646
而这能轻而易举地


1025
00:31:23,646 --> 00:31:24,586
改进你的源代码


1026
00:31:24,586 --> 00:31:26,206
如果你在许多小目标上


1027
00:31:26,206 --> 00:31:27,916
完成数百万次的


1028
00:31:27,916 --> 00:31:29,546
字符串哈希映射


1029
00:31:29,546 --> 00:31:31,126
和字符串 equation 的话


1030
00:31:31,126 --> 00:31:32,546
你会惊讶于你花费了


1031
00:31:32,546 --> 00:31:33,316
多少时间


1032
00:31:34,516 --> 00:31:35,736
那么接下来的时间


1033
00:31:35,736 --> 00:31:37,386
我想请 Matthew 上台来


1034
00:31:37,386 --> 00:31:38,966
谈谈我们如何将这些方法


1035
00:31:39,056 --> 00:31:40,686
应用到“照片”中去


1036
00:31:42,516 --> 00:31:47,866
［ 掌声 ］


1037
00:31:48,366 --> 00:31:48,806
>> 谢谢 Jim


1038
00:31:49,966 --> 00:31:50,656
大家好


1039
00:31:50,826 --> 00:31:52,746
我是 Matthew Lucas


1040
00:31:52,806 --> 00:31:56,076
一名“照片”团队的工程师


1041
00:31:56,076 --> 00:31:57,536
今天我想给你们一些


1042
00:31:57,536 --> 00:31:59,316
直接从“照片”中来的


1043
00:31:59,316 --> 00:32:00,296
实用的性能的例子


1044
00:32:01,306 --> 00:32:02,556
那么首先 让我们先来


1045
00:32:02,556 --> 00:32:03,536
简单谈谈“照片”


1046
00:32:04,076 --> 00:32:05,466
我们都十分熟悉这个 App


1047
00:32:06,026 --> 00:32:07,766
它可以供你存储 浏览


1048
00:32:07,846 --> 00:32:09,696
并体验你最喜爱的时刻


1049
00:32:10,236 --> 00:32:11,686
因此你可以浏览你最喜欢的时刻


1050
00:32:11,716 --> 00:32:13,526
从这个“时刻”视图里


1051
00:32:13,646 --> 00:32:14,596
在这里可以看到


1052
00:32:14,596 --> 00:32:15,496
这是默认视图


1053
00:32:15,926 --> 00:32:17,526
但是你也可以


1054
00:32:17,526 --> 00:32:19,456
切换到另一种视图“精选” 


1055
00:32:19,456 --> 00:32:19,926
或者“年度”


1056
00:32:20,566 --> 00:32:22,736
这个我一会再细说


1057
00:32:23,446 --> 00:32:25,306
现在图片库里可以有


1058
00:32:25,306 --> 00:32:28,346
1000 到 100000 张先前的素材


1059
00:32:29,126 --> 00:32:30,636
这取决于你对拍照的喜爱


1060
00:32:31,196 --> 00:32:33,036
我们都喜欢捕捉每天的生活中


1061
00:32:33,036 --> 00:32:34,976
那些快乐而珍贵的瞬间


1062
00:32:36,336 --> 00:32:37,366
所以我们都很耐心地去捕捉它们


1063
00:32:37,366 --> 00:32:38,846
但是当这样的事发生时


1064
00:32:38,846 --> 00:32:40,576
我们并不是那么地有耐心


1065
00:32:41,286 --> 00:32:42,346
在你启动“照片” 


1066
00:32:42,346 --> 00:32:44,226
这个 App 的时候


1067
00:32:44,226 --> 00:32:45,296
如果你的“时刻”变成了这样


1068
00:32:45,296 --> 00:32:46,926
你会有什么感受


1069
00:32:47,386 --> 00:32:48,636
那么 你也许


1070
00:32:48,636 --> 00:32:50,596
还会遇到这样的情况


1071
00:32:50,596 --> 00:32:51,716
在这里只有许多的


1072
00:32:51,716 --> 00:32:53,106
空白图片框 这样看起来


1073
00:32:53,106 --> 00:32:53,586
并不是非常好


1074
00:32:54,266 --> 00:32:55,356
也许你轻轻滑动


1075
00:32:55,856 --> 00:32:57,216
这个灰色的地方就会消失


1076
00:32:57,216 --> 00:33:00,736
照片就会开始加载


1077
00:33:00,736 --> 00:33:01,766
但你继续滑动


1078
00:33:01,766 --> 00:33:02,886
你就会遇到一些掉帧


1079
00:33:02,886 --> 00:33:04,326
因为视图被更新了


1080
00:33:05,556 --> 00:33:06,836
好 我们的目标就是


1081
00:33:06,836 --> 00:33:07,626
不要出现这样的视图


1082
00:33:08,666 --> 00:33:09,876
我们认为这种视图


1083
00:33:09,926 --> 00:33:12,066
并不是好的用户体验


1084
00:33:12,066 --> 00:33:13,366
但是我们知道有时候


1085
00:33:13,366 --> 00:33:14,156
这是不可避免的


1086
00:33:14,556 --> 00:33:15,706
但是当它过于频繁时


1087
00:33:15,706 --> 00:33:16,666
就无法忍受了


1088
00:33:18,546 --> 00:33:19,666
现在 当你运行一个 App 时


1089
00:33:19,666 --> 00:33:20,756
你想要确保它一开始就能用


1090
00:33:20,756 --> 00:33:22,456
能够做出响应


1091
00:33:23,576 --> 00:33:25,296
你还要确保


1092
00:33:25,296 --> 00:33:26,516
动画是很流畅的


1093
00:33:27,226 --> 00:33:30,516
而这两个属性


1094
00:33:30,516 --> 00:33:31,796
对用户体验来说


1095
00:33:31,796 --> 00:33:32,786
都是十分重要的


1096
00:33:33,446 --> 00:33:35,766
如果用户发现你的 App


1097
00:33:35,766 --> 00:33:37,256
并不相关


1098
00:33:37,256 --> 00:33:38,146
他们也许不会再使用它了


1099
00:33:39,526 --> 00:33:40,706
现在我来举例说明这两点


1100
00:33:40,706 --> 00:33:42,626
我要给你们


1101
00:33:42,626 --> 00:33:43,426
举两个例子


1102
00:33:43,716 --> 00:33:45,726
第一个就是我们如何


1103
00:33:45,726 --> 00:33:47,406
对这个“时刻”视图的启动


1104
00:33:47,406 --> 00:33:48,166
进行优化


1105
00:33:48,886 --> 00:33:50,506
第二个则是我们如何


1106
00:33:50,506 --> 00:33:52,576
创建这个“精选”和“年度”视图


1107
00:33:52,576 --> 00:33:53,866
以更好地适应用户的偏好


1108
00:33:56,696 --> 00:33:59,876
首先是启动“时刻”


1109
00:34:00,296 --> 00:34:02,296
[ 音质不清晰 ]


1110
00:34:02,716 --> 00:34:03,876
那么什么是启动


1111
00:34:04,046 --> 00:34:05,386
我们有三种启动


1112
00:34:06,696 --> 00:34:08,176
第一种也是更为昂贵的一种


1113
00:34:08,176 --> 00:34:09,476
即我们所说的冷启动


1114
00:34:09,476 --> 00:34:11,406
它取决于在重启后


1115
00:34:11,406 --> 00:34:13,186
第一次重新启动你的 App


1116
00:34:14,346 --> 00:34:15,606
所以里面基本上


1117
00:34:15,606 --> 00:34:17,446
还没有缓存任何东西


1118
00:34:17,446 --> 00:34:19,096
也许你需要载入一些后台过程


1119
00:34:19,096 --> 00:34:19,946
或者一些库


1120
00:34:21,136 --> 00:34:23,116
下面在这样的情况也会冷启动


1121
00:34:23,206 --> 00:34:24,916
系统在内存压力下运行


1122
00:34:24,916 --> 00:34:29,686
开始回收一些内存


1123
00:34:30,045 --> 00:34:31,485
那么 如果你关闭一个 App


1124
00:34:31,485 --> 00:34:32,906
也许不会触发代码运行


1125
00:34:32,906 --> 00:34:34,606
因为是系统决定了资源


1126
00:34:34,606 --> 00:34:38,766
应该何时被放在


1127
00:34:38,766 --> 00:34:38,976
页面上


1128
00:34:39,065 --> 00:34:40,466
而如果你关闭了一个 App


1129
00:34:40,466 --> 00:34:41,646
然后几秒之后重新打开它


1130
00:34:41,726 --> 00:34:43,835
几乎可以肯定


1131
00:34:43,835 --> 00:34:45,565
你进行的是一个热启动


1132
00:34:46,036 --> 00:34:47,706
我们称其为热启动


1133
00:34:47,706 --> 00:34:50,386
是因为资源或从属的东西


1134
00:34:50,386 --> 00:34:52,116
都仍然在缓存里


1135
00:34:52,116 --> 00:34:52,996
所以它能更快地启动


1136
00:34:54,525 --> 00:34:56,636
那么 最后一种类型就是


1137
00:34:56,636 --> 00:34:59,026
我们所说的热启动


1138
00:34:59,026 --> 00:35:00,926
根本上说它就是继续启动


1139
00:35:00,926 --> 00:35:02,526
因为这时 App 已经处于运行状态


1140
00:35:02,526 --> 00:35:04,206
直接把它带回前台就可以了


1141
00:35:05,046 --> 00:35:06,136
所以当你开始测量启动时


1142
00:35:06,136 --> 00:35:07,656
你应该从测量


1143
00:35:07,656 --> 00:35:08,786
热启动开始


1144
00:35:09,456 --> 00:35:12,636
它所用的时间


1145
00:35:12,636 --> 00:35:14,036
要比冷启动所花的时间


1146
00:35:14,036 --> 00:35:17,326
变量更小


1147
00:35:17,326 --> 00:35:18,656
而测试迭代也更快


1148
00:35:18,656 --> 00:35:19,656
因为你不需要


1149
00:35:19,656 --> 00:35:20,536
重启你的设备


1150
00:35:21,846 --> 00:35:23,226
那么 我们用来测量启动的方法


1151
00:35:23,226 --> 00:35:25,156
是对从你点击这个 App


1152
00:35:25,156 --> 00:35:26,566
的图标的那一刻


1153
00:35:26,676 --> 00:35:28,236
到你可以开始与你的 App 进行互动


1154
00:35:28,236 --> 00:35:30,696
的整个时间进行评估


1155
00:35:30,986 --> 00:35:32,316
我说互动的意思就是


1156
00:35:32,316 --> 00:35:34,386
它真的可以使用了


1157
00:35:34,386 --> 00:35:35,726
而不再有旋转的圈


1158
00:35:37,436 --> 00:35:38,826
它通常会在显示


1159
00:35:38,856 --> 00:35:40,536
这个旋转的圈的同时 


1160
00:35:40,536 --> 00:35:41,956
分派一些工作


1161
00:35:41,956 --> 00:35:43,126
但并不能让 App 更快地投入使用


1162
00:35:43,126 --> 00:35:44,526
所以我们想要


1163
00:35:44,526 --> 00:35:47,086
避免这些


1164
00:35:47,386 --> 00:35:48,656
现在 我们有三个针对


1165
00:35:48,656 --> 00:35:49,886
“照片”的目标


1166
00:35:50,576 --> 00:35:52,056
第一个就是我们想要瞬时


1167
00:35:52,056 --> 00:35:54,486
我们不想出现任何


1168
00:35:54,486 --> 00:35:57,666
等待的圆圈


1169
00:35:57,666 --> 00:35:59,266
我们不想出现任何


1170
00:36:00,996 --> 00:36:02,256
空白的图片框


1171
00:36:03,286 --> 00:36:04,346
坦白地说


1172
00:36:04,346 --> 00:36:06,686
你也许会看到一些空白图片框


1173
00:36:06,686 --> 00:36:07,886
在你第一次


1174
00:36:07,886 --> 00:36:09,536
同步 iClub 的时候


1175
00:36:09,536 --> 00:36:11,196
但是当数据本地化后


1176
00:36:11,266 --> 00:36:13,746
就尽可能地不显示了


1177
00:36:13,996 --> 00:36:15,446
那么 我所说的瞬时是什么意思呢


1178
00:36:16,356 --> 00:36:17,606
就是它启动所花的时间


1179
00:36:17,606 --> 00:36:18,836
应该和从主屏幕上


1180
00:36:18,836 --> 00:36:20,646
放大的动画过程的时间 保持一致


1181
00:36:21,086 --> 00:36:22,506
这个时间通常是 500 到


1182
00:36:22,506 --> 00:36:24,796
600 毫秒之间


1183
00:36:25,176 --> 00:36:26,386
这样一来 从主屏幕到


1184
00:36:26,386 --> 00:36:27,726
App 的转换


1185
00:36:27,836 --> 00:36:29,426
就是无缝连接的了


1186
00:36:29,426 --> 00:36:31,036
用户可以立刻与 App 互动


1187
00:36:31,036 --> 00:36:32,876
只要它显示完动画过程


1188
00:36:33,446 --> 00:36:34,666
顺便说一下


1189
00:36:34,666 --> 00:36:35,986
这是最基本的建议


1190
00:36:35,986 --> 00:36:37,546
这不只是给“照片”的


1191
00:36:37,546 --> 00:36:40,186
所以它适用于所有的 App


1192
00:36:40,346 --> 00:36:41,666
那么让我们来看看“照片”


1193
00:36:41,666 --> 00:36:42,266
现在是如何启动的


1194
00:36:43,436 --> 00:36:44,956
如果我们近距离地


1195
00:36:44,956 --> 00:36:46,576
看看到底发生了什么


1196
00:36:46,576 --> 00:36:48,656
你就能看到“照片” 


1197
00:36:48,656 --> 00:36:50,146
在动画过程完成之前


1198
00:36:50,146 --> 00:36:50,576
就已经准备好了


1199
00:36:53,466 --> 00:36:55,216
如果我们深入剖析这个启动


1200
00:36:55,216 --> 00:36:57,356
我们就会看到


1201
00:36:57,356 --> 00:36:58,326
这里主要有两个部分


1202
00:36:58,746 --> 00:37:00,256
第一部分时间花在 DYD 中


1203
00:37:00,256 --> 00:37:02,156
这是载入器


1204
00:37:02,156 --> 00:37:03,466
它将加载并连接 


1205
00:37:03,466 --> 00:37:05,416
你所有的动态链接器


1206
00:37:05,416 --> 00:37:06,436
而它还要运行你的


1207
00:37:06,436 --> 00:37:07,576
静态初始化器


1208
00:37:08,766 --> 00:37:10,316
虽然你对这部分


1209
00:37:10,426 --> 00:37:11,476
的控制是有限的


1210
00:37:11,476 --> 00:37:11,886
但也有可能做到


1211
00:37:12,576 --> 00:37:14,886
我鼓励你们去看看


1212
00:37:14,886 --> 00:37:17,166
去年 DYD 的部分


1213
00:37:18,196 --> 00:37:21,496
就能得到这个方面


1214
00:37:21,496 --> 00:37:21,896
更多的细节


1215
00:37:23,566 --> 00:37:25,686
那么 DYD 也要


1216
00:37:25,686 --> 00:37:27,486
在你的项目表中调用 Main


1217
00:37:27,486 --> 00:37:28,716
这就将我们带到了第二个部分


1218
00:37:29,106 --> 00:37:30,356
在这里你有很多控件


1219
00:37:30,356 --> 00:37:32,236
这个部分里 你需要确保


1220
00:37:32,236 --> 00:37:34,016
将它的时间保持在


1221
00:37:34,016 --> 00:37:35,056
500 毫秒以内


1222
00:37:35,976 --> 00:37:38,386
现在 第一个布局正好被排在


1223
00:37:38,386 --> 00:37:39,786
Did Finish Launching 之后


1224
00:37:40,276 --> 00:37:41,286
它将标记启动的结束


1225
00:37:41,286 --> 00:37:42,796
而这时你基本上


1226
00:37:42,796 --> 00:37:43,946
就可以使用你的 App 了


1227
00:37:46,016 --> 00:37:47,556
在这个部分 


1228
00:37:47,606 --> 00:37:49,116
我们将要提到


1229
00:37:49,116 --> 00:37:51,056
一些原则


1230
00:37:51,056 --> 00:37:52,316
它们的确是我们在


1231
00:37:52,316 --> 00:37:53,456
进行性能工作时


1232
00:37:53,456 --> 00:37:53,846
最大的收获


1233
00:37:55,116 --> 00:37:56,976
第一是我们需要惰性


1234
00:37:56,976 --> 00:37:59,566
推迟我们不需要


1235
00:37:59,616 --> 00:38:00,876
的工作


1236
00:38:01,396 --> 00:38:02,546
第二则是要积极主动


1237
00:38:02,546 --> 00:38:04,506
而这两个方面


1238
00:38:04,506 --> 00:38:05,256
都有它的效用


1239
00:38:05,256 --> 00:38:07,866
积极主动能够


1240
00:38:08,006 --> 00:38:09,716
十分有效地预料


1241
00:38:09,716 --> 00:38:12,296
我们之后要做的工作


1242
00:38:12,296 --> 00:38:13,526
我们想要积极主动地


1243
00:38:13,526 --> 00:38:15,176
快速捕捉到衰退


1244
00:38:15,176 --> 00:38:16,116
因而你要确保


1245
00:38:16,116 --> 00:38:18,716
你设置了连续的综合测试


1246
00:38:21,536 --> 00:38:23,116
最后一点就是


1247
00:38:23,116 --> 00:38:24,726
无论我们总共需要


1248
00:38:24,806 --> 00:38:26,046
加载多少数据


1249
00:38:26,046 --> 00:38:26,566
我们都要持续不变


1250
00:38:29,496 --> 00:38:31,646
现在 如果我们用这个方法


1251
00:38:31,646 --> 00:38:32,986
我们载入所有在启动中


1252
00:38:32,986 --> 00:38:34,186
要用到的东西


1253
00:38:34,186 --> 00:38:35,366
这是它大概会在一个


1254
00:38:35,366 --> 00:38:37,806
有 30000 项的库里


1255
00:38:37,806 --> 00:38:38,556
花费的时间


1256
00:38:39,696 --> 00:38:41,106
首先你需要初始化数据库


1257
00:38:41,106 --> 00:38:42,696
然后你需要


1258
00:38:42,696 --> 00:38:43,986
准备一些视图控件


1259
00:38:44,356 --> 00:38:45,516
接着需要配置数据资源


1260
00:38:45,516 --> 00:38:47,236
加载一些库图像


1261
00:38:47,236 --> 00:38:49,066
然后读取云状态


1262
00:38:49,986 --> 00:38:52,236
你要记住 这个时间也许会


1263
00:38:52,306 --> 00:38:54,496
随着数据的生长发生变化


1264
00:38:54,496 --> 00:38:56,666
而其实数据将会一直生长


1265
00:38:56,666 --> 00:38:59,593
只要人们每天都拍照


1266
00:39:00,046 --> 00:39:01,666
所以在“照片”里一定要记住


1267
00:39:01,666 --> 00:39:02,646
我们要处理的是没有边界的


1268
00:39:02,646 --> 00:39:05,526
数据集


1269
00:39:05,766 --> 00:39:07,016
那么让我们来看看


1270
00:39:07,016 --> 00:39:09,166
如何优化“照片”的每一个步骤


1271
00:39:09,166 --> 00:39:11,846
就让我们从初始化数据库开始


1272
00:39:13,236 --> 00:39:15,146
首先 数据库通常


1273
00:39:15,146 --> 00:39:16,606
是在执行第一个查询的时候


1274
00:39:16,606 --> 00:39:18,056
被初始化和载入的


1275
00:39:18,656 --> 00:39:19,886
我们发现了一个非常


1276
00:39:19,886 --> 00:39:21,806
值得优化的地方 就是尽快地


1277
00:39:21,806 --> 00:39:22,796
在后台线程中完成初始化


1278
00:39:22,796 --> 00:39:24,586
这样它就不需要


1279
00:39:24,586 --> 00:39:26,346
在执行第一个查询时


1280
00:39:26,346 --> 00:39:27,636
再进行初始化工作了


1281
00:39:28,996 --> 00:39:30,736
这是个问题 特别是


1282
00:39:30,946 --> 00:39:32,256
如果第一个查询已经


1283
00:39:32,256 --> 00:39:33,006
从主线程当中完成了


1284
00:39:34,756 --> 00:39:39,696
现在 我们已经花了很多时间


1285
00:39:39,696 --> 00:39:40,646
而我们仍要花费很多时间


1286
00:39:40,706 --> 00:39:41,956
来检查我们在启动过程中的


1287
00:39:41,956 --> 00:39:43,116
所有的查询


1288
00:39:43,626 --> 00:39:44,766
我们想要确保


1289
00:39:44,846 --> 00:39:46,396
我们正在做的工作


1290
00:39:46,396 --> 00:39:47,786
是必要的


1291
00:39:47,786 --> 00:39:49,276
我们不再做更多的工作


1292
00:39:53,246 --> 00:39:56,106
那么最后 我们要确保


1293
00:39:56,106 --> 00:39:57,586
我们所做的所有查询


1294
00:39:57,586 --> 00:39:59,576
都要尽可能地高效


1295
00:39:59,576 --> 00:40:01,086
我们也想尽可能地


1296
00:40:01,086 --> 00:40:04,876
避免复杂的查询


1297
00:40:05,276 --> 00:40:06,986
我们有时知道


1298
00:40:06,986 --> 00:40:08,646
我们需要这样做 针对这类情况


1299
00:40:08,686 --> 00:40:10,676
我们设置了一些索引


1300
00:40:10,676 --> 00:40:12,276
以便我们能提高速度


1301
00:40:15,676 --> 00:40:17,396
现在我们的目标是


1302
00:40:17,396 --> 00:40:19,546
在初始化上花费的时间


1303
00:40:19,546 --> 00:40:20,406
不超过 30 毫秒


1304
00:40:21,286 --> 00:40:22,526
那么接下来让我们看看


1305
00:40:22,526 --> 00:40:23,826
我们如何准备视图控件


1306
00:40:25,106 --> 00:40:25,986
这里我们有四个标记


1307
00:40:25,986 --> 00:40:27,796
呈现在 App 的


1308
00:40:27,906 --> 00:40:29,486
主要特性上


1309
00:40:29,656 --> 00:40:30,966
那么我们需要注意的第一件事


1310
00:40:30,966 --> 00:40:32,826
就是我们想要


1311
00:40:32,826 --> 00:40:33,926
通过做最少的工作


1312
00:40:33,926 --> 00:40:35,756
来初始化这三个


1313
00:40:35,756 --> 00:40:37,306
不可见的标记


1314
00:40:37,746 --> 00:40:39,896
这里我们要遵循的原则


1315
00:40:39,896 --> 00:40:41,516
就是做尽可能地


1316
00:40:41,566 --> 00:40:43,666
少的工作来进行初始化


1317
00:40:44,396 --> 00:40:45,436
我们想要将工作最小化


1318
00:40:45,436 --> 00:40:47,246
同时记录载入的视图中的


1319
00:40:47,246 --> 00:40:47,946
所有的数据


1320
00:40:50,486 --> 00:40:52,716
这也让我们可以


1321
00:40:52,786 --> 00:40:54,646
在恒定时间内


1322
00:40:54,706 --> 00:40:56,446
初始化我们的控件


1323
00:40:58,206 --> 00:40:59,936
那么最后 我们想要


1324
00:40:59,936 --> 00:41:02,376
确保我们只加载了可见视图


1325
00:41:02,896 --> 00:41:06,116
这很简单 而我们通常是


1326
00:41:06,116 --> 00:41:07,806
在那个部分出现衰退的


1327
00:41:07,806 --> 00:41:11,376
因此你应该格外小心


1328
00:41:12,016 --> 00:41:12,706
那么在准备视图控件的工作上


1329
00:41:12,706 --> 00:41:14,106
我们现在的目标是


1330
00:41:14,106 --> 00:41:15,696
花费 120 毫秒


1331
00:41:16,626 --> 00:41:18,376
但是准备视图控件意味着


1332
00:41:18,376 --> 00:41:19,646
要配置数据资源


1333
00:41:19,646 --> 00:41:22,216
接下来我们就来看这一块


1334
00:41:25,056 --> 00:41:26,716
所以在“时刻”视图里


1335
00:41:26,716 --> 00:41:27,996
会呈现出这些东西


1336
00:41:27,996 --> 00:41:30,086
呈现你生活中的事件


1337
00:41:30,086 --> 00:41:31,376
而 UI 则通过获得


1338
00:41:31,426 --> 00:41:32,796
这组照片来呈现出


1339
00:41:32,866 --> 00:41:33,266
这些标题栏


1340
00:41:34,206 --> 00:41:35,866
比如说在这个图库中


1341
00:41:35,866 --> 00:41:38,596
我们也许有 500 张照片


1342
00:41:38,596 --> 00:41:40,026
为了创建一个视图


1343
00:41:40,026 --> 00:41:40,976
我们需要预先加载所有的图片


1344
00:41:43,236 --> 00:41:44,706
但是我们只是需要


1345
00:41:44,956 --> 00:41:46,846
这些照片的元数据


1346
00:41:46,846 --> 00:41:48,986
这样我们就可以创建视图了


1347
00:41:49,706 --> 00:41:50,676
我们不需要你的内容


1348
00:41:51,226 --> 00:41:54,846
因此我们首先要做的就是


1349
00:41:54,846 --> 00:41:56,726
执行那个超高速的询问


1350
00:41:56,926 --> 00:41:59,356
然后我们只加载


1351
00:41:59,396 --> 00:42:01,086
我们这里需要的内容


1352
00:42:02,286 --> 00:42:04,046
既然是这样


1353
00:42:04,046 --> 00:42:05,016
我们只要加载可见内容


1354
00:42:05,016 --> 00:42:07,466
在我们这个例子里


1355
00:42:07,466 --> 00:42:09,616
可见内容在 7 到 10 个图片之间


1356
00:42:10,956 --> 00:42:12,536
因为我们的可见内容


1357
00:42:12,876 --> 00:42:14,616
是有限值 所以我们可以


1358
00:42:14,616 --> 00:42:16,066
在主线程上


1359
00:42:16,066 --> 00:42:18,376
同时进行加载


1360
00:42:18,696 --> 00:42:20,896
同时 我们还想预先安排工作


1361
00:42:20,896 --> 00:42:23,526
这样我们就可以


1362
00:42:23,526 --> 00:42:25,546
开始异步加载


1363
00:42:25,546 --> 00:42:26,596
剩下的数据


1364
00:42:27,156 --> 00:42:28,406
我们在后台线程上


1365
00:42:28,406 --> 00:42:30,236
以正确的特性进行加载


1366
00:42:30,316 --> 00:42:31,356
来确保它不会


1367
00:42:31,356 --> 00:42:33,886
抢占主线程的运行


1368
00:42:38,416 --> 00:42:40,516
在这里我们的目标是


1369
00:42:40,516 --> 00:42:41,416
100 毫秒


1370
00:42:44,706 --> 00:42:48,266
那么最后 我们的数据源


1371
00:42:48,266 --> 00:42:50,226
还提供一些图像


1372
00:42:50,226 --> 00:42:51,736
我们来看看如何优化这个部分


1373
00:42:53,666 --> 00:42:54,916
所以目前为止


1374
00:42:54,916 --> 00:42:55,936
这是我们面对的


1375
00:42:55,936 --> 00:42:57,986
最大的数据块 


1376
00:42:57,986 --> 00:42:59,066
当我们意识到在启动时


1377
00:42:59,066 --> 00:43:00,376
我们花费了好几秒的时间


1378
00:43:00,376 --> 00:43:02,536
来加载这个图像 我们就意识到


1379
00:43:02,586 --> 00:43:04,686
我们做了太多的工作


1380
00:43:05,086 --> 00:43:06,296
所以我们所做的第一件事


1381
00:43:06,296 --> 00:43:08,686
就是估计我们在启动时


1382
00:43:08,686 --> 00:43:10,246
需要用到多少张图像


1383
00:43:10,246 --> 00:43:12,556
然后在第一个事务中


1384
00:43:12,556 --> 00:43:14,566
我们只加载那些图像


1385
00:43:15,286 --> 00:43:17,216
这种情况下 这一数量


1386
00:43:17,216 --> 00:43:19,436
可以达到 60 张


1387
00:43:19,436 --> 00:43:19,876
包括上下堆起的


1388
00:43:20,576 --> 00:43:23,386
接下来 为了先加载那些图像


1389
00:43:23,386 --> 00:43:25,036
我们需要确保


1390
00:43:25,036 --> 00:43:26,676
我们只加载


1391
00:43:26,676 --> 00:43:28,046
低分辨率的图像


1392
00:43:28,806 --> 00:43:29,956
这样我们加载在


1393
00:43:29,956 --> 00:43:32,026
内存里的像素就越少


1394
00:43:32,026 --> 00:43:32,546
这样就能更高效


1395
00:43:35,316 --> 00:43:36,566
呈现出这个数据块


1396
00:43:36,566 --> 00:43:37,486
现在需要 200 毫秒


1397
00:43:39,316 --> 00:43:40,846
这是目前为止


1398
00:43:40,846 --> 00:43:41,566
我们提速最多的部分


1399
00:43:42,296 --> 00:43:43,466
我要它成为一个常数时间


1400
00:43:43,466 --> 00:43:46,966
真的很不错


1401
00:43:47,786 --> 00:43:49,346
那么 有时候你禁不住


1402
00:43:49,346 --> 00:43:50,806
问问自己这个问题


1403
00:43:50,806 --> 00:43:52,056
这在启动的时候真的需要吗


1404
00:43:52,286 --> 00:43:54,116
我们这里的一个例子


1405
00:43:54,116 --> 00:43:54,896
是页脚视图


1406
00:43:55,486 --> 00:43:57,256
它通过网络或数据库


1407
00:43:57,256 --> 00:44:00,316
来搜集信息


1408
00:44:00,316 --> 00:44:01,666
而其实我们最先的设计


1409
00:44:01,666 --> 00:44:03,616
是不要在启动时显示它


1410
00:44:04,086 --> 00:44:05,806
以优先所有我们


1411
00:44:05,806 --> 00:44:06,636
在这里看到的图像


1412
00:44:06,906 --> 00:44:08,946
我们想要显示尽可能多的图像


1413
00:44:09,366 --> 00:44:10,356
那这样可能就更简单了


1414
00:44:11,456 --> 00:44:12,936
我们现在只要安排


1415
00:44:12,996 --> 00:44:14,596
启动后的工作


1416
00:44:14,596 --> 00:44:16,216
我们缓存并加工之后要


1417
00:44:16,216 --> 00:44:18,756
显示的信息


1418
00:44:20,686 --> 00:44:21,716
现在 如果我们已经需要


1419
00:44:21,716 --> 00:44:22,936
显示这个信息


1420
00:44:22,936 --> 00:44:24,606
有一个方法可以办到


1421
00:44:24,606 --> 00:44:25,786
利用后台来


1422
00:44:25,786 --> 00:44:27,176
从 UA 工具包中


1423
00:44:27,176 --> 00:44:29,506
刷新 API


1424
00:44:29,506 --> 00:44:31,036
它便会主动清除你的 App


1425
00:44:31,086 --> 00:44:32,376
这样当用户要启动 App 的时候


1426
00:44:32,376 --> 00:44:33,856
你就可以开始


1427
00:44:33,856 --> 00:44:35,446
准备一些内容了


1428
00:44:37,156 --> 00:44:38,836
所以现在 这个部分已经从启动中删除了


1429
00:44:38,836 --> 00:44:40,726
为我们节省了 400 秒的


1430
00:44:40,726 --> 00:44:42,066
CPU 时间


1431
00:44:43,486 --> 00:44:45,276
现在我们看这里的


1432
00:44:45,276 --> 00:44:47,046
更新后的分解图


1433
00:44:47,046 --> 00:44:48,866
可以看到这些工作


1434
00:44:48,866 --> 00:44:50,216
只值得花费 450 毫秒


1435
00:44:50,896 --> 00:44:53,776
而我们现在在这个 500 毫秒


1436
00:44:53,836 --> 00:44:55,866
窗口之中


1437
00:44:55,866 --> 00:44:58,006
而且不论如何


1438
00:44:58,006 --> 00:44:59,486
将其同时呈现出来


1439
00:44:59,486 --> 00:45:00,816
最重要的是


1440
00:45:01,246 --> 00:45:02,626
一定要确保


1441
00:45:02,626 --> 00:45:03,596
你要考虑你


1442
00:45:03,636 --> 00:45:04,656
准备内容的时间成本


1443
00:45:05,296 --> 00:45:07,466
我这里说的考虑


1444
00:45:07,466 --> 00:45:09,086
是要真的去测量它


1445
00:45:10,606 --> 00:45:12,806
现在 你应该争取


1446
00:45:12,806 --> 00:45:13,746
在常量时间里进行工作


1447
00:45:13,746 --> 00:45:14,926
无论你加载的


1448
00:45:14,926 --> 00:45:15,896
数据总共有多少


1449
00:45:16,676 --> 00:45:17,796
在我们的例子里


1450
00:45:17,796 --> 00:45:19,526
我们的确有许多数据集


1451
00:45:19,746 --> 00:45:21,976
我们需要保持常量时间


1452
00:45:24,756 --> 00:45:25,846
既然我们已经启动了 App


1453
00:45:25,846 --> 00:45:27,746
我们要开始使用它


1454
00:45:27,746 --> 00:45:28,866
那么我们来看看我们是


1455
00:45:29,096 --> 00:45:30,256
如何创建“精选”和“年度”视图的


1456
00:45:30,256 --> 00:45:31,146
以便我们提高性能


1457
00:45:31,226 --> 00:45:34,416
正如我之前提到过


1458
00:45:34,416 --> 00:45:37,236
我们的用户能够进行


1459
00:45:37,236 --> 00:45:39,136
从动画过程到“时刻”视图的无缝转换


1460
00:45:39,436 --> 00:45:40,966
再通过“精选”


1461
00:45:40,966 --> 00:45:41,496
到“年度”视图


1462
00:45:44,316 --> 00:45:46,206
这是一个复杂的层级


1463
00:45:46,886 --> 00:45:48,746
我们要展示数千张的照片


1464
00:45:49,606 --> 00:45:51,116
我们要支持实时更新


1465
00:45:51,686 --> 00:45:53,436
我们也要支持


1466
00:45:53,436 --> 00:45:55,186
这些图层间的动画过程


1467
00:45:55,816 --> 00:45:57,276
我们还有一些手势


1468
00:46:00,436 --> 00:46:02,076
那么 我们这里还有一些目标


1469
00:46:02,956 --> 00:46:05,356
对于带给我们用户的体验


1470
00:46:06,426 --> 00:46:07,726
第一个和之前一样


1471
00:46:07,726 --> 00:46:08,706
我们不想有任何


1472
00:46:08,706 --> 00:46:09,436
等待的圆圈


1473
00:46:09,436 --> 00:46:10,156
我们不想有空白的图片框


1474
00:46:10,256 --> 00:46:12,586
当然我们想要


1475
00:46:12,586 --> 00:46:13,806
流畅的动画过程


1476
00:46:13,996 --> 00:46:15,576
这里所说的流畅


1477
00:46:15,846 --> 00:46:19,396
是指 60 到 120 帧每秒


1478
00:46:19,446 --> 00:46:21,686
这依赖于你正在运行的屏幕


1479
00:46:23,266 --> 00:46:25,356
记得之前我们说过的原则


1480
00:46:25,876 --> 00:46:27,236
现在 它们在这里都是有用的


1481
00:46:27,586 --> 00:46:28,926
我们想要懈怠并推迟


1482
00:46:28,926 --> 00:46:30,036
我们预先递交的工作


1483
00:46:30,786 --> 00:46:31,876
我们想要积极地


1484
00:46:31,876 --> 00:46:34,316
快速捕捉衰退


1485
00:46:34,316 --> 00:46:35,956
但是我们也想要


1486
00:46:35,956 --> 00:46:37,476
在布局关口中保持不变


1487
00:46:37,476 --> 00:46:39,686
无论我们要加载多少数据


1488
00:46:41,566 --> 00:46:42,886
那么 这次我们还想要及时


1489
00:46:42,886 --> 00:46:44,396
我们想要记住


1490
00:46:44,396 --> 00:46:46,046
绘制循环周期


1491
00:46:47,076 --> 00:46:48,426
这里我的意思是


1492
00:46:48,426 --> 00:46:49,676
你要记住


1493
00:46:49,676 --> 00:46:52,096
我们只有 8 或 16 毫秒


1494
00:46:52,096 --> 00:46:53,426
来绘制那一帧


1495
00:46:53,426 --> 00:46:54,206
所以我们需要确保


1496
00:46:54,256 --> 00:46:55,876
我们不超时


1497
00:46:55,916 --> 00:46:57,156
否则就会开始掉帧


1498
00:46:59,356 --> 00:47:01,486
现在 让我们返回一步


1499
00:47:01,486 --> 00:47:02,636
看看我们要在这里


1500
00:47:02,636 --> 00:47:03,176
获取什么


1501
00:47:03,866 --> 00:47:05,076
我们要这个便捷视图


1502
00:47:05,076 --> 00:47:07,466
里面有分栏和小单元格


1503
00:47:09,846 --> 00:47:11,226
而这基本上就是


1504
00:47:11,226 --> 00:47:12,836
“精选”视图给你提供的


1505
00:47:12,836 --> 00:47:13,076
对吗


1506
00:47:13,636 --> 00:47:15,036
只不过在这样极端的例子里


1507
00:47:15,036 --> 00:47:16,246
我们会限制


1508
00:47:16,246 --> 00:47:17,506
我们使用这个基本的方法


1509
00:47:17,506 --> 00:47:18,576
可以获得的极限


1510
00:47:18,746 --> 00:47:20,546
那样就会导致过多的


1511
00:47:20,546 --> 00:47:21,616
视图和过多的图层


1512
00:47:23,796 --> 00:47:26,256
但是随着分层的复杂性不断增加


1513
00:47:26,256 --> 00:47:28,396
花在内存上的时间


1514
00:47:28,396 --> 00:47:30,086
也在不断增加


1515
00:47:31,706 --> 00:47:33,086
所以这里我们需要创新


1516
00:47:33,846 --> 00:47:35,126
我们大幅地限制视图的数量


1517
00:47:35,126 --> 00:47:36,436
同时仍使用一个


1518
00:47:36,436 --> 00:47:37,966
“精选”视图


1519
00:47:40,176 --> 00:47:42,066
我们使用的这种方法


1520
00:47:42,066 --> 00:47:43,466
在电子游戏里更为常见


1521
00:47:43,466 --> 00:47:44,606
它叫做图谱法


1522
00:47:45,146 --> 00:47:47,106
它基本上就是


1523
00:47:47,106 --> 00:47:48,766
把一组图像组合


1524
00:47:48,766 --> 00:47:49,406
成为一个


1525
00:47:50,536 --> 00:47:52,186
我们高效地完成了它


1526
00:47:52,186 --> 00:47:53,806
开始只用很小的缩略图


1527
00:47:53,806 --> 00:47:56,736
然后我们将所有的原始图像数据


1528
00:47:56,736 --> 00:47:58,856
标记在一个我们用作


1529
00:47:58,856 --> 00:47:59,716
带状的画布上


1530
00:48:01,156 --> 00:48:03,336
接着 我们使用图像原始数据


1531
00:48:03,336 --> 00:48:04,866
这样就能够避免去解码每一个


1532
00:48:04,866 --> 00:48:07,766
我们发送的缩略图


1533
00:48:08,376 --> 00:48:09,576
因此基本上我们会显示一条


1534
00:48:09,576 --> 00:48:10,726
随机的图像


1535
00:48:12,406 --> 00:48:14,286
那么 我们飞速生成并缓存它们


1536
00:48:14,286 --> 00:48:16,206
因此我们可以更加灵活


1537
00:48:18,436 --> 00:48:20,086
当我们将多个图片绘制成一个时


1538
00:48:20,086 --> 00:48:22,026
我们会大量寄存


1539
00:48:22,026 --> 00:48:24,716
单元格 图层及目标的数量


1540
00:48:24,716 --> 00:48:26,006
这样便简化了布局


1541
00:48:26,006 --> 00:48:29,066
节省了创建它要花费的时间


1542
00:48:29,686 --> 00:48:31,266
现在这样很好 


1543
00:48:31,266 --> 00:48:32,356
但是也要有所取舍


1544
00:48:32,356 --> 00:48:34,966
这就是它们的其中一个


1545
00:48:36,806 --> 00:48:38,606
如果有人试着长按


1546
00:48:38,606 --> 00:48:40,996
或强制搜索一个这里的项目


1547
00:48:40,996 --> 00:48:42,866
我们就需要计算它的位置


1548
00:48:42,916 --> 00:48:44,536
这样我们才能


1549
00:48:44,536 --> 00:48:45,426
正确地获得预览


1550
00:48:45,996 --> 00:48:48,136
因为只要我们显示一张图像


1551
00:48:48,136 --> 00:48:50,776
我们就需要维持


1552
00:48:50,776 --> 00:48:53,156
每个图像的映射


1553
00:48:53,156 --> 00:48:54,736
以及它的绘制条


1554
00:48:56,086 --> 00:48:57,226
现在你也许在想


1555
00:48:57,226 --> 00:48:58,536
我们为什么要飞速地生成它们


1556
00:49:00,016 --> 00:49:01,736
我们要支持实时更新


1557
00:49:01,736 --> 00:49:03,626
这就是原因


1558
00:49:04,416 --> 00:49:06,536
我们也需要不一样的视图大小


1559
00:49:07,426 --> 00:49:09,016
比如说 我们这里有风景图


1560
00:49:09,516 --> 00:49:11,476
但也有人像图


1561
00:49:12,976 --> 00:49:16,276
但是这没有关系


1562
00:49:16,276 --> 00:49:17,096
因为我们的用户增长


1563
00:49:17,096 --> 00:49:18,786
在很长一段时间里 


1564
00:49:18,786 --> 00:49:20,606
是十分典型的


1565
00:49:20,606 --> 00:49:22,766
而我们需要生成


1566
00:49:22,766 --> 00:49:24,076
数千张图像这样的例子


1567
00:49:24,076 --> 00:49:25,016
相当地罕见


1568
00:49:27,716 --> 00:49:29,086
现在 你或许想知道


1569
00:49:29,086 --> 00:49:30,236
那我们为什么不生成


1570
00:49:30,236 --> 00:49:31,016
整个这部分呢


1571
00:49:32,616 --> 00:49:33,776
答案就是我们的设计记录


1572
00:49:33,776 --> 00:49:35,306
就是完成这个动画过程


1573
00:49:35,306 --> 00:49:36,966
在这里你能看到


1574
00:49:36,966 --> 00:49:37,926
在“精选”视图中它们


1575
00:49:37,926 --> 00:49:39,036
都扩展到自己的那部分中


1576
00:49:39,036 --> 00:49:40,436
或者相反地


1577
00:49:40,436 --> 00:49:42,986
折叠进它们的小组里


1578
00:49:45,616 --> 00:49:47,206
所以如果说第二部分里


1579
00:49:47,206 --> 00:49:48,376
你只要记住一件事情


1580
00:49:48,376 --> 00:49:49,776
那就是你应该考虑


1581
00:49:49,776 --> 00:49:50,916
你的层级的布局成本


1582
00:49:50,916 --> 00:49:54,506
然后对它进行测量


1583
00:49:56,356 --> 00:49:59,106
最后 你要时刻考虑性能


1584
00:49:59,566 --> 00:50:01,066
在“照片”里我们十分关心这点


1585
00:50:01,066 --> 00:50:02,916
这正是我们日常工作的一部分


1586
00:50:04,906 --> 00:50:06,796
要了解更多的信息


1587
00:50:06,796 --> 00:50:09,026
你们可以观看我在这里提到的


1588
00:50:09,026 --> 00:50:10,146
三个实验室


1589
00:50:10,246 --> 00:50:12,486
祝你们


1590
00:50:12,486 --> 00:50:13,026
参会愉快


1591
00:50:13,526 --> 00:50:13,806
谢谢


1592
00:50:14,516 --> 00:50:20,450
［ 掌声 ］

