1
00:00:07,516 --> 00:00:15,500
[ 音乐 ]


2
00:00:20,456 --> 00:00:22,976
>> 各位 上午好


3
00:00:23,516 --> 00:00:27,016
[ 掌声 ]


4
00:00:27,516 --> 00:00:28,696
欢迎大家参加今年的


5
00:00:28,696 --> 00:00:30,586
关于 HTTP 流媒体网络传输协议（HLS）的会议


6
00:00:31,486 --> 00:00:32,786
我是 Emil Andriescu


7
00:00:33,476 --> 00:00:35,286
今天我们将讨论


8
00:00:35,286 --> 00:00:37,516
测量和优化 HLS 性能


9
00:00:38,516 --> 00:00:40,226
首先 让我们思考一下


10
00:00:40,226 --> 00:00:42,936
为什么我们应该关注它


11
00:00:42,936 --> 00:00:44,796
以及为什么它对于 App 很重要


12
00:00:45,336 --> 00:00:48,646
假设在一个星期六的晚上


13
00:00:48,646 --> 00:00:50,276
你们坐在舒适的沙发上


14
00:00:50,276 --> 00:00:52,076
熟练地浏览了所有的评论


15
00:00:52,076 --> 00:00:53,676
确定了要观看的视频


16
00:00:53,676 --> 00:00:55,446
爆米花也已经准备好了


17
00:00:55,886 --> 00:00:58,046
你们迫不及待地轻点播放键


18
00:00:58,046 --> 00:01:01,526
但是这时发生了这样的事


19
00:01:02,916 --> 00:01:05,336
面对这种神秘且永无止境的动画


20
00:01:05,336 --> 00:01:07,376
你们会问自己


21
00:01:07,376 --> 00:01:09,096
还有什么比这更糟糕的呢


22
00:01:10,506 --> 00:01:12,296
让我们面对它 你们知道吗


23
00:01:12,296 --> 00:01:13,136
它其实是一个播放错误


24
00:01:13,706 --> 00:01:17,846
但是客户真正期望


25
00:01:17,906 --> 00:01:20,306
HLS 会提供什么样的体验呢


26
00:01:21,016 --> 00:01:22,126
他们期待清晰的图像


27
00:01:22,256 --> 00:01:24,176
高保真的音质


28
00:01:24,176 --> 00:01:26,506
以及轻点播放键时


29
00:01:26,506 --> 00:01:28,686
即时的媒体反应


30
00:01:29,466 --> 00:01:31,096
然而 互联网上流媒体 App


31
00:01:31,096 --> 00:01:32,836
的性能表现总是受网络的影响


32
00:01:32,836 --> 00:01:35,616
那么我们该如何调和呢


33
00:01:36,696 --> 00:01:38,656
HLS 的设计


34
00:01:38,656 --> 00:01:40,176
就是为了解决这个问题


35
00:01:40,176 --> 00:01:42,246
即在不可预知的


36
00:01:42,516 --> 00:01:43,786
网络环境中


37
00:01:43,786 --> 00:01:46,166
提供最好的


38
00:01:46,166 --> 00:01:47,156
不间断的流媒体体验


39
00:01:47,156 --> 00:01:48,406
所以我们为什么今天在这里


40
00:01:48,666 --> 00:01:49,576
还有很多理由


41
00:01:50,006 --> 00:01:52,696
如今 HLS 已经发展成一个


42
00:01:52,696 --> 00:01:54,336
更动态的生态系统


43
00:01:54,546 --> 00:01:56,566
它支持新的功能


44
00:01:56,566 --> 00:01:58,376
如 I-frame 播放


45
00:01:58,376 --> 00:02:00,896
新媒体格式 当然还有新的编解码器


46
00:02:01,336 --> 00:02:03,316
与此同时


47
00:02:03,316 --> 00:02:05,896
我们不断地添加强大的


48
00:02:06,046 --> 00:02:08,985
iOS tvOS 以及 macOS 的 API


49
00:02:09,316 --> 00:02:12,236
比如你们可以针对你们的目标用户


50
00:02:12,236 --> 00:02:13,946
优化和调整播放


51
00:02:13,946 --> 00:02:15,786
并提供更丰富的用户体验


52
00:02:16,876 --> 00:02:18,686
交付模式和传输协议


53
00:02:18,726 --> 00:02:20,136
也在不断发展


54
00:02:20,136 --> 00:02:22,186
因此重要的是


55
00:02:22,186 --> 00:02:23,776
结合观察


56
00:02:23,776 --> 00:02:26,046
在移动设备上或客厅中


57
00:02:26,046 --> 00:02:27,506
内容被消费的情况


58
00:02:27,776 --> 00:02:33,996
以判断服务器端的性能


59
00:02:34,216 --> 00:02:36,266
考虑到所有这些指标


60
00:02:36,266 --> 00:02:37,616
你们如何确定


61
00:02:37,616 --> 00:02:39,616
你们为观众提供的用户体验


62
00:02:39,616 --> 00:02:41,016
是最好的呢


63
00:02:41,016 --> 00:02:43,256
第一步是


64
00:02:43,256 --> 00:02:47,296
结合你们对内容 App


65
00:02:47,296 --> 00:02:48,796
或交付的更改


66
00:02:49,056 --> 00:02:51,056
理解并量化用户体验


67
00:02:52,176 --> 00:02:53,866
我们认为在这一方面


68
00:02:53,866 --> 00:02:55,456
确定哪种配置是最优的方法


69
00:02:55,906 --> 00:02:57,416
应该是测量


70
00:02:57,416 --> 00:02:58,996
而不是猜测


71
00:03:00,246 --> 00:03:01,416
那么这个会议将是什么内容呢


72
00:03:02,176 --> 00:03:03,846
首先 我们想要建立一种


73
00:03:03,846 --> 00:03:05,456
共同的语言


74
00:03:05,456 --> 00:03:06,946
来讨论流媒体服务的质量


75
00:03:07,636 --> 00:03:09,436
然后我们想讨论


76
00:03:09,436 --> 00:03:11,156
如何客观地度量


77
00:03:11,156 --> 00:03:12,836
App 的流媒体性能


78
00:03:13,766 --> 00:03:15,266
第三 我们希望


79
00:03:15,266 --> 00:03:17,796
帮助你们识别


80
00:03:17,796 --> 00:03:19,746
并解决一些


81
00:03:19,746 --> 00:03:20,906
影响流媒体服务质量的问题


82
00:03:22,416 --> 00:03:24,196
最后 我们想修正


83
00:03:24,196 --> 00:03:25,606
主播放列表


84
00:03:25,976 --> 00:03:27,486
这是因为


85
00:03:27,616 --> 00:03:29,376
我们在流媒体质量中


86
00:03:29,596 --> 00:03:31,056
看到的许多问题


87
00:03:31,056 --> 00:03:33,226
实际上根源于


88
00:03:33,256 --> 00:03:34,626
主播放列表的编写


89
00:03:35,446 --> 00:03:37,216
在详细讨论之前


90
00:03:37,216 --> 00:03:38,916
让我们先简要概述一下


91
00:03:38,916 --> 00:03:40,246
HLS 播放会话


92
00:03:41,216 --> 00:03:42,736
正如你们所期望的


93
00:03:42,736 --> 00:03:44,426
它从下载一个主播放列表开始


94
00:03:44,896 --> 00:03:47,396
一旦 AVPlayer 开始读取播放列表


95
00:03:47,396 --> 00:03:50,176
它就知道这个播放列表指向的是什么内容


96
00:03:50,416 --> 00:03:51,496
在这种情况下


97
00:03:51,496 --> 00:03:53,836
我们有两个比特率 1 兆比特和 2 兆比特


98
00:03:53,836 --> 00:03:55,546
AVPlayer 会选择其中的一个


99
00:03:55,546 --> 00:03:57,406
然后下载


100
00:03:57,406 --> 00:03:58,846
一个媒体播放列表


101
00:03:58,846 --> 00:03:59,816
以及附加的


102
00:03:59,816 --> 00:04:01,806
例如密钥的工件


103
00:04:01,806 --> 00:04:03,026
然后继续下载


104
00:04:03,026 --> 00:04:05,216
媒体片段


105
00:04:05,216 --> 00:04:06,596
直到缓冲层足够播放


106
00:04:07,106 --> 00:04:10,446
这种情况出现时


107
00:04:10,446 --> 00:04:11,916
AVPlayeItem


108
00:04:11,916 --> 00:04:14,516
将通过设置


109
00:04:14,516 --> 00:04:16,176
playbackLikeyToKeepUp == true 的方式


110
00:04:16,176 --> 00:04:17,766
来传达对播放性能的预测


111
00:04:18,406 --> 00:04:20,466
如果你预先将


112
00:04:20,546 --> 00:04:22,125
AVPlayer 速率设置为 1


113
00:04:22,125 --> 00:04:24,026
那么你正在使用


114
00:04:24,026 --> 00:04:26,426
AVPlayer 的自动播放功能


115
00:04:26,426 --> 00:04:27,886
该播放器将立即开始播放


116
00:04:28,476 --> 00:04:29,946
我们称之为时间间隔


117
00:04:29,946 --> 00:04:30,786
启动时间


118
00:04:31,666 --> 00:04:33,426
从这一点开始


119
00:04:33,426 --> 00:04:35,516
挂钟（也称为实时时钟）


120
00:04:35,866 --> 00:04:37,516
将和 PlayerItem.timebase


121
00:04:37,516 --> 00:04:39,076
以相同的速度前进


122
00:04:39,436 --> 00:04:41,396
有一个条件


123
00:04:41,396 --> 00:04:43,786
即内容必须以


124
00:04:43,786 --> 00:04:46,056
与 AVPlayer 使用的内容


125
00:04:46,056 --> 00:04:47,926
相同或更快的速度到达


126
00:04:48,586 --> 00:04:49,916
如果这样不行


127
00:04:49,966 --> 00:04:52,036
AVPlayer 会尝试


128
00:04:52,036 --> 00:04:53,336
切换到这里的 1 兆比特


129
00:04:53,766 --> 00:04:55,426
如果网络仍然不能


130
00:04:55,426 --> 00:04:57,446
在 1 兆比特时保持实时速度


131
00:04:57,726 --> 00:04:59,276
那么缓冲区将最终耗尽


132
00:04:59,276 --> 00:05:01,566
AVPlayer 没有选择


133
00:05:01,566 --> 00:05:03,006
它需要停止播放


134
00:05:03,006 --> 00:05:04,926
我们将这种事件称为卡顿


135
00:05:05,816 --> 00:05:07,246
播放器将保持这种状态


136
00:05:07,246 --> 00:05:09,196
不仅直到数据


137
00:05:09,196 --> 00:05:10,776
再次开始流动


138
00:05:10,776 --> 00:05:11,996
而且直到有足够的缓冲区


139
00:05:11,996 --> 00:05:13,796
为 PlayItem 触发


140
00:05:13,796 --> 00:05:15,346
另一个积极的


141
00:05:15,416 --> 00:05:18,596
播放性能预测之后


142
00:05:18,596 --> 00:05:19,576
播放将正常继续


143
00:05:20,666 --> 00:05:22,166
现在让我们讨论一下


144
00:05:22,456 --> 00:05:24,176
如何量化这种会话中的


145
00:05:24,176 --> 00:05:25,116
用户体验


146
00:05:26,216 --> 00:05:27,926
我们通过定义一组


147
00:05:27,926 --> 00:05:29,526
关键性能指标 也就是 KPI


148
00:05:29,526 --> 00:05:30,396
来实现这一点


149
00:05:31,056 --> 00:05:32,596
我们选择了其中 5 个


150
00:05:32,596 --> 00:05:34,166
我们认为是 HLS 中


151
00:05:34,196 --> 00:05:35,556
最具代表性的 KPI


152
00:05:36,946 --> 00:05:38,776
你们可能会问


153
00:05:38,776 --> 00:05:40,436
我的用户需要花多少时间


154
00:05:40,836 --> 00:05:42,996
等待播放


155
00:05:42,996 --> 00:05:47,166
1 秒吗 还是 5 秒或30 秒


156
00:05:47,486 --> 00:05:49,036
这是用户体验的


157
00:05:49,036 --> 00:05:50,486
一个重要方面


158
00:05:51,336 --> 00:05:53,906
此外 播放卡顿


159
00:05:53,906 --> 00:05:55,616
就像我们刚才看到的那样


160
00:05:55,616 --> 00:05:56,966
也会对用户造成干扰


161
00:05:57,076 --> 00:05:59,156
我们关心这两者发生的频率


162
00:05:59,156 --> 00:06:00,936
但也许更重要的是


163
00:06:00,936 --> 00:06:02,646
从卡顿中恢复


164
00:06:02,676 --> 00:06:04,126
需要多长时间


165
00:06:05,126 --> 00:06:09,126
然而 在不了解未来的情况下


166
00:06:09,126 --> 00:06:11,136
最好的策略是


167
00:06:11,136 --> 00:06:12,666
以最低的可用比特率交付内容


168
00:06:13,106 --> 00:06:14,666
但那当然不是我们想要的


169
00:06:14,666 --> 00:06:16,076
我们希望提供


170
00:06:16,076 --> 00:06:18,206
最好的音频和视频质量


171
00:06:18,206 --> 00:06:19,356
同时仍不卡顿


172
00:06:19,686 --> 00:06:21,116
所以 在卡顿的风险


173
00:06:21,116 --> 00:06:23,136
以及媒体质量之间


174
00:06:23,136 --> 00:06:24,526
有一个明显的权衡


175
00:06:24,626 --> 00:06:28,566
为此 我们需要另一个


176
00:06:28,566 --> 00:06:29,776
可以衡量整体媒体质量的会话


177
00:06:30,736 --> 00:06:32,976
最后 播放错误


178
00:06:32,976 --> 00:06:33,806
我已经讨论过这点


179
00:06:34,166 --> 00:06:36,166
它们比卡顿更具破坏性


180
00:06:36,826 --> 00:06:39,806
我们如何跟踪


181
00:06:39,806 --> 00:06:40,276
播放错误呢


182
00:06:41,196 --> 00:06:42,866
好的 让我们从启动时间开始讲起


183
00:06:43,676 --> 00:06:45,526
有很多种 API 


184
00:06:45,526 --> 00:06:48,296
你可以用来获取或计算启动时间


185
00:06:48,666 --> 00:06:50,786
首先 不要使用将 AVPlayer.status 更改为


186
00:06:51,046 --> 00:06:52,836
.readyToPlay 这种方法


187
00:06:52,836 --> 00:06:53,796
这并没有告诉你


188
00:06:53,836 --> 00:06:56,256
播放将要开始


189
00:06:56,446 --> 00:06:58,086
然而 如果你正在使用自动播放


190
00:06:58,086 --> 00:06:59,346
那么你可以预先设置


191
00:06:59,346 --> 00:07:00,726
播放器的速率


192
00:07:00,726 --> 00:07:02,716
你可以将 AVPlayerItem.status 更改为


193
00:07:02,716 --> 00:07:04,506
.readyToPlay


194
00:07:04,506 --> 00:07:06,606
或者将


195
00:07:06,606 --> 00:07:08,536
AVPlayerItem.isPlaybackLikelyToKeepUp


196
00:07:08,536 --> 00:07:09,516
更改为 true


197
00:07:09,516 --> 00:07:11,026
这些都是可观测的属性


198
00:07:12,176 --> 00:07:13,836
这样做之后


199
00:07:13,886 --> 00:07:15,876
你就可以知道播放即将开始


200
00:07:15,876 --> 00:07:16,916
但是播放可能需要


201
00:07:17,076 --> 00:07:19,616
几毫秒才会开始


202
00:07:19,876 --> 00:07:21,346
所以我们向你们推荐两种方法


203
00:07:21,346 --> 00:07:23,766
一种是将 AVPlayer.timeControlStatus


204
00:07:23,766 --> 00:07:25,056
更改为 .Playing


205
00:07:25,056 --> 00:07:26,836
另一种是跟踪


206
00:07:26,836 --> 00:07:28,376
AVplayerItem.timebase


207
00:07:28,376 --> 00:07:30,086
而且会有一个通知允许你这么做


208
00:07:30,596 --> 00:07:34,526
AVPlayer 依靠探试法来避免卡顿


209
00:07:34,526 --> 00:07:36,696
但我们知道


210
00:07:36,696 --> 00:07:38,026
有时它们是不可避免的


211
00:07:38,846 --> 00:07:40,946
你可以通过观察


212
00:07:40,946 --> 00:07:43,946
AVPlayerItemPlaybackStalled 的通知


213
00:07:43,946 --> 00:07:44,736
来监控卡顿


214
00:07:45,136 --> 00:07:46,816
这里的建议是计数


215
00:07:46,876 --> 00:07:48,126
卡顿的出现


216
00:07:48,736 --> 00:07:49,776
当然 如果你想要


217
00:07:49,776 --> 00:07:52,346
比较和合计


218
00:07:52,346 --> 00:07:54,466
不同时长的会话的


219
00:07:54,466 --> 00:07:56,016
卡顿行为


220
00:07:56,016 --> 00:07:57,096
那么你需要将其正常化


221
00:07:57,096 --> 00:07:57,826
这又该如何做到呢


222
00:07:58,296 --> 00:08:00,056
我们建议你使用


223
00:08:00,296 --> 00:08:01,996
总观看时长


224
00:08:01,996 --> 00:08:04,636
并计算卡顿率


225
00:08:04,636 --> 00:08:09,326
以单位观看时间内的卡顿次数为单位 例如卡顿/小时


226
00:08:09,926 --> 00:08:13,976
对用户来说


227
00:08:13,976 --> 00:08:16,296
30 秒的卡顿


228
00:08:16,296 --> 00:08:17,206
比 1 秒的卡顿更糟糕


229
00:08:17,436 --> 00:08:19,296
这就是为什么我们也关心


230
00:08:19,506 --> 00:08:21,356
再缓冲时间或卡顿时长


231
00:08:22,276 --> 00:08:23,716
通过测量


232
00:08:23,716 --> 00:08:25,026
播放卡顿的通知


233
00:08:25,026 --> 00:08:26,956
以及当 PlayerItem.timebase 变为 1 时


234
00:08:26,956 --> 00:08:28,566
之间的时间间隔


235
00:08:28,566 --> 00:08:31,306
你就可以计算出


236
00:08:31,306 --> 00:08:32,206
准确的卡顿时长


237
00:08:32,936 --> 00:08:34,956
此外 通过使用


238
00:08:34,956 --> 00:08:37,206
会话的播放时长


239
00:08:37,206 --> 00:08:38,746
你也可以对总时长进行正常化


240
00:08:39,025 --> 00:08:40,106
那么 你可能想知道


241
00:08:40,106 --> 00:08:41,356
我是如何计算


242
00:08:41,356 --> 00:08:43,006
一个会话的播放时长的


243
00:08:43,395 --> 00:08:45,636
答案是通过访问日志


244
00:08:45,636 --> 00:08:46,596
让我们来看看怎么做


245
00:08:47,686 --> 00:08:49,866
这是一段代码


246
00:08:50,806 --> 00:08:52,396
首先 我们从 PlayerItem 中


247
00:08:52,396 --> 00:08:54,126
获得对访问日志的引用


248
00:08:55,096 --> 00:08:57,386
我们迭代访问日志中的事件


249
00:08:57,386 --> 00:08:59,316
并简单地


250
00:08:59,316 --> 00:09:02,156
计算每个


251
00:09:02,156 --> 00:09:02,456
event.durationWatched


252
00:09:02,456 --> 00:09:04,466
就是这样 我们计算了


253
00:09:04,466 --> 00:09:05,406
一个会话的总播放时长


254
00:09:05,936 --> 00:09:07,416
现在你可能会想


255
00:09:07,416 --> 00:09:08,576
这个事件是什么


256
00:09:08,576 --> 00:09:09,946
访问日志中的事件


257
00:09:09,946 --> 00:09:10,456
是什么意思呢


258
00:09:10,726 --> 00:09:12,206
那么 让我们看看


259
00:09:12,206 --> 00:09:14,486
AVPlayerItemAccessLog 是如何工作的


260
00:09:15,306 --> 00:09:16,976
AVPlayerItemAccessLog 提供了


261
00:09:16,976 --> 00:09:18,876
你的会话的历史记录


262
00:09:19,476 --> 00:09:21,196
它最初是 null


263
00:09:21,196 --> 00:09:23,476
但是当播放开始时


264
00:09:23,476 --> 00:09:25,476
你将收到一个


265
00:09:25,476 --> 00:09:27,086
AVPlayerItemNewAccessLogEntry 通知


266
00:09:27,086 --> 00:09:29,396
到那时你将拥有一个访问日志


267
00:09:29,916 --> 00:09:30,946
你将看到


268
00:09:30,946 --> 00:09:33,136
访问日志中的事件


269
00:09:33,856 --> 00:09:36,426
包含关于不同方面的信息


270
00:09:36,426 --> 00:09:38,436
例如 当前变体 URL 当前比特率


271
00:09:38,436 --> 00:09:41,326
播放时长


272
00:09:41,326 --> 00:09:45,636
卡顿次数等等这些值


273
00:09:45,636 --> 00:09:49,326
初始化为负值或 null


274
00:09:49,906 --> 00:09:52,316
当播放开始时


275
00:09:52,316 --> 00:09:53,706
它们会依据实际的测量数据


276
00:09:53,706 --> 00:09:56,406
和正在播放的实际变量 URL 进行更新


277
00:09:56,406 --> 00:09:59,016
两种情况下


278
00:09:59,016 --> 00:10:00,576
我们会向访问日志中添加新事件


279
00:10:00,576 --> 00:10:02,886
一种是变量切换


280
00:10:02,886 --> 00:10:04,916
就像在本例中一样


281
00:10:04,916 --> 00:10:05,806
另一种是播放查找


282
00:10:06,256 --> 00:10:08,056
但是在添加新事件之前


283
00:10:08,126 --> 00:10:10,036
旧的事件不再可变


284
00:10:10,416 --> 00:10:11,926
然后我们才能添加新事件


285
00:10:12,226 --> 00:10:13,606
现在请记住


286
00:10:13,606 --> 00:10:16,066
当播放开始时


287
00:10:16,066 --> 00:10:17,876
这些值会不断更新


288
00:10:17,876 --> 00:10:20,286
所以上一个事件中的值


289
00:10:21,436 --> 00:10:22,976
并不是可观察的属性


290
00:10:25,116 --> 00:10:26,966
我们也提到我们关心的


291
00:10:26,966 --> 00:10:29,466
媒体质量


292
00:10:29,956 --> 00:10:31,566
我们应如何计算它呢


293
00:10:33,376 --> 00:10:35,326
衡量用户


294
00:10:35,326 --> 00:10:36,966
是否获得最好的


295
00:10:36,966 --> 00:10:38,346
媒体质量的一种方法


296
00:10:38,346 --> 00:10:40,136
当然是看视频比特率


297
00:10:40,636 --> 00:10:42,646
这里我们不关心


298
00:10:42,646 --> 00:10:44,416
启动时间或卡顿时长


299
00:10:44,416 --> 00:10:46,026
所以我们把它们去掉


300
00:10:46,396 --> 00:10:47,946
我们还剩下播放状态


301
00:10:48,446 --> 00:10:50,066
在这个例子中


302
00:10:50,066 --> 00:10:52,426
我们看到我们在 2 兆比特的变量上


303
00:10:52,426 --> 00:10:55,536
播放的时间更长


304
00:10:55,576 --> 00:10:56,476
而 1 兆比特的时间更短


305
00:10:57,016 --> 00:10:59,166
按时间加权每一个比特率


306
00:10:59,466 --> 00:11:01,326
我们可以获得一个


307
00:11:01,326 --> 00:11:02,766
视频质量的单一值


308
00:11:02,766 --> 00:11:04,956
并对此在不同的会话中进行比较


309
00:11:06,046 --> 00:11:07,226
我们称这个度量为


310
00:11:07,226 --> 00:11:09,206
时间加权的指示比特率


311
00:11:09,586 --> 00:11:11,706
计算它就像计算


312
00:11:11,836 --> 00:11:14,266
总时长一样简单


313
00:11:15,116 --> 00:11:17,496
再一次 我们获得了


314
00:11:17,496 --> 00:11:19,176
对 PlayerItems 的访问日志的引用


315
00:11:19,546 --> 00:11:21,526
我们迭代日志中的事件


316
00:11:21,846 --> 00:11:23,526
我们也计算了


317
00:11:23,526 --> 00:11:25,026
相对于我们之前计算过的


318
00:11:25,026 --> 00:11:26,936
totalDurationWatched 的每个事件的


319
00:11:26,936 --> 00:11:29,396
时间权重 最后


320
00:11:29,586 --> 00:11:31,126
我们计算得出了加权比特率值


321
00:11:31,526 --> 00:11:33,036
现在请记住


322
00:11:33,036 --> 00:11:35,546
有些属性可能没有初始化


323
00:11:35,546 --> 00:11:36,516
所以在代码中


324
00:11:36,516 --> 00:11:39,206
应进行适当的检查


325
00:11:41,076 --> 00:11:44,286
另一个你绝对应该跟踪的事件


326
00:11:44,376 --> 00:11:45,306
当然是播放失败


327
00:11:45,866 --> 00:11:47,526
为此 你需要观察


328
00:11:47,526 --> 00:11:48,796
AVPlayerItem.status


329
00:11:49,646 --> 00:11:51,256
如果它的值更改为 false


330
00:11:51,256 --> 00:11:52,986
则意味着 AVPlayer


331
00:11:52,986 --> 00:11:54,746
遇到不可恢复的错误


332
00:11:55,666 --> 00:11:56,926
有没有将这种观察


333
00:11:56,926 --> 00:11:58,576
转换成 KPI 的好方法呢


334
00:11:59,736 --> 00:12:02,856
一种方法是


335
00:12:03,026 --> 00:12:04,636
观察失败的会话


336
00:12:04,636 --> 00:12:06,526
占总会话的百分比


337
00:12:06,526 --> 00:12:07,436
但是可能


338
00:12:07,436 --> 00:12:08,206
还有其他的方法


339
00:12:08,856 --> 00:12:10,636
这里我想强调的一点是


340
00:12:10,636 --> 00:12:12,596
并非你的流中的


341
00:12:12,596 --> 00:12:14,246
所有错误都是致命的


342
00:12:14,376 --> 00:12:16,316
有些可能会影响媒体质量


343
00:12:16,536 --> 00:12:18,066
而有些错误


344
00:12:18,066 --> 00:12:19,386
用户甚至可能无法察觉


345
00:12:19,676 --> 00:12:21,046
但是尽管如此


346
00:12:21,046 --> 00:12:23,806
如果存在错误


347
00:12:23,806 --> 00:12:25,656
它们就反映了你的流存在问题


348
00:12:25,876 --> 00:12:29,286
那么 我该如何深入了解


349
00:12:29,286 --> 00:12:30,626
流中出现了什么问题呢


350
00:12:31,176 --> 00:12:32,986
答案就来自


351
00:12:32,986 --> 00:12:34,586
PlayerItemErrorLog


352
00:12:35,436 --> 00:12:37,046
AVPlayerItemErrorLog


353
00:12:37,156 --> 00:12:38,756
错误日志记录了


354
00:12:38,756 --> 00:12:40,636
对用户造成不同程度影响的错误


355
00:12:41,136 --> 00:12:43,626
它的工作方式


356
00:12:43,836 --> 00:12:45,446
与访问日志类似


357
00:12:45,446 --> 00:12:47,426
只是事件表示错误


358
00:12:47,426 --> 00:12:48,806
而不是播放器的访问状态


359
00:12:49,936 --> 00:12:52,766
它们涉及很多方面


360
00:12:52,766 --> 00:12:54,586
如交付问题 网络问题


361
00:12:54,586 --> 00:12:57,476
内容编写错误等等


362
00:12:57,666 --> 00:12:59,476
例如 它们可以让你了解


363
00:12:59,476 --> 00:13:01,076
发生卡顿的原因


364
00:13:01,076 --> 00:13:03,296
比如媒体文件


365
00:13:03,296 --> 00:13:05,286
在大约 10 秒内没有响应


366
00:13:05,886 --> 00:13:09,126
我们之前讨论了


367
00:13:09,126 --> 00:13:11,006
你可以在每次会话中跟踪的启动时间


368
00:13:11,646 --> 00:13:12,876
我们建议你查看一下


369
00:13:12,876 --> 00:13:14,256
你的 App 的


370
00:13:14,286 --> 00:13:15,666
启动时间分布


371
00:13:16,346 --> 00:13:18,086
我们还讨论了卡顿的发生


372
00:13:18,086 --> 00:13:19,906
以及卡顿时长


373
00:13:20,926 --> 00:13:22,356
我们也提到了


374
00:13:22,436 --> 00:13:23,816
时间加权表示的比特率


375
00:13:23,816 --> 00:13:25,716
可以很好地表示


376
00:13:25,716 --> 00:13:27,946
整个会话的媒体质量


377
00:13:27,946 --> 00:13:29,526
最后 你可能希望


378
00:13:29,526 --> 00:13:30,916
尽可能降低


379
00:13:30,916 --> 00:13:32,806
失败会话的百分比


380
00:13:36,716 --> 00:13:39,066
请记住 并非所有的 KPI


381
00:13:39,066 --> 00:13:41,606
都可以在会话中进行比较


382
00:13:42,246 --> 00:13:44,256
一个例子就是


383
00:13:44,256 --> 00:13:46,476
AVPlayerFoundation


384
00:13:46,476 --> 00:13:48,696
使用屏幕上的 AVPlayer 层大小


385
00:13:48,916 --> 00:13:51,116
来评估 HLS 的模糊变体


386
00:13:51,686 --> 00:13:53,246
例如 


387
00:13:53,336 --> 00:13:55,556
如果你有 10 个 ATP 的内容


388
00:13:55,556 --> 00:13:57,486
它可能不会显示在 200 像素的视图上


389
00:13:57,486 --> 00:13:58,856
但这并不意味着


390
00:13:58,856 --> 00:14:01,486
用户体验了很差的图像质量


391
00:14:02,026 --> 00:14:03,826
接下怎么做


392
00:14:03,966 --> 00:14:05,366
我们建议你


393
00:14:05,366 --> 00:14:07,276
收集附加的上下文信息


394
00:14:07,346 --> 00:14:08,886
以及流化度量


395
00:14:09,466 --> 00:14:10,876
这将允许你


396
00:14:10,926 --> 00:14:12,556
稍后在对 App 


397
00:14:12,776 --> 00:14:14,296
有意义的类中


398
00:14:14,296 --> 00:14:15,106
对回放会话进行分区


399
00:14:16,396 --> 00:14:18,726
作为 HLS 目录示例的一部分


400
00:14:18,726 --> 00:14:20,306
本节的示例代码


401
00:14:20,306 --> 00:14:21,786
可在 Apple 开发人员


402
00:14:21,786 --> 00:14:23,136
网站上获得


403
00:14:24,276 --> 00:14:26,776
现在 请允许我欢迎 Zhenheng Li


404
00:14:26,776 --> 00:14:28,026
她将与你们讨论


405
00:14:28,026 --> 00:14:29,636
如何提高 HLS 的性能


406
00:14:29,636 --> 00:14:29,976
谢谢大家


407
00:14:30,516 --> 00:14:34,666
[ 掌声 ]


408
00:14:35,166 --> 00:14:43,626
>> 谢谢 Emil 大家好


409
00:14:43,736 --> 00:14:44,816
我是 Zhenheng


410
00:14:45,376 --> 00:14:50,236
我们已经讨论了


411
00:14:50,556 --> 00:14:52,636
所有用户最关心的 KPI


412
00:14:53,256 --> 00:14:55,166
在这部分的讨论中


413
00:14:55,246 --> 00:14:57,076
我们将着重探讨如何


414
00:14:57,076 --> 00:14:57,416
改进这些 API


415
00:14:57,456 --> 00:15:00,376
我们将在三个方面进行更深入的研究


416
00:15:00,976 --> 00:15:04,036
第一 如何减少启动时间


417
00:15:05,136 --> 00:15:07,486
第二 如何调查和


418
00:15:07,486 --> 00:15:08,346
避免卡顿


419
00:15:09,186 --> 00:15:11,736
第三 如何调查和


420
00:15:11,736 --> 00:15:12,906
避免错误


421
00:15:13,506 --> 00:15:14,276
让我们开始吧


422
00:15:15,756 --> 00:15:18,166
什么可以导致播放延迟开始呢


423
00:15:19,006 --> 00:15:20,596
下面是用户


424
00:15:20,596 --> 00:15:23,056
从点按播放键


425
00:15:23,056 --> 00:15:25,536
到视频开始的操作示例


426
00:15:27,096 --> 00:15:28,606
App 创建每个资源


427
00:15:28,606 --> 00:15:31,026
并开始对资源进行检查


428
00:15:31,026 --> 00:15:33,756
以确定资源的时长


429
00:15:34,146 --> 00:15:37,226
和可授予的媒体选项


430
00:15:38,106 --> 00:15:40,016
下载主播放列表


431
00:15:40,516 --> 00:15:42,526
和 [ 音质不清晰 ] 播放列表


432
00:15:42,526 --> 00:15:44,946
需要在设备和


433
00:15:45,136 --> 00:15:47,656
内容服务器之间来回运行几次


434
00:15:48,606 --> 00:15:53,696
然后 App 会创建 AVPlayer 和 AVPlayerItem


435
00:15:54,646 --> 00:15:55,426
开始缓冲


436
00:15:56,966 --> 00:15:59,096
有时 缓冲会被中断


437
00:15:59,096 --> 00:16:01,716
内容被加密


438
00:16:02,606 --> 00:16:04,386
它需要在设备


439
00:16:04,436 --> 00:16:06,216
和密钥服务器之间


440
00:16:06,216 --> 00:16:07,846
进行几次往返


441
00:16:07,846 --> 00:16:08,776
以获取解密密钥


442
00:16:09,576 --> 00:16:11,256
一旦密钥被获取


443
00:16:12,876 --> 00:16:14,306
缓冲便会恢复


444
00:16:15,046 --> 00:16:17,756
然而 它也可能再次被中断


445
00:16:18,346 --> 00:16:20,846
假设这个 App 提供了一个特性


446
00:16:20,936 --> 00:16:22,986
可以从之前播放的


447
00:16:22,986 --> 00:16:24,506
断点处恢复


448
00:16:25,546 --> 00:16:27,816
App 为用户


449
00:16:27,816 --> 00:16:28,876
在播放器上


450
00:16:28,916 --> 00:16:31,116
设置一个 sic 时间[ 音质不清晰 ]


451
00:16:32,096 --> 00:16:34,366
播放器将丢弃


452
00:16:34,366 --> 00:16:36,396
现有的缓冲区


453
00:16:36,396 --> 00:16:37,966
并从新的位置开始下载


454
00:16:38,656 --> 00:16:39,856
第 100 个片段


455
00:16:41,776 --> 00:16:43,516
它还可能再一次被打断


456
00:16:44,026 --> 00:16:47,246
用户在 App 中


457
00:16:47,326 --> 00:16:49,356
拥有语言首选项设置


458
00:16:50,186 --> 00:16:52,316
她或他更喜欢西班牙语


459
00:16:53,226 --> 00:16:56,966
因此 App 在 PlayerItem 上


460
00:16:57,996 --> 00:16:59,656
设置 MediaSelection


461
00:16:59,656 --> 00:17:01,906
丢弃现有的音频缓冲区


462
00:17:01,906 --> 00:17:05,266
播放器开始下载不同的语言变量


463
00:17:05,266 --> 00:17:08,736
几秒钟后


464
00:17:08,736 --> 00:17:11,965
PlayerItem 通知 isPlaybackLikeToKeepUp


465
00:17:11,996 --> 00:17:14,626
App 设置一个速率


466
00:17:15,376 --> 00:17:17,746
播放开始 并从断点继续


467
00:17:18,465 --> 00:17:20,856
这一段时间 用户都在等待


468
00:17:22,165 --> 00:17:28,266
所以正如我们所看到的启动


469
00:17:28,266 --> 00:17:30,686
以及在设备 内容服务器


470
00:17:31,076 --> 00:17:33,436
和密钥服务器之间运行


471
00:17:33,896 --> 00:17:34,796
还有 AVPlayer 和


472
00:17:35,326 --> 00:17:37,726
App 之间的往返


473
00:17:37,726 --> 00:17:39,556
均需要一些耗时的操作


474
00:17:40,156 --> 00:17:42,236
通常 AVPlayer 和 App


475
00:17:42,236 --> 00:17:43,266
在不同的进程中


476
00:17:44,446 --> 00:17:46,176
那么 App 如何


477
00:17:46,516 --> 00:17:48,506
测量时间成本和启动时间呢


478
00:17:49,536 --> 00:17:52,776
它可以测量在 API 调用


479
00:17:52,776 --> 00:17:55,426
与 Player/PlayerItem


480
00:17:55,426 --> 00:17:56,936
状态更改通知之间


481
00:17:57,156 --> 00:17:58,916
所花费的时间


482
00:17:59,516 --> 00:18:02,836
每个 PlayerItem 也提供


483
00:18:02,936 --> 00:18:05,546
访问日志中的启动时间


484
00:18:06,146 --> 00:18:09,416
这个时间是


485
00:18:09,456 --> 00:18:11,986
由 AVPlayeritem 测量的


486
00:18:11,986 --> 00:18:13,476
只表示缓存的时间


487
00:18:14,506 --> 00:18:15,816
它从开始媒体下载时开始测量


488
00:18:15,816 --> 00:18:17,896
并在第一个播放


489
00:18:17,896 --> 00:18:20,376
被选定开始时结束


490
00:18:21,676 --> 00:18:23,366
我们的用户希望视频快速启动


491
00:18:23,366 --> 00:18:26,876
最多几秒钟内完成


492
00:18:27,366 --> 00:18:29,546
有很多方法可以做到这一点


493
00:18:30,236 --> 00:18:33,606
一种方法是


494
00:18:33,606 --> 00:18:36,006
我们可以在用户点按播放键之前


495
00:18:36,826 --> 00:18:39,886
将一些操作移动到另一个阶段


496
00:18:40,676 --> 00:18:43,776
例如 可以将 AV 资源创建


497
00:18:44,556 --> 00:18:46,266
和检查移出


498
00:18:46,966 --> 00:18:50,376
密钥获取可以被移出


499
00:18:51,756 --> 00:18:54,456
因此 当用户开始视频播放时


500
00:18:54,456 --> 00:18:58,616
等待的时间会更少


501
00:18:59,296 --> 00:19:00,886
那么我们将这些操作


502
00:19:00,886 --> 00:19:01,866
移到哪里呢


503
00:19:03,916 --> 00:19:06,156
当你的用户正在查看


504
00:19:06,156 --> 00:19:09,286
视频目录或视频信息时


505
00:19:09,776 --> 00:19:11,336
在用户决定播放之前


506
00:19:12,356 --> 00:19:15,026
就可以提前


507
00:19:15,026 --> 00:19:17,696
创建并检查 AV 资源了


508
00:19:17,916 --> 00:19:19,926
去年我们引入了


509
00:19:19,926 --> 00:19:21,446
AVContentKeySession 的 API


510
00:19:22,346 --> 00:19:25,646
这个新的 API 将媒体负载


511
00:19:25,646 --> 00:19:27,056
与密钥获取分离开来


512
00:19:27,596 --> 00:19:29,836
它为 App 提供了


513
00:19:29,836 --> 00:19:31,326
对密钥管理的全面控制


514
00:19:31,926 --> 00:19:35,336
它提供了优化密钥获取的方法


515
00:19:35,336 --> 00:19:39,316
例如将多个密钥请求打包回


516
00:19:39,816 --> 00:19:40,686
密钥服务器


517
00:19:41,566 --> 00:19:43,346
如果你碰巧采用


518
00:19:43,346 --> 00:19:45,906
AVContentKeySession


519
00:19:45,906 --> 00:19:47,686
并花费几个小时的工程时间


520
00:19:48,566 --> 00:19:50,886
你的用户将会注意到


521
00:19:50,886 --> 00:19:52,356
启动时间变得更快


522
00:19:53,476 --> 00:19:56,136
现在我们已经将创建 AV 资源


523
00:19:56,186 --> 00:19:58,436
和密钥获取的工作


524
00:19:58,436 --> 00:19:59,316
从启动时间中移出


525
00:19:59,896 --> 00:20:03,256
那么剩下的主要是


526
00:20:03,306 --> 00:20:05,906
AVPlayerItem 缓冲时间


527
00:20:05,906 --> 00:20:08,576
以及 AVPlayer


528
00:20:08,576 --> 00:20:10,286
和 App 之间的通信时间


529
00:20:11,356 --> 00:20:14,686
通常情况下 


530
00:20:14,906 --> 00:20:18,266
由于播放查找或媒体选项等等因素


531
00:20:19,176 --> 00:20:20,346
App 可以避免缓冲


532
00:20:20,906 --> 00:20:24,036
我们甚至可以尝试


533
00:20:24,036 --> 00:20:26,736
减少播放器


534
00:20:26,736 --> 00:20:28,136
和 App 之间的往返次数


535
00:20:29,186 --> 00:20:31,646
这样 启动时间将进一步减少


536
00:20:33,056 --> 00:20:33,806
我们来看一下


537
00:20:34,386 --> 00:20:38,386
当你创建 AVPlayerItem 时


538
00:20:38,996 --> 00:20:42,246
如果你知道


539
00:20:42,246 --> 00:20:44,016
用户打算在哪里开始回放


540
00:20:45,056 --> 00:20:47,176
请设置 PlayerItem 上的当前时间


541
00:20:47,846 --> 00:20:49,106
如果你知道媒体选项


542
00:20:49,106 --> 00:20:51,476
都是如何设置的


543
00:20:51,476 --> 00:20:53,966
比如要下载哪一种语言进行播放


544
00:20:53,966 --> 00:20:56,956
那么在你将 AVPlayerItem 放置到


545
00:20:56,956 --> 00:20:58,906
播放器上之前也要设置它


546
00:20:59,806 --> 00:21:01,456
AVPlayer 也是如此


547
00:21:02,006 --> 00:21:03,946
一旦用户点按播放键


548
00:21:05,106 --> 00:21:07,336
在为 AVPlayerItem


549
00:21:07,336 --> 00:21:11,406
开始下载之前设置速率


550
00:21:12,086 --> 00:21:13,496
因此 只要 PlayerItem


551
00:21:13,496 --> 00:21:16,586
有足够的内容播放


552
00:21:16,586 --> 00:21:18,176
播放就会自动开始


553
00:21:19,016 --> 00:21:22,386
总而言之


554
00:21:22,646 --> 00:21:23,366
即在缓冲之前设置 AVPlayer


555
00:21:24,486 --> 00:21:27,476
在将 PlayerItem 设置到播放器之前


556
00:21:28,366 --> 00:21:31,646
设置 AVPlayer速率


557
00:21:31,696 --> 00:21:36,096
很多 App 都提供了一个特性


558
00:21:36,096 --> 00:21:38,626
即允许用户


559
00:21:39,176 --> 00:21:41,696
选择多个视频


560
00:21:41,746 --> 00:21:43,936
然后一个接一个地播放


561
00:21:43,936 --> 00:21:45,576
比如狂热地观看电视节目


562
00:21:46,756 --> 00:21:48,636
我们已经看到了


563
00:21:48,636 --> 00:21:50,986
例如每个视频分配一个播放器和一个 PlayerItem


564
00:21:50,986 --> 00:21:52,266
的这种实现


565
00:21:52,846 --> 00:21:54,616
每个新视频都


566
00:21:54,746 --> 00:21:57,036
需要一个启动缓冲时间


567
00:21:57,706 --> 00:21:59,686
你可以使用 AVQueuePlayer


568
00:22:00,236 --> 00:22:02,956
以减少新视频的


569
00:22:02,956 --> 00:22:03,936
缓冲时间


570
00:22:05,576 --> 00:22:07,916
创建多个 PlayerItem


571
00:22:08,426 --> 00:22:10,706
将它们全部包含在播放队列中


572
00:22:11,256 --> 00:22:14,356
在播放器


573
00:22:14,356 --> 00:22:17,796
播放当前项目的过程中


574
00:22:17,796 --> 00:22:19,186
当媒体下载结束时


575
00:22:19,186 --> 00:22:22,246
播放器将开始


576
00:22:22,246 --> 00:22:23,626
下载下一个项目


577
00:22:24,226 --> 00:22:26,016
同时当前项目仍在播放


578
00:22:27,346 --> 00:22:30,666
因此 一旦当前事件


579
00:22:30,666 --> 00:22:32,656
播放到最后


580
00:22:32,706 --> 00:22:34,916
下一个 PlayerItem 将立即开始播放


581
00:22:35,526 --> 00:22:39,446
因此一定要使用 AVQueuePlayer


582
00:22:39,446 --> 00:22:42,086
来播放多个项目


583
00:22:42,086 --> 00:22:44,826
并提前将第二个 AVPlayerItem 编入队列


584
00:22:47,406 --> 00:22:48,266
那么还剩下些什么呢


585
00:22:49,516 --> 00:22:50,266
缓冲时间


586
00:22:51,446 --> 00:22:55,086
首先 什么决定了网络缓冲时间


587
00:22:55,696 --> 00:22:56,566
有四个因素


588
00:22:57,796 --> 00:23:00,886
变量的选择


589
00:23:01,136 --> 00:23:04,556
内容的比特率


590
00:23:04,556 --> 00:23:06,696
播放列表目标时长


591
00:23:06,696 --> 00:23:09,276
当然还有 网络带宽


592
00:23:09,806 --> 00:23:13,706
让我们看几个


593
00:23:13,706 --> 00:23:14,776
缓冲时间的例子


594
00:23:16,286 --> 00:23:19,016
首先 这是一个简单的主播放列表


595
00:23:19,396 --> 00:23:22,236
它将一个 ATP 视频


596
00:23:22,236 --> 00:23:24,386
设置在 5 mbps 左右的下载速度


597
00:23:24,386 --> 00:23:26,656
假设网络带宽


598
00:23:26,656 --> 00:23:28,986
在 6 mbps 左右


599
00:23:28,986 --> 00:23:31,896
我们的目标时长是 10 秒


600
00:23:32,886 --> 00:23:35,116
在大多数情况下


601
00:23:35,186 --> 00:23:38,556
PlayerItem 会在通知播放


602
00:23:39,446 --> 00:23:41,216
需要开始之前


603
00:23:41,216 --> 00:23:42,526
缓冲一个片段


604
00:23:42,636 --> 00:23:46,336
然而 相同的主播放列表


605
00:23:46,336 --> 00:23:48,816
在几乎相同的网络条件下


606
00:23:48,816 --> 00:23:51,676
用户可能会


607
00:23:51,676 --> 00:23:54,246
观察到较慢的启动


608
00:23:55,996 --> 00:23:58,216
请记住 原因是


609
00:23:58,216 --> 00:24:00,256
网络带宽改变


610
00:24:00,256 --> 00:24:02,366
内容比特率也会改变


611
00:24:02,776 --> 00:24:04,506
在这种情况下


612
00:24:04,506 --> 00:24:06,176
有一些片段需要更长的时间来下载


613
00:24:06,566 --> 00:24:08,106
因此播放器需要更久的时间来启动


614
00:24:09,086 --> 00:24:11,946
要解决这个问题


615
00:24:13,286 --> 00:24:14,916
提供一个低比特率的变量


616
00:24:14,916 --> 00:24:15,236
可能会有所帮助


617
00:24:16,896 --> 00:24:19,936
播放器就可以选择


618
00:24:20,426 --> 00:24:23,586
调低比特率并更快启动


619
00:24:24,336 --> 00:24:26,056
当其他信息均缺失时


620
00:24:26,056 --> 00:24:29,026
所列出的第一个变量


621
00:24:29,026 --> 00:24:30,946
将是你的启动变量


622
00:24:31,586 --> 00:24:35,536
在这个例子中 有两个变量


623
00:24:36,216 --> 00:24:37,466
在相同的网络条件下


624
00:24:37,506 --> 00:24:40,106
首先列出较低比特率的变量


625
00:24:40,636 --> 00:24:43,666
播放器将会启动更快


626
00:24:45,196 --> 00:24:50,086
并且在网络带宽


627
00:24:50,086 --> 00:24:52,646
足够的情况下快速切换


628
00:24:53,936 --> 00:24:58,466
总之 为了减少网络缓冲时间


629
00:24:58,466 --> 00:25:00,306
我们应该明智地


630
00:25:00,306 --> 00:25:01,736
选择初始变量


631
00:25:02,936 --> 00:25:04,516
更低的内容比特率


632
00:25:05,266 --> 00:25:07,676
意味着更短的缓冲时间


633
00:25:07,676 --> 00:25:09,826
但也同时是视频质量的折衷


634
00:25:11,406 --> 00:25:13,486
如果你正在提供


635
00:25:13,486 --> 00:25:16,366
多种媒体格式


636
00:25:16,496 --> 00:25:19,646
例如 HDR 和 SDR 视频


637
00:25:19,646 --> 00:25:22,976
或者立体声音频和多声道音频


638
00:25:22,976 --> 00:25:26,276
请确保每种媒体格式的初始版本


639
00:25:26,316 --> 00:25:29,246
都处于类似的比特率级别


640
00:25:29,246 --> 00:25:32,216
以便你的用户


641
00:25:32,216 --> 00:25:33,706
将拥有类似的体验


642
00:25:34,066 --> 00:25:36,166
无论他们进行


643
00:25:36,166 --> 00:25:37,826
何种类型的观看设置


644
00:25:38,536 --> 00:25:42,216
这就是我要讲的关于减少启动时间的内容


645
00:25:42,746 --> 00:25:43,926
我们的视频已经开始播放了


646
00:25:45,556 --> 00:25:47,566
现在我们来谈谈卡顿


647
00:25:48,526 --> 00:25:51,186
需要明确的是


648
00:25:51,186 --> 00:25:53,396
尤其是当网络带宽特别低的时候


649
00:25:53,396 --> 00:25:55,456
卡顿就可能发生


650
00:25:56,176 --> 00:25:58,116
所以在这部分的演讲中


651
00:25:58,116 --> 00:25:59,796
让我们关注如何调查卡顿


652
00:25:59,906 --> 00:26:03,636
以及如何改进 或避免卡顿


653
00:26:04,196 --> 00:26:08,696
App 是如何调查卡顿的呢


654
00:26:09,246 --> 00:26:12,616
App 应该一直在


655
00:26:12,616 --> 00:26:14,416
监听卡顿通知


656
00:26:16,296 --> 00:26:20,286
App 也应该检查


657
00:26:20,286 --> 00:26:23,096
AVPlayer.status 


658
00:26:23,456 --> 00:26:27,546
例如 isPlayBackLikelyToKeepUp


659
00:26:27,546 --> 00:26:30,106
AVPlayerItem 还提供


660
00:26:30,106 --> 00:26:32,006
错误日志和访问日志


661
00:26:32,576 --> 00:26:33,666
当暂停发生时


662
00:26:33,906 --> 00:26:37,846
App 应该时刻关注


663
00:26:37,846 --> 00:26:38,996
对那些日志的检查


664
00:26:39,546 --> 00:26:43,896
接下来让我们看两个卡顿的例子


665
00:26:44,716 --> 00:26:49,096
首先 App 已收到了卡顿通知


666
00:26:49,616 --> 00:26:51,956
也应该收到了


667
00:26:52,076 --> 00:26:54,116
错误日志


668
00:26:55,126 --> 00:26:58,236
错误注释会告诉你


669
00:26:58,396 --> 00:27:00,886
所发生的事情的详细信息


670
00:27:01,456 --> 00:27:03,266
在这种情况下它的记录是


671
00:27:03,266 --> 00:27:05,206
“15 秒内未收到媒体文件”


672
00:27:06,406 --> 00:27:09,056
App 检查访问日志


673
00:27:09,056 --> 00:27:12,286
以找出发生卡顿时


674
00:27:12,346 --> 00:27:14,856
AVPlayer 正在播放的内容


675
00:27:15,846 --> 00:27:17,886
它会记录详细的信息


676
00:27:17,886 --> 00:27:20,046
比如播放器


677
00:27:20,046 --> 00:27:23,186
正在播放什么内容以及 URI


678
00:27:24,506 --> 00:27:26,036
indicatedBitrate 指的是


679
00:27:26,036 --> 00:27:27,046
内容比特率


680
00:27:27,416 --> 00:27:30,656
这里具体是 36 mbps


681
00:27:30,656 --> 00:27:31,756
它是一个 4K 内容


682
00:27:32,606 --> 00:27:35,166
observedBitrate 指的是


683
00:27:35,356 --> 00:27:36,766
当前的网络带宽


684
00:27:37,066 --> 00:27:39,616
这里具体是 2.8 mbps


685
00:27:40,236 --> 00:27:45,276
显然网络带宽跟不上


686
00:27:45,316 --> 00:27:47,286
内容比特率


687
00:27:47,916 --> 00:27:50,536
所以要处理变化的网络情况


688
00:27:50,536 --> 00:27:53,686
请记得提供一套


689
00:27:53,686 --> 00:27:54,706
完整的比特率层


690
00:27:55,226 --> 00:27:57,436
你的一些用户的网络


691
00:27:57,436 --> 00:27:58,966
可能连接较慢


692
00:27:58,966 --> 00:28:01,336
或者你的用户可能正忙


693
00:28:01,336 --> 00:28:03,306
比如在查看视频时


694
00:28:03,596 --> 00:28:04,886
使用蜂窝网络


695
00:28:05,746 --> 00:28:07,236
如果你提供多种视频


696
00:28:07,236 --> 00:28:09,846
和多种媒体格式


697
00:28:10,616 --> 00:28:12,216
那么每个编解码组合


698
00:28:12,216 --> 00:28:15,826
都需要自己的一组层


699
00:28:16,806 --> 00:28:20,166
并不是所有的卡顿


700
00:28:20,166 --> 00:28:21,096
都是由于网络环境造成的


701
00:28:22,356 --> 00:28:23,416
让我们来看看这个


702
00:28:24,536 --> 00:28:26,986
卡顿发生了


703
00:28:26,986 --> 00:28:28,486
然而错误日志中却有了不同的记录


704
00:28:29,786 --> 00:28:32,756
“播放列表文件


705
00:28:32,756 --> 00:28:34,956
连续两次没有改变”


706
00:28:35,976 --> 00:28:37,976
如果你在那个时候检查访问日志


707
00:28:37,976 --> 00:28:40,986
播放器正在线播放


708
00:28:42,336 --> 00:28:44,456
indicatedBitrate 很低


709
00:28:44,996 --> 00:28:48,296
内容比特率是 400 kbps


710
00:28:48,296 --> 00:28:51,546
而网络带宽是 3.7 mbps


711
00:28:51,956 --> 00:28:53,646
这看起来像是一个


712
00:28:53,646 --> 00:28:54,586
内容交付问题


713
00:28:57,016 --> 00:28:59,156
因此 为了减少或避免


714
00:28:59,156 --> 00:29:01,696
由于内容交付而造成的卡顿


715
00:29:01,696 --> 00:29:04,626
内容服务器和 CDN


716
00:29:04,626 --> 00:29:07,166
必须无延迟地


717
00:29:07,166 --> 00:29:08,246
交付媒体文件 片段和密钥


718
00:29:09,196 --> 00:29:11,776
至少每一个目标时长


719
00:29:11,776 --> 00:29:15,446
更新实时播放列表 CDN 缓存


720
00:29:15,666 --> 00:29:17,576
必须加以配置


721
00:29:17,576 --> 00:29:22,416
以交付最新的播放列表 避免过时


722
00:29:22,466 --> 00:29:26,086
同步播放列表之间的不连续序号


723
00:29:27,996 --> 00:29:29,466
使用正确的 HTTP 状态代码


724
00:29:29,466 --> 00:29:33,096
进而清楚地指示服务器端失败


725
00:29:35,416 --> 00:29:36,856
这就是所有关于卡顿的内容


726
00:29:37,336 --> 00:29:38,026
那么错误又是怎么回事


727
00:29:39,206 --> 00:29:42,066
我们应该如何调查错误呢


728
00:29:42,066 --> 00:29:44,746
有几种方法可供选择


729
00:29:45,906 --> 00:29:49,346
我们有来自 AVPlayerItem 的


730
00:29:49,346 --> 00:29:51,226
错误日志和访问日志


731
00:29:52,186 --> 00:29:55,486
我们也有来自


732
00:29:55,486 --> 00:29:57,196
每个 Player 和


733
00:29:57,516 --> 00:30:00,506
PlayerItem 的错误属性


734
00:30:02,016 --> 00:30:04,066
此外 我们还为你们提供了


735
00:30:04,066 --> 00:30:06,176
一些媒体验证工具


736
00:30:06,486 --> 00:30:08,926
来检测内容问题


737
00:30:09,536 --> 00:30:11,076
让我们一个一个地看


738
00:30:11,686 --> 00:30:15,086
AVPlayerItemErrorLog


739
00:30:15,086 --> 00:30:17,696
Emil 对此已经与我们讨论了一些 


740
00:30:19,146 --> 00:30:21,056
这种类型的错误日志


741
00:30:21,056 --> 00:30:22,906
表明网络或


742
00:30:22,906 --> 00:30:25,186
内容格式存在问题


743
00:30:25,746 --> 00:30:28,136
然而这些问题并不总是致命的


744
00:30:28,726 --> 00:30:31,666
当错误被指示出来时


745
00:30:31,856 --> 00:30:33,406
播放可能是完全


746
00:30:33,626 --> 00:30:34,446
没问题的


747
00:30:36,516 --> 00:30:40,356
但是 App 显示了在错误注释中的检查结果


748
00:30:40,706 --> 00:30:42,796
以查找更多的细节


749
00:30:42,796 --> 00:30:46,486
比如这个我们之前见过的


750
00:30:46,486 --> 00:30:48,766
“15 秒内未收到媒体文件”


751
00:30:49,476 --> 00:30:54,286
这表明你的用户可能已经


752
00:30:54,286 --> 00:30:55,096
或者即将观察到卡顿


753
00:30:56,916 --> 00:31:00,206
下一个是 HTTP 错误


754
00:31:00,206 --> 00:31:01,336
它记录“文件没有找到”


755
00:31:01,916 --> 00:31:03,716
这表明了


756
00:31:03,716 --> 00:31:04,566
内容交付的问题


757
00:31:05,376 --> 00:31:07,696
用户可能会观察到音频丢失或视频丢失 


758
00:31:07,916 --> 00:31:13,926
甚至同时观察到这两者


759
00:31:13,926 --> 00:31:15,516
[ 音质不清晰 ] 变量的


760
00:31:15,516 --> 00:31:16,206
指定带宽


761
00:31:16,576 --> 00:31:17,836
这个很有趣


762
00:31:18,096 --> 00:31:19,856
它指示了卡顿的风险


763
00:31:20,236 --> 00:31:22,546
然而当错误被指示时


764
00:31:22,616 --> 00:31:25,296
播放可能没有问题


765
00:31:25,836 --> 00:31:28,336
它意味着


766
00:31:28,336 --> 00:31:30,466
某些片段的比特率


767
00:31:30,466 --> 00:31:32,556
比主播放列表中指定的比特率要高


768
00:31:32,996 --> 00:31:36,276
最后一个例子


769
00:31:37,046 --> 00:31:39,626
加密格式错误 “不支持的加密格式”


770
00:31:40,026 --> 00:31:42,316
这可能指示了一个


771
00:31:42,316 --> 00:31:43,926
播放失败


772
00:31:44,816 --> 00:31:47,926
当我们有 AVPlayer 和 PlayerItem 的错误时


773
00:31:47,926 --> 00:31:49,556
所有列出的这些


774
00:31:49,556 --> 00:31:52,006
以及这里没有提到的


775
00:31:52,006 --> 00:31:54,966
其他错误信息 都非常有用


776
00:31:55,816 --> 00:31:57,046
让我们看一下


777
00:31:59,016 --> 00:32:00,476
App 应该观察


778
00:32:01,076 --> 00:32:03,476
AVPlayerItem.status


779
00:32:04,006 --> 00:32:05,576
和 AVPlayerItem 的错误属性


780
00:32:05,576 --> 00:32:08,086
以查找此类错误


781
00:32:09,146 --> 00:32:10,816
这些便是致命错误


782
00:32:11,916 --> 00:32:13,056
当错误被指示


783
00:32:13,406 --> 00:32:15,106
且播放已经终止时


784
00:32:15,106 --> 00:32:17,586
我们该怎么办呢


785
00:32:18,306 --> 00:32:19,626
我们如何找出原因


786
00:32:20,206 --> 00:32:22,016
这有一个例子


787
00:32:22,806 --> 00:32:24,576
App 观察到


788
00:32:24,986 --> 00:32:27,706
PlayerItem.status 


789
00:32:27,706 --> 00:32:29,346
已经改成失败状态


790
00:32:30,286 --> 00:32:35,636
然后 App 对 AVPlayer 的错误属性


791
00:32:35,636 --> 00:32:37,766
和 AVPlayerItem的 错误日志


792
00:32:37,766 --> 00:32:39,416
进行检查


793
00:32:41,376 --> 00:32:45,766
这个就是


794
00:32:45,766 --> 00:32:46,716
PlayerItem 的错误属性


795
00:32:47,146 --> 00:32:49,056
它提供了一些有用的信息


796
00:32:50,206 --> 00:32:52,296
来自于 AVFoundationErrorDomain 的


797
00:32:52,296 --> 00:32:53,026
错误代码


798
00:32:53,746 --> 00:32:56,536
它还提供了一些提示


799
00:32:56,536 --> 00:32:59,246
检查了 AVPlayerItem 的


800
00:32:59,246 --> 00:33:00,516
错误日志


801
00:33:01,526 --> 00:33:05,446
相对应的 AVPlayer 错误日志


802
00:33:05,446 --> 00:33:07,766
可以提供更多细节


803
00:33:08,506 --> 00:33:10,706
它会告诉你日期 时间


804
00:33:10,706 --> 00:33:13,786
以及在什么 URI 上


805
00:33:13,786 --> 00:33:14,396
有什么类型的错误


806
00:33:14,396 --> 00:33:18,066
在这里错误是“不支持的加密格式”


807
00:33:19,056 --> 00:33:22,226
它还告诉你


808
00:33:22,566 --> 00:33:24,496
当发生错误时


809
00:33:24,606 --> 00:33:29,356
设备处于哪种类型的网络接口


810
00:33:29,606 --> 00:33:31,776
下一种错误类型 HDCP


811
00:33:33,006 --> 00:33:34,796
如果你正在提供


812
00:33:34,796 --> 00:33:38,086
需要 HDCP 保护的内容


813
00:33:38,086 --> 00:33:39,666
你的 App 应该注意


814
00:33:39,666 --> 00:33:43,186
这个十分长的属性名


815
00:33:43,736 --> 00:33:45,776
IsOutputObscuredDueTo


816
00:33:46,076 --> 00:33:48,066
InsufficientExternalProtection


817
00:33:49,236 --> 00:33:50,566
此属性的值变化为 2 时


818
00:33:50,566 --> 00:33:52,726
意味着三件事情


819
00:33:54,166 --> 00:33:57,996
当前项目需要外部保护


820
00:33:58,726 --> 00:34:01,696
设备不满足保护级别


821
00:34:02,326 --> 00:34:04,506
用户将会观察到


822
00:34:04,506 --> 00:34:06,566
或已经观察到视频丢失


823
00:34:06,566 --> 00:34:07,866
例如通过 [ 音质不清晰 ]


824
00:34:08,866 --> 00:34:13,255
为了避免这个问题


825
00:34:13,255 --> 00:34:16,565
你的主播放列表应该提供


826
00:34:16,565 --> 00:34:19,226
至少一个不需要 HDCP


827
00:34:19,226 --> 00:34:21,926
作为回退的变量


828
00:34:22,626 --> 00:34:24,656
请记住 并不是所有的用户


829
00:34:24,876 --> 00:34:27,326
都有 HDCP 支持的


830
00:34:27,326 --> 00:34:28,065
查看设置


831
00:34:28,996 --> 00:34:31,436
App 用户界面


832
00:34:31,436 --> 00:34:33,706
应反映属性的变化


833
00:34:33,706 --> 00:34:35,116
以便及时提示用户


834
00:34:36,496 --> 00:34:38,766
许多播放问题


835
00:34:38,766 --> 00:34:40,616
都是由创建内容引起的


836
00:34:41,176 --> 00:34:43,396
比如在 [ 音质不清晰 ] 切换时


837
00:34:43,396 --> 00:34:46,166
声音和视频出现了


838
00:34:46,376 --> 00:34:46,916
中断或故障


839
00:34:48,085 --> 00:34:49,076
除了我们讨论过的


840
00:34:49,076 --> 00:34:50,815
错误调查


841
00:34:50,815 --> 00:34:53,146
和错误处理之外


842
00:34:53,146 --> 00:34:55,755
我们还建议你们使用


843
00:34:55,755 --> 00:34:58,656
我们的媒体流验证器


844
00:34:58,656 --> 00:35:01,256
它可以在开发者网站中获得


845
00:35:02,026 --> 00:35:03,826
这就是我今天想说的全部内容


846
00:35:04,606 --> 00:35:08,806
现在让我们欢迎我的同事 Eryk Vershen


847
00:35:10,136 --> 00:35:12,006
来谈谈如何以正确的方式


848
00:35:12,676 --> 00:35:14,166
编写主播放列表 谢谢大家


849
00:35:15,516 --> 00:35:18,500
[ 掌声 ]


850
00:35:25,046 --> 00:35:25,976
>> 谢谢你 Zhenheng


851
00:35:26,346 --> 00:35:27,336
我是 Eryk Vershen


852
00:35:27,336 --> 00:35:29,566
我是一名从事于 HLS 工具的工程师


853
00:35:29,566 --> 00:35:31,596
我们已经讨论了


854
00:35:31,596 --> 00:35:33,606
如何衡量


855
00:35:33,826 --> 00:35:35,406
流媒体 App 的性能表现


856
00:35:35,406 --> 00:35:36,236
以及如何解决相关问题


857
00:35:36,746 --> 00:35:38,166
然而 获得成功且无错误的


858
00:35:38,786 --> 00:35:40,436
播放体验的


859
00:35:40,436 --> 00:35:42,656
关键元素之一


860
00:35:42,656 --> 00:35:44,636
是确保你的


861
00:35:44,636 --> 00:35:45,566
主播放列表是正确的


862
00:35:46,246 --> 00:35:47,826
主播放列表


863
00:35:47,826 --> 00:35:49,216
使得播放器


864
00:35:49,216 --> 00:35:51,426
在播放之前和播放期间


865
00:35:51,476 --> 00:35:53,226
做出明智的决定


866
00:35:53,756 --> 00:35:55,196
所以确保它的正确是十分重要的


867
00:35:56,466 --> 00:35:57,846
让我们开始吧 我的建议是


868
00:35:58,046 --> 00:35:59,246
不不 这只是个玩笑


869
00:35:59,646 --> 00:36:01,066
我想我需要给你们


870
00:36:01,066 --> 00:36:02,356
更多的背景知识


871
00:36:02,356 --> 00:36:03,476
来理解 Roger 的意思


872
00:36:04,426 --> 00:36:06,086
我们希望你们


873
00:36:06,086 --> 00:36:07,706
把所有的编码选项


874
00:36:07,756 --> 00:36:09,666
都放到你的主播放列表中


875
00:36:09,666 --> 00:36:11,796
并且尽可能完整地描述它们


876
00:36:12,556 --> 00:36:14,296
假设你在问我这个问题


877
00:36:14,846 --> 00:36:17,876
这是一个关键问题


878
00:36:17,876 --> 00:36:19,296
也是你们必须解决的主要问题


879
00:36:20,316 --> 00:36:22,866
首先 你需要记住


880
00:36:22,866 --> 00:36:24,396
一个主播放列表不能仅仅因为有效


881
00:36:24,396 --> 00:36:26,826
就被判定是正确的


882
00:36:27,446 --> 00:36:28,686
我就见过


883
00:36:28,686 --> 00:36:30,596
像这样的主播放列表


884
00:36:30,996 --> 00:36:32,576
它在语法上是正确的


885
00:36:32,576 --> 00:36:33,756
却几乎没用


886
00:36:34,356 --> 00:36:36,616
好的 那这个怎么样


887
00:36:36,616 --> 00:36:37,956
它有更多的变量


888
00:36:38,816 --> 00:36:41,386
好一点 但还是很糟糕


889
00:36:41,856 --> 00:36:42,836
我们还能播放这个视频吗


890
00:36:42,836 --> 00:36:43,986
它使用什么编解码器


891
00:36:44,266 --> 00:36:45,156
它是 HDR 吗


892
00:36:45,156 --> 00:36:46,166
它是 60 fps 吗


893
00:36:46,916 --> 00:36:48,316
你需要告诉我们一切


894
00:36:48,316 --> 00:36:50,096
我们想要你告诉我们一切


895
00:36:50,716 --> 00:36:52,256
比如 平均带宽


896
00:36:52,536 --> 00:36:54,486
平均带宽


897
00:36:54,486 --> 00:36:56,396
使我们能够更好地决定


898
00:36:56,396 --> 00:36:57,616
切换到哪个变量


899
00:36:58,446 --> 00:36:59,396
它能更好地预测


900
00:36:59,396 --> 00:37:00,626
我们是否能


901
00:37:00,626 --> 00:37:01,306
与流保持同步


902
00:37:02,276 --> 00:37:04,276
编解码器使我们能够过滤掉


903
00:37:04,276 --> 00:37:06,416
不能播放的东西


904
00:37:06,416 --> 00:37:08,806
分辨率使我们能够


905
00:37:08,806 --> 00:37:10,156
对选择哪种变量


906
00:37:10,156 --> 00:37:11,236
做出正确的决定


907
00:37:12,086 --> 00:37:13,806
请记住 直到我们需要


908
00:37:13,806 --> 00:37:15,776
我们才会查看


909
00:37:15,776 --> 00:37:17,436
媒体播放列表或媒体片段


910
00:37:17,816 --> 00:37:19,246
所以你需要提前在你的


911
00:37:19,466 --> 00:37:20,846
主播放列表中


912
00:37:20,846 --> 00:37:21,406
告诉我们一些事情


913
00:37:22,616 --> 00:37:25,406
这是一个简单的


914
00:37:25,406 --> 00:37:26,266
主播放列表的例子


915
00:37:26,766 --> 00:37:28,306
这个播放列表使得播放器


916
00:37:28,306 --> 00:37:30,266
适应带宽的变化


917
00:37:30,266 --> 00:37:31,876
并正确地选择


918
00:37:31,876 --> 00:37:32,816
使用哪种变量


919
00:37:33,756 --> 00:37:36,436
我们在这里所做的一切


920
00:37:36,436 --> 00:37:38,066
对于用户来说都是不可见的


921
00:37:38,066 --> 00:37:39,896
它只会让流播放得更好


922
00:37:41,156 --> 00:37:43,516
好的 让我们来看一个常见的问题


923
00:37:43,516 --> 00:37:45,546
你的流正在播放


924
00:37:45,546 --> 00:37:46,876
但你没有在快进中看到任何图像


925
00:37:46,876 --> 00:37:48,186
或者 你没有在搓擦条中


926
00:37:48,186 --> 00:37:49,496
看到缩略图


927
00:37:50,826 --> 00:37:52,656
这是 Apple TV 的搓擦条


928
00:37:53,616 --> 00:37:55,356
你可以看到你的内容有多长


929
00:37:55,596 --> 00:37:56,586
你也可以看到你在内容中的位置


930
00:37:56,586 --> 00:37:57,826
以及你想去的位置


931
00:37:58,756 --> 00:37:59,976
为了得到缩略图


932
00:37:59,976 --> 00:38:02,126
你需要给我们一个


933
00:38:02,126 --> 00:38:04,316
I-frame 播放列表


934
00:38:04,356 --> 00:38:06,226
I-frame 播放列表允许我们


935
00:38:06,506 --> 00:38:09,166
在你的 iPad 


936
00:38:09,206 --> 00:38:10,646
或 iPhone 上提供


937
00:38:10,646 --> 00:38:13,526
快进和回放中的图像


938
00:38:14,046 --> 00:38:15,616
为了讨论


939
00:38:15,616 --> 00:38:17,526
I-frame 播放列表


940
00:38:17,616 --> 00:38:18,986
我们首先需要讨论一下


941
00:38:18,986 --> 00:38:19,716
普通视频


942
00:38:20,516 --> 00:38:22,286
这是一种在 HLS 中


943
00:38:22,866 --> 00:38:24,406
可视化常规视频片段的方法


944
00:38:25,076 --> 00:38:26,796
每个段都有


945
00:38:26,796 --> 00:38:28,136
若干帧的内容


946
00:38:28,136 --> 00:38:30,266
所以它有一个总帧数


947
00:38:30,266 --> 00:38:31,776
也有一个特定的平均比特率


948
00:38:31,776 --> 00:38:34,346
这个比特率在每个片段中


949
00:38:34,866 --> 00:38:36,176
都是不同的


950
00:38:36,516 --> 00:38:38,586
由于压缩技术


951
00:38:38,586 --> 00:38:40,096
视频中的大多数帧


952
00:38:40,096 --> 00:38:41,326
只能依照其他帧


953
00:38:41,326 --> 00:38:42,756
进行解码


954
00:38:43,676 --> 00:38:45,436
但是 I-frame


955
00:38:45,436 --> 00:38:47,056
其中的 I 代表的是


956
00:38:47,056 --> 00:38:48,536
内部编码的帧


957
00:38:48,536 --> 00:38:49,876
它们是可独立解码的帧


958
00:38:49,876 --> 00:38:52,126
也是允许其他帧进行解码的基本帧


959
00:38:52,996 --> 00:38:54,846
正如我在这里展示的


960
00:38:54,846 --> 00:38:56,716
在一个片段中


961
00:38:56,716 --> 00:38:58,696
你可能有多个 I-frame


962
00:38:58,696 --> 00:39:02,836
并且 I-frame 不需要


963
00:39:02,836 --> 00:39:03,826
以固定间隔排列


964
00:39:05,676 --> 00:39:07,366
I-frame 播放列表


965
00:39:07,366 --> 00:39:09,036
是一个只指向 I-frame 内容的


966
00:39:09,036 --> 00:39:10,806
播放列表


967
00:39:10,806 --> 00:39:12,926
也就是说 它只下载 I-frame 数据


968
00:39:13,236 --> 00:39:14,786
当我们讨论


969
00:39:14,786 --> 00:39:16,016
一个 I-frame 的时长时


970
00:39:16,016 --> 00:39:17,536
我们指的是从这个 I-frame


971
00:39:17,536 --> 00:39:19,626
到下一个 I-frame 的时间


972
00:39:20,456 --> 00:39:21,596
我已经将这个特殊的 I-frame 组


973
00:39:21,596 --> 00:39:23,956
从正常的内容中


974
00:39:23,956 --> 00:39:24,976
提取出来了


975
00:39:24,976 --> 00:39:26,986
但是你也可以制作一个


976
00:39:26,986 --> 00:39:28,156
所谓高密度的


977
00:39:28,156 --> 00:39:29,066
I-frame 播放列表


978
00:39:29,996 --> 00:39:31,376
你不能仅仅从


979
00:39:31,376 --> 00:39:32,886
正常内容中将它提取出来


980
00:39:32,886 --> 00:39:33,696
相反 你需要刻意地


981
00:39:33,946 --> 00:39:35,696
用间隔更加均匀的


982
00:39:35,696 --> 00:39:36,846
I-frame 来制作


983
00:39:37,516 --> 00:39:38,756
这样会更有效


984
00:39:38,756 --> 00:39:40,716
它允许我们在快进的时候


985
00:39:40,716 --> 00:39:42,736
为你提供一个更加平滑的体验


986
00:39:44,376 --> 00:39:45,576
现在 我给你们看一个


987
00:39:45,576 --> 00:39:47,866
没有添加 I-frame 的主播放列表


988
00:39:49,236 --> 00:39:51,956
请注意 I-frame 播放列表


989
00:39:51,956 --> 00:39:53,816
与普通播放列表的标签


990
00:39:53,816 --> 00:39:56,336
几乎完全相同


991
00:39:56,946 --> 00:39:58,656
唯一的区别是


992
00:39:58,656 --> 00:39:59,906
I-frame 播放列表不支持


993
00:39:59,906 --> 00:40:01,786
帧速率这个属性


994
00:40:02,096 --> 00:40:02,886
因为在那个上下文中


995
00:40:02,886 --> 00:40:04,136
它没有任何意义


996
00:40:04,986 --> 00:40:06,166
对于你的 I-frame 播放列表而言


997
00:40:06,166 --> 00:40:07,936
一个好的测试


998
00:40:07,936 --> 00:40:08,746
是尝试直接播放它


999
00:40:09,346 --> 00:40:11,376
也就是说


1000
00:40:11,376 --> 00:40:13,116
将 I-frame 播放列表的 URI


1001
00:40:13,116 --> 00:40:13,846
粘贴到 Safari 浏览器中


1002
00:40:14,316 --> 00:40:16,496
它应该以 1 倍的速度播放


1003
00:40:16,496 --> 00:40:18,136
你会看到 I-frame


1004
00:40:18,136 --> 00:40:20,916
一个接一个地


1005
00:40:20,916 --> 00:40:22,216
在一个缓慢变化的序列中显示


1006
00:40:23,596 --> 00:40:24,886
现在我还要指出


1007
00:40:24,886 --> 00:40:26,266
比特率方面的区别


1008
00:40:27,036 --> 00:40:28,516
请注意 I-frame 的比特率


1009
00:40:28,516 --> 00:40:30,796
比正常的比特率要低得多


1010
00:40:30,936 --> 00:40:33,806
应该一直是这样的


1011
00:40:34,256 --> 00:40:36,326
谈到比特率


1012
00:40:36,616 --> 00:40:39,366
我们已经在 HLS 规范中


1013
00:40:39,436 --> 00:40:40,766
定义了如何计算


1014
00:40:40,766 --> 00:40:41,616
峰值比特率


1015
00:40:42,396 --> 00:40:43,976
一定要这样做


1016
00:40:43,976 --> 00:40:44,986
否则你可能会得到


1017
00:40:45,086 --> 00:40:46,616
片段超过


1018
00:40:46,616 --> 00:40:49,436
指定带宽的错误


1019
00:40:50,026 --> 00:40:52,306
现在 我们不再讨论视频


1020
00:40:52,306 --> 00:40:54,986
将话题转向音频


1021
00:40:55,426 --> 00:40:57,046
对此最常见的问题是


1022
00:40:57,046 --> 00:40:58,606
我如何支持多种语言


1023
00:40:59,306 --> 00:41:00,986
界面是这个样子


1024
00:41:01,296 --> 00:41:03,846
我有一个语言列表


1025
00:41:03,846 --> 00:41:05,146
用户可以从中选择一种语言


1026
00:41:06,336 --> 00:41:08,786
这是一个样本播放列表


1027
00:41:09,036 --> 00:41:10,746
我们所做的就是


1028
00:41:10,746 --> 00:41:13,836
在每个视频变量上


1029
00:41:13,836 --> 00:41:17,356
添加一个


1030
00:41:17,356 --> 00:41:19,976
音频属性


1031
00:41:19,976 --> 00:41:21,966
我们也添加了


1032
00:41:21,966 --> 00:41:22,716
带有组 ID 的媒体标签


1033
00:41:23,126 --> 00:41:27,646
组 ID 是一个标签


1034
00:41:27,646 --> 00:41:30,496
它允许你将音频展示


1035
00:41:30,596 --> 00:41:32,876
与视频变量关联起来


1036
00:41:33,546 --> 00:41:34,996
请注意这两个


1037
00:41:34,996 --> 00:41:37,266
音频版本之间


1038
00:41:37,266 --> 00:41:38,316
有很多不同之处


1039
00:41:38,846 --> 00:41:40,266
就像对待你的变量一样 我们希望你


1040
00:41:40,266 --> 00:41:42,196
尽可能详细地


1041
00:41:42,196 --> 00:41:43,726
描述你的媒体


1042
00:41:44,626 --> 00:41:46,216
在媒体标签上


1043
00:41:46,216 --> 00:41:47,396
有两个属性


1044
00:41:47,396 --> 00:41:49,446
令人们困扰


1045
00:41:49,446 --> 00:41:51,096
那就是 Default 和 Autoselect


1046
00:41:52,306 --> 00:41:56,376
好的 Autoselect 指的是


1047
00:41:56,376 --> 00:41:57,426
播放器中的媒体选择代码


1048
00:41:57,426 --> 00:42:00,576
可以在用户没有


1049
00:42:00,576 --> 00:42:02,596
任何特殊输入的情况下


1050
00:42:02,596 --> 00:42:03,586
进行选择


1051
00:42:04,316 --> 00:42:05,836
大多数情况下


1052
00:42:05,836 --> 00:42:07,436
你会将 Autoselect 设置为 yes


1053
00:42:08,506 --> 00:42:10,066
如果你没有设置


1054
00:42:10,066 --> 00:42:11,156
用户将不得不做出一个明确的选择


1055
00:42:11,156 --> 00:42:13,546
从而进行视频的播放


1056
00:42:15,276 --> 00:42:17,496
另一方面 Default 是指


1057
00:42:17,496 --> 00:42:19,496
当用户没有提供首选语言时


1058
00:42:19,496 --> 00:42:20,916
所进行的选择


1059
00:42:22,216 --> 00:42:23,406
一般来说


1060
00:42:23,406 --> 00:42:25,566
它应该是你的视频的原始语言


1061
00:42:26,066 --> 00:42:27,186
并且 Default


1062
00:42:27,186 --> 00:42:28,986
必须是可自动选择的


1063
00:42:28,986 --> 00:42:30,436
因为系统必须进行选择


1064
00:42:31,136 --> 00:42:33,696
这里的 Default


1065
00:42:33,696 --> 00:42:35,326
与默认的视频变量没有关系


1066
00:42:35,326 --> 00:42:38,426
它是演示组中的默认值


1067
00:42:39,916 --> 00:42:43,166
好的 我有多种语言


1068
00:42:43,166 --> 00:42:44,496
但我真的想要一些


1069
00:42:44,566 --> 00:42:45,496
多声道音频


1070
00:42:45,496 --> 00:42:47,186
我有 5.1 声道音频


1071
00:42:48,126 --> 00:42:50,086
好的 首先要记住的是


1072
00:42:50,086 --> 00:42:52,126
并不是所有的设备


1073
00:42:52,126 --> 00:42:53,156
都能播放多声道音频


1074
00:42:53,516 --> 00:42:56,606
你还需要为用户提供


1075
00:42:56,606 --> 00:42:58,236
立体声选项


1076
00:42:58,826 --> 00:43:00,066
你应该把这件事看成


1077
00:43:00,066 --> 00:43:01,676
填满一个矩阵


1078
00:43:02,256 --> 00:43:04,516
你需要拥有


1079
00:43:04,676 --> 00:43:05,796
涵盖每种语言的每种格式


1080
00:43:07,456 --> 00:43:10,296
你可能会说 好吧


1081
00:43:10,296 --> 00:43:14,076
我没有法语版多声道的原版音频


1082
00:43:14,076 --> 00:43:16,206
我没有法语版的 5.1 声道音频


1083
00:43:16,396 --> 00:43:17,616
在这种情况下


1084
00:43:17,616 --> 00:43:19,936
你仍应该把你的立体声内容


1085
00:43:19,936 --> 00:43:22,546
放到那个组中


1086
00:43:23,786 --> 00:43:25,396
你需要填满


1087
00:43:25,396 --> 00:43:26,906
在这个矩阵中的每个槽


1088
00:43:27,586 --> 00:43:31,116
我们再来看一个播放列表


1089
00:43:31,256 --> 00:43:34,666
这个播放列表


1090
00:43:34,666 --> 00:43:36,626
和之前的例子一样


1091
00:43:36,626 --> 00:43:38,256
只是我改变了组 ID


1092
00:43:38,256 --> 00:43:39,566
而且这样没有问题


1093
00:43:39,566 --> 00:43:41,426
因为组 ID 只是用来


1094
00:43:41,426 --> 00:43:43,686
连接音频


1095
00:43:43,686 --> 00:43:44,806
和视频变量的


1096
00:43:45,406 --> 00:43:48,356
我们有了多声道组


1097
00:43:48,356 --> 00:43:50,396
然后我用法语


1098
00:43:50,396 --> 00:43:52,956
把它设置为立体声


1099
00:43:52,956 --> 00:43:54,986
在这你可以看到如何做到这点


1100
00:43:55,566 --> 00:43:58,146
你需要做的是确保


1101
00:43:58,146 --> 00:44:00,306
编解码器标签指示了


1102
00:44:00,716 --> 00:44:04,096
所有可能出现在该演示组中的


1103
00:44:04,096 --> 00:44:07,766
不同的编解码器


1104
00:44:08,086 --> 00:44:09,126
请注意 我们需要复制


1105
00:44:09,126 --> 00:44:11,506
我们的视频变量


1106
00:44:12,196 --> 00:44:13,986
现在我们有两个条目


1107
00:44:13,986 --> 00:44:16,186
一个条目指向其中一个音频组


1108
00:44:16,536 --> 00:44:17,416
另一个条目


1109
00:44:17,416 --> 00:44:18,256
则指向另一个音频组


1110
00:44:18,476 --> 00:44:19,286
在后面的幻灯片中


1111
00:44:19,286 --> 00:44:21,596
你会再次看到这种重复


1112
00:44:22,936 --> 00:44:25,856
假设我有几个不同音频比特率的音频


1113
00:44:25,856 --> 00:44:27,566
但不是 5.1 声道的


1114
00:44:27,566 --> 00:44:30,616
我有一些高比特率音频


1115
00:44:30,616 --> 00:44:32,176
而且我知道我需要


1116
00:44:32,176 --> 00:44:35,476
为一些用户提供


1117
00:44:35,786 --> 00:44:36,326
低比特率音频


1118
00:44:36,996 --> 00:44:38,566
所以在展示方面


1119
00:44:38,736 --> 00:44:41,386
和我们之前所谈到的类似


1120
00:44:41,596 --> 00:44:42,636
我们仍然需要一个矩阵


1121
00:44:42,636 --> 00:44:43,676
并用每种语言


1122
00:44:44,046 --> 00:44:45,996
来填充每一个比特率变量


1123
00:44:47,126 --> 00:44:48,606
由于这两者都是 AAC


1124
00:44:48,606 --> 00:44:50,266
我们可以认为它们是相同格式的


1125
00:44:50,706 --> 00:44:52,426
如果我想要另一种格式


1126
00:44:52,886 --> 00:44:55,556
我所做的就是


1127
00:44:55,556 --> 00:44:56,606
扩展这个矩阵


1128
00:44:57,096 --> 00:44:58,306
我想提出一点


1129
00:44:58,306 --> 00:44:59,256
我一直说语言是为了便利


1130
00:44:59,256 --> 00:45:00,296
但是你们应该记住


1131
00:45:00,296 --> 00:45:01,876
这里涉及的


1132
00:45:01,876 --> 00:45:03,906
唯一的属性是名称属性


1133
00:45:04,466 --> 00:45:06,616
而不是语言属性


1134
00:45:07,056 --> 00:45:09,286
在这个播放列表中


1135
00:45:09,286 --> 00:45:10,726
我不会给你们展示媒体标签


1136
00:45:10,726 --> 00:45:11,776
但我将展示


1137
00:45:11,776 --> 00:45:13,876
带有音频组名称的视频变量


1138
00:45:14,416 --> 00:45:16,426
你需要将你的低比特率视频


1139
00:45:16,426 --> 00:45:18,006
与你的低比特率音频相关联


1140
00:45:18,006 --> 00:45:21,476
同时将高比特率视频


1141
00:45:21,476 --> 00:45:22,936
与高比特率音频相关联


1142
00:45:23,986 --> 00:45:26,346
你总是需要将它们像这样分开


1143
00:45:27,036 --> 00:45:29,316
如果你有一套


1144
00:45:29,316 --> 00:45:30,556
配有低比特率音频的


1145
00:45:30,556 --> 00:45:31,866
完整视频变量


1146
00:45:31,866 --> 00:45:33,716
和一套配有高比特率音频的


1147
00:45:33,716 --> 00:45:35,016
完整视频变量


1148
00:45:35,016 --> 00:45:36,156
那么这种情况是完全错误的


1149
00:45:36,156 --> 00:45:37,786
因为如果你这样做


1150
00:45:37,786 --> 00:45:39,876
你就会在


1151
00:45:39,876 --> 00:45:41,816
高视频比特率和低音频比特率变量


1152
00:45:41,816 --> 00:45:42,726
之间跳跃


1153
00:45:43,236 --> 00:45:49,376
在这里 我添加了 AC3 内容


1154
00:45:50,006 --> 00:45:51,876
再次注意


1155
00:45:51,876 --> 00:45:54,446
我们必须复制我们的视频变量条目


1156
00:45:54,446 --> 00:45:56,176
但是它们指向


1157
00:45:56,176 --> 00:45:57,346
相同的视频播放列表


1158
00:45:58,196 --> 00:45:59,926
也要注意视频变量中的


1159
00:45:59,926 --> 00:46:02,536
比特率也在变化


1160
00:46:02,826 --> 00:46:03,926
这是因为


1161
00:46:03,926 --> 00:46:06,486
与视频变量


1162
00:46:06,486 --> 00:46:07,496
相关的比特率


1163
00:46:07,496 --> 00:46:08,966
是视频本身


1164
00:46:08,966 --> 00:46:11,806
以及任何相关展示的比特率


1165
00:46:12,406 --> 00:46:16,056
现在让我们


1166
00:46:16,056 --> 00:46:18,406
再次讨论一下视频


1167
00:46:18,406 --> 00:46:19,896
因为我想要具有多个视频格式


1168
00:46:19,896 --> 00:46:22,756
我想要 HEVC


1169
00:46:23,186 --> 00:46:25,366
这样我就可以以同样的比特率


1170
00:46:25,366 --> 00:46:26,816
获得更好的质量


1171
00:46:26,816 --> 00:46:28,196
或者我想要杜比视界（Dolby Vision）


1172
00:46:28,196 --> 00:46:29,266
这样我就可以获得 HDR 内容


1173
00:46:29,806 --> 00:46:33,936
同样 我们需要填一个矩阵


1174
00:46:34,116 --> 00:46:35,556
在这种情况下


1175
00:46:35,556 --> 00:46:37,886
无论我们选择哪种视频格式


1176
00:46:37,886 --> 00:46:39,406
我们都需要设置一组


1177
00:46:39,496 --> 00:46:40,136
合理的变量


1178
00:46:40,626 --> 00:46:42,576
所以这里的行是基于质量的层


1179
00:46:42,576 --> 00:46:46,006
我们需要


1180
00:46:46,006 --> 00:46:47,906
用每一层中每一个格式的变量


1181
00:46:47,906 --> 00:46:49,466
来填充矩阵


1182
00:46:50,846 --> 00:46:52,956
我们不需要


1183
00:46:52,956 --> 00:46:57,496
在旧格式中填写


1184
00:46:57,496 --> 00:46:58,686
更高的层


1185
00:46:58,686 --> 00:46:59,906
你可以节省一下


1186
00:47:00,336 --> 00:47:02,876
但与音频类似


1187
00:47:02,876 --> 00:47:04,586
并不是所有设备


1188
00:47:04,586 --> 00:47:06,516
都支持杜比视界（Dolby Vision）等功能


1189
00:47:06,516 --> 00:47:10,476
因此你需要提供一个 H.264 变体作为备用


1190
00:47:11,476 --> 00:47:12,586
有一个主要的点需要记住


1191
00:47:12,586 --> 00:47:13,806
在每一列中


1192
00:47:13,806 --> 00:47:16,066
你都需要让比特率形成一个良好的递进


1193
00:47:16,616 --> 00:47:19,266
这个播放列表


1194
00:47:19,266 --> 00:47:20,876
有点太大了


1195
00:47:20,876 --> 00:47:21,946
不能在一张幻灯片上显示


1196
00:47:21,946 --> 00:47:22,806
所以我要把它分成三张幻灯片


1197
00:47:23,276 --> 00:47:25,686
这一部分向你展示 H.264 的变量


1198
00:47:26,336 --> 00:47:29,946
在这张幻灯片中 我们展示了 HEVC 变量


1199
00:47:30,026 --> 00:47:31,906
请注意 任何变量


1200
00:47:31,906 --> 00:47:34,206
都有其指向的


1201
00:47:34,206 --> 00:47:36,046
视频播放列表


1202
00:47:36,046 --> 00:47:37,926
这是我们的杜比视界（Dolby Vision）变量


1203
00:47:37,926 --> 00:47:40,016
这里的一切变量


1204
00:47:40,016 --> 00:47:40,956
都有相同的音频组


1205
00:47:41,336 --> 00:47:42,976
如果我们想要


1206
00:47:42,976 --> 00:47:45,216
含有多种音频格式


1207
00:47:45,216 --> 00:47:47,146
我们需要为每种音频格式


1208
00:47:47,146 --> 00:47:49,466
复制视频变量


1209
00:47:49,796 --> 00:47:51,326
同样 这不会增加


1210
00:47:51,326 --> 00:47:53,206
视频播放列表的数量


1211
00:47:53,646 --> 00:47:54,566
只会增加


1212
00:47:54,566 --> 00:47:56,666
播放列表中条目的数量


1213
00:47:57,696 --> 00:48:00,016
好的 我们几乎完成了


1214
00:48:00,436 --> 00:48:02,366
最后一点关于一般字幕


1215
00:48:02,366 --> 00:48:03,316
和可隐藏式字幕


1216
00:48:03,316 --> 00:48:05,946
你可能可以猜到


1217
00:48:05,946 --> 00:48:06,536
它是如何工作的


1218
00:48:07,316 --> 00:48:09,676
我们的变量


1219
00:48:10,206 --> 00:48:12,316
需要指向我们正在使用的


1220
00:48:12,446 --> 00:48:13,616
一般字幕和可隐藏式字幕


1221
00:48:14,096 --> 00:48:15,946
所以我们需要


1222
00:48:15,946 --> 00:48:18,686
为视频变量添加一个属性


1223
00:48:18,686 --> 00:48:20,166
我们也需要描述这个展示


1224
00:48:20,826 --> 00:48:24,146
请注意可隐藏式字幕的展示


1225
00:48:24,146 --> 00:48:25,456
没有 URI 属性


1226
00:48:26,526 --> 00:48:28,456
这告诉系统


1227
00:48:28,456 --> 00:48:30,396
可隐藏式字幕的数据


1228
00:48:30,616 --> 00:48:33,516
存在于在视频内容中


1229
00:48:33,516 --> 00:48:34,396
而不是在单独的播放列表中


1230
00:48:34,946 --> 00:48:38,216
那么没错


1231
00:48:38,216 --> 00:48:38,816
“正确的做法是


1232
00:48:38,816 --> 00:48:39,456
把一切都交给我们”


1233
00:48:39,616 --> 00:48:41,666
现在你应该更加明白我的意思了


1234
00:48:42,476 --> 00:48:44,836
好的 请允许我快速地总结一下


1235
00:48:44,836 --> 00:48:46,186
我们今天的演讲


1236
00:48:47,036 --> 00:48:48,236
Emil 谈到了


1237
00:48:48,236 --> 00:48:49,976
关键性能指标


1238
00:48:49,976 --> 00:48:51,406
关于如何获取或计算这些值


1239
00:48:51,406 --> 00:48:52,156
以及它们的含义


1240
00:48:52,776 --> 00:48:55,246
Zhenheng 谈到了


1241
00:48:55,246 --> 00:48:57,476
减少启动时间的方法


1242
00:48:57,476 --> 00:49:00,426
以及如何解决


1243
00:49:00,426 --> 00:49:01,206
卡顿和其他错误


1244
00:49:01,336 --> 00:49:02,896
我则谈到了


1245
00:49:02,896 --> 00:49:03,756
如何制作主播放列表


1246
00:49:04,216 --> 00:49:06,156
我想简单地提一下


1247
00:49:06,156 --> 00:49:07,586
HLS 验证工具


1248
00:49:08,266 --> 00:49:10,466
它们可以发现


1249
00:49:10,466 --> 00:49:12,316
很多与主播放列表和媒体播放列表有关的问题


1250
00:49:12,566 --> 00:49:14,446
值得你花时间去使用


1251
00:49:15,616 --> 00:49:17,816
一如既往地 你可以从


1252
00:49:17,816 --> 00:49:20,316
WWDC App 或者


1253
00:49:20,366 --> 00:49:21,496
开发者网站中获得更多信息


1254
00:49:21,946 --> 00:49:22,906
这就是我们今天要讲的全部内容


1255
00:49:23,136 --> 00:49:24,706
非常感谢各位的关注和时间


1256
00:49:25,508 --> 00:49:27,508
[ 掌声 ]

