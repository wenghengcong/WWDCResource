1
00:00:17,251 --> 00:00:22,055 line:0
（SWIFT通用型）


2
00:00:34,535 --> 00:00:35,369 line:-1
大家好


3
00:00:36,436 --> 00:00:38,505 line:-2
我是Ben 我是Swift
标准程序库的员工


4
00:00:38,805 --> 00:00:41,141 line:-2
今天我要和来自编译团队的同事
Doug一起


5
00:00:41,208 --> 00:00:43,310 line:-2
跟大家分享关于
Swift通用型的信息


6
00:00:45,112 --> 00:00:48,415 line:-2
Swift最近发布的版本
添加了一些重要的新特性


7
00:00:48,782 --> 00:00:52,553 line:-1
包括条件一致性和递归协议约束条件


8
00:00:53,887 --> 00:00:57,758 line:-2
其实在Swift发布的每个版本中
我们都会改善通用型系统


9
00:00:58,091 --> 00:00:59,459 line:-1
让它变得更有表现性


10
00:01:00,460 --> 00:01:03,297 line:-1
我们觉得4.2版本是一个重要节点


11
00:01:04,230 --> 00:01:07,100 line:-2
从这个节点开始
我们终于可以完全实施


12
00:01:07,434 --> 00:01:09,570 line:-2
许多期待应用到
标准程序库的设计中了


13
00:01:09,636 --> 00:01:12,439 line:-1
这在达到Swift中


14
00:01:12,506 --> 00:01:15,275 line:-2
ABI的稳定性的目标方面
对于我们来说非常重要


15
00:01:17,044 --> 00:01:19,179 line:-2
因此我们之前也针对通用型
做了很多次演讲


16
00:01:19,246 --> 00:01:20,814 line:-1
但我们一直没有往后退一步


17
00:01:20,881 --> 00:01:22,850 line:-1
将通用型作为一个整体来讲


18
00:01:23,450 --> 00:01:26,453 line:-2
今天我们要给大家
分享一些不同的功能


19
00:01:26,520 --> 00:01:28,856 line:-2
关于通用型系统
有新功能也有老功能


20
00:01:29,323 --> 00:01:31,191 line:-1
以便帮你们理解它们如何共同协作


21
00:01:32,626 --> 00:01:35,462 line:-1
我要快速回顾一下通用型的动机


22
00:01:36,964 --> 00:01:39,066 line:-1
我们会谈到设计协议


23
00:01:39,132 --> 00:01:40,734 line:-1
给出一系列具体类型


24
00:01:40,801 --> 00:01:42,970 line:-1
通过从标准程序库中获取的示例


25
00:01:44,471 --> 00:01:46,473 line:-1
我们会回顾一下协议继承


26
00:01:46,540 --> 00:01:49,109 line:-1
并谈谈条件一致性的新功能


27
00:01:49,176 --> 00:01:51,178 line:-1
以及它如何与协议继承相互作用


28
00:01:51,945 --> 00:01:56,183 line:-2
最后我们会通过对类和通用型的讨论
总结一下今天的内容


29
00:01:58,452 --> 00:02:00,954 line:-2
为何通用型对于Swift
是如此重要的部分？


30
00:02:01,755 --> 00:02:06,860 line:-2
了解它们之间相互影响的一个方式
是通过设计简单的集合 比如类型


31
00:02:08,195 --> 00:02:09,263 line:-1
我们把它叫做缓冲器


32
00:02:09,596 --> 00:02:12,366 line:-1
它类似于标准程序库中的数组类型


33
00:02:12,799 --> 00:02:15,802 line:-2
现在对于缓冲器的可读部分来说
最简单的API


34
00:02:15,869 --> 00:02:18,105 line:-1
可能包括元素的一个计数


35
00:02:18,405 --> 00:02:21,508 line:-2
以及把每个元素
获取到索引中指定位置的方式


36
00:02:21,975 --> 00:02:24,211 line:-1
但我们怎么让它返回类型呢？


37
00:02:25,112 --> 00:02:27,481 line:-2
现在如果我们没有通用型
我们得做一个


38
00:02:27,548 --> 00:02:29,750 line:-1
有些类型可以表达


39
00:02:29,816 --> 00:02:31,552 line:-1
我们想在缓冲器内放置的一切东西


40
00:02:32,052 --> 00:02:35,155 line:-2
你可以调用那个类型ID
或对象或Void Star


41
00:02:35,455 --> 00:02:37,124 line:-2
Swift中
我们把它叫做Any


42
00:02:37,791 --> 00:02:41,395 line:-2
它是一个可以在Swift中
代替任意不同类型的类型


43
00:02:43,864 --> 00:02:45,866 line:-2
因此若你想在缓冲器中
处理任意一个元素


44
00:02:45,933 --> 00:02:47,701 line:-1
你可以让自定义下标返回Any


45
00:02:47,968 --> 00:02:49,436 line:-1
但是当然了 你很可能知道


46
00:02:49,503 --> 00:02:52,039 line:-1
那会营造一种令用户愉悦的体验


47
00:02:52,105 --> 00:02:55,576 line:-2
在某个点上
你不得不把那个类型从方框内拿出来


48
00:02:56,043 --> 00:02:58,045 line:-1
以便能实际使用它


49
00:03:00,814 --> 00:03:04,484 line:-1
这不仅烦人 还容易出错


50
00:03:04,751 --> 00:03:06,987 line:-2
如果你代码中的某个位置
也许是偶然


51
00:03:07,221 --> 00:03:10,424 line:-2
你在被认为是字符串的缓冲器中
放了一个整型会怎么样呢？


52
00:03:12,292 --> 00:03:14,094 line:-1
但那不仅仅关系到易用性


53
00:03:14,161 --> 00:03:15,863 line:-1
我们还想解决一些问题


54
00:03:15,929 --> 00:03:19,032 line:-1
关于如何在内存中表达这些值


55
00:03:21,235 --> 00:03:24,404 line:-2
现在对于字符串的缓冲器来说
最理想的表达方式


56
00:03:24,771 --> 00:03:26,773 line:-1
就是内存的连续块


57
00:03:27,074 --> 00:03:29,743 line:-1
每个元素之间用线隔开


58
00:03:31,278 --> 00:03:34,248 line:-2
但如果是无类型方法
这就不会那么有效了


59
00:03:34,314 --> 00:03:38,685 line:-2
因为缓冲器不会提前知道
它将会包含哪种类型


60
00:03:38,752 --> 00:03:40,888 line:-1
它得使用一种像Any一样的类型


61
00:03:40,954 --> 00:03:43,023 line:-1
那可以涵盖任意一个可能性


62
00:03:43,457 --> 00:03:45,826 line:-2
并且在那个Any中
在追踪类型、把类型装盒


63
00:03:45,893 --> 00:03:48,028 line:-2
和把类型从箱中取出方面
还有许多消耗


64
00:03:50,597 --> 00:03:53,133 line:-2
在这里 我可能只想要
一个整型缓冲器


65
00:03:53,200 --> 00:03:56,036 line:-1
但我不能在编译器中表达它


66
00:03:56,103 --> 00:04:00,073 line:-2
因此我必须为灵活性付出代价
即使我对它并不感兴趣


67
00:04:01,508 --> 00:04:04,978 line:-2
另外 因为Any得解释
任意一种不同的类型


68
00:04:05,412 --> 00:04:09,783 line:-2
包括那些太大以至于
不能在自己内部存储器内存储的类型


69
00:04:10,284 --> 00:04:11,985 line:-1
它有时候不得不使用间接存储


70
00:04:12,252 --> 00:04:13,987 line:-1
它得给值保留一个指针


71
00:04:14,054 --> 00:04:16,757 line:-1
那个值可以在整个内存中定位找到


72
00:04:17,824 --> 00:04:19,293 line:-1
我们真的想要解决这些问题


73
00:04:19,358 --> 00:04:23,564 line:-2
不仅仅是为了易用性和正确性
还为了性能原因


74
00:04:24,731 --> 00:04:28,735 line:-2
并且我们通过一种叫做
参数多态性的技术来实现


75
00:04:29,303 --> 00:04:33,507 line:-2
它就是Swift中
通用型的另一个术语


76
00:04:35,175 --> 00:04:38,278 line:-2
通过通用型方法
我们可以在缓冲器中存放更多信息


77
00:04:38,345 --> 00:04:40,814 line:-1
用于表达缓冲器即将要包含的类型


78
00:04:41,682 --> 00:04:43,016 line:-1
我们那个类型叫做元素


79
00:04:44,151 --> 00:04:46,420 line:-1
元素是类型的一个通用型参数


80
00:04:46,753 --> 00:04:48,956 line:-1
这就是术语参数多态性


81
00:04:49,690 --> 00:04:52,359 line:-2
你可以把它看作
类似一个编译时间参数


82
00:04:52,426 --> 00:04:54,595 line:-1
它会告诉缓冲器即将要包含什么


83
00:04:55,662 --> 00:04:57,865 line:-2
现在它有一种方式
可以提及那个元素类型


84
00:04:57,931 --> 00:05:00,400 line:-2
它可以使用那个元素类型
而以前它用的是Any


85
00:05:03,237 --> 00:05:05,272 line:-1
那意味着不再需要任何转换


86
00:05:05,339 --> 00:05:06,874 line:-1
当你从缓冲器中获取类型时


87
00:05:07,341 --> 00:05:10,611 line:-1
如果你意外分配了错误的类型


88
00:05:10,677 --> 00:05:13,580 line:-1
或者类似的情况 编译器会捕捉你


89
00:05:15,148 --> 00:05:20,220 line:-2
现在并没有这种不带相关联的
元素类型的缓冲器类型了


90
00:05:21,021 --> 00:05:24,458 line:-2
如果你尝试声明一个那样的类型
你会得到一个编译错误


91
00:05:26,059 --> 00:05:29,062 line:-2
你可能会感觉有点吃惊
因为有时候你会看到


92
00:05:29,129 --> 00:05:32,499 line:-2
你可以声明不带任何元素类型的类型
比如缓冲器


93
00:05:33,133 --> 00:05:34,434 line:-1
但那仅仅是因为编译器


94
00:05:34,501 --> 00:05:38,172 line:-2
可以根据情境推断
应该是哪种元素类型


95
00:05:38,438 --> 00:05:40,774 line:-2
在本例中
是从右手边这儿的字面进行推断


96
00:05:41,942 --> 00:05:44,745 line:-1
元素仍然还在那里 就是有点含蓄


97
00:05:46,313 --> 00:05:48,515 line:-1
到底包含哪种类型


98
00:05:49,383 --> 00:05:51,318 line:-1
诸如缓冲器一样的类型


99
00:05:51,385 --> 00:05:55,022 line:-2
可以应用在
编译和运行期的整个过程中


100
00:05:56,523 --> 00:06:00,227 line:-2
这意味着我们可以实现在内存的
连续块中保留全部元素的目标


101
00:06:00,460 --> 00:06:03,096 line:-1
而不会超前


102
00:06:03,931 --> 00:06:06,600 line:-1
即使那些类型任意大


103
00:06:08,468 --> 00:06:12,272 line:-1
因为编译器始终能直接了解


104
00:06:12,339 --> 00:06:15,442 line:-1
关于缓冲器具体包含哪种元素类型


105
00:06:15,876 --> 00:06:18,445 line:-1
它就有机会进行优化


106
00:06:18,512 --> 00:06:19,980 line:-1
而其它时候却没有


107
00:06:20,514 --> 00:06:23,483 line:-2
那么在本例中
在我声明整型缓冲器的位置


108
00:06:24,318 --> 00:06:27,287 line:-2
一个类似这样的循环
应该被编译为


109
00:06:27,354 --> 00:06:29,523 line:-2
仅仅应用于
某些非常有效的CPU指令


110
00:06:31,892 --> 00:06:36,196 line:-2
现在如果你正在一个常规基础上
写一个这样的循环


111
00:06:36,496 --> 00:06:37,931 line:-1
用于总计整型缓冲器


112
00:06:37,998 --> 00:06:40,901 line:-1
把它提取到一个方法中可能会有意义


113
00:06:41,368 --> 00:06:45,072 line:-1
缓冲器上的扩展单位-可测试性更好


114
00:06:45,138 --> 00:06:47,107 line:-1
当你实际调用它时也可读性也更强


115
00:06:48,208 --> 00:06:50,577 line:-1
但你很可能知道如果你像这样写代码


116
00:06:50,644 --> 00:06:52,079 line:-1
你会出现编译问题


117
00:06:52,446 --> 00:06:56,416 line:-2
因为并不是所有的元素类型
都可以像这样总计起来


118
00:06:57,618 --> 00:06:59,019 line:-1
我们需要告诉编译器


119
00:06:59,086 --> 00:07:02,990 line:-2
更多关于元素
所需要具备的性能的信息


120
00:07:03,290 --> 00:07:06,026 line:-1
以便让这个方法在缓冲器上可用


121
00:07:07,394 --> 00:07:10,998 line:-2
现在最简单的方式就是
通过限制元素类型


122
00:07:11,064 --> 00:07:13,901 line:-2
为指定类型实现
就好像原始循环中的整型


123
00:07:16,803 --> 00:07:20,007 line:-2
如果你采用这种简单的方法来实现
并和扩展一起运行


124
00:07:20,073 --> 00:07:22,009 line:-1
那么稍后的推广会很简单


125
00:07:22,075 --> 00:07:23,610 line:-2
当你发现你需要
做一些不同的操作时


126
00:07:23,677 --> 00:07:25,946 line:-2
比如总计双精度浮点型缓冲器
或单精度浮点型缓冲器


127
00:07:26,914 --> 00:07:29,316 line:-1
请看看你所限制的类型


128
00:07:30,017 --> 00:07:31,785 line:-1
查看它所遵循的协议


129
00:07:31,852 --> 00:07:34,388 line:-1
并保持追踪直到你获得最通用的协议


130
00:07:34,655 --> 00:07:37,024 line:-1
那你就万事俱备了


131
00:07:37,624 --> 00:07:39,726 line:-1
在本例中 数字协议


132
00:07:39,793 --> 00:07:42,062 line:-2
给我们提供了
我们在这里所依赖的两个功能


133
00:07:42,429 --> 00:07:46,533 line:-1
创建值为0的新元素的能力


134
00:07:46,600 --> 00:07:48,535 line:-1
以及添加新元素的能力


135
00:07:48,969 --> 00:07:50,871 line:-1
这是数字协议的一部分


136
00:07:53,607 --> 00:07:55,142 line:-1
现在让我们谈谈


137
00:07:55,209 --> 00:07:58,445 line:-1
从不同类型中析出协议的过程


138
00:08:00,180 --> 00:08:01,882 line:-1
那么我们一直在谈这个缓冲器类型


139
00:08:01,949 --> 00:08:04,885 line:-1
我们可以让它在不同的元素之间通用


140
00:08:05,085 --> 00:08:08,689 line:-2
但是要在不同用法中通用的通用代码
要怎么写呢？


141
00:08:09,122 --> 00:08:11,892 line:-2
一段可以在任意不同种类的集合中
使用的代码？


142
00:08:13,193 --> 00:08:16,230 line:-2
比如数组
非常类似于我们的缓冲器类型


143
00:08:16,830 --> 00:08:18,398 line:-1
但拥有更多不同种类的类型


144
00:08:18,465 --> 00:08:21,568 line:-1
比如字典 它是关键值对的一个集合


145
00:08:23,136 --> 00:08:24,972 line:-1
或者也许是不通用的类型


146
00:08:25,038 --> 00:08:27,975 line:-2
或者不同的元素类型
比如数据或字符串


147
00:08:28,041 --> 00:08:29,776 line:-1
返回特定的元素类型


148
00:08:31,845 --> 00:08:36,250 line:-2
我们想要创建一个协议
可以捕捉它们全部常见的功能


149
00:08:37,116 --> 00:08:39,886 line:-1
我们要创建一个简化版本


150
00:08:39,953 --> 00:08:42,322 line:-1
标准程序库自己的集合协议


151
00:08:45,058 --> 00:08:49,863 line:-2
那么请注意 我们首先要考虑到
各式各样的具体类型


152
00:08:50,297 --> 00:08:52,733 line:-1
现在我们正在思考一种协议


153
00:08:53,000 --> 00:08:54,601 line:-1
可以把它们全部结合在一起


154
00:08:54,668 --> 00:08:57,171 line:-1
有必要以这种方式进行思考


155
00:08:57,237 --> 00:08:59,072 line:-1
我们要从一些具体类型开始


156
00:08:59,373 --> 00:09:01,909 line:-2
然后尝试通过一个协议
把它们统一起来


157
00:09:03,277 --> 00:09:04,811 line:-1
那些类型共同拥有什么？


158
00:09:05,145 --> 00:09:06,547 line:-1
它们不共同拥有什么？


159
00:09:07,681 --> 00:09:09,183 line:-1
当你正设计一个这样的协议时


160
00:09:09,249 --> 00:09:11,919 line:-2
你可以把它看作是一种
诸如合约谈判一样的东西


161
00:09:13,287 --> 00:09:14,922 line:-1
这里有一个很常见的拉锯战


162
00:09:14,988 --> 00:09:17,124 line:-1
在一致性类型之间 一方面


163
00:09:17,724 --> 00:09:21,528 line:-2
在执行那个约束方面
想要尽可能多的灵活性


164
00:09:22,596 --> 00:09:24,264 line:-1
而协议的用户


165
00:09:24,531 --> 00:09:27,134 line:-1
想要一个漂亮、紧凑、简单的协议


166
00:09:27,568 --> 00:09:29,369 line:-1
以便实现他们的扩展


167
00:09:30,704 --> 00:09:32,206 line:-1
这就是为什么非常重要的原因


168
00:09:32,272 --> 00:09:35,409 line:-2
同时考虑到
尽可能多的种类的一致性类型


169
00:09:35,843 --> 00:09:38,045 line:-1
和一系列不同用例


170
00:09:38,312 --> 00:09:41,582 line:-2
当你正在设计协议时
因为它是一种平衡做法


171
00:09:44,251 --> 00:09:46,653 line:-1
那么让我们开始具体化集合协议吧


172
00:09:46,720 --> 00:09:48,689 line:-1
那么首先我们需要表达元素类型


173
00:09:49,122 --> 00:09:51,758 line:-2
现在在协议中
我们使用了一个相关联类型


174
00:09:52,893 --> 00:09:56,530 line:-2
每个一致性类型
都需要对元素进行适当的设置


175
00:09:57,364 --> 00:09:59,166 line:-1
在缓冲器或数组的例子中


176
00:09:59,533 --> 00:10:02,636 line:0
对于Swift 4.2来说
这是自动发生的


177
00:10:03,203 --> 00:10:06,440 line:0
因为我们也把它们的通用参数
命名为元素


178
00:10:07,641 --> 00:10:08,842 line:0
这是一很棒的附带利益


179
00:10:08,909 --> 00:10:11,345 line:0
可以赋予你的通用参数
一个有意义的名字


180
00:10:11,411 --> 00:10:14,281 line:0
遵循共同的惯例
就像元素这个词一样


181
00:10:15,616 --> 00:10:17,985 line:0
而不是随意给它们一个名字
比如T


182
00:10:18,051 --> 00:10:20,587 line:0
你要分别陈述的是元素类型


183
00:10:21,955 --> 00:10:24,825 line:0
对于其它数据类型
你可能需要做的更具体一些


184
00:10:24,892 --> 00:10:27,194 line:0
比如字典 需要把元素类型设置为


185
00:10:27,261 --> 00:10:29,429 line:0
它的关键值对和值类型


186
00:10:32,065 --> 00:10:34,835 line:-1
接下来让我们谈谈添加自定义下标


187
00:10:35,836 --> 00:10:39,039 line:-2
现在如果我们只谈
诸如数组类型一样的协议


188
00:10:39,306 --> 00:10:43,277 line:-2
我们可能会让自定义下标
以整型作为它的参数


189
00:10:45,312 --> 00:10:49,716 line:-2
但是让自定义下标用整型
可能会意味着非常强的约束


190
00:10:50,884 --> 00:10:53,954 line:-1
每个一致性类型都要提供


191
00:10:54,021 --> 00:10:57,491 line:-2
把元素取到
由整数表达的指定位置的功能


192
00:10:58,425 --> 00:11:00,761 line:-1
那对于像数组一样的类型来说没问题


193
00:11:01,562 --> 00:11:05,132 line:0
对于协议的用户来说也非常容易理解


194
00:11:06,066 --> 00:11:08,569 line:0
但它对于稍微有些复杂的
类型来说灵活性够吗？


195
00:11:08,635 --> 00:11:09,603 line:0
比如字典？


196
00:11:11,738 --> 00:11:13,774 line:-1
现在无论你如何处理它


197
00:11:13,841 --> 00:11:15,475 line:-1
字典很可能会被阻碍


198
00:11:15,542 --> 00:11:18,245 line:-1
被一些非常复杂的内部数据结构


199
00:11:18,612 --> 00:11:21,882 line:-2
在从一个元素移动到下一个元素方面
有特定逻辑的数据结构


200
00:11:22,850 --> 00:11:26,420 line:-1
比如它可能会被某种内部缓冲器阻碍


201
00:11:26,620 --> 00:11:31,291 line:-2
它可以使用在那个缓冲器中
存储有位移的索引类型


202
00:11:31,925 --> 00:11:34,228 line:-1
然后它会把参数作为自定义下标


203
00:11:34,294 --> 00:11:37,464 line:-2
以便把元素获取到那个位置
使用那个位移


204
00:11:38,432 --> 00:11:41,168 line:-1
但有一点很重要 字典的索引类型


205
00:11:41,235 --> 00:11:44,371 line:-1
是一个隐含类型 只有字典可以控制


206
00:11:45,138 --> 00:11:48,208 line:-1
你不希望别人在你的位移中添加1


207
00:11:48,275 --> 00:11:50,944 line:-1
那未必会在字典中移动到下一个元素


208
00:11:51,011 --> 00:11:52,412 line:-1
它可能会移动到任意元素


209
00:11:52,479 --> 00:11:55,716 line:-2
也许会移动到字典的内部存储器中
未初始化的部分


210
00:11:56,984 --> 00:12:01,021 line:-2
因此我们希望字典能控制
继续向前移动


211
00:12:01,221 --> 00:12:03,323 line:-1
通过集合 通过改善索引实现


212
00:12:04,191 --> 00:12:08,028 line:-2
那么为此我们添加了另一个
提供索引的方法


213
00:12:08,395 --> 00:12:10,931 line:-2
为你提供一个
可以在它之后标记位置的索引


214
00:12:12,399 --> 00:12:14,401 line:0
一旦你采取了这个步骤
你需要更多的东西


215
00:12:14,468 --> 00:12:17,771 line:0
你需一个startIndex属性
和一个endIndex属性


216
00:12:18,172 --> 00:12:20,040 line:0
因为简单的计数不再起作用了


217
00:12:20,107 --> 00:12:22,109 line:0
不能再告诉我们是否已经到达末端


218
00:12:22,643 --> 00:12:24,778 line:0
现在我们不再在索引类型中
使用整型了


219
00:12:26,513 --> 00:12:28,949 line:0
那么让我们把这些带回到集合协议中


220
00:12:29,950 --> 00:12:32,986 line:0
那么我们得到了一个自定义下标
让某个索引类型


221
00:12:33,053 --> 00:12:35,522 line:0
表示一个位置并给你提供一个元素


222
00:12:35,589 --> 00:12:38,091 line:0
我们还有一种
可以向前移动那个位置的方法


223
00:12:39,026 --> 00:12:41,828 line:0
但我们还需要类型提供


224
00:12:41,895 --> 00:12:43,530 line:0
它们即将在索引中使用的类型


225
00:12:43,764 --> 00:12:45,999 line:0
我们通过另一个相关联类型实现


226
00:12:47,835 --> 00:12:50,637 line:0
一致性类型可以提供适当的类型


227
00:12:50,704 --> 00:12:54,608 line:0
因此数组或数据可以提供一个整型
作为它们的索引类型


228
00:12:54,908 --> 00:12:58,045 line:-2
然而字典可以提供
它自己的自定义实施


229
00:12:58,111 --> 00:12:59,847 line:-1
处理它自己的内部逻辑


230
00:13:04,218 --> 00:13:07,054 line:-2
那么让我们返回到一分钟之前
我们所讲的内容


231
00:13:07,120 --> 00:13:09,456 line:-1
以便推广我们的索引模型


232
00:13:09,523 --> 00:13:11,325 line:-1
它仍然是一个非常有用的属性


233
00:13:11,391 --> 00:13:15,896 line:-2
因此我们很想把它重新添加到集合中
作为一个扩展


234
00:13:16,663 --> 00:13:20,801 line:-1
可以跨过集合 让索引向前移动


235
00:13:21,201 --> 00:13:23,804 line:-1
让计数器增长然后就返回


236
00:13:26,440 --> 00:13:29,576 line:-2
现在如果我们尝试实施它
我们就遇到了另一个漏掉的要求


237
00:13:30,511 --> 00:13:33,013 line:-2
因为我们把整型
移动到一个通用的索引类型


238
00:13:33,347 --> 00:13:36,650 line:-2
我们再也不能假定索引类型
是等同的了


239
00:13:37,484 --> 00:13:40,354 line:-1
整型是 但任意索引类型却没有必要


240
00:13:40,787 --> 00:13:44,024 line:-2
并且我们需要它
以便了解我们是否到达了末端


241
00:13:45,526 --> 00:13:48,595 line:-2
现在我们可以用之前所采用过的
同样的方法来解决这个问题


242
00:13:48,662 --> 00:13:50,697 line:-1
约束我们的扩展


243
00:13:50,764 --> 00:13:53,467 line:-1
比如它只能在索引类型是等同时使用


244
00:13:54,668 --> 00:13:56,103 line:-1
但感觉似乎不对劲


245
00:13:57,437 --> 00:13:59,473 line:-1
我们想要一个易用的协议


246
00:13:59,673 --> 00:14:02,142 line:-1
但看起来非常非常烦人


247
00:14:02,209 --> 00:14:04,645 line:-2
如果我们不得不经常
在我们所写的每一个扩展上


248
00:14:05,712 --> 00:14:06,813 line:-1
应用这个约束


249
00:14:06,880 --> 00:14:09,883 line:-1
因为我们几乎总是需要比较两个索引


250
00:14:10,250 --> 00:14:14,221 line:-2
相反 它作为协议的要求
很可能更好地进行表述


251
00:14:16,089 --> 00:14:19,092 line:-1
作为我们索引相关联类型的约束


252
00:14:20,294 --> 00:14:22,095 line:-1
把这个约束应用到协议上


253
00:14:22,162 --> 00:14:24,131 line:-1
意味着遵循协议的全部类型


254
00:14:24,198 --> 00:14:27,301 line:-2
都需要向它们的索引提供一个
等同的类型


255
00:14:28,569 --> 00:14:32,039 line:-2
那样你就不需要
在每次写扩展时都要指定它了


256
00:14:34,641 --> 00:14:37,444 line:-1
这是协商协议约束的另一个例子


257
00:14:38,779 --> 00:14:40,647 line:-1
协议的用户有一个要求


258
00:14:40,714 --> 00:14:43,083 line:-1
他们需要能比较索引


259
00:14:43,650 --> 00:14:47,688 line:-2
一致性协议 他们查看了一下
他们可以很合理地进行调整


260
00:14:47,754 --> 00:14:49,590 line:-1
而不需要放弃太多的灵活性


261
00:14:51,024 --> 00:14:52,559 line:-1
在本例中他们当然可以


262
00:14:53,460 --> 00:14:56,196 line:-2
数据和数组所使用的整型
已经是等同的了


263
00:14:56,630 --> 00:15:00,300 line:-2
并且通过Swift 4.2的
新功能自动合成等同的一致性


264
00:15:01,301 --> 00:15:04,204 line:-2
字典可以很简单地把它的索引类型
变为等同


265
00:15:07,074 --> 00:15:10,344 line:-1
接下来让我们谈谈优化这个计数操作


266
00:15:10,410 --> 00:15:12,312 line:-1
通过一个自定义点


267
00:15:14,348 --> 00:15:16,884 line:-1
那么我们已经写了一个版本的计数


268
00:15:17,384 --> 00:15:20,487 line:-1
计算集合中元素的数量


269
00:15:20,554 --> 00:15:22,256 line:-1
通过跨过整个集合


270
00:15:22,322 --> 00:15:25,792 line:-1
但很明显 许多集合很可能做得更快


271
00:15:26,593 --> 00:15:29,496 line:-1
比如 假如字典在内部保留


272
00:15:29,563 --> 00:15:31,465 line:-1
它所持有的元素数量


273
00:15:31,532 --> 00:15:32,633 line:-1
用于实现自己的目的


274
00:15:33,467 --> 00:15:34,735 line:-1
如果它拥有这个信息


275
00:15:34,801 --> 00:15:37,504 line:-2
它就可以在它自己的计数实施中
使用它


276
00:15:38,605 --> 00:15:41,408 line:-1
那意味着当人们在字典上调用计数时


277
00:15:41,975 --> 00:15:43,677 line:-1
他们会获得快速、恒定的时间


278
00:15:44,044 --> 00:15:45,212 line:-1
而不是线性时间


279
00:15:45,279 --> 00:15:48,215 line:-2
是指那个适用于任意集合的原始版本
所需要的线性时间


280
00:15:49,816 --> 00:15:52,686 line:-2
但当添加这样的优化时
你需要注意几点


281
00:15:52,753 --> 00:15:56,290 line:-1
即旅行协议的要求之间的不同点


282
00:15:56,857 --> 00:16:00,060 line:-1
和仅在指定类型上添加大量负载


283
00:16:01,128 --> 00:16:05,799 line:-2
直到现在 这个字典上的计数新版本
就是一个负载


284
00:16:06,533 --> 00:16:08,435 line:-1
那意味着当你有一个字典时


285
00:16:08,836 --> 00:16:10,204 line:-1
你知道它是一个字典


286
00:16:10,437 --> 00:16:12,506 line:-1
你将会获得更新、更好的计数版本


287
00:16:13,440 --> 00:16:16,009 line:-2
但如果在通用算法内部调用它
会怎么样呢？


288
00:16:18,545 --> 00:16:20,180 line:-1
那么假如我们希望 比如说


289
00:16:20,247 --> 00:16:22,649 line:-1
写一个标准程序库的地图版本？


290
00:16:23,116 --> 00:16:26,253 line:-2
如果你还不熟悉它
它真的是一个很有用的操作


291
00:16:26,653 --> 00:16:29,556 line:-1
可以转换集合中的每一个元素


292
00:16:29,623 --> 00:16:31,592 line:-1
并给你返回一个新数组


293
00:16:33,126 --> 00:16:34,928 line:-1
这个实施非常简单


294
00:16:34,995 --> 00:16:36,730 line:-1
它只是创建一个新数组


295
00:16:37,364 --> 00:16:38,565 line:-1
在集合内部移动


296
00:16:38,999 --> 00:16:41,668 line:-2
转换每一个元素
然后把它添加到数组中


297
00:16:42,936 --> 00:16:45,539 line:-2
现在随着你在像这样的数组中
添加元素


298
00:16:45,606 --> 00:16:47,841 line:-1
数组会自动增长


299
00:16:48,575 --> 00:16:53,080 line:-2
它随着需要增长
有时候会重新分配它的内部存储


300
00:16:53,146 --> 00:16:55,749 line:-1
以便拥有更多的空间来容纳新元素


301
00:16:56,517 --> 00:16:59,453 line:-2
在一个这样的循环中
可能会多次执行上述过程


302
00:16:59,520 --> 00:17:00,787 line:-1
取决于它要变得多大


303
00:17:01,455 --> 00:17:02,856 line:-1
那么这个过程需要时间


304
00:17:03,056 --> 00:17:05,492 line:-1
分配内存的消耗非常大


305
00:17:06,727 --> 00:17:09,863 line:-2
有一个很棒的优化小技巧
我们可以应用于这种实施上


306
00:17:10,564 --> 00:17:14,001 line:-2
我们已经了解
最终的数组具体会有多大了


307
00:17:14,501 --> 00:17:17,471 line:-1
它会跟我们原始集合的尺寸一样大


308
00:17:18,605 --> 00:17:23,510 line:-2
那么我们可以
提前在数组中储备好空间


309
00:17:23,577 --> 00:17:26,914 line:-2
在我们开始添加之前
这是一次很漂亮的加速


310
00:17:27,580 --> 00:17:29,650 line:-1
为此我们要调用计数


311
00:17:30,984 --> 00:17:32,452 line:-1
但我们在这里调用计数


312
00:17:32,519 --> 00:17:35,489 line:-1
在通用情境中


313
00:17:35,822 --> 00:17:40,727 line:-2
也就是集合类型是完全通用的情境
而不是特定的情境


314
00:17:40,794 --> 00:17:43,764 line:-1
可以是一个数组或字典或链表或任意


315
00:17:44,731 --> 00:17:47,301 line:-1
那么我们不知道有一个


316
00:17:47,568 --> 00:17:50,137 line:-1
更好的计数实施可用


317
00:17:50,204 --> 00:17:52,039 line:-1
当编译器编译这段代码时


318
00:17:52,973 --> 00:17:56,877 line:-2
那么在这种情况下
即将被调用的计数版本


319
00:17:57,344 --> 00:18:00,614 line:0
实际上是计数的通用版本
可以应用在任意集合上


320
00:18:00,814 --> 00:18:02,883 line:0
并会在整个集合上进行迭代


321
00:18:03,617 --> 00:18:05,052 line:0
如果你在字典上调用地图


322
00:18:05,118 --> 00:18:08,655 line:0
就不会调用我们刚写的计数的新版本


323
00:18:11,124 --> 00:18:14,728 line:-1
为了在通用情境中调用


324
00:18:15,195 --> 00:18:18,131 line:-1
像这样的自定义方法或属性


325
00:18:18,632 --> 00:18:22,002 line:-2
它需要在协议上
把自己声明为一个要求


326
00:18:23,504 --> 00:18:26,106 line:-1
我们已经确定一定有一种方式


327
00:18:26,173 --> 00:18:29,209 line:0
可以让某些集合提供计数的优化版本


328
00:18:29,576 --> 00:18:33,213 line:0
这样它在协议上
把自己声明为一个要求就有意义了


329
00:18:34,348 --> 00:18:38,085 line:0
现在即便我们把它作为
一个要求来实施


330
00:18:39,786 --> 00:18:42,756 line:-2
所有集合
都不需要提供它们自己的实施


331
00:18:42,823 --> 00:18:45,559 line:-2
因为我们已经通过我们的扩展
提供了一个


332
00:18:45,626 --> 00:18:47,094 line:-1
可以应用在任意集合上


333
00:18:48,695 --> 00:18:51,798 line:0
向协议中添加一个要求
并且在旁边


334
00:18:51,865 --> 00:18:54,902 line:0
通过一个扩展添加一个默认实施


335
00:18:55,169 --> 00:18:58,238 line:0
这就是我们称为自定义点的东西


336
00:19:00,207 --> 00:19:02,609 line:-1
通过自定义点 编译器可以了解


337
00:19:02,809 --> 00:19:05,812 line:-2
有一个可用的方法
或属性的更好的实施


338
00:19:05,879 --> 00:19:09,716 line:0
因此在通用情境中


339
00:19:09,783 --> 00:19:13,987 line:0
它会在协议中动态地调遣那个实施


340
00:19:15,489 --> 00:19:18,025 line:0
那么现在如果你在字典上调用地图


341
00:19:18,292 --> 00:19:20,294 line:0
即便是一个完全通用的函数


342
00:19:20,494 --> 00:19:22,663 line:0
你将会得到计数的更好的实施


343
00:19:24,531 --> 00:19:26,466 line:0
添加这样的自定义点


344
00:19:26,800 --> 00:19:29,403 line:0
同时通过扩展添加默认实施


345
00:19:30,337 --> 00:19:33,106 line:0
是一种很强大的方式
可以获得同样的好处


346
00:19:33,340 --> 00:19:35,175 line:0
跟你用类获得的好处一样


347
00:19:35,242 --> 00:19:37,744 line:-1
实施继承和方法重写


348
00:19:38,212 --> 00:19:42,416 line:-2
但这个技巧可以用在
结构和枚举以及类上


349
00:19:45,252 --> 00:19:48,455 line:-2
现在并不是每一个方法
都可以像这样进行优化


350
00:19:49,122 --> 00:19:54,161 line:-2
并且自定义点在你的二进制尺寸上
有一个小但非零的影响


351
00:19:54,228 --> 00:19:55,929 line:-1
你的编译器运行时间的性能


352
00:19:56,363 --> 00:19:58,732 line:-1
那么只有当明确有机会自定义时


353
00:19:59,132 --> 00:20:01,835 line:-1
添加自定义点才有意义


354
00:20:02,503 --> 00:20:05,105 line:-1
比如在我们刚写的地图操作中


355
00:20:05,405 --> 00:20:08,509 line:0
并没有合理的方式让任意种类的集合


356
00:20:08,842 --> 00:20:11,578 line:0
提供更好的实施


357
00:20:12,012 --> 00:20:14,815 line:0
因此把它添加为一个自定义点
就没有意义


358
00:20:15,048 --> 00:20:16,984 line:0
仅仅保持为一个扩展就可以了


359
00:20:18,585 --> 00:20:20,554 line:-1
那么我们已经创建了这个集合类型


360
00:20:20,621 --> 00:20:22,089 line:-1
且它其实已拥有了完整的功能


361
00:20:22,155 --> 00:20:25,058 line:-1
它有尽可能多的不同的一致性类型


362
00:20:25,125 --> 00:20:27,895 line:-1
你可以为它写许多不同但有用的算法


363
00:20:28,562 --> 00:20:31,298 line:-2
但有时候
你不是只需要一个单一的协议


364
00:20:31,532 --> 00:20:33,700 line:-1
为了将各种类型进行分类


365
00:20:34,601 --> 00:20:36,336 line:-1
你需要协议继承


366
00:20:36,870 --> 00:20:39,006 line:-2
为了让大家了解更多信息
请Doug上台来


367
00:20:40,774 --> 00:20:45,913 line:-1
（协议继承）


368
00:20:45,979 --> 00:20:46,813 line:-1
谢谢Ben


369
00:20:48,549 --> 00:20:51,718 line:-2
那么协议继承
自Swift创建之初就有了


370
00:20:52,286 --> 00:20:54,922 line:-1
为了考虑我们在哪里需要协议继承


371
00:20:54,988 --> 00:20:57,925 line:-2
让我们看一下
我们一直在创建的这个集合协议


372
00:20:57,991 --> 00:21:00,027 line:-1
它是一个很好的协议 设计很棒


373
00:21:00,527 --> 00:21:02,563 line:-1
它描述了一组一致性类型


374
00:21:02,963 --> 00:21:06,300 line:-2
可以让你在类型上写一些
有趣的通用算法


375
00:21:06,700 --> 00:21:10,704 line:-2
但我们不用做太多
就能找到其它类似集合的算法


376
00:21:10,771 --> 00:21:14,608 line:-1
依据目前的集合协议 我们不能实施


377
00:21:15,142 --> 00:21:19,046 line:-1
比如如果我们想在集合中找到


378
00:21:19,379 --> 00:21:20,714 line:-1
匹配某谓语的最后一个元素索引


379
00:21:20,781 --> 00:21:24,451 line:-2
最佳方式就是从末端开始
然后倒着进行


380
00:21:24,985 --> 00:21:26,954 line:-1
集合协议不允许我们这样做


381
00:21:27,888 --> 00:21:30,090 line:-1
或者加入我们想创建一个洗牌操作


382
00:21:30,157 --> 00:21:32,626 line:-1
以便在集合中的元素之间随机洗牌


383
00:21:32,826 --> 00:21:35,662 line:-1
嗯 那需要突变 而集合不允许这样


384
00:21:35,729 --> 00:21:38,432 line:-1
现在并不是因为集合协议错了


385
00:21:39,833 --> 00:21:41,668 line:-1
而是我们需要更多的东西


386
00:21:41,735 --> 00:21:44,204 line:-1
来描述这些额外的通用算法


387
00:21:44,605 --> 00:21:46,940 line:-1
这就需要协议继承


388
00:21:47,274 --> 00:21:49,776 line:-1
这是BidirectionalCollection协议


389
00:21:49,977 --> 00:21:52,846 line:-1
继承自集合或者继承集合


390
00:21:53,614 --> 00:21:54,982 line:-1
意思就是


391
00:21:55,048 --> 00:21:57,851 line:-2
遵循BidirectionalCollection协议的
任意类型


392
00:21:58,285 --> 00:21:59,620 line:-1
同样也会遵循集合


393
00:21:59,686 --> 00:22:01,688 line:-1
你可以使用那些集合算法


394
00:22:02,122 --> 00:22:04,758 line:-2
但是BidirectionalCollection
添加了这个额外要求


395
00:22:04,825 --> 00:22:07,861 line:-1
就是能在集合中倒着操作


396
00:22:08,695 --> 00:22:09,897 line:-1
有一个重点需要注意


397
00:22:09,963 --> 00:22:13,500 line:-2
并不是每个集合都可以实施
这个特定的要求


398
00:22:13,901 --> 00:22:18,005 line:-2
思考一下SinglyLinkedList
你只能让这些指针


399
00:22:18,071 --> 00:22:19,973 line:-1
从一个位置跳到下一个位置


400
00:22:20,040 --> 00:22:22,843 line:-2
并没有一种有效的方式
可以按照这个顺序倒着进行


401
00:22:22,910 --> 00:22:25,379 line:-2
因此它不能是
BidirectionalCollection


402
00:22:25,679 --> 00:22:27,281 line:-1
那么一旦我们引入了继承


403
00:22:27,347 --> 00:22:29,449 line:-1
你就已经限制了一致性类型


404
00:22:30,050 --> 00:22:33,987 line:0
但你也允许你自己
实施更多有趣的算法


405
00:22:34,221 --> 00:22:37,090 line:0
那么这是这个lastIndex(where:)
操作背后的代码


406
00:22:37,357 --> 00:22:40,661 line:0
非常简单
我们只是在集合中倒着进行


407
00:22:40,961 --> 00:22:44,598 line:0
使用这个来自BidirectionalCollection
协议的新要求


408
00:22:46,567 --> 00:22:48,535 line:-1
让我们看一个更有意思的算法


409
00:22:48,836 --> 00:22:50,337 line:-1
那么这是一个洗牌操作


410
00:22:50,404 --> 00:22:53,607 line:-2
那么它在Swift 4.2中
针对集合进行了引入


411
00:22:53,674 --> 00:22:55,108 line:-1
你不需要自己实施它


412
00:22:55,175 --> 00:22:56,643 line:-1
我们会查看算法自身


413
00:22:56,710 --> 00:22:59,079 line:-1
了解它引入了哪些要求


414
00:22:59,146 --> 00:23:02,616 line:-2
从而算出如何有意义地将那些
归类到协议中


415
00:23:03,283 --> 00:23:06,086 line:-2
Fisher-Yates洗牌算法
是一个很古老的算法


416
00:23:06,153 --> 00:23:07,254 line:-1
它也非常简单


417
00:23:07,487 --> 00:23:10,691 line:-1
你从集合中第一个元素的索引开始


418
00:23:11,525 --> 00:23:13,861 line:-1
然后随机选择


419
00:23:14,161 --> 00:23:17,197 line:-2
集合中另一个元素
并把这两个元素交换一下


420
00:23:18,498 --> 00:23:22,703 line:-2
在下一次迭代中
你把左边的索引向前移动一个


421
00:23:23,470 --> 00:23:26,507 line:-2
在那个和最后一个之间随机选择
然后交换那些元素


422
00:23:26,807 --> 00:23:28,408 line:-1
那么算法非常简单


423
00:23:28,475 --> 00:23:31,044 line:-1
只是集合中的线性移动


424
00:23:31,879 --> 00:23:34,281 line:-1
随机选择另一个元素进行交换


425
00:23:34,681 --> 00:23:38,452 line:-2
在最后你会得到一个
经过漂亮洗牌的集合


426
00:23:39,486 --> 00:23:41,288 line:-1
那么我们可以看一下代码


427
00:23:41,355 --> 00:23:43,557 line:-1
有一点复杂 但不要担心


428
00:23:43,624 --> 00:23:46,560 line:0
我们要在某个集合上实施它


429
00:23:46,827 --> 00:23:48,829 line:0
那么让我们看一下这里的核心操作


430
00:23:48,896 --> 00:23:50,430 line:0
那么首先我们需要能获取


431
00:23:50,497 --> 00:23:53,033 line:0
随机编号
在我们目前在集合中的位置


432
00:23:53,100 --> 00:23:56,103 line:0
和集合末端之间 通过这个随机功能


433
00:23:56,336 --> 00:23:57,304 line:0
但那儿有一个整型


434
00:23:57,371 --> 00:23:59,239 line:0
我们需要的是集合中的索引


435
00:23:59,306 --> 00:24:00,474 line:0
我们知道那是不同的


436
00:24:00,541 --> 00:24:02,042 line:0
所以我们需要一些操作


437
00:24:02,109 --> 00:24:03,744 line:0
让我们把它叫做
Index offsetBy


438
00:24:04,478 --> 00:24:06,113 line:0
从startIndex迅速跳到


439
00:24:06,480 --> 00:24:08,749 line:0
我们所选择的任意位置


440
00:24:10,050 --> 00:24:13,854 line:0
我们所需要的另一个操作是
可以交换两个元素


441
00:24:14,888 --> 00:24:17,891 line:0
很棒 我们有两个操作
我们需要添加


442
00:24:17,958 --> 00:24:20,994 line:0
到集合的概念中 以便可以实施洗牌


443
00:24:21,295 --> 00:24:23,764 line:0
因此我们有一个
新的ShuffleCollection协议


444
00:24:26,633 --> 00:24:27,801 line:0
请不要这样做


445
00:24:28,068 --> 00:24:30,037 line:0
那么这是一个反面模式


446
00:24:30,504 --> 00:24:33,140 line:-1
这里的反面模式是我们有一个算法


447
00:24:33,207 --> 00:24:34,408 line:-1
我们找到它的要求


448
00:24:34,808 --> 00:24:38,412 line:-2
然后我们把它打包到一个协议中
就是那个…


449
00:24:39,246 --> 00:24:40,814 line:-1
描述那一个算法


450
00:24:41,048 --> 00:24:44,651 line:-2
如果你这样做了
你就拥有了许多协议


451
00:24:44,952 --> 00:24:46,553 line:-1
但并没有任何意义


452
00:24:46,620 --> 00:24:48,956 line:-1
你并不是在从那些协议中学习什么


453
00:24:49,022 --> 00:24:51,358 line:-1
因此你应该做的是注意


454
00:24:51,425 --> 00:24:53,927 line:-1
我们实际上在这里有不同的功能


455
00:24:54,394 --> 00:24:57,497 line:-2
那么洗牌使用的是随机存取
并使用了突变


456
00:24:57,898 --> 00:25:01,702 line:-2
但这些是不同的 并且我们可以
把它们归类为不同的协议


457
00:25:01,768 --> 00:25:04,571 line:-2
比如
RandomAccessCollection协议


458
00:25:04,938 --> 00:25:08,475 line:-2
就是可以让我们在集合中
跳来跳去的协议


459
00:25:08,542 --> 00:25:09,743 line:-1
可以迅速移动索引


460
00:25:10,410 --> 00:25:12,513 line:0
还有像UnsafeBufferPointer的类型


461
00:25:12,579 --> 00:25:16,650 line:0
可以给你提供随机存取
但不允许任何突变


462
00:25:16,717 --> 00:25:18,118 line:0
这是不同的功能


463
00:25:18,986 --> 00:25:21,522 line:0
我们这里还有
MutableCollection协议


464
00:25:22,256 --> 00:25:24,525 line:0
我们可以认为这里的类型允许突变


465
00:25:24,591 --> 00:25:25,626 line:0
但不允许随机获取


466
00:25:25,692 --> 00:25:28,195 line:0
就像我们刚讲过的
SinglyLinkedList一样


467
00:25:28,529 --> 00:25:32,032 line:0
现在请注意我们已经从根本上
分离了继承等级


468
00:25:33,233 --> 00:25:36,537 line:0
我们有用于随机存取
双向作用等等的存取端


469
00:25:36,603 --> 00:25:38,338 line:0
然后我们有这个突变端


470
00:25:38,705 --> 00:25:42,543 line:0
非常完美
因为客户自己可以编写多个协议


471
00:25:42,843 --> 00:25:45,245 line:-1
用来实施他们所写的通用算法


472
00:25:45,612 --> 00:25:47,514 line:-1
那么让我们返回到我们的洗牌算法


473
00:25:47,581 --> 00:25:51,752 line:-2
它可以在RandomAccessCollection上
作为一个扩展


474
00:25:51,818 --> 00:25:52,653 line:-1
带有自类型


475
00:25:52,719 --> 00:25:55,422 line:-2
所以这是一个既遵循
RandomAccessCollection


476
00:25:55,656 --> 00:25:58,058 line:-1
又遵循MutableCollection协议的类型


477
00:25:58,592 --> 00:26:01,295 line:-2
现在我们把这两个协议的功能
放在了一起


478
00:26:02,429 --> 00:26:05,532 line:-1
现在当你拥有许多一致性类型时


479
00:26:05,599 --> 00:26:07,301 line:-1
以及许多通用算法时


480
00:26:07,367 --> 00:26:10,237 line:-1
你常常会形成协议等级


481
00:26:10,671 --> 00:26:13,073 line:-1
这些等级不应该太长


482
00:26:13,140 --> 00:26:15,042 line:-1
不应该太深入


483
00:26:15,809 --> 00:26:17,711 line:-1
因为你其实是希望要少量的协议


484
00:26:17,778 --> 00:26:21,381 line:-2
只要能描述在域名中出现的类型即可
对吧？


485
00:26:22,583 --> 00:26:24,318 line:-1
现在你一定注意到了


486
00:26:24,384 --> 00:26:26,553 line:-1
当你着手创建这些协议等级时


487
00:26:26,620 --> 00:26:29,056 line:-1
那么随着你从等级的底层到顶层


488
00:26:29,489 --> 00:26:32,893 line:-1
你得到的协议会拥有较少的要求


489
00:26:32,960 --> 00:26:36,630 line:-2
因此有更多的一致性类型
可以实施那些要求


490
00:26:37,464 --> 00:26:40,100 line:-2
现在从另一方面说
随着你往等级的底层移动


491
00:26:40,801 --> 00:26:43,370 line:-1
并结合等级中不同的协议


492
00:26:43,437 --> 00:26:46,640 line:-1
你就要实施更复杂、更专业的算法


493
00:26:46,707 --> 00:26:48,775 line:-1
要求更高级的功能


494
00:26:48,842 --> 00:26:51,011 line:-2
但实际上只能用于
较少的一致性类型上


495
00:26:53,213 --> 00:26:54,047 line:-1
好的


496
00:26:55,582 --> 00:26:57,217 line:-1
让我们谈谈条件一致性


497
00:26:57,284 --> 00:26:59,820 line:-2
这是 当然了
Swift中的一个较新的功能


498
00:27:00,654 --> 00:27:02,990 line:-1
让我们首先从切片开始看


499
00:27:03,524 --> 00:27:07,961 line:-2
对于你所拥有的任意一个集合
你可以形成那个集合的一个切片


500
00:27:08,161 --> 00:27:12,833 line:-2
通过带有指定
索引范围的自定义下标实现


501
00:27:13,300 --> 00:27:16,770 line:-2
并且那个切片
其实是集合的某一个部分的视图


502
00:27:17,971 --> 00:27:21,909 line:-2
现在你在切片集合中
所得到的一种默认类型


503
00:27:22,209 --> 00:27:23,677 line:-1
叫做切片


504
00:27:24,444 --> 00:27:26,513 line:-1
并且切片是一个通用的适配器类型


505
00:27:27,314 --> 00:27:30,951 line:-1
那么它在基础集合类型上参数化了


506
00:27:31,552 --> 00:27:33,187 line:-1
它自己就是一个集合


507
00:27:33,954 --> 00:27:37,891 line:-2
所以我们对于切片的期待就是
你可以对切片做任何


508
00:27:37,958 --> 00:27:40,027 line:-1
你能对下面的集合所做的事


509
00:27:40,093 --> 00:27:41,528 line:-1
这个要求很合理


510
00:27:41,929 --> 00:27:44,932 line:-1
我们当然可以使用向前搜索操作


511
00:27:44,998 --> 00:27:47,701 line:-2
比如index(where:)
来查找匹配某个谓语的东西


512
00:27:47,768 --> 00:27:50,671 line:-2
那适用于集合
以及那个集合的任意切片


513
00:27:51,505 --> 00:27:54,141 line:0
我们想用向后搜索来做同样的事


514
00:27:54,208 --> 00:27:55,809 line:0
但在这里我们会产生一个问题


515
00:27:55,876 --> 00:27:58,512 line:0
即便缓冲器是一个
BidirectionalCollection


516
00:27:59,346 --> 00:28:02,149 line:0
并没说切片也是一个
BidirectionalCollection


517
00:28:04,685 --> 00:28:05,619 line:-1
我们可以修复这个问题


518
00:28:05,886 --> 00:28:09,623 line:-2
让我们把切片扩展一下
使它遵循BidirectionalCollection协议


519
00:28:10,457 --> 00:28:12,526 line:-2
我们需要实施这个
index(before:)操作


520
00:28:12,593 --> 00:28:16,163 line:-2
这样我们可以按照下面的基础集合
进行实施


521
00:28:17,064 --> 00:28:18,966 line:-1
除非编译器会在这里进行约束


522
00:28:19,700 --> 00:28:22,236 line:-2
关于基础集合
我们所了解的唯一一件事就是


523
00:28:22,302 --> 00:28:23,570 line:-1
它是一个集合


524
00:28:23,637 --> 00:28:26,273 line:-2
它并没有
index(before:)操作


525
00:28:27,808 --> 00:28:28,942 line:-1
我们知道如何修复这个问题


526
00:28:29,476 --> 00:28:32,579 line:-2
我们所需要做的就是
在这个扩展中引入一个要求


527
00:28:32,646 --> 00:28:35,282 line:-2
换句话说就是基础集合需要是
BidirectionalCollection


528
00:28:35,716 --> 00:28:37,251 line:-1
这是条件一致性


529
00:28:38,085 --> 00:28:42,356 line:-1
其实就是扩展声明遵循某个协议


530
00:28:42,723 --> 00:28:46,159 line:-2
然后那个协议下的约束条件
实际上就有意义了


531
00:28:46,994 --> 00:28:48,829 line:-1
关于条件一致性的最棒的事就是


532
00:28:48,896 --> 00:28:51,732 line:0
当你拥有这些协议等级时
它会漂亮地进行堆栈


533
00:28:51,798 --> 00:28:55,636 line:0
所以我们还可以说切片是一个
RandomAccessCollection


534
00:28:55,969 --> 00:28:59,306 line:-2
当它下面的基础类型是
RandomAccessCollection时


535
00:29:00,374 --> 00:29:03,010 line:-2
现在请注意
我在这里写了两个不同的扩展


536
00:29:03,744 --> 00:29:05,579 line:0
它是常见的Swift样式


537
00:29:06,013 --> 00:29:08,348 line:0
写扩展 让它遵循某个协议


538
00:29:08,415 --> 00:29:11,051 line:0
这样你就知道该扩展是干什么的
你就了解了它的意思


539
00:29:11,418 --> 00:29:16,223 line:0
它有条件一致性特别重要


540
00:29:16,290 --> 00:29:19,793 line:0
因为你在这些扩展上有不同的要求


541
00:29:21,261 --> 00:29:22,829 line:0
这就允许有可组合性


542
00:29:22,896 --> 00:29:25,299 line:0
无论下面的基层集合可以做什么


543
00:29:25,832 --> 00:29:27,367 line:0
切片类型同样也可以做


544
00:29:30,470 --> 00:29:33,040 line:-2
那么让我们看看
条件一致性的另一个app


545
00:29:33,106 --> 00:29:35,409 line:-1
也是在标准程序库中 这些是范围


546
00:29:35,475 --> 00:29:37,611 line:-1
那么范围永远存在于Swift中


547
00:29:37,678 --> 00:29:40,948 line:-2
你可以形成一个范围
比如说这些操作符


548
00:29:41,415 --> 00:29:45,352 line:-2
因此你可以形成双精度浮点型范围
也可以形成整型范围


549
00:29:45,886 --> 00:29:48,155 line:-1
但有些范围比另外一些更强大


550
00:29:48,355 --> 00:29:52,326 line:-1
那么你可以在整型范围内迭代元素


551
00:29:52,860 --> 00:29:53,827 line:-1
为什么你能这样做呢？


552
00:29:53,894 --> 00:29:56,797 line:-1
那是因为intRange遵循集合


553
00:29:58,198 --> 00:29:59,833 line:-1
现在如果你查看一下类型


554
00:29:59,900 --> 00:30:01,969 line:-1
由那个运算符创建的类型


555
00:30:02,302 --> 00:30:04,738 line:-1
它适当地命名了范围类型


556
00:30:05,305 --> 00:30:08,075 line:-2
它相对于下面的绑定类型来说
是通用的


557
00:30:08,141 --> 00:30:10,043 line:-2
这种情况下
我们有一系列双浮点精度型


558
00:30:10,110 --> 00:30:12,513 line:-1
它仅仅存储较低和较高的绑定型


559
00:30:12,579 --> 00:30:13,580 line:-1
非常简单


560
00:30:14,248 --> 00:30:18,819 line:-2
但在Swift 4.2之前
你从整型范围中得到的


561
00:30:18,886 --> 00:30:20,320 line:-1
实际上是一个不同的类型


562
00:30:20,387 --> 00:30:22,289 line:-1
这是CountableRange类型


563
00:30:23,090 --> 00:30:25,993 line:0
现在请注意
它与范围类型的结构一模一样


564
00:30:26,059 --> 00:30:27,160 line:0
它有一个类型参数


565
00:30:27,227 --> 00:30:28,729 line:0
它有较低和较高绑定型


566
00:30:29,329 --> 00:30:33,066 line:0
但它在那个绑定型上
增加了一些额外的要求


567
00:30:33,300 --> 00:30:35,369 line:0
那个绑定型是可跨过的 对吧？


568
00:30:35,435 --> 00:30:37,771 line:0
意思是你可以枚举全部元素


569
00:30:37,838 --> 00:30:40,007 line:0
现在这是你所需要的功能 从而可以


570
00:30:40,073 --> 00:30:42,709 line:0
让CountableRange遵循
RandomAccessCollection


571
00:30:43,777 --> 00:30:46,813 line:0
那就启用了forEach迭代循环
和其它功能


572
00:30:47,981 --> 00:30:50,851 line:0
但是通过条件一致性 当然了
我们可以做得更好


573
00:30:51,518 --> 00:30:56,089 line:-2
让我们把基础范围类型
变成一个集合


574
00:30:56,890 --> 00:31:01,395 line:-2
当绑定类型
拥有这些额外的可跨过的要求时


575
00:31:01,662 --> 00:31:04,064 line:-1
它是条件一致性的简单app


576
00:31:04,131 --> 00:31:09,236 line:-2
但它让范围类型变得更强大
当和更好的类型参数一起使用时


577
00:31:10,737 --> 00:31:14,842 line:-2
现在请注意我只是遵循
RandomAccessCollection


578
00:31:15,442 --> 00:31:19,279 line:-2
我其实没有提到集合
或BidirectionalCollection


579
00:31:20,113 --> 00:31:22,683 line:-1
这是无条件顺应 没问题


580
00:31:22,983 --> 00:31:25,652 line:-2
声明遵循
RandomAccessCollection


581
00:31:25,719 --> 00:31:29,523 line:-1
暗示着遵循它所继承的任何协议


582
00:31:29,590 --> 00:31:32,125 line:-2
在本例中是
BidirectionalCollection和集合


583
00:31:32,693 --> 00:31:35,696 line:-2
然而对于条件一致性
这实际上是个错误


584
00:31:36,563 --> 00:31:38,632 line:-1
现在如果你回想一下切片例子


585
00:31:38,699 --> 00:31:40,968 line:-1
我们需要有不同的约束


586
00:31:41,235 --> 00:31:43,637 line:-1
来处理那些不同的等级


587
00:31:43,704 --> 00:31:45,639 line:-2
针对集合与
BidirectionalCollection


588
00:31:45,706 --> 00:31:47,241 line:-1
与RandomAccessCollection


589
00:31:47,708 --> 00:31:50,577 line:-2
因此编译器会强制执行
你要考虑到这个


590
00:31:50,644 --> 00:31:53,180 line:-1
并确保你拥有正确的约束条件


591
00:31:53,247 --> 00:31:54,781 line:-1
对于条件一致性来说


592
00:31:55,849 --> 00:31:59,052 line:-2
在本例中
整个等级的约束条件都是相同的


593
00:31:59,353 --> 00:32:02,856 line:-2
我们可以只明确写出集合
和BidirectionalCollection


594
00:32:03,290 --> 00:32:06,026 line:-1
以宣称这就是全部一致性的位置


595
00:32:06,426 --> 00:32:08,495 line:-1
或者我们可以做得更好


596
00:32:08,695 --> 00:32:10,597 line:-1
分离不同的一致性


597
00:32:12,432 --> 00:32:15,269 line:-2
现在这点上
我们的范围类型非常强大


598
00:32:15,335 --> 00:32:17,137 line:-2
它会做一切CountableRange
所能做的工作


599
00:32:17,204 --> 00:32:19,106 line:-2
我们应该如何使用
CountableRange呢？


600
00:32:19,506 --> 00:32:20,541 line:-1
我们可以把它丢到一边去


601
00:32:20,607 --> 00:32:22,576 line:-1
在本例中我们讲的是标准程序库


602
00:32:22,643 --> 00:32:25,679 line:-2
有许多代码实际上使用了
CountableRange


603
00:32:25,946 --> 00:32:29,583 line:-2
因此我们可以把它作为通用类型别名
保留下来


604
00:32:30,951 --> 00:32:32,419 line:0
这是一个很棒的方案


605
00:32:32,486 --> 00:32:36,256 line:0
那么通用类型别名添加了


606
00:32:36,523 --> 00:32:37,791 line:0
让范围可计数所需要的全部额外要求


607
00:32:38,025 --> 00:32:40,794 line:0
你需要把这些要求放在集合中


608
00:32:41,395 --> 00:32:44,865 line:0
但它只是下面范围类型的
一个可替换的名字


609
00:32:46,700 --> 00:32:48,235 line:0
这对于源兼容性来说很棒


610
00:32:48,302 --> 00:32:50,804 line:-2
因为代码仍可使用
CountableRange


611
00:32:51,071 --> 00:32:54,107 line:-1
从另一方面说 它还可以


612
00:32:54,308 --> 00:32:57,311 line:-2
给那些拥有额外功能的范围
取一个漂亮的名字


613
00:32:57,377 --> 00:32:59,213 line:-2
额外功能只是成为
RandomAccessCollection


614
00:32:59,880 --> 00:33:02,149 line:-1
事实上我们可以用此来清理其它代码


615
00:33:02,216 --> 00:33:04,518 line:-2
比如 我们知道什么是
CountableRange


616
00:33:04,818 --> 00:33:08,055 line:-1
它是带有这种额外跨越功能的范围


617
00:33:08,589 --> 00:33:10,591 line:-2
因此我们可以扩展
CountableRanges


618
00:33:10,858 --> 00:33:14,995 line:-2
这就是我们拥有RandomAccessCollection
一致性的情况


619
00:33:16,430 --> 00:33:18,198 line:-1
Swift 4.2中引入了这个


620
00:33:18,632 --> 00:33:21,068 line:-1
用于帮助简化我们要处理的类型


621
00:33:21,134 --> 00:33:23,303 line:-1
并让现有核心类型 比如范围


622
00:33:23,570 --> 00:33:25,339 line:-1
组合性更强 也更灵活


623
00:33:27,608 --> 00:33:28,442 line:-1
好的


624
00:33:29,476 --> 00:33:30,477 line:-1
最后一个话题


625
00:33:31,411 --> 00:33:33,413 line:-1
那么Swift是一个多范式语言


626
00:33:33,480 --> 00:33:36,016 line:-1
现在我们一直在专心讲通用型


627
00:33:36,083 --> 00:33:39,152 line:-2
但是当然了
Swift也支持面向对象的编程


628
00:33:40,087 --> 00:33:41,622 line:-1
那么我想花一些时间


629
00:33:41,688 --> 00:33:44,758 line:-1
谈谈这两个功能之间的相互影响


630
00:33:44,825 --> 00:33:47,060 line:-2
以及它们如何在Swift语言中
协同合作


631
00:33:47,594 --> 00:33:51,465 line:-2
那么对于类继承
我们知道类继承是如何运作的


632
00:33:51,532 --> 00:33:52,432 line:-1
非常简单


633
00:33:52,799 --> 00:33:54,868 line:-1
你可以声明一个超类 比如汽车


634
00:33:54,935 --> 00:33:57,871 line:-2
你可以声明某些子类
比如出租车和警车


635
00:33:57,938 --> 00:33:59,373 line:-1
它们都继承自汽车


636
00:34:00,007 --> 00:34:02,910 line:-2
一旦你这么做了
你就拥有了这个面向对象的等级


637
00:34:03,343 --> 00:34:06,947 line:-1
你期望那些子类可以在哪里使用


638
00:34:07,381 --> 00:34:10,150 line:-1
那么如果我要用一个新方法扩展汽车


639
00:34:10,217 --> 00:34:11,251 line:-1
让它变成驱动器


640
00:34:11,918 --> 00:34:16,556 line:-2
我非常期待我可以在我的一个子类上
调用那个方法 比如出租车


641
00:34:17,925 --> 00:34:21,862 line:-2
那么这是面向对象编程中的一个
根本方面


642
00:34:22,161 --> 00:34:25,065 line:-2
Barbara Liskov其实
很好地描述了相关信息


643
00:34:25,132 --> 00:34:26,567 line:-1
在80年代的一场演讲中


644
00:34:27,234 --> 00:34:30,571 line:-2
自那时起 我们就把这个叫做
Liskov替换原则


645
00:34:30,904 --> 00:34:32,773 line:-1
理念其实很简单


646
00:34:33,273 --> 00:34:35,876 line:-1
那么如果你的程序中有一些地方


647
00:34:35,943 --> 00:34:41,348 line:-1
引用了一个超类型或超类 比如汽车


648
00:34:42,349 --> 00:34:46,420 line:-2
你就应该可以获取它的子类型
或子类的任意实例


649
00:34:47,286 --> 00:34:50,858 line:-1
比如出租车或汽车子类 并使用它


650
00:34:51,257 --> 00:34:54,494 line:-2
程序应该仍然继续监测类型
并正常运行


651
00:34:55,062 --> 00:34:57,397 line:-1
那么这里的替换是作为子类的实例


652
00:34:57,464 --> 00:35:00,734 line:-2
应该可以去到
子类所能去到的任何地方


653
00:35:01,768 --> 00:35:03,270 line:-1
这是一个很简单的原则


654
00:35:03,337 --> 00:35:06,473 line:-1
我们把它内在化了 但它仍然很强大


655
00:35:06,840 --> 00:35:08,108 line:-1
如果你思考一下的话


656
00:35:08,342 --> 00:35:09,910 line:-1
请考虑你程序中的任何一点


657
00:35:09,977 --> 00:35:12,079 line:-2
如果我得到一个不同的子类
会发生什么


658
00:35:12,145 --> 00:35:14,214 line:-1
也许是一个我没有想到的子类？


659
00:35:15,516 --> 00:35:18,185 line:-1
那么返回到通用型


660
00:35:19,353 --> 00:35:22,823 line:-1
当在通用型系统上应用


661
00:35:23,156 --> 00:35:24,725 line:-2
Liskov替换原则时
我们期待什么呢？


662
00:35:25,392 --> 00:35:28,195 line:-2
也许我们添加了一个新协议
可驾驶 无论是什么


663
00:35:28,762 --> 00:35:31,665 line:-1
并把汽车扩展为可驾驶


664
00:35:31,899 --> 00:35:33,166 line:-1
我们期待发生什么呢？


665
00:35:33,233 --> 00:35:36,503 line:-1
我们期待你可以使用协议一致性


666
00:35:36,570 --> 00:35:40,073 line:-2
把汽车的一致性用于可驾驶的一致性
并用在它的某些子类上


667
00:35:41,041 --> 00:35:45,179 line:0
比如你在可驾驶协议中
添加了一个简单的通用算法


668
00:35:45,245 --> 00:35:46,713 line:0
比如sundayDrive


669
00:35:46,780 --> 00:35:50,884 line:0
现在你应该可以在警车上使用
那个API了


670
00:35:51,351 --> 00:35:53,220 line:0
即使这并不是最好的方式


671
00:35:54,721 --> 00:36:00,260 line:0
那么子类有效地继承了协议一致性


672
00:36:01,195 --> 00:36:03,197 line:-1
并且这在一致性上添加了约束


673
00:36:03,263 --> 00:36:04,865 line:-1
你所写的那个一致性


674
00:36:04,932 --> 00:36:07,401 line:-1
就是让汽车可驾驶的东西


675
00:36:07,668 --> 00:36:10,637 line:-1
现在必须适用于汽车的全部子类


676
00:36:10,938 --> 00:36:13,307 line:-1
以及稍后出现的子类


677
00:36:14,274 --> 00:36:16,710 line:-1
大部分时候就是有用


678
00:36:17,711 --> 00:36:19,046 line:-1
然而在某些情况下


679
00:36:19,112 --> 00:36:22,482 line:-1
它会在子类上添加一些新要求


680
00:36:23,116 --> 00:36:27,487 line:-2
最常见的就是
当处理初始化程序要求时


681
00:36:28,555 --> 00:36:30,757 line:-1
那么如果你查看了可解协议


682
00:36:30,824 --> 00:36:34,461 line:-2
它有一个有趣的要求
就是初始化程序要求


683
00:36:34,795 --> 00:36:39,099 line:-1
从解码器中创建符合型的新实例


684
00:36:40,667 --> 00:36:41,602 line:-1
我们要如何使用它呢？


685
00:36:41,869 --> 00:36:44,838 line:-2
让我们继续向可解协议中
添加一个便捷方法


686
00:36:45,138 --> 00:36:48,542 line:-2
它是一个静态方法解码
从解码器中生成新实例


687
00:36:48,742 --> 00:36:51,612 line:-2
其实就是初始化程序的一个包装
让它简单易用


688
00:36:52,379 --> 00:36:56,884 line:-2
关于这个特定的方法
你需要注意两个有意思的事情


689
00:36:57,284 --> 00:36:59,820 line:-2
首先它是否一个
带大写字母S的Self


690
00:36:59,887 --> 00:37:01,588 line:-1
请记住这是一致性类型


691
00:37:01,889 --> 00:37:04,992 line:-1
它与你在静态方法上调用的类型相同


692
00:37:06,560 --> 00:37:10,163 line:-2
现在第二件有意思的事是
我们要如何实施它？


693
00:37:10,230 --> 00:37:12,833 line:-1
我们调用上边那个初始化程序


694
00:37:12,900 --> 00:37:14,601 line:-1
来创建一个全新的实例


695
00:37:14,902 --> 00:37:19,406 line:-2
是我们所拥有的可解码类型的实例
然后返回它


696
00:37:21,208 --> 00:37:22,042 line:-1
很公平


697
00:37:22,543 --> 00:37:24,945 line:-1
我们可以继续并让汽车类型可解码


698
00:37:25,812 --> 00:37:27,748 line:-1
然后我们期待


699
00:37:27,814 --> 00:37:29,716 line:-1
当应用Liskov替换原理时


700
00:37:29,783 --> 00:37:32,886 line:-1
我们可以使用汽车的任意子类


701
00:37:33,487 --> 00:37:36,156 line:0
带有我们通过协议一致性
创建的这些新API


702
00:37:36,223 --> 00:37:39,226 line:0
那么我们可以在出租车子类上
调用解码


703
00:37:39,893 --> 00:37:41,495 line:0
而我们得到的不是汽车


704
00:37:41,562 --> 00:37:45,465 line:0
也不是任意汽车实例 而是出租车
出租车的实例


705
00:37:47,100 --> 00:37:48,635 line:0
很棒 但应该如何使用它？


706
00:37:49,503 --> 00:37:52,639 line:0
让我们看看出租车会包含什么？


707
00:37:52,706 --> 00:37:54,241 line:0
也许这里有一个按小时计费的工具


708
00:37:54,308 --> 00:37:56,643 line:0
当我们调用
Taxi.decode(from:)时


709
00:37:57,511 --> 00:37:58,679 line:0
我们就会通过协议


710
00:37:58,745 --> 00:38:01,181 line:0
通过协议初始化程序要求


711
00:38:01,582 --> 00:38:03,951 line:-1
它其实只能调用一个初始化程序


712
00:38:04,218 --> 00:38:10,224 line:-1
就是在汽车类内部声明的初始化程序


713
00:38:10,290 --> 00:38:11,458 line:-1
在这里的超类中


714
00:38:12,893 --> 00:38:17,130 line:0
那么那个初始化工具
它知道如何解码汽车的全部状态


715
00:38:17,598 --> 00:38:19,867 line:0
但它并不了解出租车子类


716
00:38:20,734 --> 00:38:23,003 line:0
那么如果我们要直接使用这个
初始化程序


717
00:38:23,070 --> 00:38:24,271 line:0
我们会产生一个问题


718
00:38:24,338 --> 00:38:26,940 line:0
hourlyRate
完全未被初始化


719
00:38:27,140 --> 00:38:29,543 line:0
那会导致一些更不幸的误解


720
00:38:29,610 --> 00:38:31,044 line:0
当你在最后得到账单时


721
00:38:32,746 --> 00:38:34,014 line:0
我们该如何解决这个？


722
00:38:34,081 --> 00:38:37,150 line:0
看起来Swift
不会让你陷入这个问题中


723
00:38:37,818 --> 00:38:41,722 line:0
它会在你尝试让汽车遵循
可解码协议时进行判断


724
00:38:41,788 --> 00:38:45,192 line:0
是指那个初始化程序中
有问题的可解码协议


725
00:38:45,259 --> 00:38:47,427 line:0
它应该被标记为必需


726
00:38:49,329 --> 00:38:53,634 line:0
现在必须在全部超类中实施
所必需的初始化程序


727
00:38:53,901 --> 00:38:55,736 line:0
不仅仅是直接的超类


728
00:38:56,003 --> 00:38:58,405 line:0
而是任意一个超类


729
00:38:58,472 --> 00:39:00,941 line:0
以及你现在还不知道的
将来可能会出现的超类


730
00:39:02,209 --> 00:39:03,677 line:0
现在通过添加那个要求


731
00:39:03,911 --> 00:39:07,414 line:0
意味着当出租车从汽车中继承时


732
00:39:07,614 --> 00:39:12,286 line:0
它还需要引入一个
拥有相同名称的初始化程序


733
00:39:13,020 --> 00:39:15,989 line:0
现在这非常重要
因为这个初始化程序负责


734
00:39:16,223 --> 00:39:17,958 line:0
解码hourlyRate


735
00:39:18,192 --> 00:39:20,561 line:0
然后锁住超类初始化程序


736
00:39:20,627 --> 00:39:22,829 line:0
以便解码剩余的汽车类型


737
00:39:25,365 --> 00:39:26,200 line:-1
好的


738
00:39:26,667 --> 00:39:29,236 line:-1
现在如果你快速阅读了那些红色方框


739
00:39:29,303 --> 00:39:32,573 line:0
你可能会注意到子短语并不是最终


740
00:39:33,240 --> 00:39:36,944 line:0
那么从定义上说 最终类没有子类


741
00:39:37,344 --> 00:39:40,280 line:0
因此从本质上说
它稍后会让它们免于替换


742
00:39:42,516 --> 00:39:45,419 line:-2
意思是拥有一个必需初始化程序
没有意义


743
00:39:45,485 --> 00:39:47,421 line:-1
因为你知道那儿没有子类


744
00:39:47,487 --> 00:39:50,457 line:-1
因此最终类用起来稍微简单点儿


745
00:39:50,524 --> 00:39:53,827 line:-2
当处理诸如可解码
或其它初始化程序要求方面


746
00:39:53,894 --> 00:39:55,229 line:-1
因为它们不需遵循这些规则


747
00:39:55,295 --> 00:39:57,097 line:-1
即拥有必需初始化程序


748
00:39:58,365 --> 00:40:01,368 line:-1
那么当你用类引用语义时


749
00:40:02,436 --> 00:40:06,206 line:-2
考虑使用最终类
当你不再需要自定义类时


750
00:40:06,540 --> 00:40:08,275 line:-1
通过集成机制


751
00:40:08,575 --> 00:40:12,145 line:-2
现在这并不意味着
你稍后不能自定义你的类


752
00:40:12,212 --> 00:40:13,947 line:-1
你仍然可以在类上写扩展


753
00:40:14,014 --> 00:40:16,216 line:-1
与你扩展结构或枚举的方式一样


754
00:40:17,017 --> 00:40:20,153 line:-2
你还可以给它添加一致性
以获取更加动态的调遣


755
00:40:21,321 --> 00:40:24,091 line:-2
但最终类可以通过通用系统
简化相互作用


756
00:40:24,157 --> 00:40:27,427 line:-2
也会解锁在运行时间内
优化编译器的机会


757
00:40:30,731 --> 00:40:32,900 line:-1
我们今天谈了谈Swift的通用型


758
00:40:32,966 --> 00:40:36,970 line:-2
Swift通用型背后的理念
是提供重复使用代码的能力


759
00:40:37,237 --> 00:40:39,273 line:-1
同时保持静态类型信息


760
00:40:39,606 --> 00:40:41,742 line:-1
使得写正确的程序变得较为简单


761
00:40:41,808 --> 00:40:45,479 line:-1
并把这些有效地编译到执行程序中


762
00:40:46,180 --> 00:40:47,714 line:-1
当你设计协议时


763
00:40:48,048 --> 00:40:49,816 line:-1
让这个进行拉锯战


764
00:40:49,883 --> 00:40:52,986 line:-1
在你想要写的协议的通用算法之间


765
00:40:53,053 --> 00:40:55,956 line:-1
并且一致性类型需要实施那个协议


766
00:40:56,023 --> 00:40:58,959 line:-2
以便指导你的设计成为一个
有意义的提取


767
00:41:00,027 --> 00:41:01,762 line:-1
引入协议继承


768
00:41:01,828 --> 00:41:04,464 line:-1
当你需要更多特定功能


769
00:41:04,531 --> 00:41:08,135 line:-1
来实施新的通用算法时


770
00:41:08,202 --> 00:41:10,103 line:-1
只有一致性类型的子集支持那些算法


771
00:41:11,071 --> 00:41:14,675 line:-1
还有条件一致性 当你写通用类型时


772
00:41:14,975 --> 00:41:18,111 line:-1
以便它们可以编写得很漂亮


773
00:41:18,178 --> 00:41:20,280 line:-1
尤其是当与协议继承一起使用时


774
00:41:20,781 --> 00:41:23,784 line:-2
最后当你针对棘手的相互作用
产生疑问时


775
00:41:23,851 --> 00:41:26,386 line:-1
在类继承和通用系统之间


776
00:41:27,020 --> 00:41:29,489 line:-1
返回到Liskov替换原理


777
00:41:29,556 --> 00:41:31,825 line:-1
思考一下这里发生了什么


778
00:41:32,259 --> 00:41:35,429 line:-1
如果我引入子类而不是超类


779
00:41:35,495 --> 00:41:36,964 line:-2
我在子类而非超类上
写了一个一致性


780
00:41:39,933 --> 00:41:41,168 line:0
非常感谢


781
00:41:41,235 --> 00:41:43,904 line:0
还有一些关于拥抱算法的相关演讲


782
00:41:43,971 --> 00:41:46,306 line:0
你可以了解它们会如何帮助你
创建更好的代码


783
00:41:46,373 --> 00:41:50,611 line:0
以及如何在你的日常编程中
有效地使用Swift集合


784
00:41:51,411 --> 00:41:52,246 line:-1
谢谢

