1
00:00:17,150 --> 00:00:22,055 line:0
（Metal游戏性能优化）


2
00:00:22,122 --> 00:00:24,491 line:0
（演讲612）


3
00:00:29,329 --> 00:00:31,231 line:0
早上好 欢迎来到本次演讲


4
00:00:31,832 --> 00:00:34,368 line:-1
我叫Guillem Vinals Gangolells


5
00:00:34,434 --> 00:00:37,604 line:-2
在Apple的
GPU软件性能团队工作


6
00:00:38,839 --> 00:00:42,709 line:-2
你们这样的游戏开发者
使iOS成为一个优秀的游戏平台


7
00:00:43,243 --> 00:00:45,546 line:-2
在Apple
我们当然想助一臂之力


8
00:00:46,380 --> 00:00:49,216 line:-2
所以今年
我们检查了一些顶级的iOS游戏


9
00:00:49,583 --> 00:00:51,552 line:-1
并发现了一些常见的性能问题


10
00:00:52,386 --> 00:00:53,921 line:-1
我们分析了很多数据


11
00:00:54,188 --> 00:00:56,023 line:-1
作为调查的结果


12
00:00:56,423 --> 00:00:58,225 line:-1
我们决定做这个谈话


13
00:00:59,860 --> 00:01:01,862 line:-1
所以这将是今天的主题


14
00:01:02,296 --> 00:01:03,730 line:-1
开发出色的游戏


15
00:01:04,965 --> 00:01:07,868 line:-1
但是 我只能在这里提供技术指导


16
00:01:07,935 --> 00:01:09,303 line:-1
所以我们只能满足于此


17
00:01:09,369 --> 00:01:11,238 line:-1
（开发技术出色的游戏）


18
00:01:11,305 --> 00:01:12,272 line:-1
在开始之前


19
00:01:12,940 --> 00:01:14,908 line:-1
我想借机感谢Croteam的朋友


20
00:01:15,309 --> 00:01:17,711 line:-1
他们是《塔洛斯法则》背后的开发者


21
00:01:18,011 --> 00:01:19,546 line:-1
这是一款非常棒的游戏


22
00:01:19,847 --> 00:01:22,716 line:-2
你将在这些幻灯片
和两个演示中看到它


23
00:01:23,917 --> 00:01:26,787 line:-1
请注意 它具有令人惊叹的视觉效果


24
00:01:27,221 --> 00:01:29,623 line:-1
但它确实在性能上没变差


25
00:01:29,990 --> 00:01:31,458 line:-1
这就是我们今天的目标


26
00:01:32,059 --> 00:01:34,027 line:-1
让我们快速过一下今天的议题


27
00:01:36,396 --> 00:01:38,398 line:-1
我将首先介绍这些工具


28
00:01:38,832 --> 00:01:40,367 line:-1
这是一个非常好的起步


29
00:01:40,868 --> 00:01:43,804 line:-1
然后我们将讨论实际的性能问题


30
00:01:44,371 --> 00:01:48,141 line:-1
有关帧速 线程优先级 热状态


31
00:01:48,509 --> 00:01:50,043 line:-1
和不必要的GPU工作


32
00:01:51,078 --> 00:01:53,780 line:-1
尽管所有这些问题似乎互不相关


33
00:01:54,281 --> 00:01:56,283 line:-1
它们会互相复合和影响


34
00:01:56,483 --> 00:01:58,118 line:-1
所以解决所有这些问题很重要


35
00:01:59,820 --> 00:02:01,021 line:-1
让我们从工具开始


36
00:02:01,788 --> 00:02:03,690 line:-1
（分析工具）


37
00:02:03,757 --> 00:02:04,625 line:-1
（及早分析及经常分析）


38
00:02:04,691 --> 00:02:06,493 line:-1
这是最重要的建议


39
00:02:06,760 --> 00:02:09,429 line:-1
你应该尽早建档分析并经常更新


40
00:02:10,564 --> 00:02:13,233 line:-2
除非你已经对游戏进行了分析
否则不要推出游戏


41
00:02:13,967 --> 00:02:16,570 line:-1
为此 你需要了解这些工具


42
00:02:17,471 --> 00:02:19,940 line:-1
今天 我将关注其中两个


43
00:02:20,941 --> 00:02:22,709 line:-2
首先
我们看Instruments


44
00:02:23,043 --> 00:02:24,678 line:-1
这是我们的主要分析工具


45
00:02:25,345 --> 00:02:27,581 line:-1
你会想用它来理解性能


46
00:02:28,148 --> 00:02:30,284 line:-1
延迟和总体时间


47
00:02:31,151 --> 00:02:33,687 line:-1
其次 我们有Metal框架调试器


48
00:02:34,021 --> 00:02:35,689 line:-1
这也是一个非常强大的工具


49
00:02:36,323 --> 00:02:38,892 line:-1
你希望用它来调试GPU工作负载


50
00:02:40,627 --> 00:02:41,828 line:-1
我们从哪里开始呢？


51
00:02:42,763 --> 00:02:44,164 line:-1
这是我们经常遇到的问题


52
00:02:45,132 --> 00:02:47,701 line:-1
嗯 今年我们让你们更轻松


53
00:02:48,135 --> 00:02:50,237 line:0
我们正在推出一种新的仪器模板


54
00:02:50,671 --> 00:02:52,673 line:0
这将是一个很好的起点


55
00:02:53,073 --> 00:02:54,508 line:0
游戏性能模板


56
00:02:55,275 --> 00:02:57,744 line:0
这是现有工具的组合


57
00:02:58,245 --> 00:02:59,713 line:-1
例如系统跟踪


58
00:03:00,581 --> 00:03:01,548 line:-1
时间分析仪


59
00:03:02,082 --> 00:03:03,317 line:-1
和Metal系统跟踪


60
00:03:03,951 --> 00:03:05,319 line:-1
我们为你配置好了


61
00:03:05,619 --> 00:03:09,223 line:-2
它会记录与你的游戏相关的
所有CPU和GPU数据


62
00:03:09,656 --> 00:03:10,757 line:-1
所以你可以用它调试


63
00:03:12,259 --> 00:03:14,261 line:-2
那么我们如何推出呢？
我们怎么到那里？


64
00:03:14,695 --> 00:03:15,529 line:-1
嗯…


65
00:03:15,696 --> 00:03:18,899 line:-2
只需打开Instruments
它就在屏幕中心


66
00:03:19,967 --> 00:03:20,934 line:-1
选择后


67
00:03:21,001 --> 00:03:23,704 line:-1
你将像设任何其它模板一样设置


68
00:03:24,838 --> 00:03:27,407 line:-2
开始记录后
你将在窗口模式下执行此操作


69
00:03:27,808 --> 00:03:30,644 line:-1
允许你任意地玩游戏


70
00:03:30,978 --> 00:03:33,714 line:-1
只有最后几秒的数据会被记录下来


71
00:03:34,114 --> 00:03:37,317 line:-1
这就是最后几秒数据的样子


72
00:03:38,785 --> 00:03:42,422 line:-1
有很多信息 所以我们简单概述一下


73
00:03:43,457 --> 00:03:45,092 line:-1
（系统跟踪和时间分析仪）


74
00:03:45,158 --> 00:03:47,928 line:-1
首先 我们有系统跟踪和时间分析仪


75
00:03:47,995 --> 00:03:50,264 line:-1
它将为你提供系统负载的概述


76
00:03:50,330 --> 00:03:52,399 line:-1
以及你的app CPU使用情况


77
00:03:53,300 --> 00:03:55,636 line:-1
例如 用户交互式加载


78
00:03:55,702 --> 00:03:58,705 line:-1
将记录给定时间内的所有活动线程


79
00:03:59,273 --> 00:04:00,107 line:-1
在这种情况下


80
00:04:00,807 --> 00:04:02,176 line:-1
你看到的橙色


81
00:04:02,643 --> 00:04:05,279 line:-1
表示可运行的线程数量


82
00:04:05,445 --> 00:04:06,547 line:-1
大于CPU核心数


83
00:04:06,813 --> 00:04:08,148 line:-1
所以有一些意外情况


84
00:04:09,016 --> 00:04:11,318 line:-1
这将提供系统的绝佳视图


85
00:04:12,753 --> 00:04:14,188 line:0
有几个很棒的谈话


86
00:04:14,388 --> 00:04:16,456 line:0
更深入地探讨这个工具


87
00:04:16,990 --> 00:04:18,225 line:-1
请进一步关注这些


88
00:04:20,327 --> 00:04:22,863 line:-1
下一个是Metal系统跟踪


89
00:04:23,096 --> 00:04:24,398 line:-1
我们的GPU分析工具


90
00:04:24,932 --> 00:04:27,534 line:-1
它提供了图形堆栈的绝佳视图


91
00:04:28,135 --> 00:04:29,870 line:-1
从Metal框架


92
00:04:30,270 --> 00:04:31,338 line:-1
一直到到显示


93
00:04:32,539 --> 00:04:33,740 line:-1
特别注意


94
00:04:33,974 --> 00:04:36,844 line:-1
我们要密切关注GPU硬件时间


95
00:04:37,344 --> 00:04:39,713 line:-1
分为顶点 片段


96
00:04:40,113 --> 00:04:41,582 line:-1
及计算 如果你的游戏用到


97
00:04:42,749 --> 00:04:44,384 line:-1
还要注意显示监视器


98
00:04:44,451 --> 00:04:46,987 line:-1
将是我们许多调查的起点


99
00:04:47,621 --> 00:04:49,756 line:-1
我们将识别长框架或启动器


100
00:04:49,823 --> 00:04:51,725 line:-1
我们将从那里开始一直调查下去


101
00:04:52,125 --> 00:04:53,861 line:-1
所以这是一个非常自然的起点


102
00:04:56,530 --> 00:04:58,432 line:-1
关于这个工具有很多信息


103
00:04:58,498 --> 00:05:00,367 line:-1
因为它确实是一个非常强大的工具


104
00:05:00,434 --> 00:05:02,302 line:-1
我鼓励大家去熟悉它


105
00:05:03,303 --> 00:05:04,638 line:-1
这几个演讲


106
00:05:04,705 --> 00:05:06,707 line:-1
将为你提供一个很好的起点


107
00:05:08,141 --> 00:05:08,976 line:-1
好


108
00:05:09,042 --> 00:05:10,077 line:-1
接下来要谈的是


109
00:05:10,577 --> 00:05:13,347 line:-1
我们今年推出了一个线程状态视图


110
00:05:14,314 --> 00:05:17,017 line:-1
此视图显示游戏中每个线程的状态


111
00:05:17,484 --> 00:05:20,587 line:-2
在这种情况下
每种颜色代表一种可能的线程状态


112
00:05:21,321 --> 00:05:24,124 line:-1
例如被抢占以橙色表示


113
00:05:24,458 --> 00:05:26,360 line:-1
已屏蔽以灰色表示


114
00:05:27,561 --> 00:05:29,930 line:-1
我们专门为你 游戏开发者


115
00:05:29,997 --> 00:05:31,231 line:-1
设计了此视图


116
00:05:31,698 --> 00:05:36,036 line:-2
因为我们知道
现代游戏中的线程系统非常复杂


117
00:05:36,270 --> 00:05:38,138 line:-1
我们希望这对你有所帮助


118
00:05:40,240 --> 00:05:43,443 line:-2
我们还为每个CPU核心
提供了一个轨道


119
00:05:44,278 --> 00:05:46,313 line:-1
它将显示在该核心上运行的线程


120
00:05:46,680 --> 00:05:50,184 line:-1
以及以颜色编码的该线程的优先级


121
00:05:51,552 --> 00:05:52,486 line:-1
用这个工具


122
00:05:52,553 --> 00:05:55,622 line:-1
你将能够一目了然地看到系统的状态


123
00:05:56,924 --> 00:05:57,758 line:-1
还有…


124
00:05:58,225 --> 00:06:02,262 line:-1
这是一个简短但相当宽泛的工具介绍


125
00:06:02,329 --> 00:06:05,432 line:-1
现在我们该转向实际的性能问题了


126
00:06:05,999 --> 00:06:08,569 line:-1
第一个是关于帧速度


127
00:06:10,237 --> 00:06:12,005 line:-1
让我们先看一下它


128
00:06:12,773 --> 00:06:16,476 line:-2
为此 我们用了Fox II
SceneKit演示的修改版本


129
00:06:16,677 --> 00:06:18,745 line:-1
这将有助于我们更好地说明问题


130
00:06:20,647 --> 00:06:24,084 line:-1
你能猜出哪个游戏生成得更快吗？


131
00:06:27,287 --> 00:06:28,121 line:-1
嗯…


132
00:06:28,956 --> 00:06:30,657 line:-1
你们中的一些人可能没有猜到


133
00:06:31,458 --> 00:06:35,429 line:-2
左边的游戏试图以
每秒60帧的速度生成


134
00:06:35,963 --> 00:06:37,564 line:-1
但它只达到40


135
00:06:38,198 --> 00:06:40,467 line:-1
所以它不流畅而有抖动


136
00:06:40,901 --> 00:06:42,636 line:-1
另一方面 右边的游戏


137
00:06:43,003 --> 00:06:45,105 line:-1
它的目标是每秒30帧


138
00:06:45,372 --> 00:06:47,241 line:-1
可以一贯地实现


139
00:06:47,841 --> 00:06:49,176 line:-1
这就是为何它看起来更顺畅


140
00:06:50,944 --> 00:06:53,814 line:-1
但这有点违反直觉


141
00:06:54,047 --> 00:06:57,417 line:-1
为什么生成速度更快的游戏


142
00:06:58,218 --> 00:06:59,353 line:-1
反倒看起来不太顺畅？


143
00:07:00,287 --> 00:07:02,856 line:-1
嗯 这个问题被称为微型口吃


144
00:07:03,223 --> 00:07:04,758 line:-1
或不一致帧速


145
00:07:06,059 --> 00:07:07,995 line:-1
它出现于帧时间


146
00:07:08,529 --> 00:07:10,597 line:-1
高于显示刷新间隔


147
00:07:11,265 --> 00:07:12,099 line:-1
例如


148
00:07:13,033 --> 00:07:15,969 line:-1
我们的游戏可能要25毫秒生成一帧


149
00:07:16,170 --> 00:07:17,538 line:-1
或每秒40帧


150
00:07:17,938 --> 00:07:21,275 line:-1
而显示屏可能会每16.6毫秒刷新


151
00:07:21,675 --> 00:07:23,143 line:-1
或每秒60帧


152
00:07:23,577 --> 00:07:25,045 line:-1
与我们刚看到的视频相同


153
00:07:25,345 --> 00:07:27,781 line:-1
这会产生一些视觉上的不一致


154
00:07:29,650 --> 00:07:31,151 line:-1
这种情况是怎么造成的？


155
00:07:31,718 --> 00:07:34,988 line:-1
我们在这种情况下做了什么？


156
00:07:35,789 --> 00:07:36,623 line:-1
嗯…


157
00:07:37,491 --> 00:07:38,592 line:-1
我们没有做什么


158
00:07:38,659 --> 00:07:40,527 line:-1
这就是问题所在


159
00:07:41,728 --> 00:07:43,163 line:-1
生成帧后


160
00:07:43,597 --> 00:07:46,033 line:-1
我们从显示链请求下一个可绘图


161
00:07:46,233 --> 00:07:47,701 line:-1
一旦我们得到了可绘图


162
00:07:48,101 --> 00:07:50,871 line:-1
我们完成了最后一步并立即展示


163
00:07:51,438 --> 00:07:53,473 line:-1
我们明确地告诉了系统


164
00:07:54,041 --> 00:07:56,410 line:-1
在下一个刷新间隔


165
00:07:56,643 --> 00:07:58,111 line:-1
尽快呈现可绘图


166
00:07:58,412 --> 00:07:59,246 line:-1
毕竟


167
00:07:59,413 --> 00:08:01,548 line:-1
我们的目标是每秒60帧 对吗？


168
00:08:03,350 --> 00:08:06,620 line:-1
还有另一类问题会导致微型口吃


169
00:08:06,687 --> 00:08:11,425 line:-1
有些游戏已经设定较低的帧率


170
00:08:12,392 --> 00:08:14,995 line:-1
但我们也发现了很多这样的游戏


171
00:08:15,495 --> 00:08:18,298 line:-2
在主线程或
图像生成线程上用usleep


172
00:08:18,365 --> 00:08:19,333 line:-2
（勿用usleep()
控制帧速！）


173
00:08:19,399 --> 00:08:21,168 line:-1
这在iOS中是一种很糟糕的做法


174
00:08:21,235 --> 00:08:22,936 line:-1
所以请不要那样做


175
00:08:23,737 --> 00:08:25,706 line:-1
耐心等我几分钟


176
00:08:25,772 --> 00:08:28,442 line:-1
我会告诉你在iOS中的正确方法


177
00:08:30,577 --> 00:08:31,411 line:-1
现在…


178
00:08:32,145 --> 00:08:36,350 line:-1
让我们深入了解系统中发生了什么


179
00:08:36,416 --> 00:08:38,118 line:-1
微型口吃是可见的


180
00:08:39,119 --> 00:08:40,888 line:-1
在这种情况下 我们在这里看到


181
00:08:40,953 --> 00:08:42,956 line:-1
生成中涉及的所有组件的时间表


182
00:08:43,924 --> 00:08:47,160 line:-1
我们开始正常生成我们的游戏


183
00:08:47,761 --> 00:08:51,298 line:-2
注意 这是一个三重缓冲区
在iOS中常见


184
00:08:51,532 --> 00:08:52,366 line:-1
在这种情况下


185
00:08:52,699 --> 00:08:55,769 line:-1
每个可绘图都用字母和颜色表示


186
00:08:56,670 --> 00:08:58,372 line:-1
注意这里的前提


187
00:08:58,972 --> 00:09:00,474 line:-1
生成可绘图B


188
00:09:01,108 --> 00:09:03,911 line:-1
历时超过一个显示刷新间隔


189
00:09:04,244 --> 00:09:05,913 line:-1
即Vsyncs之间的时间


190
00:09:07,281 --> 00:09:10,651 line:-2
在这种情况下
生成到B可能需要25毫秒


191
00:09:10,817 --> 00:09:14,121 line:-1
显示刷新间隔之间为16.6毫秒


192
00:09:16,223 --> 00:09:18,525 line:-1
所以 既然这是前提


193
00:09:18,592 --> 00:09:21,728 line:-1
这意味着我们需要在显示屏上保持A


194
00:09:22,162 --> 00:09:25,532 line:-1
为下一个间隔给出时间以便完成


195
00:09:26,633 --> 00:09:27,835 line:-1
我们会这样做


196
00:09:27,901 --> 00:09:29,503 line:-1
在那个时间段内


197
00:09:29,770 --> 00:09:32,739 line:-1
B实际上会完成


198
00:09:33,574 --> 00:09:35,275 line:-1
并准备好呈现


199
00:09:36,343 --> 00:09:38,979 line:-1
但注意我们刚在这里隐藏了一个问题


200
00:09:39,646 --> 00:09:43,050 line:-2
在此间隔期间
我们还完成了C的生成


201
00:09:43,617 --> 00:09:45,419 line:-1
我们已准备好立即呈现它


202
00:09:46,653 --> 00:09:49,723 line:-1
所以从这个时间段开始


203
00:09:49,790 --> 00:09:51,091 line:-1
我们会遇到不一致的帧速


204
00:09:51,592 --> 00:09:52,960 line:-1
我们陷入了这种模式


205
00:09:53,460 --> 00:09:55,596 line:-1
每隔一帧都不一致


206
00:09:56,330 --> 00:09:58,398 line:-1
用户将看到微型口吃


207
00:10:00,601 --> 00:10:01,435 line:-1
现在…


208
00:10:01,602 --> 00:10:05,472 line:-2
现实世界中
这可能在以不同的形状和形式出现


209
00:10:06,006 --> 00:10:08,108 line:-1
所以我们现在做的就是快速演示


210
00:10:08,442 --> 00:10:10,210 line:-1
我将向你展示《塔洛斯法则》


211
00:10:10,277 --> 00:10:11,912 line:-1
的仪器跟踪


212
00:10:12,412 --> 00:10:13,413 line:-1
我们会用它来观察


213
00:10:13,480 --> 00:10:16,083 line:-1
看能否识别现实世界中的微型口吃情况


214
00:10:25,225 --> 00:10:26,126 line:-1
好


215
00:10:26,193 --> 00:10:27,194 line:-1
我们在这里看到的


216
00:10:27,261 --> 00:10:29,963 line:-1
与我之前展示的信息相同


217
00:10:30,330 --> 00:10:31,331 line:-1
我们的游戏性能模板


218
00:10:31,398 --> 00:10:33,500 line:-1
已在默认状态下将此信息捕获


219
00:10:34,134 --> 00:10:36,203 line:-1
注意我谈到的所有相同的工具


220
00:10:36,270 --> 00:10:37,504 line:-1
显示在左侧


221
00:10:39,473 --> 00:10:41,875 line:-1
所有游戏线程都在中间


222
00:10:42,676 --> 00:10:46,480 line:-1
尤其我们现在正在寻找微型口吃


223
00:10:47,314 --> 00:10:50,484 line:-1
所以这很直观地会让我们看显示轨道


224
00:10:50,551 --> 00:10:54,488 line:-2
因为微型口吃的定义
即是不一致的帧显示


225
00:10:55,189 --> 00:10:57,157 line:-2
在这种情况下
我们在这里有显示轨道


226
00:10:58,492 --> 00:11:01,428 line:-1
注意 该显示轨道中有一些提示


227
00:11:02,029 --> 00:11:05,165 line:-2
我们添加了它们
这些是提示 这里


228
00:11:05,933 --> 00:11:06,867 line:-1
它们会告诉你


229
00:11:06,934 --> 00:11:08,569 line:-1
当表面显示


230
00:11:08,635 --> 00:11:12,306 line:-1
比正常生成时预期更长


231
00:11:13,040 --> 00:11:15,175 line:-1
也许这是一个开始观察的好地方


232
00:11:15,242 --> 00:11:16,844 line:-1
有一些堆砌


233
00:11:17,144 --> 00:11:18,278 line:-1
让我们放大一个


234
00:11:19,112 --> 00:11:21,014 line:-1
要放大 我们将长按选项键


235
00:11:21,281 --> 00:11:24,151 line:-1
并将指针拖动到感兴趣的区域


236
00:11:25,719 --> 00:11:28,355 line:-2
这种情况下
如果我们继续查看显示轨道


237
00:11:29,189 --> 00:11:31,959 line:-1
已经很明显存在微型口吃


238
00:11:32,025 --> 00:11:35,729 line:-2
我们可以看到
每个显示器都有不同的时间


239
00:11:36,363 --> 00:11:37,664 line:-1
所以在这种情况下 例如


240
00:11:37,731 --> 00:11:39,566 line:-1
我们有50、33


241
00:11:40,133 --> 00:11:42,302 line:-1
16 回到50


242
00:11:42,903 --> 00:11:43,937 line:-1
再回到33


243
00:11:44,438 --> 00:11:45,973 line:-1
所以当我们在仪器捕获中


244
00:11:46,640 --> 00:11:47,841 line:-1
看到这种模式时


245
00:11:47,908 --> 00:11:51,011 line:-2
这意味着存在微型口吃
我们应该纠正它


246
00:11:51,778 --> 00:11:52,746 line:-1
我们看看做法


247
00:11:53,146 --> 00:11:54,081 line:-1
回到幻灯片


248
00:11:58,051 --> 00:11:58,886 line:-1
好了…


249
00:11:59,453 --> 00:12:02,122 line:-2
我们刚刚看到了这个问题
及它在现实世界中的发生


250
00:12:02,389 --> 00:12:04,258 line:-1
模式基本相同


251
00:12:04,691 --> 00:12:06,393 line:-1
那我们该怎么做呢？


252
00:12:07,928 --> 00:12:11,498 line:-2
最佳做实践
是确定游戏可以达到的帧速率


253
00:12:12,165 --> 00:12:13,800 line:-1
所以在最小帧持续时间


254
00:12:14,401 --> 00:12:16,703 line:-1
长于帧生成时间


255
00:12:17,938 --> 00:12:20,674 line:-1
为此 有很多API可以帮助你


256
00:12:21,241 --> 00:12:24,111 line:-2
例如 MTLDrawable
addPresentedHandler


257
00:12:24,578 --> 00:12:27,781 line:-1
一旦可绘图出现 会给你一个回调


258
00:12:27,848 --> 00:12:30,851 line:-2
这样一旦微型口吃发生
你就可以识别


259
00:12:31,919 --> 00:12:35,355 line:-1
其它两个API会帮你解决这个问题


260
00:12:35,822 --> 00:12:39,793 line:-1
它们将允许你明确控制帧速


261
00:12:40,394 --> 00:12:42,863 line:-2
在这种情况下
我们提供了afterMinimumDuration


262
00:12:43,163 --> 00:12:44,231 line:-1
和atTime


263
00:12:45,165 --> 00:12:46,333 line:-1
我们这里的目的


264
00:12:46,867 --> 00:12:50,704 line:-2
是把帧的最小持续时间
设置得比生成时间长


265
00:12:51,839 --> 00:12:54,208 line:-2
这正是我们要做的
让我们看看


266
00:12:55,943 --> 00:12:57,778 line:-1
注意 当我们开始生成时


267
00:12:58,712 --> 00:13:00,714 line:-1
我们从一开始就保持一致


268
00:13:01,081 --> 00:13:04,952 line:-1
我们的帧显示时间长于生成时间


269
00:13:05,686 --> 00:13:07,254 line:-1
每一帧都是一致的


270
00:13:08,655 --> 00:13:11,358 line:-1
用户的观感也会一致


271
00:13:12,159 --> 00:13:12,993 line:-1
太好了


272
00:13:13,060 --> 00:13:15,462 line:-1
另外 注意有副作用


273
00:13:15,729 --> 00:13:16,964 line:-1
帧速率将降低


274
00:13:17,030 --> 00:13:20,367 line:-1
我们从每秒40帧降到30帧


275
00:13:20,968 --> 00:13:23,570 line:-1
所以这也给了我们额外的帧时间


276
00:13:25,138 --> 00:13:26,206 line:-1
我们是怎么做到的？


277
00:13:27,307 --> 00:13:31,678 line:-1
我们是如何修复帧速的？


278
00:13:31,745 --> 00:13:32,579 line:-1
嗯…


279
00:13:33,180 --> 00:13:35,415 line:-1
真的 只需几行代码


280
00:13:36,016 --> 00:13:37,818 line:-1
我们的模式与以前相同


281
00:13:38,118 --> 00:13:39,152 line:-1
我们生成场景


282
00:13:39,586 --> 00:13:40,687 line:-1
得到了下一个可绘图


283
00:13:41,188 --> 00:13:42,289 line:-1
我们做最后一步生成


284
00:13:43,090 --> 00:13:44,358 line:-1
唯一的区别


285
00:13:44,691 --> 00:13:47,995 line:-1
是我们指定帧的最小持续时间


286
00:13:48,428 --> 00:13:50,864 line:-1
并以最短持续时间呈现


287
00:13:51,598 --> 00:13:52,599 line:-1
就是这样


288
00:13:53,400 --> 00:13:56,470 line:-1
这将允许我们设置帧的最小持续时间


289
00:13:56,537 --> 00:13:58,005 line:-1
它们将保持一致


290
00:13:59,306 --> 00:14:01,408 line:-1
这样做之后 你可能会想


291
00:14:01,475 --> 00:14:04,778 line:-1
那么 最长持续时间呢？


292
00:14:05,646 --> 00:14:08,582 line:-1
我们的工作优先级概念如何体现？


293
00:14:08,649 --> 00:14:10,350 line:-1
或一帧可以花多长时间？


294
00:14:11,185 --> 00:14:13,754 line:-1
嗯 这是我们要谈的下一个问题


295
00:14:13,954 --> 00:14:14,855 line:-1
线程优先级


296
00:14:16,390 --> 00:14:18,859 line:-1
像之前一样 让我们先看一下它


297
00:14:19,593 --> 00:14:22,029 line:-1
还是用Fox II演示的修改版本


298
00:14:23,497 --> 00:14:25,232 line:-1
你可能在想 而你会是对的


299
00:14:25,299 --> 00:14:27,668 line:-1
有很多事情可能导致这类的口吃


300
00:14:27,734 --> 00:14:31,205 line:-1
也许你正在作资源加载或着色器编译


301
00:14:32,072 --> 00:14:34,675 line:-1
今天我们将重点关注更为根本


302
00:14:35,209 --> 00:14:37,411 line:-1
但也是非常常见的类型的口吃


303
00:14:38,912 --> 00:14:40,447 line:-1
即由线程停滞引起的口吃


304
00:14:42,316 --> 00:14:46,653 line:-1
如果工作优先级未很好地传达给系统


305
00:14:47,054 --> 00:14:48,989 line:-1
你的游戏可能有意想不到的停滞


306
00:14:50,123 --> 00:14:53,427 line:-2
除了生成游戏之外
iOS还做很多事


307
00:14:54,928 --> 00:14:57,164 line:-1
线程优先级用于保证


308
00:14:57,364 --> 00:14:59,533 line:-1
整个系统的服务质量


309
00:15:00,667 --> 00:15:02,503 line:-1
所以如果一个线程做了很多工作


310
00:15:02,970 --> 00:15:05,339 line:-1
其优先级将随时间的推移而降低


311
00:15:05,772 --> 00:15:07,441 line:-1
以让其它线程有机会运行


312
00:15:08,242 --> 00:15:10,511 line:-1
这就是优先级衰减的概念


313
00:15:11,979 --> 00:15:13,847 line:-1
另外 在我身后的幻灯片上可看到


314
00:15:14,615 --> 00:15:15,682 line:-1
优先级倒置


315
00:15:16,116 --> 00:15:19,887 line:-2
这是另一类
以非常类似的方式表现出来的问题


316
00:15:20,521 --> 00:15:23,257 line:-1
当生成线程依赖于来自同一引擎的


317
00:15:23,323 --> 00:15:27,194 line:-1
较低优先级的工作线程以完成工作时


318
00:15:28,028 --> 00:15:30,564 line:-1
在这种情况下 发生优先级倒置


319
00:15:31,298 --> 00:15:32,466 line:-1
我们看看它是怎么样的


320
00:15:32,533 --> 00:15:34,401 line:-1
与我们之前看到的时间表相同


321
00:15:35,802 --> 00:15:36,770 line:-1
在这种情况下


322
00:15:36,837 --> 00:15:38,906 line:-1
我们开始以每秒30帧的速度生成


323
00:15:39,273 --> 00:15:40,107 line:-1
很轻松


324
00:15:41,041 --> 00:15:43,844 line:-1
但是 有一些背景工作


325
00:15:44,678 --> 00:15:47,347 line:-2
iOS做很多东西
也许现在正在检查电子邮件


326
00:15:48,715 --> 00:15:49,950 line:-1
若我们的线程配置不正确


327
00:15:50,017 --> 00:15:52,286 line:-1
那问题就来了


328
00:15:53,487 --> 00:15:55,556 line:-1
你可能会被该后台工作抢占


329
00:15:55,989 --> 00:15:59,760 line:-2
你可能无法完成GPU上
所有工作安排


330
00:16:01,128 --> 00:16:04,498 line:-1
并且没有帧的最大持续时间的概念


331
00:16:05,165 --> 00:16:08,068 line:-1
所以帧生成可能会持续数百毫秒


332
00:16:08,735 --> 00:16:10,537 line:-1
用户会看到口吃


333
00:16:12,673 --> 00:16:14,675 line:-1
这就是它背后的理论


334
00:16:14,741 --> 00:16:19,213 line:-2
在实践中 它的发生遵循相同的模式
但以不同的方式显示


335
00:16:19,847 --> 00:16:20,981 line:-1
我们再作一个演示


336
00:16:21,048 --> 00:16:24,284 line:-2
我将向你展示另一个仪器捕捉的
《塔洛斯法则》信息


337
00:16:24,351 --> 00:16:27,087 line:-1
来看看如何识别此问题


338
00:16:37,998 --> 00:16:41,101 line:-1
在这种情况下 你看到的是


339
00:16:41,168 --> 00:16:43,604 line:-1
使用游戏性能模板作的信息捕捉


340
00:16:44,271 --> 00:16:46,073 line:-1
但这一次 我们已经放大了


341
00:16:46,373 --> 00:16:48,041 line:-1
进入我们感兴趣的帧


342
00:16:48,509 --> 00:16:50,110 line:-1
这是一个很长的帧


343
00:16:51,378 --> 00:16:54,081 line:-1
它的持续时间为233毫秒


344
00:16:54,147 --> 00:16:57,017 line:-1
所以我们应该调查这个很典型的口吃


345
00:16:58,619 --> 00:17:00,454 line:-1
一眼看去


346
00:17:00,521 --> 00:17:04,458 line:-1
我们已经知道GPU似乎未做什么


347
00:17:04,958 --> 00:17:06,425 line:-1
在此期间它处于闲置状态


348
00:17:07,094 --> 00:17:09,329 line:-1
这意味着我们没有喂饱它


349
00:17:10,130 --> 00:17:14,134 line:-1
现在 我们可以看一下CPU


350
00:17:14,800 --> 00:17:17,137 line:-1
CPU似乎相当忙


351
00:17:17,704 --> 00:17:18,771 line:-1
就像它们真的……


352
00:17:19,540 --> 00:17:20,874 line:-1
所有这些看起来都很稳固


353
00:17:22,476 --> 00:17:28,048 line:-2
注意 你在此处看到的是我们的
app的时间分析器视图


354
00:17:28,315 --> 00:17:30,284 line:-1
看上去没有在运行


355
00:17:31,318 --> 00:17:32,753 line:-1
为什么我们的游戏没有运行


356
00:17:33,587 --> 00:17:36,190 line:-1
这怎么会导致口吃？为什么？


357
00:17:36,924 --> 00:17:37,758 line:-1
嗯…


358
00:17:38,659 --> 00:17:41,094 line:-1
我们可以切换到我提到的新视图


359
00:17:41,161 --> 00:17:42,496 line:-1
新的线程状态视图


360
00:17:43,363 --> 00:17:47,034 line:-1
要做到这个 你进入app的图标


361
00:17:47,768 --> 00:17:49,837 line:-1
并点击此处的按钮


362
00:17:50,604 --> 00:17:52,406 line:-1
这将拉出轨道显示


363
00:17:53,640 --> 00:17:55,809 line:-2
在这种情况下
你可以切换到线程状态


364
00:17:57,711 --> 00:18:01,481 line:-1
这有望帮助你看到这里有问题


365
00:18:02,349 --> 00:18:05,953 line:-1
它以橙色突出显示 这已经告诉我们


366
00:18:06,019 --> 00:18:09,756 line:-1
该线程已被抢占192毫秒


367
00:18:10,490 --> 00:18:13,493 line:-1
这就是问题所在 生成线程未运行


368
00:18:13,894 --> 00:18:15,062 line:-1
有些东西先占用了


369
00:18:16,263 --> 00:18:17,331 line:0
如果你想了解更多


370
00:18:18,232 --> 00:18:20,167 line:0
你可以在底部展开信息


371
00:18:20,234 --> 00:18:22,302 line:0
也将包含线程叙述


372
00:18:23,804 --> 00:18:26,907 line:0
并且通过单击被抢先的线程


373
00:18:27,741 --> 00:18:28,909 line:0
你会看到这里


374
00:18:29,676 --> 00:18:31,278 line:0
对正在发生的事情的解释


375
00:18:31,612 --> 00:18:32,446 line:0
在这里


376
00:18:33,046 --> 00:18:35,749 line:0
你的生成线程优先级为26


377
00:18:36,016 --> 00:18:36,917 line:0
非常低


378
00:18:36,984 --> 00:18:38,552 line:0
低于后台线程优先级


379
00:18:39,486 --> 00:18:41,088 line:0
因为App Store正更新


380
00:18:42,122 --> 00:18:43,657 line:0
这是不应该的


381
00:18:44,024 --> 00:18:47,060 line:0
我们想告诉系统
对我们的用户来说


382
00:18:47,494 --> 00:18:49,730 line:0
在那个特定的时刻 我们的游戏


383
00:18:49,796 --> 00:18:51,131 line:0
比App Store更新更重要


384
00:18:51,765 --> 00:18:54,134 line:-2
让我们回到幻灯片
看看该怎么做


385
00:19:02,276 --> 00:19:05,345 line:-1
最好的做法是配置你的生成线程


386
00:19:06,213 --> 00:19:10,017 line:-1
建议将生成线程优先级固定为45


387
00:19:11,118 --> 00:19:15,889 line:-2
注意 在iOS和macOS中
优先级具有升序值


388
00:19:16,823 --> 00:19:21,395 line:-1
因此优先级31高于优先级4


389
00:19:22,162 --> 00:19:25,999 line:-2
此外 我们需要选择退出
调度程序的服务质量


390
00:19:26,333 --> 00:19:30,337 line:-2
以防止优先级衰减
从而降低我们的优先级


391
00:19:31,738 --> 00:19:34,341 line:-2
我们看看配置良好的
生成线程是怎样的


392
00:19:36,043 --> 00:19:39,046 line:-1
现在我们按照刚才所说的来配置


393
00:19:39,847 --> 00:19:41,181 line:-1
我们开始正常生成


394
00:19:42,649 --> 00:19:44,751 line:-1
我们还有一些背景工作在运行


395
00:19:44,818 --> 00:19:46,186 line:-1
否则这不公平


396
00:19:46,787 --> 00:19:49,389 line:-2
而且 这个后台工作
可能是更新App Store


397
00:19:49,456 --> 00:19:50,791 line:-1
正如我们在演示中看到的


398
00:19:51,692 --> 00:19:56,563 line:-2
但请注意一个又一个Vsync后
正常生成


399
00:19:57,197 --> 00:20:01,401 line:-2
我们正在抢占CPU的
后台工作以运行


400
00:20:02,603 --> 00:20:04,872 line:-1
用户看不到口吃


401
00:20:05,339 --> 00:20:08,642 line:-1
你的游戏可以每秒30个固帧运行


402
00:20:09,243 --> 00:20:11,211 line:-1
即使系统负载很重


403
00:20:12,012 --> 00:20:14,815 line:-1
这在技术上很棒 这就是我们要做的


404
00:20:15,182 --> 00:20:18,418 line:-2
让我们看看如何通过
一点代码实现这一点


405
00:20:19,953 --> 00:20:22,322 line:-1
确实是一点代码


406
00:20:22,556 --> 00:20:23,991 line:-1
只有几行


407
00:20:24,791 --> 00:20:25,726 line:-1
在这种情况下


408
00:20:26,593 --> 00:20:28,929 line:-1
它只是配置pthread属性


409
00:20:29,229 --> 00:20:31,031 line:-1
在创建pthread之前


410
00:20:32,165 --> 00:20:36,904 line:-2
我们需要选择退出服务质量
将优先级设置为45


411
00:20:37,938 --> 00:20:40,741 line:-2
就是这样 现在我们
可以用这些属性创建pthread


412
00:20:41,074 --> 00:20:42,409 line:-1
它会正常工作


413
00:20:43,110 --> 00:20:45,012 line:-1
这很简单同时技术上很了不起


414
00:20:47,181 --> 00:20:48,649 line:-1
不是那么简单的


415
00:20:49,650 --> 00:20:51,285 line:-1
是我们要讲的下一个问题


416
00:20:52,586 --> 00:20:54,922 line:-1
处理多个热状态的问题


417
00:20:56,256 --> 00:20:57,724 line:-1
目的是明确的


418
00:20:59,092 --> 00:21:00,827 line:-1
为持续性能设计


419
00:21:02,930 --> 00:21:04,932 line:-1
并处理偶尔出现的热问题


420
00:21:05,666 --> 00:21:07,100 line:-1
我们看看我们如何来做


421
00:21:08,602 --> 00:21:12,639 line:-1
iOS设备可提供前所未有的电量


422
00:21:12,806 --> 00:21:15,075 line:-1
但是在一个非常小的外形中


423
00:21:15,609 --> 00:21:18,378 line:-2
因此 随着更多的app
在设备上使用更多资源


424
00:21:18,946 --> 00:21:21,582 line:-1
系统可能会开始采取措施


425
00:21:21,648 --> 00:21:24,084 line:-1
以保持低温和反应速度


426
00:21:25,118 --> 00:21:29,423 line:-1
此外 用户可能已启用低功耗模式


427
00:21:29,756 --> 00:21:32,192 line:-1
会产生相似的效果


428
00:21:34,561 --> 00:21:36,763 line:-1
好 所以最好的做法


429
00:21:37,130 --> 00:21:41,034 line:-1
是将工作负载调整为系统状态


430
00:21:42,269 --> 00:21:45,305 line:-1
你应该监控系统并相应调整工作负载


431
00:21:45,873 --> 00:21:48,308 line:-1
iOS有许多API可以有帮助


432
00:21:48,909 --> 00:21:52,379 line:-2
例如
用NSProcessInfo thermalState


433
00:21:52,746 --> 00:21:55,215 line:-1
来查询或注册通知


434
00:21:55,516 --> 00:21:57,251 line:-1
设备热状态变化


435
00:21:57,851 --> 00:22:02,155 line:-1
检查低功耗模式的方式类似


436
00:22:02,923 --> 00:22:06,426 line:-2
另外 请考虑查询
来自MTLCommandBuffer的


437
00:22:06,493 --> 00:22:07,928 line:-1
GPU启动/GPU结束时间


438
00:22:08,395 --> 00:22:12,432 line:-1
以了解系统负载如何影响GPU时间


439
00:22:14,434 --> 00:22:17,070 line:-2
我们看看如何用一个简单的
代码示例来做到这个


440
00:22:18,372 --> 00:22:20,407 line:-1
这直接来自我们的最佳实践


441
00:22:21,175 --> 00:22:24,478 line:-2
它的核心是一个
非常简单的switch语句


442
00:22:24,878 --> 00:22:27,281 line:-1
每个case对应一个热状态


443
00:22:27,681 --> 00:22:28,649 line:-1
这里有名义上的


444
00:22:30,083 --> 00:22:30,918 line:-1
一般


445
00:22:32,186 --> 00:22:33,020 line:-1
重要


446
00:22:33,754 --> 00:22:34,588 line:-1
和关键


447
00:22:37,424 --> 00:22:39,359 line:-1
这一切都很好


448
00:22:39,426 --> 00:22:41,862 line:-1
现在我们知道我们处于热状态


449
00:22:42,629 --> 00:22:45,165 line:-1
并且这些指令告诉我们要做些什么


450
00:22:45,999 --> 00:22:49,903 line:-2
我们怎样才能真正帮助
系统保持低温？


451
00:22:50,971 --> 00:22:51,805 line:-1
嗯…


452
00:22:52,940 --> 00:22:56,310 line:-2
我可以给一些建议
但这取决于游戏开发者


453
00:22:56,376 --> 00:22:58,478 line:-1
来决定要做出什么样的妥协


454
00:22:58,979 --> 00:23:00,547 line:-1
以帮助系统


455
00:23:01,215 --> 00:23:05,252 line:-2
你知道什么行动最适合你的游戏
以在压力下保持出色


456
00:23:06,520 --> 00:23:10,390 line:-1
我的一些建议是针对帧速率


457
00:23:10,457 --> 00:23:12,960 line:-1
以在整个游戏会话保持


458
00:23:13,627 --> 00:23:16,697 line:-2
例如
如果你不能以每秒60帧


459
00:23:16,930 --> 00:23:20,067 line:-2
维持10分钟或更长
那么保持每秒30帧


460
00:23:21,435 --> 00:23:24,972 line:-1
调整GPU工作也非常有用


461
00:23:25,939 --> 00:23:28,041 line:-1
例如 考虑降低


462
00:23:28,108 --> 00:23:29,810 line:-1
中间生成目标的分辨率


463
00:23:30,777 --> 00:23:32,813 line:-1
或者简化阴影图


464
00:23:33,380 --> 00:23:34,648 line:-1
加载更简单的资产


465
00:23:34,982 --> 00:23:37,951 line:-1
甚至完全删除一些后期处理


466
00:23:38,585 --> 00:23:40,921 line:-1
什么办法最适合你的游戏


467
00:23:41,722 --> 00:23:43,056 line:-1
你就应该采取什么


468
00:23:44,892 --> 00:23:48,028 line:-1
而且这把我们带到我们的下一个议题


469
00:23:49,129 --> 00:23:51,698 line:0
关于处理不必要的GPU工作


470
00:23:51,899 --> 00:23:54,835 line:0
为此 请欢迎我的同事Ohad上台


471
00:23:54,902 --> 00:23:56,336 line:0
他会都告诉你


472
00:23:56,403 --> 00:23:59,773 line:0
（不必要的GPU工作）


473
00:24:00,574 --> 00:24:01,508 line:-1
谢谢 Guillem


474
00:24:04,845 --> 00:24:05,679 line:-1
大家好


475
00:24:06,213 --> 00:24:07,814 line:-1
我叫Ohad


476
00:24:07,881 --> 00:24:09,883 line:-1
Apple的游戏技术团队成员


477
00:24:10,751 --> 00:24:11,985 line:0
在之前的幻灯片中


478
00:24:12,519 --> 00:24:16,089 line:0
Guillem展示了
适应系统的重要性


479
00:24:17,157 --> 00:24:21,728 line:0
响应低功耗模式或不同的热状态等


480
00:24:22,229 --> 00:24:24,631 line:0
将要求你调整GPU工作负载


481
00:24:24,698 --> 00:24:26,667 line:0
以保持整个游戏阶段


482
00:24:26,733 --> 00:24:28,335 line:0
一致的帧速


483
00:24:29,303 --> 00:24:33,373 line:0
然而 对于许多开发人员来说
GPU有点像黑盒子


484
00:24:33,540 --> 00:24:35,709 line:0
藏在游戏引擎的窗帘后面


485
00:24:36,343 --> 00:24:38,545 line:-1
今天 我们来拉开这个窗帘


486
00:24:40,480 --> 00:24:43,283 line:-1
浪费GPU时间是一个很常见的问题


487
00:24:43,584 --> 00:24:45,719 line:-1
也经常被忽视


488
00:24:46,119 --> 00:24:47,487 line:-1
但我希望你记住这一点


489
00:24:47,688 --> 00:24:51,258 line:-2
技术上出色的游戏
不仅会达到其GPU预算


490
00:24:52,259 --> 00:24:57,331 line:-2
它们也是系统的好公民
帮助它保持低温并节能


491
00:24:57,898 --> 00:24:59,299 line:-1
所有流行的游戏引擎


492
00:24:59,366 --> 00:25:01,702 line:-1
都提供了一系列最佳实践


493
00:25:02,102 --> 00:25:03,136 line:-1
我们不会介绍这些


494
00:25:03,370 --> 00:25:07,107 line:-2
相反 我们将专注于
如何判断生成的内容是否昂贵


495
00:25:08,041 --> 00:25:11,078 line:-1
正如我们今天已经对CPU多次做的


496
00:25:11,712 --> 00:25:15,449 line:-1
这最佳实践是对GPU进行分析


497
00:25:17,217 --> 00:25:19,753 line:-1
我们GPU的强大功能可以隐藏许多


498
00:25:19,820 --> 00:25:22,089 line:-1
内容或算法上的效率


499
00:25:22,689 --> 00:25:26,527 line:-2
你需要对工作量计时
但也要了解


500
00:25:26,593 --> 00:25:28,495 line:-1
你启用的每种生成技术


501
00:25:29,096 --> 00:25:33,100 line:-2
并只保留那些
明显增加游戏视觉质量的技术


502
00:25:34,268 --> 00:25:36,403 line:-1
但是你怎么发现效率问题？


503
00:25:37,070 --> 00:25:40,474 line:-2
你如何确定过程的
哪些部分完全不必要？


504
00:25:40,707 --> 00:25:43,544 line:-1
这当然让我们回到了工具


505
00:25:44,878 --> 00:25:47,414 line:-2
与往常一样 你的第一站
应该是Instruments


506
00:25:48,015 --> 00:25:49,983 line:-1
我们在这里看看Metal系统跟踪


507
00:25:50,517 --> 00:25:54,154 line:-1
它将为你提供精确的时间：


508
00:25:54,354 --> 00:25:56,023 line:-1
顶点、片段及计算工作


509
00:25:57,224 --> 00:26:00,394 line:-2
但是测量GPU时间
只是一半的工作


510
00:26:00,894 --> 00:26:05,599 line:-2
接下来 你想要真正了解
每一步正在做什么


511
00:26:07,000 --> 00:26:11,071 line:-2
为此我们今年为Metal系统跟踪
添加了一个新工具


512
00:26:11,371 --> 00:26:12,806 line:-1
这是依赖关系图


513
00:26:15,175 --> 00:26:18,912 line:0
依赖关系图是一个单帧的故事


514
00:26:20,080 --> 00:26:21,815 line:0
它由节点和边组成


515
00:26:21,882 --> 00:26:24,651 line:0
每一个都讲述了故事的不同部分


516
00:26:25,719 --> 00:26:29,590 line:0
边表示步与步之间的依赖关系


517
00:26:29,857 --> 00:26:31,525 line:0
当你从上到下跟踪它们时


518
00:26:31,758 --> 00:26:34,528 line:0
你将看到每一步
在哪里可嵌入你的生成管道


519
00:26:34,761 --> 00:26:37,598 line:0
以及它们如何协同工作来创建框架


520
00:26:39,032 --> 00:26:42,703 line:0
另一方面 节点是单个步的故事


521
00:26:44,271 --> 00:26:46,139 line:-1
它们由三个主要组成部分组成


522
00:26:46,440 --> 00:26:50,310 line:-1
首先 title元素将给出步名称


523
00:26:50,711 --> 00:26:52,346 line:-1
我想确实强调这一点


524
00:26:52,613 --> 00:26:53,714 line:-1
命名标记一切


525
00:26:54,114 --> 00:26:56,316 line:-2
这不仅有助于
Dependency查看器


526
00:26:56,383 --> 00:26:58,485 line:-1
也有助于我们的整个工具套件


527
00:26:59,586 --> 00:27:00,420 line:-1
其次


528
00:27:00,487 --> 00:27:04,124 line:-2
它可以让你快速了解
正在查看的步类型


529
00:27:04,958 --> 00:27:07,127 line:-1
生成、位块传输还是计算


530
00:27:07,461 --> 00:27:09,997 line:-2
这里 从图标中
我们可以看到它是一个生成步


531
00:27:11,465 --> 00:27:13,567 line:-1
接下来 这里有一个统计列表


532
00:27:13,634 --> 00:27:15,736 line:-1
描述了此步中正在完成的工作


533
00:27:16,837 --> 00:27:20,407 line:0
最后 在底部 在此步中写入的


534
00:27:20,474 --> 00:27:22,743 line:-1
所有资源的列表


535
00:27:22,943 --> 00:27:24,778 line:-1
并且每个资源都带标签


536
00:27:25,212 --> 00:27:27,281 line:-1
允许预览的缩略图


537
00:27:27,681 --> 00:27:31,885 line:-1
以及具体描述每个资源的信息列表


538
00:27:33,086 --> 00:27:34,188 line:-1
所有这些一起


539
00:27:34,454 --> 00:27:37,191 line:-1
可让你真正了解每一步


540
00:27:37,791 --> 00:27:40,227 line:-1
好的 现在我们知道如何读图表了


541
00:27:40,294 --> 00:27:43,463 line:-2
让我们跳转到一个演示
看看它们是如何组合在一起的


542
00:27:52,940 --> 00:27:56,743 line:-2
我在我的机器上运行了
Fox II演示


543
00:27:57,077 --> 00:27:58,345 line:-1
它是在SceneKit中构建的


544
00:27:58,612 --> 00:28:01,148 line:-1
允许我添加各种很棒的效果


545
00:28:02,349 --> 00:28:05,352 line:-1
如你所见 我有瀑落式阴影图


546
00:28:06,420 --> 00:28:09,823 line:-1
高光 景深 所有这些合在一起


547
00:28:09,990 --> 00:28:11,792 line:-1
创建一个精美生成的场景


548
00:28:12,526 --> 00:28:15,329 line:-2
我们用依赖关系查看器
来查看它是如何工作的


549
00:28:15,929 --> 00:28:18,765 line:-2
首先 我们将转到Xcode
然后我们将捕获一个帧


550
00:28:18,832 --> 00:28:21,001 line:-2
用底部的
Capture GPU框架按钮


551
00:28:21,535 --> 00:28:23,403 line:-1
我们选择左边的主要步


552
00:28:25,906 --> 00:28:27,641 line:-1
并切换到自动模式


553
00:28:27,708 --> 00:28:30,043 line:-1
我们右边出现助手


554
00:28:30,344 --> 00:28:34,248 line:-2
现在 注意我在调试导航器中
选择的同一步


555
00:28:34,314 --> 00:28:38,185 line:-1
也是被选的 并且在主视图中心


556
00:28:38,519 --> 00:28:39,987 line:-1
这是一条双向的街


557
00:28:40,888 --> 00:28:43,624 line:-1
当我们与图表进行交互时


558
00:28:43,690 --> 00:28:48,929 line:-1
选择不同的步或纹理甚至缓冲区


559
00:28:49,730 --> 00:28:52,499 line:-1
左侧的导航器和右侧的助手


560
00:28:52,733 --> 00:28:54,601 line:-1
都会更新以显示你的选择


561
00:28:55,302 --> 00:28:58,238 line:-1
这是帧导航的一种非常棒的方式


562
00:29:01,108 --> 00:29:03,710 line:-2
现在当我缩小时
你会注意到的第一件事


563
00:29:03,777 --> 00:29:06,280 line:-1
是统计隐藏了 焦点消失了


564
00:29:06,346 --> 00:29:09,550 line:-1
视图从单独步转到了整个帧


565
00:29:10,217 --> 00:29:11,785 line:-1
我可以缩小更多


566
00:29:12,186 --> 00:29:15,656 line:-1
可以看到我整个帧的鸟瞰图


567
00:29:17,357 --> 00:29:19,359 line:-1
现在注意真正酷的是


568
00:29:19,560 --> 00:29:22,963 line:-1
由于依赖关系驱动图的互联


569
00:29:24,364 --> 00:29:27,668 line:-1
每个逻辑工作在空间中组合在一起


570
00:29:28,335 --> 00:29:29,870 line:-2
让我们放大
看看我是什么意思


571
00:29:30,437 --> 00:29:33,540 line:-2
这里我有一个工作分支
正在创建我的阴影图


572
00:29:35,642 --> 00:29:38,045 line:-1
在左边 我可以看到三步


573
00:29:39,112 --> 00:29:40,547 line:-1
生成阴影


574
00:29:41,114 --> 00:29:42,516 line:-1
这太好了


575
00:29:42,749 --> 00:29:46,086 line:-1
因为我不只是了解整个帧的状态


576
00:29:46,153 --> 00:29:49,122 line:-1
还有这两层之间的联系


577
00:29:49,756 --> 00:29:52,593 line:-1
每个生成技术是怎么构建起来的


578
00:29:53,293 --> 00:29:56,196 line:-1
而当你使用游戏引擎打开它们时


579
00:29:56,263 --> 00:29:58,365 line:-1
这并非总是显而易见的


580
00:29:58,432 --> 00:30:01,301 line:-1
例如 用我的阴影图 我可能不知道


581
00:30:01,602 --> 00:30:04,771 line:-1
每个级联都需要自己的步


582
00:30:05,572 --> 00:30:07,674 line:-1
如果我单独考虑这些中的每一个


583
00:30:08,108 --> 00:30:09,543 line:-1
这不会很明显


584
00:30:09,710 --> 00:30:12,212 line:-2
但现在我看到
我必须将它们视为一个群体


585
00:30:13,447 --> 00:30:17,317 line:-1
我在调整GPU工作负载作妥协时


586
00:30:17,551 --> 00:30:21,188 line:-1
这个认识帮我做出明智决策


587
00:30:22,890 --> 00:30:24,358 line:-1
这就是依赖关系查看器


588
00:30:24,758 --> 00:30:26,193 line:-1
我切换回幻灯片


589
00:30:26,260 --> 00:30:29,563 line:-2
欢迎Guillem回到台上
谈他最后几点想法


590
00:30:29,630 --> 00:30:30,464 line:-1
谢谢


591
00:30:36,270 --> 00:30:37,938 line:-1
谢谢 这是一个出色的演示


592
00:30:38,372 --> 00:30:39,206 line:-1
谢谢


593
00:30:43,911 --> 00:30:44,745 line:-1
酷


594
00:30:44,811 --> 00:30:46,313 line:-1
Ohad刚刚向我们展示过


595
00:30:46,547 --> 00:30:48,782 line:-1
通过依赖关系查看器查看图帧的方式


596
00:30:50,117 --> 00:30:54,054 line:-1
而且 你可以检查GPU工作负载


597
00:30:54,721 --> 00:30:59,493 line:-2
例如 我们通常可能
从一个非常小而简单的过程


598
00:30:59,560 --> 00:31:00,594 line:-1
像这个


599
00:31:01,728 --> 00:31:03,263 line:-1
演变到一个非常复杂的过程


600
00:31:03,897 --> 00:31:05,866 line:-1
经过后期处理


601
00:31:06,166 --> 00:31:08,368 line:-1
HDR中的多个阴影图


602
00:31:09,703 --> 00:31:12,372 line:-1
所有这些的实现方法可以是


603
00:31:12,539 --> 00:31:15,976 line:-2
在你的游戏引擎的相机对象中
添加几个属性


604
00:31:17,244 --> 00:31:20,614 line:-1
你会发现这些更改的代码复杂性很小


605
00:31:21,215 --> 00:31:25,485 line:-1
但生成复杂性可能增加了十倍


606
00:31:26,820 --> 00:31:29,923 line:-1
这就把我们带回到开头


607
00:31:29,990 --> 00:31:31,391 line:-1
就在我们开篇的地方


608
00:31:32,793 --> 00:31:33,627 line:-1
分析资料


609
00:31:34,361 --> 00:31:38,065 line:-1
了解游戏的功能非常重要


610
00:31:39,399 --> 00:31:42,970 line:-1
你花了数万小时开发游戏


611
00:31:43,437 --> 00:31:46,573 line:-1
你应该考虑花一些时间进行分析


612
00:31:47,608 --> 00:31:49,309 line:-1
我们今天看到的一切


613
00:31:50,043 --> 00:31:51,612 line:-1
可以在几分钟内找到


614
00:31:52,646 --> 00:31:53,514 line:-1
最好的部分是什么？


615
00:31:53,847 --> 00:31:55,916 line:-1
你无需知道自己在寻找什么


616
00:31:56,083 --> 00:31:58,719 line:-1
仅仅记录口吃 查到长帧


617
00:31:59,152 --> 00:32:01,188 line:-1
并从那里开始一直继续


618
00:32:01,588 --> 00:32:02,623 line:-1
就这么简单


619
00:32:03,090 --> 00:32:05,325 line:-1
这个工具将为你提供所需的所有信息


620
00:32:05,592 --> 00:32:06,760 line:-1
来识别问题


621
00:32:07,594 --> 00:32:09,029 line:-1
但你需要使用该工具


622
00:32:10,564 --> 00:32:14,067 line:-1
这就是关键


623
00:32:14,535 --> 00:32:16,803 line:-1
我们看到了一堆常见的陷阱


624
00:32:17,171 --> 00:32:18,772 line:-1
和一些最佳的解决办法


625
00:32:19,806 --> 00:32:20,707 line:-1
所有这些问题


626
00:32:21,508 --> 00:32:22,943 line:-1
可以通过分析找到


627
00:32:23,177 --> 00:32:24,311 line:-1
我们就是这样找到问题


628
00:32:24,378 --> 00:32:27,214 line:-2
我们分析了大量游戏
发现了常见问题


629
00:32:27,281 --> 00:32:28,849 line:-1
并决定把它们放在一起


630
00:32:29,917 --> 00:32:32,920 line:-1
如果你有权访问引擎源代码


631
00:32:33,687 --> 00:32:37,324 line:-1
确保帧速度和线程优先级都配置好


632
00:32:37,824 --> 00:32:39,726 line:-1
这只是几行代码


633
00:32:40,694 --> 00:32:41,562 line:-1
但无论如何


634
00:32:41,895 --> 00:32:44,364 line:-1
你的游戏应该始终适应热量需求


635
00:32:44,765 --> 00:32:47,601 line:-1
并且不要提交不必要的GPU工作


636
00:32:48,435 --> 00:32:51,338 line:-1
确保遵循所有这些最佳实践


637
00:32:51,972 --> 00:32:54,408 line:-1
你也将开发技术上令人敬畏的游戏


638
00:32:54,741 --> 00:32:56,210 line:-1
这就是我们这个谈话的宗旨


639
00:32:57,344 --> 00:32:58,478 line:-1
更多信息


640
00:32:58,979 --> 00:33:01,515 line:-1
中午12点会设一个实验室


641
00:33:01,682 --> 00:33:03,083 line:-1
我们会在那儿 我会在那儿


642
00:33:03,150 --> 00:33:05,719 line:-1
如果你在这次会议之后有任何问题


643
00:33:05,786 --> 00:33:07,321 line:-1
我们非常乐意回答


644
00:33:07,955 --> 00:33:11,825 line:-2
或者也许你只是想坐下来
让我们分析你的游戏


645
00:33:12,659 --> 00:33:15,996 line:-1
此次WWDC还有两场精彩的演讲


646
00:33:16,063 --> 00:33:18,966 line:-2
关于游戏开发者的Metal
和我们的分析工具


647
00:33:21,068 --> 00:33:23,270 line:-1
非常感谢 祝你们今天愉快


648
00:33:23,770 --> 00:33:24,671 line:-1
度过愉快的一天

