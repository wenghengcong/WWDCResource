1
00:00:06,516 --> 00:00:13,500
[ 音乐 ]


2
00:00:18,516 --> 00:00:25,786
[ 掌声 ]


3
00:00:26,286 --> 00:00:27,426
>> 上午好


4
00:00:27,536 --> 00:00:28,836
我是 Chad Woolf


5
00:00:28,956 --> 00:00:30,186
我是一名 Apple 的


6
00:00:30,186 --> 00:00:31,706
性能工具工程师


7
00:00:31,706 --> 00:00:32,886
欢迎各位参加今天的 410 号讨论会


8
00:00:32,886 --> 00:00:33,976
我们将讨论


9
00:00:33,976 --> 00:00:35,336
如何在 Instruments 10 中


10
00:00:35,336 --> 00:00:36,706
创建自定义 Instrument


11
00:00:37,346 --> 00:00:38,666
今天的讨论会是这样的


12
00:00:38,666 --> 00:00:39,576
我们将讨论一下


13
00:00:39,796 --> 00:00:41,226
为什么要创建


14
00:00:41,226 --> 00:00:42,246
自定义 Instrument


15
00:00:42,296 --> 00:00:43,526
我们将回顾一下


16
00:00:43,526 --> 00:00:45,406
Instruments 的结构


17
00:00:45,406 --> 00:00:46,366
我们今天有很多内容


18
00:00:46,366 --> 00:00:47,106
所以讨论将会分为


19
00:00:47,106 --> 00:00:48,726
三个部分


20
00:00:48,826 --> 00:00:50,256
入门 中级和进阶部分


21
00:00:50,316 --> 00:00:51,626
在那之后


22
00:00:51,626 --> 00:00:52,956
我们会讨论一些最佳实践


23
00:00:52,956 --> 00:00:54,036
以及一些在我们


24
00:00:54,096 --> 00:00:55,546
编写我们自己的 Instrument 时


25
00:00:55,546 --> 00:00:56,346
所学到的东西


26
00:00:57,166 --> 00:00:58,846
首先


27
00:00:58,846 --> 00:01:00,566
为什么要创建自定义 Instrument


28
00:01:00,996 --> 00:01:02,576
Instruments 已经集成了很多


29
00:01:02,576 --> 00:01:03,896
非常强大的工具


30
00:01:03,896 --> 00:01:05,616
例如这里我们有系统跟踪


31
00:01:05,616 --> 00:01:06,776
你可以看到 App 


32
00:01:06,776 --> 00:01:08,046
如何与调度器


33
00:01:08,046 --> 00:01:09,456
和虚拟内存交互


34
00:01:10,736 --> 00:01:12,076
今年我们有一个新的


35
00:01:12,106 --> 00:01:13,396
游戏性能模板 它结合了


36
00:01:13,396 --> 00:01:14,596
系统跟踪和 Metal 系统跟踪


37
00:01:14,596 --> 00:01:17,496
来帮助你发现 App 中的


38
00:01:17,496 --> 00:01:19,776
故障和丢失的帧


39
00:01:20,176 --> 00:01:24,916
在 App 的网络部分


40
00:01:24,916 --> 00:01:27,166
我们也有网络连接 Instrument


41
00:01:27,166 --> 00:01:28,916
它可以显示进出 App 的


42
00:01:28,916 --> 00:01:30,476
TCP/IP 流量


43
00:01:30,476 --> 00:01:32,126
当然还有


44
00:01:32,126 --> 00:01:34,156
很多人都熟悉的时间分析器


45
00:01:34,276 --> 00:01:35,506
时间分析器可以帮助你


46
00:01:35,506 --> 00:01:37,316
查看 App 


47
00:01:37,316 --> 00:01:38,866
在何处花费时间


48
00:01:38,866 --> 00:01:40,006
无论是网络层


49
00:01:40,006 --> 00:01:41,826
游戏引擎还是其他部分


50
00:01:42,816 --> 00:01:45,756
普遍来说


51
00:01:45,756 --> 00:01:48,896
如果你了解


52
00:01:48,896 --> 00:01:50,376
你正在编辑的代码


53
00:01:50,376 --> 00:01:51,646
这些都是非常有用的


54
00:01:51,646 --> 00:01:52,466
如果你知道这些 IP 地址


55
00:01:52,466 --> 00:01:53,416
是什么意思


56
00:01:53,416 --> 00:01:54,856
知道不同的函数


57
00:01:54,856 --> 00:01:56,306
是什么意思


58
00:01:56,306 --> 00:01:58,236
以及时间分析器的调用堆栈


59
00:01:58,306 --> 00:01:59,196
它会让事情变得更简单


60
00:01:59,966 --> 00:02:01,826
然而 如果有人打算分析你的 App 


61
00:02:01,826 --> 00:02:02,916
但他们不熟悉其中的代码


62
00:02:02,916 --> 00:02:04,176
那该怎么办呢


63
00:02:04,176 --> 00:02:05,746
要是他们只是想知道


64
00:02:05,746 --> 00:02:07,216
App 是否在网络层上


65
00:02:07,216 --> 00:02:08,265
花费了大量的时间


66
00:02:08,316 --> 00:02:10,086
如果是 它在做什么


67
00:02:10,596 --> 00:02:12,946
自定义 Instrument 的一个


68
00:02:12,946 --> 00:02:14,566
很好的用途就是


69
00:02:14,696 --> 00:02:16,886
尝试以一种


70
00:02:16,886 --> 00:02:18,096
使原本无法理解代码的人


71
00:02:18,096 --> 00:02:19,936
能够理解和欣赏代码的方式


72
00:02:19,936 --> 00:02:21,216
讲述你的某一层或 App 


73
00:02:21,496 --> 00:02:22,983
正在做什么


74
00:02:24,856 --> 00:02:25,986
在进阶部分中


75
00:02:25,986 --> 00:02:27,516
我们将向你展示如何


76
00:02:27,516 --> 00:02:28,596
利用在 Instruments


77
00:02:28,596 --> 00:02:30,296
内部构建的


78
00:02:30,296 --> 00:02:31,846
专家系统技术


79
00:02:31,846 --> 00:02:33,766
以便你可以创建一个


80
00:02:33,846 --> 00:02:35,366
即使你不亲力亲为


81
00:02:35,366 --> 00:02:36,476
也能够查找错误模式


82
00:02:36,476 --> 00:02:38,206
并在代码中


83
00:02:38,206 --> 00:02:38,786
发现反面模式的 Instrument


84
00:02:40,376 --> 00:02:41,256
好的 让我们来看看


85
00:02:41,256 --> 00:02:43,156
使上述功能成为可能的架构


86
00:02:43,626 --> 00:02:45,226
要做到这一点


87
00:02:45,226 --> 00:02:47,996
我们必须从这里开始


88
00:02:47,996 --> 00:02:48,406
回到原始版本


89
00:02:49,196 --> 00:02:51,276
起初的 Instruments 的


90
00:02:51,276 --> 00:02:52,866
工作原理和今天的差不多


91
00:02:52,936 --> 00:02:54,156
同样有一个库


92
00:02:54,196 --> 00:02:55,546
你仍然可以拖出 Instrument


93
00:02:55,546 --> 00:02:56,816
并将它们放入跟踪文档中


94
00:02:56,816 --> 00:02:58,456
然后按下记录按钮


95
00:02:58,456 --> 00:03:00,946
多个性能工具就可以同时运行


96
00:03:01,616 --> 00:03:02,966
那时和现在的 Instruments 之间的


97
00:03:02,966 --> 00:03:04,646
主要区别是


98
00:03:04,716 --> 00:03:05,516
当时的 Instruments 基础结构


99
00:03:05,516 --> 00:03:06,816
并无法帮助我们


100
00:03:06,816 --> 00:03:08,976
快速编写 Instrument


101
00:03:09,746 --> 00:03:11,606
在当时这样还好


102
00:03:11,606 --> 00:03:12,866
因为我们已经


103
00:03:12,916 --> 00:03:14,526
继承了一些我们已有的


104
00:03:14,526 --> 00:03:16,336
素材和性能工具


105
00:03:16,796 --> 00:03:17,956
它们都有自己的


106
00:03:17,956 --> 00:03:18,726
记录技术和分析逻辑


107
00:03:18,726 --> 00:03:20,436
我们所要做的就是建立一个


108
00:03:20,436 --> 00:03:22,196
自定义的存储机制


109
00:03:22,196 --> 00:03:23,266
来获取跟踪中的数据


110
00:03:23,266 --> 00:03:25,506
以及一个自定义的 UI 来帮助它


111
00:03:25,506 --> 00:03:27,786
与 App 的其他部分集成


112
00:03:27,886 --> 00:03:29,816
随着时间的推移


113
00:03:29,816 --> 00:03:31,126
Instruments 的维护成本


114
00:03:31,126 --> 00:03:32,736
和模型的维护成本都上升了


115
00:03:33,576 --> 00:03:34,626
原因就是


116
00:03:34,626 --> 00:03:36,526
每次我们想要


117
00:03:36,526 --> 00:03:37,876
添加新特性时


118
00:03:37,876 --> 00:03:39,546
我们必须修改 7 个自定义 UI


119
00:03:39,546 --> 00:03:41,846
和 7 个自定义存储机制


120
00:03:42,196 --> 00:03:43,746
但这不是我们想让你们


121
00:03:43,746 --> 00:03:44,676
学习的处理方式


122
00:03:44,676 --> 00:03:45,626
我们不想让你们


123
00:03:45,626 --> 00:03:46,756
承担这种维护成本


124
00:03:47,216 --> 00:03:48,516
所以在我们讨论


125
00:03:48,516 --> 00:03:49,646
定制 Instrument 的特性之前


126
00:03:49,646 --> 00:03:51,236
我们首先需要解决这个问题


127
00:03:51,236 --> 00:03:52,776
我认为我们做到了


128
00:03:53,586 --> 00:03:54,556
在新版本的 Instruments 中


129
00:03:54,556 --> 00:03:56,186
我们没有自定义 UI


130
00:03:56,186 --> 00:03:57,516
和自定义存储机制


131
00:03:57,516 --> 00:03:58,906
而是有两个


132
00:03:58,906 --> 00:04:00,456
标准化的组件


133
00:04:00,456 --> 00:04:02,286
它们是 “Standard UI（标准 UI）”和


134
00:04:02,286 --> 00:04:03,116
“Analysis Core（分析核心）”


135
00:04:03,616 --> 00:04:06,606
标准 UI 实现了新版 Instruments 的


136
00:04:06,606 --> 00:04:07,926
整个用户界面


137
00:04:08,666 --> 00:04:09,986
它与分析核心


138
00:04:09,986 --> 00:04:10,776
紧密相连


139
00:04:11,496 --> 00:04:12,756
而分析核心


140
00:04:12,756 --> 00:04:13,976
你可以将其视为


141
00:04:13,976 --> 00:04:16,906
数据库和专家系统的结合


142
00:04:17,305 --> 00:04:18,516
这两种都针对


143
00:04:18,516 --> 00:04:19,745
时间序列数据进行了优化


144
00:04:19,846 --> 00:04:21,966
使得它们成为构建 Instrument 的重要基础


145
00:04:22,406 --> 00:04:23,786
当你使用新型架构


146
00:04:24,226 --> 00:04:25,406
构建一个 Instrument 时


147
00:04:25,626 --> 00:04:27,456
实际上你所做的是


148
00:04:27,456 --> 00:04:29,236
创建标准 UI 


149
00:04:29,876 --> 00:04:30,876
和分析核心


150
00:04:30,876 --> 00:04:32,916
的自定义配置


151
00:04:34,126 --> 00:04:35,636
如果你看一下


152
00:04:35,636 --> 00:04:36,826
我一开始展示的那些强大的 Instrument


153
00:04:36,826 --> 00:04:38,286
的屏幕快照


154
00:04:38,286 --> 00:04:40,006
我们有系统跟踪


155
00:04:40,006 --> 00:04:42,276
游戏性能模板


156
00:04:42,276 --> 00:04:44,196
网络连接模板


157
00:04:44,196 --> 00:04:48,196
以及时间分析器


158
00:04:48,886 --> 00:04:51,416
所有这些文档中的所有 Instrument


159
00:04:51,476 --> 00:04:53,076
都是完全基于标准 UI 


160
00:04:53,076 --> 00:04:55,246
和分析核心生成的


161
00:04:55,476 --> 00:04:56,616
所以你也同样可以做


162
00:04:56,616 --> 00:04:57,586
它们能做的事情


163
00:04:58,266 --> 00:05:01,516
在 Xcode 10 和 Instruments 10 中


164
00:05:01,516 --> 00:05:02,976
我们提供了相同的工具 来构建你的 Instrument


165
00:05:03,046 --> 00:05:05,966
Xcode 集成的 Instrument


166
00:05:06,086 --> 00:05:07,156
和你生成的 Instrument 之间的


167
00:05:07,466 --> 00:05:10,336
唯一区别就是


168
00:05:10,336 --> 00:05:12,206
谁生成了它


169
00:05:12,886 --> 00:05:16,116
你的 Instrument 会显示在我们的库中


170
00:05:16,116 --> 00:05:18,266
你可以看到顶部的活动监视器


171
00:05:19,106 --> 00:05:20,176
就像这样


172
00:05:20,176 --> 00:05:21,696
你可以将你的 Instrument 拖放到


173
00:05:21,696 --> 00:05:23,386
跟踪文档中并进行记录


174
00:05:24,136 --> 00:05:25,076
接下来


175
00:05:25,076 --> 00:05:26,036
Instruments 将用数据


176
00:05:26,036 --> 00:05:27,646
填充分析核心


177
00:05:27,646 --> 00:05:29,436
标准 UI 将创建图形


178
00:05:29,436 --> 00:05:30,886
和表格视图


179
00:05:31,846 --> 00:05:33,696
Instruments 有两种


180
00:05:33,696 --> 00:05:34,306
显示数据的方式


181
00:05:34,416 --> 00:05:35,686
在顶部有一个图形化的视图


182
00:05:35,686 --> 00:05:36,876
我们称之为轨道视图


183
00:05:36,876 --> 00:05:38,486
一个 Instrument 可以根据需要


184
00:05:38,486 --> 00:05:41,186
定义多个轨道


185
00:05:42,236 --> 00:05:43,796
如果你想


186
00:05:43,796 --> 00:05:44,776
在定义 Instrument 的图之间


187
00:05:44,776 --> 00:05:45,706
进行选择


188
00:05:45,706 --> 00:05:47,056
在 Instrument 图标上


189
00:05:47,056 --> 00:05:48,456
有一个小控件


190
00:05:48,776 --> 00:05:49,886
你可以把它


191
00:05:49,986 --> 00:05:52,106
从 “CPU” 改为 “Network（网络）”


192
00:05:53,746 --> 00:05:55,966
每个图都被允许


193
00:05:55,966 --> 00:05:57,496
定义一定数量的轨道


194
00:05:57,736 --> 00:05:58,926
这里我们定义了 3 个轨道


195
00:05:58,926 --> 00:06:00,156
并绘制了 3 种不同类型的


196
00:06:00,156 --> 00:06:01,576
CPU 利用情况


197
00:06:02,266 --> 00:06:04,436
这里的每一个轨道


198
00:06:04,436 --> 00:06:05,906
都被绑定到分析核心中的


199
00:06:05,906 --> 00:06:07,426
不同的表上


200
00:06:07,426 --> 00:06:08,796
或者它可以被绑定到同一个表上


201
00:06:08,796 --> 00:06:09,646
但是你看到的是


202
00:06:09,646 --> 00:06:11,046
这个表中的另一列


203
00:06:12,266 --> 00:06:14,566
这个 Instrument 的另一部分


204
00:06:14,566 --> 00:06:16,556
就在下方


205
00:06:16,556 --> 00:06:17,786
它同样也很重要


206
00:06:17,786 --> 00:06:18,736
它叫做细节视图


207
00:06:18,896 --> 00:06:20,216
在这里你可以看到


208
00:06:20,216 --> 00:06:22,536
事件列表


209
00:06:22,816 --> 00:06:24,066
以及数据的任何类型的


210
00:06:24,066 --> 00:06:26,086
聚合和总结


211
00:06:26,986 --> 00:06:29,306
就像这些轨道


212
00:06:29,306 --> 00:06:31,146
抱歉 就像这些图一样


213
00:06:31,146 --> 00:06:32,836
你可以为你的 Instrument


214
00:06:32,836 --> 00:06:34,176
定义一些细节


215
00:06:34,176 --> 00:06:36,416
你也可以通过点按跳转栏的这个部分


216
00:06:36,416 --> 00:06:37,976
然后选择你定义的细节标题


217
00:06:37,976 --> 00:06:39,586
来选择哪个细节是活跃的


218
00:06:40,966 --> 00:06:42,616
就像图形视图中的轨道一样


219
00:06:42,616 --> 00:06:44,786
所有的细节都被


220
00:06:44,786 --> 00:06:46,656
绑定到分析核心的一个表上


221
00:06:46,656 --> 00:06:48,016
这就是它们


222
00:06:48,016 --> 00:06:48,786
接收数据的地方


223
00:06:49,166 --> 00:06:50,006
记录开始


224
00:06:50,006 --> 00:06:50,966
表格被填入


225
00:06:51,236 --> 00:06:52,626
UI 就会做出反应


226
00:06:52,626 --> 00:06:55,366
不需要你执行任何特殊代码


227
00:06:56,156 --> 00:06:58,836
从标准 UI 的角度来看


228
00:06:58,836 --> 00:07:00,036
分析核心中的所有内容


229
00:07:00,036 --> 00:07:02,096
似乎都是一个表格


230
00:07:02,096 --> 00:07:03,986
我们来谈谈表格


231
00:07:05,196 --> 00:07:06,916
表格是行的集合


232
00:07:06,916 --> 00:07:07,886
它们有一个


233
00:07:07,886 --> 00:07:09,516
由表格 Schema 定义的结构


234
00:07:09,666 --> 00:07:11,656
所以它和数据库 App 非常相似


235
00:07:12,536 --> 00:07:14,106
这个 Schema 定义了


236
00:07:14,106 --> 00:07:15,396
列 列的名称


237
00:07:15,396 --> 00:07:16,236
以及列的类型


238
00:07:16,746 --> 00:07:18,246
分析核心使用了一个


239
00:07:18,246 --> 00:07:19,606
非常丰富的类型系统


240
00:07:19,606 --> 00:07:21,296
叫做工程类型


241
00:07:21,296 --> 00:07:22,446
它告诉我们如何存储数据


242
00:07:22,446 --> 00:07:24,216
以及如何在标准 UI 中


243
00:07:24,216 --> 00:07:25,806
可视化和分析数据


244
00:07:27,556 --> 00:07:29,886
除此之外


245
00:07:29,886 --> 00:07:31,426
当 Schema 描述


246
00:07:31,546 --> 00:07:33,246
表的结构时


247
00:07:33,246 --> 00:07:34,516
你还可以使用 Key/value 这对属性


248
00:07:34,516 --> 00:07:36,146
来描述内容


249
00:07:36,616 --> 00:07:38,986
这能帮助我们描述表中的内容


250
00:07:39,566 --> 00:07:42,216
你可以将 Schema


251
00:07:42,216 --> 00:07:44,606
视为 Objective-C 或 Swift 中的一个类


252
00:07:44,606 --> 00:07:46,246
而行则类似于实例


253
00:07:46,586 --> 00:07:47,886
就像 Objective-C 中的


254
00:07:48,006 --> 00:07:50,236
类名是单数的一样


255
00:07:50,236 --> 00:07:51,296
你的 Schema 的名称


256
00:07:51,296 --> 00:07:53,516
也必须是单数的


257
00:07:53,516 --> 00:07:55,416
比如 NSString


258
00:07:55,416 --> 00:07:56,056
而不是 NSStrings


259
00:07:56,246 --> 00:07:58,136
当我们讲到进阶部分的时候


260
00:07:58,136 --> 00:07:58,906
这一点会更为重要


261
00:07:58,906 --> 00:07:59,876
但是我现在想把它强调一下


262
00:07:59,876 --> 00:08:01,496
到时我们就能知道


263
00:08:01,496 --> 00:08:03,026
我们在讨论什么了


264
00:08:03,026 --> 00:08:05,596
Schema 的一个例子是 Tick


265
00:08:06,136 --> 00:08:07,106
它是 Instruments


266
00:08:07,106 --> 00:08:08,926
内部的一种 Schema


267
00:08:08,926 --> 00:08:10,286
用于创建


268
00:08:10,286 --> 00:08:11,666
合成时钟节拍表


269
00:08:11,666 --> 00:08:13,676
稍后我们将在建模器中


270
00:08:13,676 --> 00:08:15,146
使用它进行统计计算


271
00:08:15,916 --> 00:08:17,076
Tick Schema 很简单


272
00:08:17,076 --> 00:08:18,456
它只有一个列要被定义


273
00:08:18,456 --> 00:08:19,956
那就是 time


274
00:08:19,956 --> 00:08:20,626
time 使用的工程类型是


275
00:08:20,626 --> 00:08:21,356
sample-time


276
00:08:22,196 --> 00:08:24,046
Tick Schema 还定义了


277
00:08:24,276 --> 00:08:26,796
一个可以附加到表格实例中的可选属性


278
00:08:26,796 --> 00:08:27,346
它叫做 frequency


279
00:08:27,856 --> 00:08:30,066
如果你为 Tick Schema


280
00:08:30,066 --> 00:08:32,096
创建一个


281
00:08:32,096 --> 00:08:34,456
频率为 10 的表格


282
00:08:34,775 --> 00:08:36,576
那么数据的提供者


283
00:08:36,576 --> 00:08:38,046
就会知道它需要


284
00:08:38,346 --> 00:08:40,806
每秒填充 10 个时间戳


285
00:08:40,806 --> 00:08:41,826
这样你就可以表达


286
00:08:41,826 --> 00:08:43,176
你想要填入表的内容


287
00:08:44,586 --> 00:08:45,916
现在 我认为


288
00:08:46,356 --> 00:08:47,766
我们有足够的信息


289
00:08:47,766 --> 00:08:48,366
来开始入门部分


290
00:08:48,856 --> 00:08:50,076
我们将展示


291
00:08:50,076 --> 00:08:52,256
如何在 Xcode 中


292
00:08:52,296 --> 00:08:54,046
创建你自己的 Instruments 包项目


293
00:08:54,046 --> 00:08:55,876
还将向你展示 如何创建你的第一个 Instrument


294
00:08:55,876 --> 00:08:57,316
来绘制这些 Tick


295
00:08:57,406 --> 00:08:59,886
并在细节视图中 显示这些 Tick


296
00:09:00,376 --> 00:09:01,916
为此我想请


297
00:09:01,916 --> 00:09:04,016
我的同事 Kacper


298
00:09:04,016 --> 00:09:04,976
给大家做一个展示


299
00:09:05,516 --> 00:09:07,966
[ 掌声 ]


300
00:09:08,466 --> 00:09:09,276
>> 谢谢大家


301
00:09:10,046 --> 00:09:12,136
现在我将向你们展示


302
00:09:12,136 --> 00:09:13,986
如何开始创建和运行


303
00:09:13,986 --> 00:09:15,306
你们的第一个自定义 Instrument 


304
00:09:16,346 --> 00:09:17,356
你们将会使用


305
00:09:17,356 --> 00:09:19,426
由 Chad 之前展示的 Tick Schema 


306
00:09:19,426 --> 00:09:21,096
并在频率恒定的节拍中


307
00:09:21,386 --> 00:09:22,556
制作一个 Instrument


308
00:09:23,256 --> 00:09:25,426
你们将会学到如何描述你们的包


309
00:09:25,426 --> 00:09:27,556
如何使用 Xcode 对其进行迭代


310
00:09:27,596 --> 00:09:30,116
以及如何在 Instruments 中进行测试


311
00:09:31,156 --> 00:09:31,866
让我们开始吧


312
00:09:33,266 --> 00:09:34,636
和在 Xcode 中


313
00:09:34,636 --> 00:09:36,596
以前的操作一样


314
00:09:36,596 --> 00:09:37,976
创建新的 Instruments 包项目


315
00:09:38,696 --> 00:09:40,216
你需要点击 “New Xcode Project”


316
00:09:40,996 --> 00:09:42,776
选择 “macOS” 作为平台


317
00:09:42,776 --> 00:09:43,706
并点击 “Instruments Package”


318
00:09:45,366 --> 00:09:46,146
你需要填写文件名称


319
00:09:46,146 --> 00:09:49,566
这将成为这个 Instrument 包的默认名称


320
00:09:50,026 --> 00:09:51,016
我们就命名为 “Ticks” 吧


321
00:09:51,626 --> 00:09:54,966
点击 “Next（下一步）”和“Create（创建）”


322
00:09:59,536 --> 00:10:01,626
Xcode 已经创建了


323
00:10:01,776 --> 00:10:03,656
带有包 Target 的项目和一个文件


324
00:10:04,406 --> 00:10:05,706
里面有对包的定义


325
00:10:06,246 --> 00:10:09,286
让我们来看看


326
00:10:10,176 --> 00:10:13,406
包是基于 XML 语法描述的


327
00:10:13,816 --> 00:10:15,626
首先 每个包最前面有


328
00:10:15,626 --> 00:10:18,846
标识符 标题和所有者


329
00:10:19,406 --> 00:10:21,146
当有人试图安装你的包时


330
00:10:21,146 --> 00:10:23,076
这些栏将是可见的


331
00:10:24,876 --> 00:10:26,466
通常 你可以从


332
00:10:26,466 --> 00:10:29,736
定义自己的 Schema


333
00:10:29,736 --> 00:10:31,546
和可选的建模器开始


334
00:10:31,756 --> 00:10:32,776
但是因为这里我们将使用


335
00:10:32,816 --> 00:10:34,776
预定义的 Tick Schema 


336
00:10:34,776 --> 00:10:36,576
我们将删除这些指示


337
00:10:38,876 --> 00:10:41,416
要从基础包中导入 Tick Schema 


338
00:10:41,416 --> 00:10:43,176
你只需指定


339
00:10:43,206 --> 00:10:44,926
import-schema 元素


340
00:10:45,586 --> 00:10:48,976
和 Schema 的名称 “tick”


341
00:10:53,696 --> 00:10:56,156
现在它可以被我们的 Instrument 使用了


342
00:10:58,516 --> 00:11:00,636
为了让你们更容易地定义


343
00:11:00,636 --> 00:11:02,736
更复杂的元素


344
00:11:02,736 --> 00:11:04,466
我们在 Xcode 中配置了一些代码片段


345
00:11:05,296 --> 00:11:07,206
要使用它们


346
00:11:07,206 --> 00:11:09,146
只需写入元素名称


347
00:11:09,146 --> 00:11:11,436
比如 “instrument” 然后按回车


348
00:11:11,436 --> 00:11:14,256
你需要填写


349
00:11:14,256 --> 00:11:15,976
你的 Instrument 的唯一标识符


350
00:11:20,706 --> 00:11:22,946
以及稍后出现在


351
00:11:22,946 --> 00:11:23,976
Instrument 库中的一些属性


352
00:11:29,626 --> 00:11:31,216
这里是 “Instrument drawing


353
00:11:31,326 --> 00:11:34,946
ticks every 10ms”


354
00:11:39,306 --> 00:11:41,186
现在是创建表格的时候了


355
00:11:41,186 --> 00:11:42,696
当这个 Instrument 从库中


356
00:11:42,696 --> 00:11:44,416
被拖到跟踪文档时


357
00:11:44,546 --> 00:11:46,456
这个表格将被实例化


358
00:11:47,956 --> 00:11:49,346
在这个 Instrument 的定义中


359
00:11:49,346 --> 00:11:51,536
表格标识符必须是唯一的


360
00:11:52,446 --> 00:11:56,116
我们叫它 “tick-table”


361
00:11:56,226 --> 00:11:57,786
在 <schema-ref> 中


362
00:11:57,786 --> 00:11:58,966
我们需要引用以前


363
00:11:58,966 --> 00:12:03,816
导入的 Schema“tick”


364
00:12:04,516 --> 00:12:05,986
现在我们需要定义


365
00:12:05,986 --> 00:12:08,126
在轨道视图和细节视图中


366
00:12:08,126 --> 00:12:09,556
会出现的内容


367
00:12:10,276 --> 00:12:11,966
我将使用 graph 元素


368
00:12:12,696 --> 00:12:15,886
我们需要为我们的图形


369
00:12:15,886 --> 00:12:16,596
填写 title


370
00:12:16,596 --> 00:12:19,166
我会命名为 “Ticks”


371
00:12:19,486 --> 00:12:21,296
轨道的标题也一样


372
00:12:21,916 --> 00:12:25,816
我需要按照前面创建的


373
00:12:25,816 --> 00:12:30,276
标识符来引用表格


374
00:12:30,276 --> 00:12:31,256
因此我将引用 “tick-table”


375
00:12:34,346 --> 00:12:36,376
现在我们要为我们的图


376
00:12:36,376 --> 00:12:37,186
指定绘制


377
00:12:38,186 --> 00:12:39,646
我会使用 plot 元素


378
00:12:40,556 --> 00:12:42,926
在最基本的形式中


379
00:12:42,926 --> 00:12:44,226
它只需要你传递


380
00:12:44,226 --> 00:12:45,446
包含要绘制的值的


381
00:12:45,496 --> 00:12:46,686
列的助记符


382
00:12:46,686 --> 00:12:48,876
我们将绘制 “time”


383
00:12:52,696 --> 00:12:53,956
我希望所有的时间戳


384
00:12:53,956 --> 00:12:57,156
都能在表格中显示出来


385
00:12:57,826 --> 00:12:59,976
为此 我将使用 list 元素


386
00:13:02,496 --> 00:13:04,916
我们需要为一个


387
00:13:04,916 --> 00:13:06,236
将会出现在 Instrument 中的列表


388
00:13:06,366 --> 00:13:11,516
填写 title 元素


389
00:13:11,516 --> 00:13:12,816
“table-ref” 就像之前的 lane 元素一样


390
00:13:12,816 --> 00:13:15,906
以及我们想要看到的 column


391
00:13:20,566 --> 00:13:22,556
现在我们的包已经准备好


392
00:13:22,556 --> 00:13:24,886
在 Instruments 中构建并运行了


393
00:13:25,946 --> 00:13:27,656
为此 你需要使用


394
00:13:27,656 --> 00:13:28,716
“Xcode Scheme Run” 操作


395
00:13:29,676 --> 00:13:34,936
我们就这样做吧


396
00:13:34,936 --> 00:13:35,336
你可以看到出现了构建错误


397
00:13:35,906 --> 00:13:37,696
在生成 Instruments 包时


398
00:13:37,696 --> 00:13:38,916
你拥有完整的 IDE 支持


399
00:13:39,336 --> 00:13:41,526
这里 出现了一行错误


400
00:13:41,526 --> 00:13:43,426
告诉我们在 Tick Schema 中


401
00:13:43,426 --> 00:13:45,386
找不到 “timestamp” 这一列


402
00:13:45,706 --> 00:13:46,816
没错 


403
00:13:46,816 --> 00:13:47,536
因为它不是 “timestamp”


404
00:13:47,536 --> 00:13:48,616
而应该是 “time”


405
00:13:48,836 --> 00:13:52,676
我将修复这个问题并再次运行它


406
00:13:53,296 --> 00:13:58,256
你可以看到它在运行


407
00:13:58,256 --> 00:13:59,796
因为这个新的 Instrument 副本出现了


408
00:13:59,796 --> 00:14:02,226
你可以通过不同的图标


409
00:14:02,226 --> 00:14:03,786
识别特殊的副本


410
00:14:04,816 --> 00:14:06,656
它仅为这个运行会话


411
00:14:06,976 --> 00:14:08,226
加载你的包


412
00:14:08,796 --> 00:14:10,516
它允许你更容易地


413
00:14:10,516 --> 00:14:11,446
对包进行迭代


414
00:14:12,066 --> 00:14:15,666
为了确保你的包已经加载


415
00:14:15,666 --> 00:14:17,356
我们可以在


416
00:14:17,356 --> 00:14:19,686
新建包管理的 UI 中检查它


417
00:14:20,396 --> 00:14:22,386
你可以在 “Instruments”-


418
00:14:22,556 --> 00:14:24,536
“Preferences（偏好设置）”


419
00:14:24,536 --> 00:14:25,176
-“Packages（包）”标签页中找到它


420
00:14:25,176 --> 00:14:29,556
你可以在这里看到


421
00:14:29,556 --> 00:14:31,746
我们新创建的包以及调试的下标


422
00:14:31,886 --> 00:14:33,466
这意味着它已经被


423
00:14:33,466 --> 00:14:35,736
临时加载


424
00:14:35,736 --> 00:14:37,296
你也可以在这里看到


425
00:14:37,296 --> 00:14:37,996
所有的系统包


426
00:14:38,396 --> 00:14:39,916
你可以通过使用副标题


427
00:14:40,096 --> 00:14:41,866
使用并链接它们


428
00:14:41,866 --> 00:14:46,576
在这里 我们的 Ticks 包里包含了


429
00:14:46,576 --> 00:14:52,776
Ticks Instrument 现在让我们用空白模板测试它


430
00:14:53,396 --> 00:14:55,966
我将把 Target 切换到我的 MacBook


431
00:15:00,456 --> 00:15:01,586
然后在 Instruments 库中


432
00:15:01,586 --> 00:15:03,386
搜索我的 Instrument


433
00:15:03,546 --> 00:15:08,106
我将填入 “Ticks”


434
00:15:08,606 --> 00:15:10,586
然后它将显示在这里


435
00:15:10,586 --> 00:15:12,226
包含从包定义中


436
00:15:12,226 --> 00:15:13,156
填充的所有属性


437
00:15:13,726 --> 00:15:15,976
让我们将它拖放到跟踪中


438
00:15:19,576 --> 00:15:20,976
并记录一秒钟


439
00:15:25,476 --> 00:15:28,486
你可以看到底部的面板


440
00:15:28,486 --> 00:15:30,506
是以每 10 毫秒生成的数据


441
00:15:30,506 --> 00:15:31,676
进行传递的


442
00:15:33,306 --> 00:15:35,896
细节和图形是相互协调的


443
00:15:36,366 --> 00:15:37,826
当我点击行时


444
00:15:37,826 --> 00:15:39,766
你可以看到检查线在这里移动


445
00:15:40,796 --> 00:15:42,706
我还可以通过 Option 点按并拖动


446
00:15:43,096 --> 00:15:48,806
来而放大一个图


447
00:15:48,806 --> 00:15:50,316
在这里 你可以看到


448
00:15:50,316 --> 00:15:51,656
Ticks 确实被画出来了


449
00:15:53,656 --> 00:15:55,736
这样你就可以创建


450
00:15:55,936 --> 00:15:56,886
第一个 Instrument 包


451
00:15:57,306 --> 00:15:59,446
现在让我们请回 Chad


452
00:15:59,446 --> 00:16:00,716
他会告诉你更多 关于标准 UI 的内容


453
00:16:01,516 --> 00:16:04,466
[ 掌声 ]


454
00:16:04,966 --> 00:16:05,226
>> 好的


455
00:16:05,226 --> 00:16:05,986
谢谢 Kacper


456
00:16:06,786 --> 00:16:07,906
我们已经知道了


457
00:16:07,906 --> 00:16:09,326
如何创建一个非常基本的 Instrument


458
00:16:09,326 --> 00:16:11,136
也了解了如何开始


459
00:16:11,326 --> 00:16:12,946
在 Xcode 中创建你的第一个项目


460
00:16:13,706 --> 00:16:15,126
现在让我们来谈谈


461
00:16:15,126 --> 00:16:17,416
我们拥有的不同类型的图


462
00:16:17,416 --> 00:16:18,846
不同类型的细节


463
00:16:18,846 --> 00:16:20,716
以及如何利用真实数据进行操作


464
00:16:21,656 --> 00:16:23,686
让我们从图形轨道开始


465
00:16:24,896 --> 00:16:27,206
你已经看到了 Kacper


466
00:16:27,206 --> 00:16:28,626
是如何使用我们称之为 plot 的元素


467
00:16:28,966 --> 00:16:30,636
来定义一个图形和轨道的


468
00:16:31,066 --> 00:16:34,256
plot 元素可以


469
00:16:34,366 --> 00:16:36,566
指示标准 UI 


470
00:16:36,566 --> 00:16:38,016
获取表的全部内容


471
00:16:38,016 --> 00:16:39,816
并尝试在特定的


472
00:16:39,816 --> 00:16:41,586
轨道中绘制它


473
00:16:42,276 --> 00:16:44,406
plot 元素


474
00:16:44,436 --> 00:16:46,536
通过查看


475
00:16:46,536 --> 00:16:49,406
Schema 和获取值的目标列


476
00:16:49,406 --> 00:16:52,446
来决定如何绘制这个内容


477
00:16:52,446 --> 00:16:53,306
以及如何处理图形


478
00:16:54,026 --> 00:16:55,586
如果是一个区间 Schema


479
00:16:55,586 --> 00:16:56,856
这意味着它有一个时间点


480
00:16:56,856 --> 00:16:58,286
和一个持续时间


481
00:16:58,286 --> 00:16:59,636
如果是一个点 Schema


482
00:16:59,636 --> 00:17:01,046
这意味着它只是一个时间戳


483
00:17:01,046 --> 00:17:01,816
我们需要用不同的方式处理


484
00:17:02,586 --> 00:17:04,705
如果目标列有一个长度


485
00:17:04,705 --> 00:17:06,945
这意味着可以


486
00:17:06,945 --> 00:17:08,296
通过它画一个条形图


487
00:17:08,296 --> 00:17:10,396
就像这样


488
00:17:11,126 --> 00:17:13,136
另一种选择是


489
00:17:13,136 --> 00:17:15,476
生命周期轨道


490
00:17:15,476 --> 00:17:16,935
它仍然是一个区间 Schema


491
00:17:16,935 --> 00:17:18,756
但是我们针对的是


492
00:17:18,756 --> 00:17:20,366
一个状态列


493
00:17:20,366 --> 00:17:21,955
而状态本身并没有长度


494
00:17:22,185 --> 00:17:23,126
所以在这里画条形图


495
00:17:23,126 --> 00:17:23,896
是没有意义的


496
00:17:24,516 --> 00:17:25,476
标准 UI 会自动选择


497
00:17:25,476 --> 00:17:27,006
状态风格的处理方法


498
00:17:27,006 --> 00:17:28,976
包括用圆角矩形样式的标签


499
00:17:28,976 --> 00:17:31,626
绘制这些区间


500
00:17:31,626 --> 00:17:33,096
这样你就可以


501
00:17:33,096 --> 00:17:35,656
把它与平面条形图区分开来


502
00:17:36,356 --> 00:17:37,296
标准 UI 能够为你选择


503
00:17:37,296 --> 00:17:38,336
这些处理的功能


504
00:17:38,336 --> 00:17:39,796
是非常重要的


505
00:17:39,796 --> 00:17:42,086
因为这可以保持 Instruments UI 的一致性


506
00:17:42,376 --> 00:17:43,616
如果你定义一个状态图的同时


507
00:17:43,616 --> 00:17:45,356
我们也定义一个状态图


508
00:17:45,356 --> 00:17:46,896
标准 UI 就会强制它们


509
00:17:46,896 --> 00:17:48,046
看起来一样


510
00:17:48,296 --> 00:17:49,686
这样 Instruments 用户就可以


511
00:17:49,686 --> 00:17:51,526
更容易在 Instrument 之间


512
00:17:51,526 --> 00:17:54,496
进行切换


513
00:17:54,496 --> 00:17:58,236
如果你想 基于数据的内容


514
00:17:58,236 --> 00:18:01,866
动态地创建图形或轨道数目


515
00:18:01,986 --> 00:18:02,326
你可以定义所谓的 “Plot Template”


516
00:18:02,996 --> 00:18:04,666
Plot 模板的定义


517
00:18:04,666 --> 00:18:06,316
与 Plot 非常类似


518
00:18:06,316 --> 00:18:07,406
除了其中有一个额外的元素


519
00:18:07,406 --> 00:18:08,936
允许你选择


520
00:18:08,936 --> 00:18:10,536
表中的一列


521
00:18:10,536 --> 00:18:12,276
它将为该列中的每个唯一值


522
00:18:12,276 --> 00:18:13,956
创建单独的行


523
00:18:16,016 --> 00:18:17,046
如果你正在寻找


524
00:18:17,046 --> 00:18:18,456
活动的峰值或周期


525
00:18:18,576 --> 00:18:19,126
我们有所谓的直方图


526
00:18:19,126 --> 00:18:21,016
你所要做的就是


527
00:18:21,016 --> 00:18:22,846
在不同的点


528
00:18:22,846 --> 00:18:24,066
或区间相交时


529
00:18:24,066 --> 00:18:25,566
打破超过某个特定大小的


530
00:18:25,566 --> 00:18:27,176
存储器中的时间轴


531
00:18:27,176 --> 00:18:29,996
假设 100 毫秒


532
00:18:29,996 --> 00:18:31,186
然后使用像 count() sum()


533
00:18:31,416 --> 00:18:32,976
min() 或 max() 这样的函数


534
00:18:32,976 --> 00:18:33,946
来提升这些存储器的大小


535
00:18:33,946 --> 00:18:36,066
这是一种寻找活动峰值的好方法


536
00:18:36,536 --> 00:18:38,136
例如 在系统跟踪中


537
00:18:38,136 --> 00:18:39,046
我们在环境切换


538
00:18:39,046 --> 00:18:40,216
或虚拟内存中


539
00:18:40,216 --> 00:18:42,086
寻找活动峰值


540
00:18:42,486 --> 00:18:45,126
现在我们来谈谈细节


541
00:18:45,156 --> 00:18:47,396
细节在这个 UI 的下半部分


542
00:18:48,486 --> 00:18:49,376
你们已经看过了第一个


543
00:18:49,376 --> 00:18:50,626
也就是列表


544
00:18:50,846 --> 00:18:52,266
它是表格 分析核心


545
00:18:52,266 --> 00:18:53,666
以及 UI 中表视图之间的


546
00:18:53,666 --> 00:18:56,896
非常简单的映射


547
00:18:56,896 --> 00:19:00,066
还有 “Aggregation（聚合）”


548
00:19:00,176 --> 00:19:01,976
当你想要


549
00:19:01,976 --> 00:19:03,186
去除时间分量


550
00:19:03,186 --> 00:19:04,586
概览你的数据


551
00:19:04,586 --> 00:19:06,726
而且想要在表格中应用一些


552
00:19:06,726 --> 00:19:07,956
统计数据的时候


553
00:19:07,956 --> 00:19:08,556
聚合是很适合的选择


554
00:19:09,376 --> 00:19:10,406
当我们定义一个聚合


555
00:19:10,406 --> 00:19:12,316
我们需要注意


556
00:19:12,316 --> 00:19:14,596
列现在是函数


557
00:19:14,896 --> 00:19:15,956
你可以使用


558
00:19:16,026 --> 00:19:19,186
sum() average() count()


559
00:19:19,186 --> 00:19:20,436
以及其他的一些统计函数


560
00:19:20,726 --> 00:19:24,396
来帮助你创建


561
00:19:24,396 --> 00:19:26,256
你想要创建的聚合视图


562
00:19:28,146 --> 00:19:30,776
聚合的好处在于 你也可以定义


563
00:19:30,776 --> 00:19:32,096
一个层级结构


564
00:19:32,266 --> 00:19:33,846
这里我们在


565
00:19:33,926 --> 00:19:35,296
虚拟内存操作结构中


566
00:19:35,296 --> 00:19:37,316
定义了一个进程线程


567
00:19:37,316 --> 00:19:38,976
我们可以看到它被分解为


568
00:19:38,976 --> 00:19:40,626
进程 然后是


569
00:19:40,626 --> 00:19:41,766
进程中的每个线程


570
00:19:42,086 --> 00:19:43,286
然后是这个线程中的


571
00:19:43,286 --> 00:19:45,156
这个进程中的


572
00:19:45,246 --> 00:19:46,036
每个类型的操作


573
00:19:46,206 --> 00:19:47,556
所以聚合是一种很好


574
00:19:47,626 --> 00:19:49,156
很强大的方式


575
00:19:49,156 --> 00:19:50,386
来总结很多数据


576
00:19:51,476 --> 00:19:53,396
另一种类型的聚合


577
00:19:53,396 --> 00:19:54,476
称为 “Call Tree（调用树）”


578
00:19:55,496 --> 00:19:56,696
当你有一个列是回溯


579
00:19:56,696 --> 00:19:57,876
而且另一个列是


580
00:19:57,876 --> 00:19:59,466
权重的时候


581
00:19:59,466 --> 00:20:00,246
调用树就会很有用处


582
00:20:00,476 --> 00:20:01,316
你可以使用调用树


583
00:20:01,316 --> 00:20:02,556
创建加权回溯


584
00:20:02,556 --> 00:20:04,546
或加权调用的树视图


585
00:20:04,616 --> 00:20:05,976
就像在时间分析器中看到的那样


586
00:20:07,136 --> 00:20:09,896
另一种样式叫做 “Narrative（叙事）”


587
00:20:10,096 --> 00:20:12,426
当你想要传达


588
00:20:12,426 --> 00:20:15,506
只有技术语言的信息


589
00:20:15,506 --> 00:20:17,046
比如专家系统的输出


590
00:20:17,046 --> 00:20:18,526
以及和叙事工程类型


591
00:20:18,526 --> 00:20:19,696
紧密相连的信息时


592
00:20:19,696 --> 00:20:21,346
叙事是常用的选择


593
00:20:23,856 --> 00:20:25,776
最后一种细节类型


594
00:20:25,866 --> 00:20:26,956
叫做 “Time Slice（时间片）”


595
00:20:27,086 --> 00:20:28,346
时间片看起来


596
00:20:28,346 --> 00:20:30,176
很像一个列表


597
00:20:30,176 --> 00:20:31,866
但是其中的内容被过滤


598
00:20:31,866 --> 00:20:33,506
只包含与图形中蓝色线


599
00:20:33,506 --> 00:20:35,086
相交的区间


600
00:20:35,236 --> 00:20:36,366
这条蓝色线叫做检查线


601
00:20:36,746 --> 00:20:37,866
当你把检查线


602
00:20:37,866 --> 00:20:39,436
移到图形上时


603
00:20:39,656 --> 00:20:40,756
列表的内容将被过滤


604
00:20:40,756 --> 00:20:42,586
从而与检查线


605
00:20:42,586 --> 00:20:44,226
相交的部分匹配


606
00:20:46,776 --> 00:20:49,156
所有这些 UI 都与


607
00:20:49,156 --> 00:20:50,896
分析核心中的表格绑定


608
00:20:51,306 --> 00:20:53,146
当你开始记录时


609
00:20:53,146 --> 00:20:55,586
数据进入 Instruments App


610
00:20:55,586 --> 00:20:57,176
并填入分析核心中


611
00:20:57,936 --> 00:20:59,396
让我们详细谈谈


612
00:20:59,396 --> 00:21:00,976
这个过程是如何进行的


613
00:21:02,786 --> 00:21:06,996
在开始记录之前的第一步


614
00:21:06,996 --> 00:21:08,416
分析核心将提取


615
00:21:08,416 --> 00:21:09,796
在其中创建的表格


616
00:21:09,796 --> 00:21:11,006
它将映射表格


617
00:21:11,006 --> 00:21:12,916
并在核心中为表分配存储


618
00:21:13,756 --> 00:21:15,236
如果一个表有


619
00:21:15,236 --> 00:21:16,516
相同的 Schema 和相同的属性


620
00:21:16,516 --> 00:21:17,796
那么根据定义


621
00:21:17,796 --> 00:21:19,686
它就是相同的数据


622
00:21:19,686 --> 00:21:21,696
所以它会被映射到相同的存储中


623
00:21:23,116 --> 00:21:24,956
对于每个存储


624
00:21:24,956 --> 00:21:26,406
第二步就是尝试为数据


625
00:21:26,406 --> 00:21:27,386
找到一个提供者


626
00:21:27,776 --> 00:21:29,056
有时 我们可以从


627
00:21:29,056 --> 00:21:30,196
从 Target 中通过数据流


628
00:21:30,196 --> 00:21:32,196
直接记录数据


629
00:21:32,196 --> 00:21:33,346
有时 我们则必须使用


630
00:21:33,486 --> 00:21:34,246
建模器来合成数据


631
00:21:35,296 --> 00:21:36,876
建模器可以请求自己的输入


632
00:21:36,876 --> 00:21:38,556
这些输入可以


633
00:21:38,556 --> 00:21:40,356
是其他建模器的输出


634
00:21:40,396 --> 00:21:42,926
或者直接从数据流中记录


635
00:21:42,926 --> 00:21:44,186
我们就是这样合成


636
00:21:44,186 --> 00:21:45,476
我们本来不知道如何直接记录的


637
00:21:45,476 --> 00:21:46,366
其余数据的


638
00:21:47,476 --> 00:21:49,516
现在我们已经得到了


639
00:21:49,516 --> 00:21:51,546
分析核心中


640
00:21:51,686 --> 00:21:53,786
所有存储的数据源


641
00:21:53,786 --> 00:21:54,866
也就是所谓的绑定方案


642
00:21:55,026 --> 00:21:57,356
第三步是优化绑定方案 


643
00:21:57,546 --> 00:21:59,966
在这里 你可以看到 Instruments 将自己的


644
00:21:59,966 --> 00:22:01,546
绑定方案可视化


645
00:22:01,546 --> 00:22:02,216
我们称之为线程叙事


646
00:22:03,706 --> 00:22:04,736
关于绑定方案的


647
00:22:04,736 --> 00:22:06,886
下一部分是


648
00:22:06,886 --> 00:22:09,056
它是 “Trace-wide（广跟踪）”的


649
00:22:09,056 --> 00:22:11,196
当你将 Instrument 拖放到跟踪中时


650
00:22:11,386 --> 00:22:13,906
Instruments 将计算


651
00:22:13,906 --> 00:22:15,956
尽可能最好的记录方案


652
00:22:16,166 --> 00:22:17,616
以尽量减少


653
00:22:17,616 --> 00:22:20,336
对 Target 的记录影响


654
00:22:20,886 --> 00:22:21,786
当你创建自己的表格


655
00:22:21,786 --> 00:22:23,256
或表实例时


656
00:22:23,256 --> 00:22:24,616
你必须给它们一个 Schema


657
00:22:25,256 --> 00:22:26,706
Instruments 已经定义了


658
00:22:26,766 --> 00:22:28,786
超过 100 种 Schema


659
00:22:29,536 --> 00:22:30,896
所有这些 Schema


660
00:22:30,896 --> 00:22:31,956
都可以使用


661
00:22:31,956 --> 00:22:33,896
并存在于在包管理的 UI 中


662
00:22:33,896 --> 00:22:34,506
所看到的包里面


663
00:22:35,236 --> 00:22:36,376
你只需将 Schema 导入到


664
00:22:36,376 --> 00:22:38,466
自己的包中


665
00:22:39,036 --> 00:22:41,216
如果该 Schema 包含在


666
00:22:41,216 --> 00:22:42,516
一个不是基础包的包中


667
00:22:42,516 --> 00:22:44,246
你需要在 Xcode 中的


668
00:22:44,246 --> 00:22:45,756
构建设置里面


669
00:22:45,756 --> 00:22:47,086
将包设置为


670
00:22:47,086 --> 00:22:49,046
“Linked Instruments Packages”


671
00:22:49,046 --> 00:22:50,116
这样我们就可以在生成时


672
00:22:50,116 --> 00:22:51,526
找到你涉及的额外的包


673
00:22:51,526 --> 00:22:53,096
并做一些类型检查


674
00:22:54,716 --> 00:22:56,276
因为所有这些 Schema


675
00:22:56,276 --> 00:22:57,586
都是在其他包中定义的


676
00:22:57,676 --> 00:22:59,346
当你开始记录时


677
00:22:59,386 --> 00:23:00,456
所有具有这些 Schema 的表格


678
00:23:00,456 --> 00:23:02,736
都会被填充


679
00:23:02,736 --> 00:23:04,026
因为要么它们定义了建模器


680
00:23:04,026 --> 00:23:04,866
要么我们知道如何


681
00:23:04,866 --> 00:23:05,176
从数据流中记录它们


682
00:23:05,176 --> 00:23:06,426
这些都是你的 Instrument 的


683
00:23:06,426 --> 00:23:07,766
出色的构件


684
00:23:08,216 --> 00:23:09,016
但它们更是


685
00:23:09,086 --> 00:23:10,856
编写建模器的


686
00:23:10,856 --> 00:23:11,706
优秀输入


687
00:23:12,576 --> 00:23:14,356
现在你已经可以编写一个建模器


688
00:23:14,356 --> 00:23:15,316
或者在你的 Instrument 包中


689
00:23:15,316 --> 00:23:16,896
用 modeler 元素


690
00:23:16,896 --> 00:23:19,046
定义一个建模器


691
00:23:19,046 --> 00:23:22,236
你还可以为该建模器


692
00:23:22,346 --> 00:23:23,676
创建一个自定义输出 Schema


693
00:23:24,066 --> 00:23:25,616
你可以只对一个时间点


694
00:23:25,616 --> 00:23:27,336
使用 point-schema


695
00:23:27,336 --> 00:23:28,416
或者如果你有一个时间点和一个区间


696
00:23:28,416 --> 00:23:29,726
你可以使用 interval-schema


697
00:23:30,386 --> 00:23:33,216
建模器可以定义


698
00:23:33,216 --> 00:23:35,126
它需要的输入


699
00:23:35,126 --> 00:23:36,266
这就告诉了绑定方案


700
00:23:36,266 --> 00:23:37,906
如何填充


701
00:23:37,906 --> 00:23:39,706
数据流图的其余部分


702
00:23:39,706 --> 00:23:41,976
这样你的建模器


703
00:23:41,976 --> 00:23:43,076
将融合到绑定方案中


704
00:23:43,906 --> 00:23:45,756
建模器实际上是


705
00:23:45,756 --> 00:23:47,576
微型专家系统


706
00:23:47,576 --> 00:23:48,626
它们是用 CLIPS 语言编写的


707
00:23:48,626 --> 00:23:50,136
这意味着


708
00:23:50,136 --> 00:23:52,006
它们非常强大


709
00:23:52,006 --> 00:23:53,206
同时非常先进


710
00:23:53,206 --> 00:23:54,346
关于如何创建


711
00:23:54,346 --> 00:23:55,896
建模器的细节


712
00:23:55,896 --> 00:23:57,106
我们将留在进阶部分讨论


713
00:23:57,106 --> 00:24:01,336
然而 能够定义自己的 Schema


714
00:24:01,336 --> 00:24:02,856
是非常重要的


715
00:24:02,856 --> 00:24:04,826
我们今年有了一个新的 os_signpost API


716
00:24:04,826 --> 00:24:06,696
它是把数据


717
00:24:06,696 --> 00:24:07,736
导入 Instruments 的绝佳方式


718
00:24:08,596 --> 00:24:10,756
我们为它创造了一条捷径


719
00:24:12,056 --> 00:24:14,246
在你的包中 你可以定义所谓的


720
00:24:14,246 --> 00:24:16,346
os-signpost-interval-schema


721
00:24:16,346 --> 00:24:17,616
它既可以定义 Schema


722
00:24:17,616 --> 00:24:20,046
也可以为我们提供足够的指令


723
00:24:20,046 --> 00:24:22,006
以便能够代替你


724
00:24:22,106 --> 00:24:23,616
生成一个建模器


725
00:24:24,226 --> 00:24:25,686
在那里你可以


726
00:24:25,686 --> 00:24:26,776
捕获在 os_signpost 调用的


727
00:24:26,776 --> 00:24:28,856
元数据中


728
00:24:28,856 --> 00:24:31,926
记录的数据


729
00:24:31,926 --> 00:24:33,986
你可以使用捕获的元数据


730
00:24:33,986 --> 00:24:35,776
和表达式来定义


731
00:24:35,776 --> 00:24:38,796
如何填充你的 Schema 的列


732
00:24:39,816 --> 00:24:42,196
我们来看一个非常简单的例子


733
00:24:43,136 --> 00:24:44,556
假设我们要做 JSON 解码


734
00:24:44,556 --> 00:24:46,776
我们有一个 os_signpost


735
00:24:47,026 --> 00:24:50,726
标记了解码 Activity 的开始


736
00:24:50,726 --> 00:24:52,186
和解码 Activity 的结束


737
00:24:52,746 --> 00:24:54,276
在开始时


738
00:24:54,276 --> 00:24:55,936
我们还需捕获一些元数据


739
00:24:55,936 --> 00:24:57,676
以指示我们将要解析的


740
00:24:57,676 --> 00:24:59,526
JSON 对象的大小


741
00:25:00,876 --> 00:25:01,956
在你的 Instrument 包定义中


742
00:25:01,956 --> 00:25:03,496
你可以创建一个


743
00:25:03,496 --> 00:25:06,136
os-signpost-interval-schema


744
00:25:06,136 --> 00:25:08,396
并在这里定义你的 Schema 名称


745
00:25:09,236 --> 00:25:11,656
你可以选择


746
00:25:11,656 --> 00:25:12,726
要记录的 signpost


747
00:25:12,786 --> 00:25:14,626
包括 signpost 名称


748
00:25:15,086 --> 00:25:16,806
然后在这里可以使用语法


749
00:25:16,806 --> 00:25:18,456
从起始元数据消息中


750
00:25:18,456 --> 00:25:20,186
捕获不同的


751
00:25:20,186 --> 00:25:21,586
元数据片段


752
00:25:21,656 --> 00:25:22,986
这里 我们将使用


753
00:25:23,016 --> 00:25:24,526
这个捕获的值


754
00:25:24,526 --> 00:25:25,296
我们将用它作为表达式


755
00:25:25,296 --> 00:25:27,016
来教我们如何


756
00:25:27,016 --> 00:25:28,956
填充我们刚才定义的


757
00:25:28,956 --> 00:25:30,256
数据大小的列


758
00:25:32,646 --> 00:25:35,756
在 405 号讨论会中 即 


759
00:25:35,756 --> 00:25:37,686
“Measuring Performance Using Logging”


760
00:25:37,686 --> 00:25:42,906
我演示了《Trailblazer》App 


761
00:25:43,216 --> 00:25:44,616
还展示了一个 Instrument


762
00:25:44,616 --> 00:25:46,056
你们可以根据这个 Instrument


763
00:25:46,196 --> 00:25:47,366
里面的 signpost 来进行编写


764
00:25:47,956 --> 00:25:49,716
现在我们对如何编写


765
00:25:49,716 --> 00:25:50,696
自定义 Instrument 


766
00:25:50,696 --> 00:25:52,406
有了更多的了解


767
00:25:52,656 --> 00:25:54,696
我想邀请 Kacper 回到台上


768
00:25:54,696 --> 00:25:56,136
来给大家演示一下


769
00:25:56,386 --> 00:25:57,626
我们是如何创建这个包的


770
00:25:58,516 --> 00:26:03,126
[ 掌声 ]


771
00:26:03,626 --> 00:26:04,886
>> 谢谢你 Chad


772
00:26:09,836 --> 00:26:12,576
《Trailblazer》 App 是一款 iOS App


773
00:26:12,706 --> 00:26:14,676
它可以显示你附近


774
00:26:14,796 --> 00:26:16,176
流行的徒步旅行路线


775
00:26:16,856 --> 00:26:19,976
作为 UI 组件 它使用了 UITabelView


776
00:26:21,006 --> 00:26:22,766
每个单元异步加载


777
00:26:22,766 --> 00:26:24,156
路线的图像


778
00:26:25,276 --> 00:26:26,936
为了防止出现故障且作为优化


779
00:26:26,936 --> 00:26:28,876
当单元被重复使用时


780
00:26:28,876 --> 00:26:30,376
我们取消了下载


781
00:26:31,556 --> 00:26:33,276
为了可视化我的下载流


782
00:26:33,276 --> 00:26:35,546
我将每个下载都置入到


783
00:26:35,586 --> 00:26:36,356
os_signpost 调用中


784
00:26:36,356 --> 00:26:36,936
让我们看一下


785
00:26:41,536 --> 00:26:42,556
当我的保存的单元显示时


786
00:26:42,556 --> 00:26:45,556
调用 startImageDownload() 方法


787
00:26:46,046 --> 00:26:48,456
我们创建了 downloader 和 signpost ID


788
00:26:48,456 --> 00:26:50,946
它包含了 os 日志句柄


789
00:26:51,026 --> 00:26:52,466
和 downloader 对象


790
00:26:53,306 --> 00:26:55,516
然后我们获取 UI 表格视图


791
00:26:55,516 --> 00:26:59,366
单元的地址 


792
00:26:59,366 --> 00:27:03,016
并调用 os_signpost(.begin)


793
00:27:03,016 --> 00:27:04,676
它自于 signpostlog.networking


794
00:27:04,946 --> 00:27:07,336
让我们看一下


795
00:27:07,336 --> 00:27:08,916
这个日志以 App 的


796
00:27:08,916 --> 00:27:11,076
标识符为子系统


797
00:27:11,106 --> 00:27:12,296
networking 为类别


798
00:27:15,046 --> 00:27:16,506
我们传入 “Background Image” 这个名称


799
00:27:17,286 --> 00:27:18,996
之前创建的 “signpostID”


800
00:27:19,436 --> 00:27:20,886
以及信息格式


801
00:27:20,886 --> 00:27:22,016
其中包含 “Image name”


802
00:27:23,956 --> 00:27:25,276
在这里 我们将它放置在全局说明符中


803
00:27:25,276 --> 00:27:27,406
因为它是一个字符串


804
00:27:28,286 --> 00:27:30,406
还有 “Caller” 它是一个单元的地址


805
00:27:31,816 --> 00:27:33,916
我们的下载可以


806
00:27:33,956 --> 00:27:35,476
通过两种方法完成


807
00:27:36,106 --> 00:27:39,086
我们现在来看看


808
00:27:39,166 --> 00:27:40,236
当下载以这样的方式完成


809
00:27:40,756 --> 00:27:42,816
就会调用委托方法


810
00:27:43,866 --> 00:27:45,636
我们像之前一样创建 signpostID


811
00:27:45,636 --> 00:27:48,496
并调用 os_signpost(.end)


812
00:27:49,546 --> 00:27:52,556
这次我们传入 “Status” 和 “Size”


813
00:27:53,876 --> 00:27:56,956
“Status” 值是 “Completed”


814
00:27:58,256 --> 00:28:01,786
“Size” 设置为图像大小


815
00:28:02,236 --> 00:28:04,456
接下来让我们看一下


816
00:28:04,456 --> 00:28:06,166
我们为重写所做的准备


817
00:28:06,766 --> 00:28:09,546
当 downloader 正在运行时


818
00:28:09,546 --> 00:28:11,116
我们会取消它


819
00:28:12,126 --> 00:28:14,076
我们创建了 signpostID


820
00:28:14,076 --> 00:28:16,006
并使用相同的格式字符串


821
00:28:16,006 --> 00:28:18,016
调用我们的 os_signpost(.end)


822
00:28:18,016 --> 00:28:20,496
但是这里 值是 “Canceled” 并且 “Size”


823
00:28:20,496 --> 00:28:21,896
为 “0” 因为下载没有成功


824
00:28:22,406 --> 00:28:25,446
让我们来看看


825
00:28:25,446 --> 00:28:26,786
我们的 os-signpost-interval-schema 定义


826
00:28:26,786 --> 00:28:28,326
以及我们如何在包中


827
00:28:28,376 --> 00:28:30,386
捕获这些 signpost


828
00:28:32,456 --> 00:28:34,456
我们定义了具有唯一 id 和 title 的


829
00:28:34,456 --> 00:28:36,936
os-signpost-interval-schema


830
00:28:37,686 --> 00:28:40,306
然后我们定义 subsystem 和 category


831
00:28:40,306 --> 00:28:41,856
它与我们在创建


832
00:28:41,856 --> 00:28:43,326
日志句柄时


833
00:28:43,326 --> 00:28:44,596
传递的 category 相对应


834
00:28:46,816 --> 00:28:49,346
我们创建 name 元素


835
00:28:49,346 --> 00:28:50,846
它与我们在 os_signpost 


836
00:28:50,846 --> 00:28:53,646
调用 start-pattern 和 end-pattern 中


837
00:28:54,016 --> 00:28:56,156
传递的 name 相对应


838
00:28:56,736 --> 00:28:58,496
这两个都对应于


839
00:28:58,656 --> 00:29:00,296
我们在 os_signpost 中传入的


840
00:29:00,296 --> 00:29:01,756
开始和结束调用


841
00:29:04,266 --> 00:29:05,966
message 元素与


842
00:29:05,966 --> 00:29:07,596
传递的格式字符串相同


843
00:29:07,596 --> 00:29:10,326
但是在调用 os_signpost 时


844
00:29:10,326 --> 00:29:12,516
为了捕获传入的值


845
00:29:12,516 --> 00:29:14,406
你传递的将是这里的变量


846
00:29:14,406 --> 00:29:15,556
而不是格式化参数


847
00:29:16,066 --> 00:29:18,786
让我们看看如何


848
00:29:18,786 --> 00:29:20,576
在列中填入这些值


849
00:29:23,926 --> 00:29:26,876
在这里 你可以看到 status 列


850
00:29:27,066 --> 00:29:28,566
它是字符串类型


851
00:29:28,566 --> 00:29:30,246
因为它只可能是 “Completed” 或者 “Canceled”


852
00:29:31,486 --> 00:29:32,756
所以我们用状态变量的值


853
00:29:32,756 --> 00:29:34,956
来填充它


854
00:29:36,676 --> 00:29:38,806
因为 expression 元素可以采用


855
00:29:38,926 --> 00:29:40,826
任意的 CLIPS 表达式


856
00:29:41,706 --> 00:29:42,586
所以我们可以在其中


857
00:29:42,586 --> 00:29:44,156
做更复杂的事情


858
00:29:44,816 --> 00:29:47,056
在这里我们可以通过查看图像大小


859
00:29:47,056 --> 00:29:49,006
来计算事件影响


860
00:29:49,846 --> 00:29:51,536
如果它大于 3.5MB


861
00:29:51,536 --> 00:29:53,326
我们可以判定影响很大


862
00:29:53,416 --> 00:29:56,516
否则操作的影响很小


863
00:29:58,076 --> 00:30:00,236
这就是我们对 os-signpost-interval-schema 


864
00:30:00,236 --> 00:30:00,976
所做的定义


865
00:30:01,106 --> 00:30:04,066
现在让我们来看看表格的创建


866
00:30:05,796 --> 00:30:07,696
对于 schema-ref


867
00:30:08,096 --> 00:30:10,456
我们传入 os-signpost-interval-schema 


868
00:30:10,456 --> 00:30:12,616
的标识符


869
00:30:12,616 --> 00:30:13,846
并为这个特定表格


870
00:30:13,846 --> 00:30:14,686
创建唯一标识符


871
00:30:15,906 --> 00:30:17,736
然后 我们可以在


872
00:30:17,736 --> 00:30:18,876
UI 定义中引用它


873
00:30:20,296 --> 00:30:22,676
对于 graph 我们创建一个单轨道


874
00:30:23,796 --> 00:30:26,036
它利用我们的表


875
00:30:26,036 --> 00:30:28,056
这次它通过使用 Plot 模板来绘制图形


876
00:30:28,796 --> 00:30:30,586
Plot 模板


877
00:30:30,586 --> 00:30:31,476
是创建图形的动态方法


878
00:30:32,146 --> 00:30:37,386
它查看在实例中


879
00:30:37,386 --> 00:30:40,126
按元素传递的列


880
00:30:40,226 --> 00:30:44,436
并为该列的每个唯一值创建 Plot


881
00:30:44,606 --> 00:30:46,436
label-format 元素


882
00:30:46,486 --> 00:30:49,966
允许我们为这个 Plot 创建格式标题


883
00:30:50,336 --> 00:30:53,956
这里是 img 列和 image-name 列中的值


884
00:30:54,516 --> 00:30:57,166
我们传入 image-name


885
00:30:57,166 --> 00:30:57,656
作为我们的 Plot 的值


886
00:30:58,766 --> 00:31:00,156
我们的每个轨道


887
00:31:00,206 --> 00:31:03,166
都会以 impact 列上色


888
00:31:03,326 --> 00:31:06,076
我们轨道上的标签


889
00:31:06,076 --> 00:31:06,976
会从 image-size 中提取出来


890
00:31:09,436 --> 00:31:12,796
接下来 我们看看 list


891
00:31:12,796 --> 00:31:14,726
你已经在 Ticks 的例子中


892
00:31:14,756 --> 00:31:15,526
见过它


893
00:31:16,866 --> 00:31:18,176
这里 我们将传入


894
00:31:18,176 --> 00:31:21,286
你希望看到的所有列


895
00:31:21,536 --> 00:31:22,766
接下来是 aggregation


896
00:31:23,726 --> 00:31:25,266
这个 aggregation 将跟踪


897
00:31:25,266 --> 00:31:26,406
所有已完成的下载


898
00:31:27,236 --> 00:31:29,836
因为我们的表


899
00:31:29,836 --> 00:31:31,146
包含已完成和已取消的下载


900
00:31:31,146 --> 00:31:32,406
所以我们需要应用


901
00:31:32,406 --> 00:31:34,836
slice 元素来过滤一些数据


902
00:31:36,016 --> 00:31:37,866
在 slice 元素中


903
00:31:37,866 --> 00:31:39,456
我们可以指定


904
00:31:39,456 --> 00:31:42,066
应用于 slice 的列


905
00:31:42,596 --> 00:31:43,496
以及需要匹配的谓词值


906
00:31:43,926 --> 00:31:45,546
在这里 我们只想从这个表中


907
00:31:45,546 --> 00:31:47,056
取出 “Completed” 的行


908
00:31:48,306 --> 00:31:50,746
我们定义了 hierarchy


909
00:31:50,746 --> 00:31:52,406
它是只有一个层级的结构


910
00:31:52,486 --> 00:31:55,276
具有 image-name


911
00:31:55,276 --> 00:31:55,836
和可见的列


912
00:31:56,676 --> 00:31:58,786
对于每个 image-name


913
00:31:58,786 --> 00:32:02,156
我们将指定 count 和 image-size


914
00:32:02,156 --> 00:32:04,916
所以我们要将图像的大小求和


915
00:32:05,386 --> 00:32:09,426
接下来我们有 time-slice


916
00:32:10,456 --> 00:32:10,746
抱歉


917
00:32:10,746 --> 00:32:12,186
我们指定所有


918
00:32:12,186 --> 00:32:13,046
将会可见的列


919
00:32:16,096 --> 00:32:18,636
为了更容易地使用我们的 Instrument


920
00:32:18,636 --> 00:32:22,796
我们可以指定我们的


921
00:32:22,796 --> 00:32:23,566
自定义模板


922
00:32:24,126 --> 00:32:26,876
我们现在尝试构建和运行


923
00:32:26,986 --> 00:32:27,306
我们的包


924
00:32:34,416 --> 00:32:36,336
你可以看到这里的模板


925
00:32:36,396 --> 00:32:36,976
我可以选中它


926
00:32:41,536 --> 00:32:43,916
Target 是我的 iPhone


927
00:32:43,916 --> 00:32:45,186
和《Trailblazer》App


928
00:32:48,956 --> 00:32:50,976
我需要记录一会


929
00:33:00,716 --> 00:33:03,786
可以看到


930
00:33:03,786 --> 00:33:04,936
跟踪视图是以数据传递的


931
00:33:06,616 --> 00:33:08,746
每一个图像名称都创建了


932
00:33:08,746 --> 00:33:09,636
一个绘图


933
00:33:11,366 --> 00:33:12,816
你可以看到标签格式


934
00:33:12,816 --> 00:33:14,366
与我们在包定义中


935
00:33:14,366 --> 00:33:15,586
传入的格式相匹配


936
00:33:16,596 --> 00:33:19,056
如果下载


937
00:33:19,056 --> 00:33:21,176
高于 3.5 MB


938
00:33:21,176 --> 00:33:22,406
那么我们的轨道将是红色的


939
00:33:23,596 --> 00:33:25,266
具体的大小可以在轨道上查看


940
00:33:25,786 --> 00:33:28,576
接下来我们看看


941
00:33:28,576 --> 00:33:30,286
所有的细节


942
00:33:32,436 --> 00:33:35,146
首先 我们看一下下载列表


943
00:33:36,066 --> 00:33:38,096
这是刚才发生的


944
00:33:38,096 --> 00:33:38,976
所有下载的列表


945
00:33:39,636 --> 00:33:42,346
我们可以选择聚合


946
00:33:42,866 --> 00:33:46,746
按照图像名称


947
00:33:46,746 --> 00:33:48,236
划分所有下载


948
00:33:48,616 --> 00:33:49,926
你可以在上面看到


949
00:33:49,926 --> 00:33:51,856
我们下载了 12 张图像


950
00:33:52,156 --> 00:33:55,886
“location7” 的图像


951
00:33:55,886 --> 00:33:59,436
被下载了两次


952
00:33:59,616 --> 00:34:00,876
接下来


953
00:34:00,876 --> 00:34:02,676
我们可以查看活动请求


954
00:34:03,296 --> 00:34:05,166
你可以在这里看到


955
00:34:05,166 --> 00:34:07,386
当我拖动我的检查线时


956
00:34:09,356 --> 00:34:12,786
细节视图中的数据发生了变化


957
00:34:13,646 --> 00:34:15,835
我们可以跟踪


958
00:34:15,876 --> 00:34:17,505
多个活动请求


959
00:34:17,505 --> 00:34:19,106
并查看截至当前检查线为止的


960
00:34:19,106 --> 00:34:20,426
持续时间


961
00:34:21,896 --> 00:34:23,976
如果你想从不同的角度


962
00:34:23,976 --> 00:34:25,286
查看你的数据


963
00:34:25,536 --> 00:34:28,226
并想查看你的存储和建模器


964
00:34:28,226 --> 00:34:31,056
我们通过 Instrument 检查器


965
00:34:31,056 --> 00:34:32,606
为你提供了这个功能


966
00:34:33,576 --> 00:34:34,976
它是调试自定义 Instrument 的


967
00:34:34,976 --> 00:34:36,076
一种方法


968
00:34:36,716 --> 00:34:38,396
在这里你可以看到


969
00:34:38,396 --> 00:34:41,646
我选择了存储步骤


970
00:34:41,976 --> 00:34:43,876
并看到创建 os-signpost 的存储


971
00:34:44,556 --> 00:34:46,916
它属于网络类别


972
00:34:47,335 --> 00:34:48,956
和 com.apple.trailblazer 子系统


973
00:34:48,956 --> 00:34:52,216
我们在这里收集了 24 行


974
00:34:53,235 --> 00:34:55,376
然后我们可以看到


975
00:34:55,466 --> 00:34:57,216
创建的表格 image-download


976
00:34:57,366 --> 00:34:57,896
它有 12 行


977
00:35:02,156 --> 00:35:04,326
在底部的区域


978
00:35:04,326 --> 00:35:04,976
你可以看到该表的整个内容


979
00:35:07,396 --> 00:35:09,146
接下来 我们跳转到建模器


980
00:35:09,546 --> 00:35:10,706
我们可以看到这里有


981
00:35:10,806 --> 00:35:12,936
GENERATED-OS-LOG 建模器


982
00:35:13,456 --> 00:35:16,916
它使用了 24 行 输出了 12 行


983
00:35:18,346 --> 00:35:20,756
在右边 你可以看到绑定方案


984
00:35:21,546 --> 00:35:23,826
所以我们的 GENERATED-OS-LOG 建模器


985
00:35:24,206 --> 00:35:26,026
从 os-signpost 表格中获取数据


986
00:35:26,026 --> 00:35:28,216
并将其放入图像下载表格中


987
00:35:29,386 --> 00:35:31,886
然后被我们的 Instrument 使用


988
00:35:32,446 --> 00:35:35,766
我们就是这样


989
00:35:35,766 --> 00:35:37,966
捕获 os-signpost 调用


990
00:35:38,036 --> 00:35:40,366
创建 UI 并使用 Instrument 检查器


991
00:35:40,366 --> 00:35:41,376
查看数据


992
00:35:42,036 --> 00:35:43,866
现在让我们请回 Chad


993
00:35:43,916 --> 00:35:44,846
他会告诉你们更多


994
00:35:44,846 --> 00:35:45,836
关于进阶建模的内容


995
00:35:46,516 --> 00:35:50,500
[ 掌声 ]


996
00:35:54,716 --> 00:35:55,056
>> 好的


997
00:35:55,326 --> 00:35:56,006
谢谢 Kacper


998
00:35:57,646 --> 00:35:59,366
现在我们已经了解了


999
00:35:59,366 --> 00:36:01,686
如何将 os-signpost 数据


1000
00:36:01,746 --> 00:36:03,396
与自定义 Instrument 结合起来


1001
00:36:03,776 --> 00:36:10,106
我们认为你们 能把这个结合做得很好


1002
00:36:10,886 --> 00:36:13,846
现在 我们可以讨论一些


1003
00:36:13,846 --> 00:36:15,026
进阶的内容


1004
00:36:15,056 --> 00:36:16,546
特别是如何创建


1005
00:36:16,546 --> 00:36:18,286
和定义建模器


1006
00:36:19,366 --> 00:36:20,466
建模器在概念上是


1007
00:36:20,466 --> 00:36:21,296
非常简单的机器


1008
00:36:21,296 --> 00:36:23,156
它需要一系列的输入


1009
00:36:23,266 --> 00:36:24,256
它对这些输入做出推理


1010
00:36:24,256 --> 00:36:26,376
然后进行输出


1011
00:36:27,326 --> 00:36:28,506
建模器的输入


1012
00:36:28,506 --> 00:36:30,246
是完全按照时间排序的


1013
00:36:30,736 --> 00:36:32,116
因此如果你请求


1014
00:36:32,116 --> 00:36:33,506
几个不同的输入表


1015
00:36:33,506 --> 00:36:34,756
这些表将首先按时间排序


1016
00:36:34,756 --> 00:36:36,246
然后合并到一个


1017
00:36:36,246 --> 00:36:38,646
按时间排序的队列中


1018
00:36:38,646 --> 00:36:39,406
该队列将提供工作内存


1019
00:36:39,916 --> 00:36:41,356
当我们把这些事件


1020
00:36:41,356 --> 00:36:42,476
一个接一个地取出时


1021
00:36:42,536 --> 00:36:43,776
它们被输入到所谓的


1022
00:36:43,776 --> 00:36:44,356
建模器的工作内存中


1023
00:36:45,236 --> 00:36:47,886
当建模器看到


1024
00:36:47,886 --> 00:36:49,306
这个工作内存的增长时


1025
00:36:49,306 --> 00:36:51,006
它就可以得出推论


1026
00:36:51,226 --> 00:36:52,766
当建模器看到需要为其


1027
00:36:52,766 --> 00:36:54,086
进行输出的模板时


1028
00:36:54,086 --> 00:36:56,206
它只需将其


1029
00:36:56,206 --> 00:36:57,406
写入对外输出表格


1030
00:36:58,166 --> 00:37:00,256
让我们以一个


1031
00:37:00,406 --> 00:37:01,766
非常有趣的例子


1032
00:37:01,766 --> 00:37:03,336
来介绍如何使用建模器


1033
00:37:03,606 --> 00:37:05,966
假设你定义了一个 Schema


1034
00:37:06,106 --> 00:37:07,906
叫做 playing-with-matches


1035
00:37:08,006 --> 00:37:10,166
它是一个


1036
00:37:10,166 --> 00:37:12,666
os-signpost-interval-schema


1037
00:37:12,876 --> 00:37:14,156
可以使已经定义的 os_signpost


1038
00:37:14,156 --> 00:37:15,036
在你的代码中


1039
00:37:15,036 --> 00:37:17,226
做一些危险的操作


1040
00:37:17,726 --> 00:37:19,996
我们又定义了另一个 Schema


1041
00:37:20,156 --> 00:37:21,766
叫做 app-on-fire


1042
00:37:22,186 --> 00:37:23,916
它也是一个 signpost Schema


1043
00:37:24,066 --> 00:37:25,206
但是这些 signpost 意味着


1044
00:37:25,206 --> 00:37:27,386
App 进入了一个糟糕的状态


1045
00:37:27,386 --> 00:37:29,396
我们真的很想知道原因


1046
00:37:30,406 --> 00:37:31,816
还要创建一个输出 Schema


1047
00:37:31,816 --> 00:37:33,306
它是一个 point-schema


1048
00:37:33,306 --> 00:37:35,836
它会保存 playing-with-matches 的对象


1049
00:37:35,836 --> 00:37:37,476
以及对象“起火”的时间


1050
00:37:37,956 --> 00:37:38,676
我们打算将它


1051
00:37:38,676 --> 00:37:39,796
命名为 started-a-fire


1052
00:37:39,796 --> 00:37:44,066
建模器看起来是这样的


1053
00:37:44,226 --> 00:37:46,686
所有的输入


1054
00:37:46,686 --> 00:37:48,486
都按时间顺序设置好了


1055
00:37:48,486 --> 00:37:51,096
左边的虚线就是


1056
00:37:51,096 --> 00:37:53,126
所谓的建模器时钟


1057
00:37:54,136 --> 00:37:55,976
当我们获取第一个输入


1058
00:37:55,976 --> 00:37:57,206
将其置入到工作内存中时


1059
00:37:57,206 --> 00:37:58,636
建模器时钟


1060
00:37:58,686 --> 00:37:59,686
将移动到区间的起始处


1061
00:37:59,686 --> 00:38:03,076
然后我们获取下一个输入


1062
00:38:03,076 --> 00:38:04,666
建模器时钟


1063
00:38:04,666 --> 00:38:06,036
再次移动到区间的起始处


1064
00:38:06,036 --> 00:38:08,046
我们将其置入到工作内存中


1065
00:38:08,836 --> 00:38:10,376
建模器观察


1066
00:38:10,376 --> 00:38:12,656
工作内存的这两个区间


1067
00:38:12,656 --> 00:38:14,366
建模器可以观察


1068
00:38:14,366 --> 00:38:16,256
playing-with-matches 是否在


1069
00:38:16,256 --> 00:38:17,336
app-on-fire 之前开始


1070
00:38:17,336 --> 00:38:18,886
这其实没有多大区别


1071
00:38:19,176 --> 00:38:19,956
如果反过来


1072
00:38:19,956 --> 00:38:22,406
app-on-fire 也已经开始了


1073
00:38:22,406 --> 00:38:24,086
我们就可以得出一个合乎逻辑的结论


1074
00:38:25,396 --> 00:38:27,936
叫做 cause-of-fire 


1075
00:38:27,936 --> 00:38:29,846
并将它置入工作内存中


1076
00:38:31,676 --> 00:38:33,456
当我们获取第三个输入时


1077
00:38:33,756 --> 00:38:34,986
你会注意到


1078
00:38:34,986 --> 00:38:36,636
建模器时钟已经移动


1079
00:38:36,636 --> 00:38:38,996
它不再与前两个输入相交


1080
00:38:39,516 --> 00:38:41,956
所以它们将被从工作内存中移除


1081
00:38:42,766 --> 00:38:44,636
如果 cause-of-fire 有


1082
00:38:44,636 --> 00:38:45,886
所谓的逻辑支持


1083
00:38:46,326 --> 00:38:50,556
它也会被从内存中移除


1084
00:38:50,856 --> 00:38:52,926
回顾一下 时钟总是被设置为


1085
00:38:52,926 --> 00:38:54,926
当前输入的时间戳


1086
00:38:55,556 --> 00:38:57,576
对于留在工作内存中的


1087
00:38:57,576 --> 00:38:58,936
输入而言


1088
00:38:58,936 --> 00:39:01,836
它必须与建模器中的


1089
00:39:01,836 --> 00:39:02,406
当前时钟相交


1090
00:39:02,956 --> 00:39:04,876
这可以帮助我们建立重合


1091
00:39:04,876 --> 00:39:06,606
它能让我们删除旧数据


1092
00:39:06,606 --> 00:39:08,626
也能让我们了解


1093
00:39:08,666 --> 00:39:10,186
是否存在


1094
00:39:10,186 --> 00:39:13,386
可能与时间相关的输入


1095
00:39:13,916 --> 00:39:15,026
建模器对其


1096
00:39:15,156 --> 00:39:16,766
工作内存的解释


1097
00:39:17,066 --> 00:39:19,196
是通过所谓的 “Production System”


1098
00:39:19,196 --> 00:39:20,426
来定义的


1099
00:39:21,496 --> 00:39:23,466
生产系统处理


1100
00:39:23,466 --> 00:39:25,306
工作内存中的 “Facts（事实）”


1101
00:39:25,306 --> 00:39:26,486
它们由具有左手边 (LHS)


1102
00:39:26,486 --> 00:39:28,176
一个生产操作符


1103
00:39:28,176 --> 00:39:30,346
和右手边 (RHS) 的规则定义


1104
00:39:31,106 --> 00:39:32,896
LHS 是工作内存


1105
00:39:33,306 --> 00:39:35,106
中的一种模板


1106
00:39:35,106 --> 00:39:37,336
它能够激活规则


1107
00:39:37,336 --> 00:39:38,976
而 RHS 则是规则触发时


1108
00:39:38,976 --> 00:39:41,576
发生的动作


1109
00:39:42,036 --> 00:39:43,306
这些操作可以包括


1110
00:39:43,746 --> 00:39:45,686
向输出表中添加一行


1111
00:39:45,866 --> 00:39:48,476
或者在建模过程进行时


1112
00:39:48,526 --> 00:39:50,896
将一个新的事实


1113
00:39:50,896 --> 00:39:52,566
添加到工作内存中


1114
00:39:54,186 --> 00:39:56,826
事实有两个来源


1115
00:39:56,926 --> 00:39:58,046
首先 它们可以来自


1116
00:39:58,046 --> 00:39:59,566
你看到过的表格输入


1117
00:39:59,566 --> 00:40:01,206
通过使用我在建模时钟中


1118
00:40:01,206 --> 00:40:03,336
展示的规则


1119
00:40:03,336 --> 00:40:04,246
表输入将被判定为事实


1120
00:40:04,246 --> 00:40:06,376
事实也可以通过


1121
00:40:06,376 --> 00:40:07,846
来自生产的 RHS 的


1122
00:40:07,846 --> 00:40:09,866
判定生成


1123
00:40:11,066 --> 00:40:12,196
如果你要创建你自己的事实


1124
00:40:12,196 --> 00:40:14,336
CLIPS 允许你


1125
00:40:14,336 --> 00:40:15,316
找到所谓的“事实模板”


1126
00:40:15,426 --> 00:40:16,106
你可以为你的事实


1127
00:40:16,106 --> 00:40:17,196
提供结构


1128
00:40:17,196 --> 00:40:17,976
并做一些基本的类型检查


1129
00:40:18,046 --> 00:40:21,306
让我们来看看 CLIPS 中的


1130
00:40:21,306 --> 00:40:22,356
一些规则


1131
00:40:23,226 --> 00:40:24,326
我们要讲的第一个规则


1132
00:40:24,326 --> 00:40:25,926
叫做 found-cause


1133
00:40:27,306 --> 00:40:30,446
它指的是 如果有一个对象


1134
00:40:30,446 --> 00:40:31,806
它的 playing-with-matches


1135
00:40:31,806 --> 00:40:35,526
在 t1 时开始


1136
00:40:35,526 --> 00:40:38,996
app-on-fire 在 t2 时开始


1137
00:40:39,286 --> 00:40:41,466
且 t1 比 t2 提前


1138
00:40:41,466 --> 00:40:42,236
那么在这个生产的 RHS 中


1139
00:40:42,236 --> 00:40:43,756
我们可以判定一个新的事实


1140
00:40:43,756 --> 00:40:46,026
叫做 cause-of-fire 


1141
00:40:46,076 --> 00:40:47,616
以及导致“起火”的对象


1142
00:40:48,196 --> 00:40:49,336
它将进入到


1143
00:40:49,426 --> 00:40:50,096
工作内存中


1144
00:40:51,136 --> 00:40:53,156
我们接下来讨论第二个规则


1145
00:40:53,156 --> 00:40:54,666
也就是 record-cause


1146
00:40:54,666 --> 00:40:58,296
如果我们有一个 App


1147
00:40:58,296 --> 00:41:00,166
在某个开始时间“起火”


1148
00:41:00,166 --> 00:41:01,796
并且我们知道“起火”的原因


1149
00:41:01,796 --> 00:41:03,536
我们有一个绑定到


1150
00:41:03,536 --> 00:41:05,876
side append 的表格


1151
00:41:05,876 --> 00:41:08,876
它是建模器的输出端


1152
00:41:08,946 --> 00:41:11,336
而且这个表是我们定义的


1153
00:41:11,336 --> 00:41:12,926
叫做 started-a-fire 的 Schema


1154
00:41:12,926 --> 00:41:16,776
我们可以创建一个表格的行


1155
00:41:16,776 --> 00:41:18,126
然后设置时间


1156
00:41:18,246 --> 00:41:19,946
以及导致


1157
00:41:19,946 --> 00:41:21,276
模板中所得的值


1158
00:41:21,276 --> 00:41:23,826
“起火”的 Schema


1159
00:41:23,906 --> 00:41:25,826
通过这两个规则


1160
00:41:25,826 --> 00:41:27,756
我们基本上创建了


1161
00:41:27,756 --> 00:41:29,356
第一个专家系统来查找


1162
00:41:29,356 --> 00:41:31,406
App 中的不良模式


1163
00:41:32,436 --> 00:41:34,376
现在你可能已经注意到


1164
00:41:34,376 --> 00:41:36,016
规则是由 MODELER::


1165
00:41:36,016 --> 00:41:38,396
或 RECORDER:: 预先编写的


1166
00:41:38,966 --> 00:41:39,546
这些都是 CLIPS 中的模块


1167
00:41:39,546 --> 00:41:41,606
它们允许你


1168
00:41:41,606 --> 00:41:43,916
同时把规则分组


1169
00:41:43,916 --> 00:41:45,956
并控制规则的执行顺序


1170
00:41:46,526 --> 00:41:48,556
举个例子


1171
00:41:48,556 --> 00:41:50,946
如果你保持了所有的


1172
00:41:50,946 --> 00:41:52,176
为 RECORDER:: 模块中的输出表格


1173
00:41:52,176 --> 00:41:54,006
生产输出的规则


1174
00:41:55,116 --> 00:41:57,536
你就可以确保


1175
00:41:57,536 --> 00:41:59,896
你不会在建模器的


1176
00:41:59,896 --> 00:42:01,916
推理过程中进行输出


1177
00:42:02,246 --> 00:42:03,566
因为在 MODELER:: 中的所有规则 


1178
00:42:03,566 --> 00:42:05,246
必须在 


1179
00:42:05,246 --> 00:42:06,966
RECORDER:: 中的规则


1180
00:42:06,966 --> 00:42:07,746
执行之前执行


1181
00:42:08,686 --> 00:42:10,736
我之前提到过的


1182
00:42:10,736 --> 00:42:12,296
逻辑支持


1183
00:42:12,776 --> 00:42:14,556
逻辑支持通常与


1184
00:42:14,776 --> 00:42:17,066
所谓的对等推理规则


1185
00:42:17,066 --> 00:42:18,586
联系在一起


1186
00:42:18,586 --> 00:42:20,336
这些规则就是 比如说


1187
00:42:20,336 --> 00:42:21,736
如果 A 和 B 那么 C


1188
00:42:22,156 --> 00:42:23,756
向生产中


1189
00:42:23,756 --> 00:42:25,286
添加逻辑支持


1190
00:42:25,286 --> 00:42:29,646
意思就是


1191
00:42:29,646 --> 00:42:30,786
如果 A 和 B 不再


1192
00:42:30,786 --> 00:42:32,126
处于工作内存中


1193
00:42:32,126 --> 00:42:33,606
那么 C 应该被自动收回


1194
00:42:33,656 --> 00:42:35,726
所以我们说


1195
00:42:35,726 --> 00:42:37,016
C 受 A 和 B 的存在的


1196
00:42:37,016 --> 00:42:38,326
逻辑支持


1197
00:42:38,806 --> 00:42:40,346
这很重要


1198
00:42:40,346 --> 00:42:41,606
因为它限制了工作内存膨胀


1199
00:42:41,606 --> 00:42:43,156
这有助于资源消耗


1200
00:42:43,156 --> 00:42:44,436
但从工作内存中


1201
00:42:44,436 --> 00:42:46,096
删除不再有效的事实


1202
00:42:46,096 --> 00:42:48,076
同样也很重要


1203
00:42:48,326 --> 00:42:49,486
如果 A 和 B 不再有效


1204
00:42:49,486 --> 00:42:51,526
那么你应该移除 C


1205
00:42:52,076 --> 00:42:54,596
为了向你的生产


1206
00:42:54,826 --> 00:42:57,606
添加逻辑支持 这里是相关的规则


1207
00:42:57,906 --> 00:42:59,826
你只需将关键字 logical


1208
00:42:59,866 --> 00:43:01,226
填入模板


1209
00:43:01,226 --> 00:43:02,146
那么在向前移动的过程中


1210
00:43:02,146 --> 00:43:03,866
规则中的 RHS


1211
00:43:03,866 --> 00:43:05,986
所判定的任何内容


1212
00:43:05,986 --> 00:43:06,836
都将被自动收回


1213
00:43:07,056 --> 00:43:08,566
你们应该注意到了


1214
00:43:08,816 --> 00:43:10,566
来自我们的 Schema 的


1215
00:43:11,146 --> 00:43:12,876
这两个规则 抱歉


1216
00:43:12,876 --> 00:43:14,326
这两个事实


1217
00:43:14,766 --> 00:43:16,446
它们都是输入


1218
00:43:16,446 --> 00:43:17,176
所以当建模器时钟


1219
00:43:17,176 --> 00:43:18,456
向前移动时


1220
00:43:18,456 --> 00:43:19,636
这些将自动被收回


1221
00:43:22,196 --> 00:43:23,626
好的 现在我们已经了解了


1222
00:43:23,626 --> 00:43:25,476
如何在包中创建


1223
00:43:25,476 --> 00:43:27,336
建模器的基本内容


1224
00:43:27,436 --> 00:43:29,746
并且看到了一些 CLIPS 语言和规则


1225
00:43:30,186 --> 00:43:32,096
让我们来看看


1226
00:43:32,096 --> 00:43:34,626
是否可以在我们的网络 Instrument 中


1227
00:43:34,626 --> 00:43:37,646
添加一个专家系统


1228
00:43:37,646 --> 00:43:39,216
以查找我们的网络层中的


1229
00:43:39,426 --> 00:43:41,106
不良模式和潜在的误用


1230
00:43:41,706 --> 00:43:43,286
为此 让我们邀请 Kacper 上台


1231
00:43:43,286 --> 00:43:44,886
做最后一个演示


1232
00:43:45,516 --> 00:43:50,500
[ 掌声 ]


1233
00:43:55,016 --> 00:43:56,486
>> 有了现有的日志记录


1234
00:43:56,526 --> 00:43:58,176
我将尝试编写建模器


1235
00:43:58,246 --> 00:43:59,796
来检测 App 的


1236
00:43:59,796 --> 00:44:00,956
网络行为中的


1237
00:44:00,956 --> 00:44:01,976
一些反面模式


1238
00:44:02,756 --> 00:44:03,656
我在运行我的


1239
00:44:03,656 --> 00:44:05,646
《Trailblazer》 App


1240
00:44:05,646 --> 00:44:07,086
如果我滚动得很快


1241
00:44:07,136 --> 00:44:08,746
这里就会出现


1242
00:44:08,746 --> 00:44:09,476
一些小故障


1243
00:44:09,906 --> 00:44:11,886
图像被多次替换


1244
00:44:11,886 --> 00:44:14,516
所以我怀疑我们的取消


1245
00:44:14,516 --> 00:44:15,906
并没有真正起作用


1246
00:44:17,366 --> 00:44:19,736
我想编写建模器来检测它


1247
00:44:21,186 --> 00:44:23,746
让我们来看看


1248
00:44:23,746 --> 00:44:24,736
我们的包定义


1249
00:44:25,246 --> 00:44:27,916
我们将从编写 modeler 元素开始


1250
00:44:28,636 --> 00:44:31,336
modeler 有 id title


1251
00:44:31,336 --> 00:44:32,366
和 purpose 几个栏


1252
00:44:33,336 --> 00:44:35,316
这些栏将被


1253
00:44:35,316 --> 00:44:36,406
提取到文档中


1254
00:44:37,536 --> 00:44:39,366
我们为 modeler 指定了


1255
00:44:39,366 --> 00:44:41,576
包含所有逻辑的


1256
00:44:41,576 --> 00:44:42,756
production system 的 path


1257
00:44:45,086 --> 00:44:47,466
然后 我们定义了 modeler 的 output


1258
00:44:48,086 --> 00:44:50,006
它将是一个 downloader-narrative Schema


1259
00:44:50,916 --> 00:44:53,506
我们的建模器的 required-input 


1260
00:44:53,506 --> 00:44:55,646
将是 os-signpost 表格


1261
00:44:56,556 --> 00:44:58,836
这个表包含开始


1262
00:44:58,836 --> 00:44:59,686
和结束事件


1263
00:45:00,926 --> 00:45:02,076
现在让我们看一下


1264
00:45:02,526 --> 00:45:03,816
downloader-narrative


1265
00:45:03,816 --> 00:45:04,946
Schema 的定义


1266
00:45:10,896 --> 00:45:13,006
它是一个 point-schema


1267
00:45:13,046 --> 00:45:15,026
定义了两个列


1268
00:45:15,526 --> 00:45:17,216
timestamp


1269
00:45:17,216 --> 00:45:19,046
跟踪记录诊断消息的时间


1270
00:45:20,176 --> 00:45:22,156
description 含有


1271
00:45:22,156 --> 00:45:23,666
运行错误的信息


1272
00:45:26,116 --> 00:45:28,346
然后 我们可以在 Instrument 定义中


1273
00:45:28,676 --> 00:45:30,086
创建这个表


1274
00:45:30,656 --> 00:45:33,316
我们传入 downloader-narrative 的


1275
00:45:33,316 --> 00:45:36,206
schema-ref 和唯一的 id 


1276
00:45:37,896 --> 00:45:40,006
然后我们可以在


1277
00:45:40,136 --> 00:45:42,206
narrative 元素定义中使用它


1278
00:45:44,556 --> 00:45:46,266
在这里我们定义 narrative 


1279
00:45:46,686 --> 00:45:49,006
我们为之前创建的表格


1280
00:45:49,006 --> 00:45:51,466
传入 table-ref


1281
00:45:51,546 --> 00:45:53,766
定义 time-column


1282
00:45:55,616 --> 00:45:55,846
和 narrative-column


1283
00:45:55,936 --> 00:45:57,876
我们已经准备好


1284
00:45:57,876 --> 00:45:58,756
为我们的建模器定义逻辑


1285
00:46:00,256 --> 00:46:01,826
为此 我将创建


1286
00:46:01,826 --> 00:46:03,736
之前在 modeler 定义中


1287
00:46:03,736 --> 00:46:04,766
引用的文件


1288
00:46:05,566 --> 00:46:07,256
为了创建 CLIPS 文件


1289
00:46:07,256 --> 00:46:12,796
前往 “File（文件）”-“New（新建）”


1290
00:46:14,276 --> 00:46:15,786
选择 “macOS” 作为平台 “Other（其他）”部分的


1291
00:46:15,786 --> 00:46:16,366
“CLIPS File（CLIPS 文件）”


1292
00:46:19,196 --> 00:46:27,586
我把名称填好并创建


1293
00:46:27,966 --> 00:46:30,286
下面展示的将是


1294
00:46:30,286 --> 00:46:31,936
检测一个单元


1295
00:46:31,936 --> 00:46:33,486
是否同时执行


1296
00:46:33,486 --> 00:46:34,256
多个请求的算法


1297
00:46:35,046 --> 00:46:37,036
我们将在工作内存中


1298
00:46:37,036 --> 00:46:38,756
追踪每一个作为事实的请求


1299
00:46:39,196 --> 00:46:40,856
首先 我们需要


1300
00:46:41,046 --> 00:46:42,946
为这个事实创建模板


1301
00:46:44,376 --> 00:46:47,696
每个事实都会有


1302
00:46:47,786 --> 00:46:49,996
存储 time


1303
00:46:49,996 --> 00:46:53,236
caller-address 也就是单元地址


1304
00:46:53,236 --> 00:46:56,286
我们捕获到的 signpost-id


1305
00:46:56,286 --> 00:46:57,286
以及我们请求的 image-name


1306
00:46:57,806 --> 00:46:59,796
我们将这个事实叫做 started-download


1307
00:47:01,036 --> 00:47:03,296
然后编写


1308
00:47:03,296 --> 00:47:05,816
在工作内存中 创建此事件的建模器规则


1309
00:47:08,576 --> 00:47:11,676
这个规则查看 os-signpost 表格


1310
00:47:12,536 --> 00:47:15,336
我们指定 subsystem name


1311
00:47:15,426 --> 00:47:18,006
并把 “Begin” 作为 even-type 的值


1312
00:47:18,006 --> 00:47:20,306
并捕获我们想要的所有信息


1313
00:47:21,186 --> 00:47:22,926
我们需要捕获 ?image-name


1314
00:47:22,926 --> 00:47:25,586
?caller-address time 以及 ?identifier


1315
00:47:25,586 --> 00:47:28,956
然后 我们向工作内存判定新的事实


1316
00:47:34,056 --> 00:47:36,676
要在下载完成后清理它


1317
00:47:36,746 --> 00:47:39,406
我们需要从工作内存中


1318
00:47:39,406 --> 00:47:40,666
收回这一事实


1319
00:47:44,426 --> 00:47:46,066
这里我们查看的是同一个表格


1320
00:47:46,066 --> 00:47:48,606
但是我们只查看


1321
00:47:48,866 --> 00:47:51,736
event-type “End”


1322
00:47:52,866 --> 00:47:54,836
我们捕获 signpost 的 identifier


1323
00:47:55,756 --> 00:47:57,426
在这里我们使用的事实


1324
00:47:57,846 --> 00:48:00,096
signpost “Begin” 和 “End”


1325
00:48:00,136 --> 00:48:01,526
必须有相同的标识符


1326
00:48:02,706 --> 00:48:04,336
我们在工作内存中


1327
00:48:04,566 --> 00:48:07,296
寻找一个具有我们捕获到的


1328
00:48:07,296 --> 00:48:09,726
signpost identifier 的事实


1329
00:48:09,726 --> 00:48:11,346
并收回这个事实


1330
00:48:14,116 --> 00:48:16,286
然后我们可以编写 RECORDER:: 规则


1331
00:48:16,286 --> 00:48:18,976
来生成所有的叙事数据


1332
00:48:24,216 --> 00:48:27,106
这个 RECORDER:: 规则


1333
00:48:27,106 --> 00:48:28,546
查看所有 started-download 事实


1334
00:48:28,726 --> 00:48:29,986
并捕获它们


1335
00:48:30,616 --> 00:48:32,136
我们捕获 time caller-address


1336
00:48:32,136 --> 00:48:33,696
以及 image-name


1337
00:48:34,796 --> 00:48:36,936
如果这里是 true


1338
00:48:37,606 --> 00:48:39,176
有另一个具有相同 caller-address 的


1339
00:48:39,216 --> 00:48:40,996
started-download 事实


1340
00:48:40,996 --> 00:48:42,786
你就可以注意到


1341
00:48:42,786 --> 00:48:44,646
这里引用的变量是相同的


1342
00:48:45,376 --> 00:48:48,616
并且在第一个事实之前发生


1343
00:48:49,606 --> 00:48:51,136
我们注意到


1344
00:48:51,136 --> 00:48:52,326
存在一些反向模式


1345
00:48:52,326 --> 00:48:53,616
而且在请求中存在重叠


1346
00:48:54,716 --> 00:48:56,086
我们可以检查


1347
00:48:56,086 --> 00:48:57,346
是否可以访问


1348
00:48:57,346 --> 00:49:01,386
downloader-narrative Schema


1349
00:49:01,386 --> 00:49:05,766
在其中创建新的行


1350
00:49:05,856 --> 00:49:08,976
将列的时间设置为第一个事实的时间


1351
00:49:08,976 --> 00:49:10,266
并设置列的描述


1352
00:49:11,036 --> 00:49:13,796
你需要输出


1353
00:49:13,796 --> 00:49:15,486
关于这个问题的一些信息


1354
00:49:15,846 --> 00:49:19,216
以便之后有人可以调试它


1355
00:49:19,456 --> 00:49:21,916
现在我可以在 App 上运行 Instruments 


1356
00:49:22,636 --> 00:49:24,956
让我们再次运行它


1357
00:49:32,216 --> 00:49:38,156
再次选择《Trailblazer》网络模板并记录


1358
00:49:38,936 --> 00:49:41,766
我将尝试执行一些


1359
00:49:41,766 --> 00:49:44,976
快速滚动并查看我的叙事表


1360
00:49:49,636 --> 00:49:51,836
你可以看到


1361
00:49:51,886 --> 00:49:53,406
叙事表包含大量


1362
00:49:53,406 --> 00:49:55,066
正在输出的诊断消息


1363
00:49:56,026 --> 00:49:57,706
我们可以看到


1364
00:49:57,706 --> 00:49:59,126
存在一些问题


1365
00:49:59,126 --> 00:49:59,866
之后再研究它们


1366
00:50:00,876 --> 00:50:03,086
你可以看到


1367
00:50:03,176 --> 00:50:04,186
叙事表是可互动的细节视图


1368
00:50:04,876 --> 00:50:06,526
例如 你可以检查


1369
00:50:06,526 --> 00:50:07,746
所有传入的参数


1370
00:50:07,876 --> 00:50:09,066
并进行筛选


1371
00:50:09,496 --> 00:50:11,586
我们可以添加这个调用者地址


1372
00:50:11,586 --> 00:50:13,826
成为一个细节过滤器


1373
00:50:13,826 --> 00:50:15,476
并拥有这个细节过滤器


1374
00:50:17,476 --> 00:50:19,386
现在 让我们请回 Chad


1375
00:50:19,386 --> 00:50:21,146
他将告诉你更多


1376
00:50:21,216 --> 00:50:23,446
关于开发 Instruments 的最佳实践经验


1377
00:50:24,516 --> 00:50:29,896
[ 掌声 ]


1378
00:50:30,396 --> 00:50:30,646
>> 好的


1379
00:50:30,646 --> 00:50:31,326
谢谢 Kacper


1380
00:50:32,076 --> 00:50:34,616
我们已经看到如何在 Instruments 中


1381
00:50:34,616 --> 00:50:37,016
创建一些基本的专家系统


1382
00:50:37,106 --> 00:50:39,656
好的 我们来谈谈


1383
00:50:39,826 --> 00:50:42,316
在这个过程中


1384
00:50:42,316 --> 00:50:43,156
我们学到的一些最佳实践经验


1385
00:50:43,416 --> 00:50:46,796
第一个是


1386
00:50:46,796 --> 00:50:47,986
编写多个 Instrument


1387
00:50:48,236 --> 00:50:49,566
我的意思并不是


1388
00:50:49,566 --> 00:50:50,286
练习编写 Instrument


1389
00:50:50,776 --> 00:50:52,146
而是 如果你


1390
00:50:52,146 --> 00:50:52,926
已经拥有了一个 Instrument


1391
00:50:52,926 --> 00:50:54,096
并且想给它添加一些特性


1392
00:50:54,396 --> 00:50:55,486
有时候 给你的 Instrument


1393
00:50:55,486 --> 00:50:56,826
添加额外的图形或细节


1394
00:50:56,826 --> 00:50:57,826
真的很容易


1395
00:50:57,826 --> 00:50:59,346
但是你应该


1396
00:50:59,346 --> 00:51:00,306
真正地思考


1397
00:51:00,306 --> 00:51:01,876
这样的话 它还可以成为自身的 Instrument 吗


1398
00:51:02,226 --> 00:51:03,216
这样想的原因是


1399
00:51:03,216 --> 00:51:05,366
如果你创建更细粒度的 Instrument


1400
00:51:05,726 --> 00:51:07,326
你会给这个 Instrument 的用户


1401
00:51:07,326 --> 00:51:08,766
更多的选择


1402
00:51:09,256 --> 00:51:10,686
他们可以从库中


1403
00:51:10,686 --> 00:51:11,716
拖出他们想要的 Instrument


1404
00:51:11,716 --> 00:51:13,156
这将最小化


1405
00:51:13,156 --> 00:51:15,496
对目标的记录影响


1406
00:51:15,876 --> 00:51:17,306
如果你把注意力集中在一个


1407
00:51:17,306 --> 00:51:18,546
有很多功能的 Instrument 上


1408
00:51:18,546 --> 00:51:19,416
那对用户来说 将是一个全盘接受


1409
00:51:19,416 --> 00:51:20,026
与被迫放弃之间的选择


1410
00:51:20,986 --> 00:51:24,616
如果你想创建


1411
00:51:24,616 --> 00:51:26,066
针对某个问题


1412
00:51:26,636 --> 00:51:27,476
的一组 Instrument


1413
00:51:27,476 --> 00:51:29,666
你一定想要看到


1414
00:51:29,666 --> 00:51:31,366
所有这些 Instrument 同时被使用


1415
00:51:31,366 --> 00:51:33,616
那么你所能做的就是


1416
00:51:33,616 --> 00:51:34,976
像我们创建网络模板那样


1417
00:51:35,146 --> 00:51:36,156
创建自己的自定义模板


1418
00:51:36,696 --> 00:51:37,896
所以你要做的应该是


1419
00:51:37,896 --> 00:51:39,486
创建一个文档


1420
00:51:39,486 --> 00:51:42,126
以你想要的方式拖拽 Instrument 配置它们


1421
00:51:42,126 --> 00:51:44,116
进入文件


1422
00:51:44,116 --> 00:51:45,316
然后保存为模板


1423
00:51:45,706 --> 00:51:46,696
然后你就可以在你的包中


1424
00:51:46,696 --> 00:51:48,656
使用那个模板


1425
00:51:48,836 --> 00:51:50,666
同时使用 Kacper


1426
00:51:50,666 --> 00:51:52,496
在我们的网络模板中添加的元素


1427
00:51:53,226 --> 00:51:54,606
使用多种 Instrument 编写


1428
00:51:54,606 --> 00:51:56,486
是使用工具更好的方式


1429
00:51:58,046 --> 00:52:00,336
第二 即时模式很难


1430
00:52:01,156 --> 00:52:03,256
即时模式指的是


1431
00:52:03,256 --> 00:52:04,616
Instruments 的记录模式


1432
00:52:04,916 --> 00:52:07,016
它可以在接近实时的时候


1433
00:52:07,016 --> 00:52:08,916
将数据可视化


1434
00:52:08,916 --> 00:52:12,766
有两个原因导致它很难


1435
00:52:12,856 --> 00:52:14,246
第一个原因是


1436
00:52:14,246 --> 00:52:16,006
它需要一些额外的支持


1437
00:52:16,006 --> 00:52:17,176
尽管今天我们很想向你们介绍这点


1438
00:52:17,176 --> 00:52:18,436
但是很遗憾没有办法


1439
00:52:18,436 --> 00:52:19,546
时间有限


1440
00:52:19,956 --> 00:52:20,726
所以我们将会


1441
00:52:20,726 --> 00:52:21,936
为此编写文档


1442
00:52:22,426 --> 00:52:24,156
第二个原因


1443
00:52:24,156 --> 00:52:26,456
也是更重要的原因


1444
00:52:26,456 --> 00:52:29,296
就是区间数据


1445
00:52:29,296 --> 00:52:31,236
区间不能被输入到


1446
00:52:31,236 --> 00:52:32,766
分析核心的表中


1447
00:52:32,766 --> 00:52:34,406
除非它们被关闭


1448
00:52:34,406 --> 00:52:35,316
这意味着这时我们已经


1449
00:52:35,316 --> 00:52:36,346
看到了开始和结束


1450
00:52:36,496 --> 00:52:37,576
所以当你查看


1451
00:52:37,576 --> 00:52:39,386
现场记录的时候


1452
00:52:39,386 --> 00:52:40,696
你会发现一堆所谓的“开区间”


1453
00:52:40,886 --> 00:52:42,216
如果你的建模器


1454
00:52:42,216 --> 00:52:43,506
需要它们作为输入


1455
00:52:43,586 --> 00:52:45,576
这是完全可行的


1456
00:52:45,576 --> 00:52:46,956
而且你会注意到


1457
00:52:46,956 --> 00:52:48,936
如果上游有一个开区间


1458
00:52:48,936 --> 00:52:50,426
那么下游的所有建模器时钟


1459
00:52:50,426 --> 00:52:52,266
都必须停止


1460
00:52:52,266 --> 00:52:53,716
直到那个区间关闭


1461
00:52:53,716 --> 00:52:55,186
因为建模器的视图


1462
00:52:55,186 --> 00:52:56,986
都是按时间排序的


1463
00:52:57,116 --> 00:52:58,796
除非所有的区间


1464
00:52:58,796 --> 00:53:00,196
都被关闭


1465
00:53:00,196 --> 00:53:01,516
否则无法把时钟向前移动


1466
00:53:02,076 --> 00:53:03,086
所以如果你有一些


1467
00:53:03,086 --> 00:53:04,856
占用时间很长的区间


1468
00:53:04,856 --> 00:53:06,636
你会注意到


1469
00:53:06,636 --> 00:53:08,276
建模器的输出似乎停止了


1470
00:53:08,986 --> 00:53:11,336
当用户点击


1471
00:53:11,626 --> 00:53:13,506
停止记录按钮


1472
00:53:13,556 --> 00:53:14,516
所有的开启的区间都被关闭时


1473
00:53:14,516 --> 00:53:15,836
所有的进程才将正常


1474
00:53:15,976 --> 00:53:17,136
数据也才会涌入


1475
00:53:17,606 --> 00:53:19,036
但这种用户体验并不好


1476
00:53:19,416 --> 00:53:21,676
如果停止录制


1477
00:53:21,676 --> 00:53:22,396
你将有两种选择


1478
00:53:22,396 --> 00:53:24,686
第一个是将 Instruments 退出


1479
00:53:24,686 --> 00:53:26,066
即时模式支持


1480
00:53:26,066 --> 00:53:27,376
为此你可以给你的 Instrument


1481
00:53:27,376 --> 00:53:28,846
添加一个限制元素


1482
00:53:28,916 --> 00:53:31,396
第二个是不再将区间数据


1483
00:53:31,396 --> 00:53:34,096
作为建模器的输入


1484
00:53:34,096 --> 00:53:35,746
就像我们在演示中


1485
00:53:35,746 --> 00:53:38,136
为我们的专家系统


1486
00:53:38,136 --> 00:53:39,856
所做的那样


1487
00:53:39,856 --> 00:53:41,316
我们实际上使用的是


1488
00:53:41,316 --> 00:53:42,746
os-signpost-point 事件


1489
00:53:42,746 --> 00:53:44,176
而不是 os-signpost-interval


1490
00:53:45,316 --> 00:53:47,156
我知道我们让它看起来简单


1491
00:53:47,326 --> 00:53:49,086
但是即时模式实现起来


1492
00:53:49,086 --> 00:53:50,046
确实有点棘手


1493
00:53:50,436 --> 00:53:55,056
第三 非常重要的一点


1494
00:53:55,056 --> 00:53:56,256
如果你要创建的 Instrument


1495
00:53:56,256 --> 00:53:57,046
针对的是


1496
00:53:57,046 --> 00:53:59,156
大量的输入数据


1497
00:53:59,156 --> 00:54:00,646
那么最后 5 秒


1498
00:54:00,646 --> 00:54:03,466
记录模式


1499
00:54:03,466 --> 00:54:04,066
是最有效的


1500
00:54:04,346 --> 00:54:05,816
你可以在跟踪文档的


1501
00:54:05,816 --> 00:54:07,256
记录选项中进行切换


1502
00:54:07,256 --> 00:54:08,886
之后你将看到


1503
00:54:08,886 --> 00:54:09,776
你可以在即时 延迟


1504
00:54:09,776 --> 00:54:11,256
和最后 n 秒模式之间


1505
00:54:11,256 --> 00:54:12,676
进行选择


1506
00:54:13,246 --> 00:54:14,486
更加有效的原因是


1507
00:54:14,486 --> 00:54:16,476
它允许记录技术


1508
00:54:16,476 --> 00:54:18,016
使用缓冲


1509
00:54:18,296 --> 00:54:19,666
来提高性能


1510
00:54:19,716 --> 00:54:20,906
这样它就不会一直尝试


1511
00:54:20,906 --> 00:54:22,976
实时向 Instruments 提供数据


1512
00:54:23,376 --> 00:54:24,586
这将产生深远的影响


1513
00:54:24,586 --> 00:54:26,876
它会对 signpost 数据


1514
00:54:26,876 --> 00:54:28,286
产生巨大的影响


1515
00:54:28,286 --> 00:54:29,856
在最后 5 秒模式下


1516
00:54:30,096 --> 00:54:31,756
速度可以提升 10 倍


1517
00:54:32,246 --> 00:54:33,326
当然 为此的权衡是


1518
00:54:33,466 --> 00:54:34,796
你只能看到


1519
00:54:34,796 --> 00:54:37,136
最后 5 秒的数据


1520
00:54:37,296 --> 00:54:39,056
但是对于产生大量


1521
00:54:39,056 --> 00:54:40,736
数据的 Instrument 来说


1522
00:54:40,736 --> 00:54:41,276
这通常是件好事


1523
00:54:41,446 --> 00:54:43,016
这使得它成为


1524
00:54:43,016 --> 00:54:45,346
系统跟踪和 Metal 系统跟踪


1525
00:54:45,346 --> 00:54:46,916
以及游戏性能模板的通用模式


1526
00:54:47,176 --> 00:54:50,066
如果你的目标是这类 App 


1527
00:54:50,066 --> 00:54:51,546
我也会建议


1528
00:54:51,546 --> 00:54:53,136
你的 Instrument 不要支持即时模式


1529
00:54:53,476 --> 00:54:54,506
这样你的用户体验


1530
00:54:54,506 --> 00:54:56,096
就不会很糟糕


1531
00:54:56,096 --> 00:54:58,086
Instruments 在获取数据时


1532
00:54:58,086 --> 00:54:59,236
也不会出现延后


1533
00:54:59,236 --> 00:55:00,746
你在区间中也不会遇到类似的问题


1534
00:55:02,926 --> 00:55:04,326
我们的讨论会差不多结束了


1535
00:55:04,896 --> 00:55:08,026
我们今天谈论很多


1536
00:55:08,026 --> 00:55:09,116
关于创建 Instrument 特性的内容


1537
00:55:09,116 --> 00:55:10,456
我们真的非常兴奋


1538
00:55:10,456 --> 00:55:11,386
因为我们能够


1539
00:55:11,386 --> 00:55:12,306
在今年向你们展示这一切


1540
00:55:12,686 --> 00:55:14,636
我们迫不及待地想知道


1541
00:55:14,636 --> 00:55:15,746
你们能通过 Instruments 创造什么样的成果


1542
00:55:16,146 --> 00:55:17,906
如果你想和我们


1543
00:55:17,906 --> 00:55:18,926
谈谈自定义 Instrument


1544
00:55:18,926 --> 00:55:21,176
我们将在今天下午 3 点


1545
00:55:21,566 --> 00:55:23,986
8 号实验室等待各位


1546
00:55:23,986 --> 00:55:25,916
另外 405 号讨论会详细介绍了


1547
00:55:25,916 --> 00:55:27,256
如何使用 os_signpost API


1548
00:55:27,256 --> 00:55:29,156
你可以通过它将数据输入 Instruments 


1549
00:55:29,856 --> 00:55:30,976
请享受接下来的讨论会


1550
00:55:31,516 --> 00:55:34,500
[ 掌声 ]

