1
00:00:07,516 --> 00:00:15,500
[ 音乐 ]


2
00:00:19,516 --> 00:00:25,176
[ 掌声 ]


3
00:00:25,676 --> 00:00:26,186
>> 下午好


4
00:00:27,166 --> 00:00:28,956
欢迎大家 我叫 Ken Ferry


5
00:00:29,246 --> 00:00:31,536
今天我与 Kasia Wawer 将会给大家介绍


6
00:00:31,536 --> 00:00:32,686
Auto Layout 的性能


7
00:00:33,666 --> 00:00:35,466
上一次我站在这里谈论


8
00:00:35,466 --> 00:00:37,446
Auto Layout 是 2011 年


9
00:00:38,056 --> 00:00:39,356
当时我们刚刚推出这个功能


10
00:00:39,726 --> 00:00:42,216
所以我很高兴可以回到这里


11
00:00:42,316 --> 00:00:43,446
与你们一起探讨这个功能


12
00:00:44,956 --> 00:00:48,896
好的 下面说 Auto Layout


13
00:00:49,796 --> 00:00:51,366
我们像这样把内容


14
00:00:51,576 --> 00:00:52,916
放置在 Mac 的 iOS 系统中


15
00:00:53,486 --> 00:00:55,096
其中主要涉及的是


16
00:00:55,096 --> 00:00:57,456
我们熟知的视图和约束


17
00:00:58,246 --> 00:00:59,096
其中约束定义


18
00:00:59,096 --> 00:01:00,406
视图之间的关系


19
00:01:01,206 --> 00:01:02,826
那么关于性能


20
00:01:03,126 --> 00:01:04,756
我想其中的挑战在于


21
00:01:04,756 --> 00:01:07,276
如果只说这两个按钮的


22
00:01:07,416 --> 00:01:09,286
间距为 20


23
00:01:09,286 --> 00:01:10,446
就很难去理解机器


24
00:01:10,446 --> 00:01:12,606
如何一步一步


25
00:01:12,606 --> 00:01:13,936
完成这个过程


26
00:01:14,226 --> 00:01:15,466
也就是说 很难去


27
00:01:15,466 --> 00:01:17,726
正确理解对


28
00:01:17,726 --> 00:01:18,736
其性能的期望


29
00:01:18,736 --> 00:01:19,826
并了解什么运行得快


30
00:01:19,826 --> 00:01:21,296
什么运行的慢 以及一般情况下


31
00:01:21,296 --> 00:01:22,006
整个过程是如何工作的


32
00:01:22,986 --> 00:01:25,156
这就是我们今天的目的


33
00:01:25,456 --> 00:01:29,556
今天的目标是 真正理解并掌握整个过程如何运作


34
00:01:29,896 --> 00:01:31,146
那么我们就


35
00:01:31,146 --> 00:01:32,696
首先展示一些


36
00:01:32,696 --> 00:01:33,826
我们在过去为了


37
00:01:33,826 --> 00:01:35,556
iOS 12 发布而做的


38
00:01:35,556 --> 00:01:36,096
性能方面的工作


39
00:01:36,436 --> 00:01:37,256
我们有很多成果


40
00:01:37,706 --> 00:01:40,286
在演讲中会进行介绍


41
00:01:41,206 --> 00:01:44,646
这之后我们将会


42
00:01:44,646 --> 00:01:46,166
讨论如何建立起


43
00:01:46,166 --> 00:01:48,376
我刚才说的那种一步一步的理解


44
00:01:48,686 --> 00:01:50,506
这样我们对于性能有


45
00:01:50,506 --> 00:01:52,006
较好的判断和较好的期望


46
00:01:52,456 --> 00:01:53,626
为此我们将会做


47
00:01:53,626 --> 00:01:55,496
一些不寻常的事情


48
00:01:55,786 --> 00:01:57,076
我们会谈到一些内在问题


49
00:01:57,746 --> 00:01:58,756
请尽情享受


50
00:02:02,546 --> 00:02:04,756
最后 如果你只依赖于


51
00:02:04,756 --> 00:02:06,316
对性能的直观判断


52
00:02:06,546 --> 00:02:07,896
这远远不够


53
00:02:08,286 --> 00:02:10,776
那么我们将有请 Kasia


54
00:02:10,776 --> 00:02:12,376
上台来分析代码


55
00:02:12,506 --> 00:02:14,686
我们将会展示如何


56
00:02:14,686 --> 00:02:16,696
将你的直观判断与


57
00:02:16,916 --> 00:02:17,736
实践结合起来


58
00:02:18,846 --> 00:02:20,126
现在开始吧


59
00:02:20,436 --> 00:02:22,226
首先 作为一个


60
00:02:22,226 --> 00:02:23,326
Apple 展示的传统


61
00:02:23,326 --> 00:02:24,676
我们先来看到一些数据和自夸


62
00:02:25,516 --> 00:02:28,796
[ 笑声 ]


63
00:02:29,296 --> 00:02:31,116
我们目前看到的是


64
00:02:31,116 --> 00:02:32,806
一个基准测试


65
00:02:33,416 --> 00:02:35,456
我们进行工作的方法是


66
00:02:35,456 --> 00:02:37,536
去寻找并查看


67
00:02:37,536 --> 00:02:38,816
一些第三方 App


68
00:02:38,816 --> 00:02:40,406
也包括我们自己的 App


69
00:02:40,406 --> 00:02:41,906
并试图将看到的内容提取


70
00:02:41,906 --> 00:02:44,646
为测试案例


71
00:02:44,646 --> 00:02:45,476
因此我们可以进行基准测试


72
00:02:45,996 --> 00:02:47,056
那么我们看到的


73
00:02:47,056 --> 00:02:49,006
就是 UICollectionView


74
00:02:49,006 --> 00:02:51,486
它具有自动调节大小的单元格


75
00:02:51,706 --> 00:02:53,236
看起来糟糕的那一边


76
00:02:53,436 --> 00:03:00,086
就是 iOS 11 它看起来很差劲


77
00:03:00,266 --> 00:03:02,946
而在 iOS 12 中它表现完美


78
00:03:03,216 --> 00:03:04,116
达到了全帧速率


79
00:03:05,096 --> 00:03:07,586
这就是我们所关注的案例之一


80
00:03:07,896 --> 00:03:10,846
这里还有一些其他的样本


81
00:03:10,846 --> 00:03:11,806
这样的样本我们有很多


82
00:03:12,526 --> 00:03:14,186
这些都是关于时间的


83
00:03:14,766 --> 00:03:16,446
你们所看到的


84
00:03:16,446 --> 00:03:18,176
灰色的条形代表 iOS 11


85
00:03:18,346 --> 00:03:19,666
即在 iOS 11 上所需的时间


86
00:03:20,016 --> 00:03:21,506
蓝色的代表 iOS 12


87
00:03:22,936 --> 00:03:24,236
你们可以看到的是


88
00:03:24,236 --> 00:03:25,516
我们发现很多地方


89
00:03:25,516 --> 00:03:27,476
都有很大的改进空间


90
00:03:28,076 --> 00:03:31,546
而这些会对你们的 App 有帮助


91
00:03:31,676 --> 00:03:32,646
这会让产品


92
00:03:32,856 --> 00:03:35,616
变得更好 希望如此


93
00:03:35,616 --> 00:03:36,896
改进存在于整个


94
00:03:36,896 --> 00:03:37,466
堆栈的过程


95
00:03:37,766 --> 00:03:39,336
其中有的位于


96
00:03:39,336 --> 00:03:41,676
核心中 可以影响到方方面面


97
00:03:42,166 --> 00:03:44,366
有的存在于 UI Kit 中


98
00:03:44,366 --> 00:03:45,486
有的则是存在于客户


99
00:03:45,486 --> 00:03:48,326
层面 关于如何使用 Auto Layout


100
00:03:48,716 --> 00:03:51,246
比如说 UICollectionView 基准测试


101
00:03:51,606 --> 00:03:52,776
也就是刚刚展示的


102
00:03:52,776 --> 00:03:53,536
就包括所有改进


103
00:03:54,016 --> 00:03:55,846
它包括了


104
00:03:55,846 --> 00:03:57,386
核心部分的 也包括了


105
00:03:57,446 --> 00:03:58,856
一些非常


106
00:03:58,856 --> 00:04:00,236
重要的改进


107
00:04:00,236 --> 00:04:01,876
是关于 UICollectionView 如何


108
00:04:01,876 --> 00:04:03,576
使用 Auto Layout 如何展现


109
00:04:04,296 --> 00:04:04,866
更高的性能的


110
00:04:05,376 --> 00:04:07,186
这对于接下来的演讲


111
00:04:07,186 --> 00:04:09,186
是一个不错的例子


112
00:04:09,256 --> 00:04:10,116
你们也可以做到


113
00:04:10,676 --> 00:04:11,786
那应该如何正确使用它呢


114
00:04:12,606 --> 00:04:14,286
当我们完成这些工作后


115
00:04:15,026 --> 00:04:16,505
我常常会想到


116
00:04:16,505 --> 00:04:17,956
我们之所以能够完成


117
00:04:17,956 --> 00:04:19,375
这些改进是因为


118
00:04:19,375 --> 00:04:21,786
我们有一个很好的心智模型


119
00:04:21,786 --> 00:04:24,336
关于事物如何组建以及


120
00:04:24,366 --> 00:04:26,226
如何执行 如何工作


121
00:04:27,366 --> 00:04:29,756
我们希望帮助你们也构建起这一模型


122
00:04:30,286 --> 00:04:31,876
为此我们会先


123
00:04:31,876 --> 00:04:34,126
探讨一个示例


124
00:04:34,126 --> 00:04:36,726
一些客户端代码


125
00:04:36,726 --> 00:04:38,676
它们有一些问题 我们将会讨论问题的原因


126
00:04:39,266 --> 00:04:40,796
你的代码或许不一定有


127
00:04:40,796 --> 00:04:42,166
一模一样的问题 但我们


128
00:04:42,166 --> 00:04:43,226
选择的是


129
00:04:43,226 --> 00:04:44,636
我们认为


130
00:04:44,636 --> 00:04:45,816
在看到的这些


131
00:04:46,056 --> 00:04:47,496
客户端 App 中最为常见的问题


132
00:04:48,096 --> 00:04:49,146
就算你没有这个


133
00:04:49,146 --> 00:04:50,876
问题 我们所做的


134
00:04:50,876 --> 00:04:52,476
对问题的探讨


135
00:04:52,706 --> 00:04:53,596
将会对每个人都有所帮助


136
00:04:53,596 --> 00:04:56,026
而且可能对所有人来说 都是新的内容


137
00:04:56,876 --> 00:04:58,426
那么我们开始吧


138
00:04:59,656 --> 00:05:01,436
这个示例是我们即将探讨的


139
00:05:01,436 --> 00:05:04,516
要产生这个布局 显然非常简单


140
00:05:05,106 --> 00:05:06,976
我想你们应该经常


141
00:05:06,976 --> 00:05:08,046
在 Interface Builder 中创建它


142
00:05:08,806 --> 00:05:09,756
这个做法很聪明


143
00:05:09,876 --> 00:05:11,716
因为这样就能够


144
00:05:11,716 --> 00:05:12,786
完全避免


145
00:05:12,786 --> 00:05:13,896
我们可能遇到的


146
00:05:13,896 --> 00:05:15,796
性能问题


147
00:05:16,076 --> 00:05:18,976
那么假设我们没有这么做


148
00:05:19,406 --> 00:05:21,886
假设我们像这样创建布局


149
00:05:24,066 --> 00:05:25,216
让我们先大致看一看


150
00:05:25,216 --> 00:05:26,406
再进行分析


151
00:05:26,406 --> 00:05:27,796
首先看一看 这些代码是做什么的


152
00:05:28,826 --> 00:05:31,316
首先我们覆写


153
00:05:31,316 --> 00:05:33,226
UIView 中的 updateConstraints 方法


154
00:05:33,866 --> 00:05:34,976
不管它是做什么的


155
00:05:35,366 --> 00:05:37,426
后面会谈到它


156
00:05:37,916 --> 00:05:42,476
接着 我们有一个成员变量叫 myConstraints


157
00:05:42,716 --> 00:05:45,446
我们提取这个


158
00:05:45,446 --> 00:05:46,436
变量中的所有内容


159
00:05:46,436 --> 00:05:47,836
并停用所有的约束


160
00:05:48,586 --> 00:05:49,516
我们然后创建


161
00:05:49,516 --> 00:05:51,176
约束 这些约束 


162
00:05:51,176 --> 00:05:52,416
实现我们刚刚看到的布局


163
00:05:53,006 --> 00:05:54,106
这非常直白


164
00:05:54,106 --> 00:05:55,546
使用的是视觉格式语言


165
00:05:56,276 --> 00:05:57,276
然后我们执行这些 


166
00:05:57,276 --> 00:05:58,776
约束 安装它们


167
00:05:59,236 --> 00:06:00,296
最后我们调用


168
00:06:00,296 --> 00:06:02,356
super.updateConstraints 


169
00:06:02,356 --> 00:06:04,256
这很重要 因为这个方法


170
00:06:04,586 --> 00:06:08,976
对 UIView 层面的执行很有用


171
00:06:09,166 --> 00:06:10,966
好的 这就是基本的结构 


172
00:06:11,436 --> 00:06:15,306
表明了它的目的 并且确实可用有效果


173
00:06:15,906 --> 00:06:18,676
但是我们接下来


174
00:06:18,676 --> 00:06:20,136
进一步探讨它的运行过程 


175
00:06:20,136 --> 00:06:21,276
让我们更好地了解其性能


176
00:06:22,016 --> 00:06:23,116
那么首先要了解的


177
00:06:23,116 --> 00:06:24,736
就是到底什么是


178
00:06:24,856 --> 00:06:26,906
updateConstraints 即我们正在覆写的方法


179
00:06:28,316 --> 00:06:30,646
它属于渲染循环


180
00:06:31,636 --> 00:06:33,266
渲染循环是一个过程


181
00:06:33,506 --> 00:06:36,476
它每秒钟可用运行高达 120 次


182
00:06:37,216 --> 00:06:38,976
从而确保所有内容


183
00:06:38,976 --> 00:06:40,656
出现在每一帧上


184
00:06:41,656 --> 00:06:43,786
好的 它包含 3 个阶段


185
00:06:43,786 --> 00:06:45,066
分别是更新约束


186
00:06:45,066 --> 00:06:46,386
布局与显示


187
00:06:47,096 --> 00:06:49,246
首先所有需要的视图都会


188
00:06:49,246 --> 00:06:50,916
收到 updateConstraints


189
00:06:51,306 --> 00:06:53,306
然后从最末端的


190
00:06:53,306 --> 00:06:55,096
视图开始 沿着视图层级向上运行


191
00:06:55,096 --> 00:06:55,786
最终到达窗口


192
00:06:56,656 --> 00:06:59,086
接着 每个视图会收到 layoutSubView


193
00:06:59,366 --> 00:07:00,616
它沿着相反方向运行


194
00:07:00,616 --> 00:07:02,516
从窗口向下直到末端


195
00:07:03,176 --> 00:07:05,886
最后 所有视图按需求提取 


196
00:07:05,886 --> 00:07:07,856
差不多就是这样


197
00:07:08,636 --> 00:07:11,166
好的 那么这是为什么呢


198
00:07:11,166 --> 00:07:12,156
它们为什么存在


199
00:07:13,306 --> 00:07:14,736
它们全部具有完全


200
00:07:14,736 --> 00:07:17,016
相同的目的以及完全


201
00:07:17,056 --> 00:07:18,226
平行的方法


202
00:07:18,646 --> 00:07:20,586
这个目的就是防止


203
00:07:20,846 --> 00:07:23,966
工作的浪费 我后面会举例子解释


204
00:07:24,856 --> 00:07:28,516
一个 UI 标签需要


205
00:07:28,516 --> 00:07:30,346
约束来表述


206
00:07:30,576 --> 00:07:33,466
其文本的尺寸 对吗


207
00:07:34,056 --> 00:07:34,986
但是 有很多属性


208
00:07:34,986 --> 00:07:36,126
都与文本尺寸相关


209
00:07:36,406 --> 00:07:37,426
比如有文本本身属性


210
00:07:37,426 --> 00:07:39,936
还有字体 以及


211
00:07:39,936 --> 00:07:41,356
文本尺寸 等等


212
00:07:41,936 --> 00:07:44,946
一种方法是每次这些


213
00:07:44,946 --> 00:07:47,576
属性出现变化时 去重新测量你的文本


214
00:07:48,556 --> 00:07:52,096
但是 那往往效率极低 因为


215
00:07:52,096 --> 00:07:53,766
一般会连续改变多个属性


216
00:07:54,206 --> 00:07:55,076
当你首次设置一个标签时


217
00:07:55,076 --> 00:07:56,176
你可能会


218
00:07:56,176 --> 00:07:57,306
调用一批此类属性设置


219
00:07:57,306 --> 00:07:58,506
那么如果你


220
00:07:58,506 --> 00:07:59,976
每次都重新测量文本


221
00:08:00,506 --> 00:08:01,536
所有的中间环节就被


222
00:08:01,536 --> 00:08:02,856
浪费了 你事实上只想


223
00:08:02,856 --> 00:08:03,516
在完成后进行测量


224
00:08:03,816 --> 00:08:05,316
那么这就是渲染循环为你做的


225
00:08:05,876 --> 00:08:07,656
这样你只需选择


226
00:08:08,086 --> 00:08:10,646
对于设置的字体调用


227
00:08:10,646 --> 00:08:13,206
setNeedsUpdateConstraints


228
00:08:13,336 --> 00:08:14,986
然后你就可以确保


229
00:08:15,176 --> 00:08:17,366
在设置后更新约束


230
00:08:17,436 --> 00:08:18,826
且在这一帧出现在屏幕上之前完成


231
00:08:19,816 --> 00:08:20,456
这就是它的作用


232
00:08:21,486 --> 00:08:22,876
那么有一些事情


233
00:08:22,876 --> 00:08:24,386
需要了解


234
00:08:24,386 --> 00:08:26,176
第一 它运行次数多


235
00:08:26,176 --> 00:08:27,626
每秒钟 120 帧


236
00:08:28,406 --> 00:08:30,346
第二 它们是平行的


237
00:08:30,686 --> 00:08:32,696
因此你也可以用作直觉判断


238
00:08:32,726 --> 00:08:33,866
如果你觉得你理解了


239
00:08:33,866 --> 00:08:35,035
布局部分的运行


240
00:08:35,035 --> 00:08:37,506
或是有了一些感觉 那么你在思考


241
00:08:37,506 --> 00:08:39,256
更新约束或显示时也是一样


242
00:08:40,155 --> 00:08:41,746
最后一件事就是


243
00:08:41,746 --> 00:08:43,756
它存在的原因是


244
00:08:43,756 --> 00:08:45,886
避免工作浪费


245
00:08:45,886 --> 00:08:48,036
延迟工作 甚至有可能跳过工作 完全跳过


246
00:08:49,006 --> 00:08:53,316
好了 看完这些之后


247
00:08:53,316 --> 00:08:54,876
我们现在可以


248
00:08:54,876 --> 00:08:56,156
分析这一方法的其他部分


249
00:08:56,896 --> 00:08:59,476
可以看到 每一次


250
00:08:59,476 --> 00:09:01,076
调用时 我们都停用


251
00:09:01,276 --> 00:09:03,996
一些约束 然后执行一些新的约束


252
00:09:05,406 --> 00:09:07,326
这与 layoutSubViews 类似


253
00:09:07,706 --> 00:09:09,616
假设我们在


254
00:09:09,616 --> 00:09:11,966
layoutSubViews 中写了相同的代码


255
00:09:11,966 --> 00:09:14,076
像是这样


256
00:09:14,476 --> 00:09:16,996
每一次 layoutSubViews


257
00:09:16,996 --> 00:09:18,436
被调用时 你就销毁了之前所有的


258
00:09:18,436 --> 00:09:20,236
子视图 然后从头开始


259
00:09:20,236 --> 00:09:22,346
创建 再添加它们


260
00:09:23,436 --> 00:09:25,596
我相信很多人都会有


261
00:09:25,596 --> 00:09:26,836
非常准确的


262
00:09:26,836 --> 00:09:27,946
直觉判断 认为这可能不会


263
00:09:27,946 --> 00:09:28,726
很好的执行


264
00:09:29,306 --> 00:09:31,916
所以只需要记住的是


265
00:09:31,916 --> 00:09:33,266
它们一样的


266
00:09:33,586 --> 00:09:34,976
不管你对此有什么直觉判断


267
00:09:34,976 --> 00:09:36,436
都可以用在


268
00:09:36,436 --> 00:09:37,756
updateConstraints 上


269
00:09:38,046 --> 00:09:39,216
当你这样停用


270
00:09:39,216 --> 00:09:40,336
各种约束时


271
00:09:40,336 --> 00:09:43,156
其实做了很多无用功 那么如何解决这个问题呢


272
00:09:43,766 --> 00:09:46,076
你需要做的是


273
00:09:46,076 --> 00:09:47,116
正如我们说的 你需要确定 


274
00:09:47,116 --> 00:09:49,286
你不会重复工作


275
00:09:49,506 --> 00:09:50,606
这就是延迟工作


276
00:09:51,566 --> 00:09:53,076
情况应该是这样的


277
00:09:53,076 --> 00:09:55,056
我们询问是否已经做过这个工作了呢


278
00:09:55,636 --> 00:09:57,856
如果做过了 那么就不要再做任何事


279
00:09:57,856 --> 00:09:58,886
如果还没有做过


280
00:09:58,886 --> 00:09:59,976
那么当然要设置这些约束 只做一次


281
00:10:00,046 --> 00:10:03,816
这样就能很好地执行了 对吧


282
00:10:04,176 --> 00:10:05,956
那么 就像之前说的


283
00:10:05,956 --> 00:10:07,916
这实际上是


284
00:10:07,916 --> 00:10:09,636
客户端代码中最常见的错误


285
00:10:09,866 --> 00:10:12,146
我们称之为约束流失


286
00:10:12,846 --> 00:10:14,116
即不必要的删除约束


287
00:10:14,116 --> 00:10:16,036
然后再次添加它们


288
00:10:16,036 --> 00:10:17,326
好的


289
00:10:17,886 --> 00:10:19,396
我们还有很多要做


290
00:10:19,766 --> 00:10:21,196
但是现在先等一下


291
00:10:21,386 --> 00:10:22,676
回顾一下渲染循环


292
00:10:22,676 --> 00:10:23,626
仔细思考


293
00:10:24,296 --> 00:10:26,576
如果你确实需要渲染循环


294
00:10:26,576 --> 00:10:27,696
那它非常好用


295
00:10:27,926 --> 00:10:29,066
它的目的是


296
00:10:29,066 --> 00:10:31,236
有助于避免那些冗余的工作


297
00:10:32,106 --> 00:10:34,386
但它也比较危险 因为


298
00:10:34,616 --> 00:10:35,506
运行次数过多


299
00:10:35,826 --> 00:10:38,036
这个代码非常敏感


300
00:10:38,356 --> 00:10:41,236
所以像这种情况 一般来说你使用


301
00:10:41,236 --> 00:10:43,486
这样敏感的代码时


302
00:10:43,486 --> 00:10:44,336
你应该在写代码时


303
00:10:44,336 --> 00:10:45,196
小心谨慎 同时也应该


304
00:10:45,196 --> 00:10:46,956
试图减少


305
00:10:46,956 --> 00:10:48,216
写此类敏感代码的次数
 
00:10:48,616 --> 00:10:50,636
因为你有可能会


306
00:10:50,636 --> 00:10:51,846
把事情搞砸


307
00:10:52,166 --> 00:10:53,426
我们都有搞砸的时候


308
00:10:53,426 --> 00:10:55,096
所以在这种情况下


309
00:10:55,096 --> 00:10:55,986
你真的应该考虑


310
00:10:55,986 --> 00:10:57,716
我是否可以只做一次


311
00:10:57,716 --> 00:10:59,956
而非把它放入


312
00:11:00,346 --> 00:11:01,256
updateConstraints 中 完成这个工作的好办法


313
00:11:01,326 --> 00:11:03,936
就是使用 Interface Builder


314
00:11:04,286 --> 00:11:05,796
如果你可以使用 Interface Builder


315
00:11:06,026 --> 00:11:06,506
你就应该使用它


316
00:11:07,496 --> 00:11:08,946
它的好处体现在方方面面


317
00:11:08,946 --> 00:11:11,276
可以让你走上正确的路径


318
00:11:11,466 --> 00:11:13,206
好的 很好


319
00:11:13,346 --> 00:11:14,876
既然我们现在已经讨论过了


320
00:11:14,876 --> 00:11:15,856
我认为 我们已经更好地理解了


321
00:11:15,856 --> 00:11:17,286
为什么这是有问题的


322
00:11:17,286 --> 00:11:20,266
至少是通过类比


323
00:11:21,336 --> 00:11:22,486
但是这个演讲的目的


324
00:11:22,486 --> 00:11:23,846
要求我们做的比这更好


325
00:11:23,846 --> 00:11:26,336
我们并不只想说这样不好


326
00:11:26,536 --> 00:11:28,376
我们希望真正的理解它


327
00:11:28,376 --> 00:11:29,666
真正地理解这个过程


328
00:11:30,366 --> 00:11:32,956
为此我们需要


329
00:11:33,016 --> 00:11:34,816
拨开表面


330
00:11:34,816 --> 00:11:36,976
看到真正发生了什么事情


331
00:11:37,546 --> 00:11:43,096
那么当我们启用约束 添加约束时


332
00:11:43,096 --> 00:11:45,626
这个过程是什么样的呢


333
00:11:46,916 --> 00:11:48,276
我们以图表的形式进行直观阐述


334
00:11:48,626 --> 00:11:50,856
假设这是一个视图


335
00:11:50,856 --> 00:11:51,946
我们想在其中添加约束


336
00:11:53,056 --> 00:11:55,596
这个视图在一个窗口中


337
00:11:55,726 --> 00:11:57,406
窗口挂着


338
00:11:57,406 --> 00:12:00,086
一个内部对象叫做引擎


339
00:12:00,516 --> 00:12:03,296
引擎是 Auto Layout 的计算内核


340
00:12:03,816 --> 00:12:06,246
在添加约束后


341
00:12:06,576 --> 00:12:10,336
我们要创建


342
00:12:10,336 --> 00:12:12,146
一个与约束对应的等式


343
00:12:12,146 --> 00:12:13,616
然后我们将


344
00:12:13,616 --> 00:12:15,846
该等式添加到引擎中


345
00:12:16,516 --> 00:12:18,306
这个图表中最后一个


346
00:12:18,306 --> 00:12:19,906
需要理解的问题是该等式


347
00:12:20,186 --> 00:12:22,996
是关于变量的


348
00:12:22,996 --> 00:12:24,526
而变量 举个例子


349
00:12:24,526 --> 00:12:25,936
假设我给你一个等式 然后我说


350
00:12:25,936 --> 00:12:28,336
解出 X 那么 X 就是变量


351
00:12:29,396 --> 00:12:30,666
在这个情况下我们


352
00:12:30,666 --> 00:12:33,326
需要解决的就是


353
00:12:33,326 --> 00:12:34,746
视图的帧数据


354
00:12:35,166 --> 00:12:36,356
对于每一个视图


355
00:12:36,356 --> 00:12:37,916
将会有 4 个变量 分别是


356
00:12:37,916 --> 00:12:40,906
X 轴坐标 Y轴坐标 宽度和高度


357
00:12:41,126 --> 00:12:43,956
好的 那么让我们进入这一过程


358
00:12:44,276 --> 00:12:45,906
这是我们将要创建的布局


359
00:12:45,906 --> 00:12:46,976
简单起见我们仅关注


360
00:12:46,976 --> 00:12:48,166
横向约束


361
00:12:48,166 --> 00:12:49,386
但是我们会


362
00:12:49,386 --> 00:12:50,486
考虑整个过程


363
00:12:51,356 --> 00:12:52,496
那么第一件事


364
00:12:52,636 --> 00:12:53,996
如我们刚才所说 就是我们


365
00:12:53,996 --> 00:12:55,536
创建等式 看起来是这样子的


366
00:12:57,156 --> 00:12:58,366
这些看起来非常直观


367
00:12:58,676 --> 00:13:00,656
我认为最有趣的是


368
00:13:00,656 --> 00:13:01,936
两个文本框之间的空间


369
00:13:01,936 --> 00:13:03,896
它看起来像是


370
00:13:03,896 --> 00:13:05,366
看起来非常


371
00:13:05,366 --> 00:13:07,656
近似于你写的


372
00:13:07,656 --> 00:13:08,896
约束 但它相对是


373
00:13:08,896 --> 00:13:10,416
更低层级的 因为它是


374
00:13:10,416 --> 00:13:11,756
关于这些变量的


375
00:13:13,376 --> 00:13:16,806
好的 然后每个等式


376
00:13:16,806 --> 00:13:18,336
都需要被添加到引擎


377
00:13:18,336 --> 00:13:20,546
事实上我们将会


378
00:13:20,546 --> 00:13:22,596
再次研究这一过程


379
00:13:22,596 --> 00:13:24,006
目标是对于


380
00:13:24,006 --> 00:13:27,386
性能特点有一个更好的把握


381
00:13:27,746 --> 00:13:28,846
那么 当我们这么写时发生了什么?


382
00:13:29,856 --> 00:13:31,856
引擎试图解出


383
00:13:31,856 --> 00:13:33,806
这些变量


384
00:13:33,806 --> 00:13:36,086
这跟你在代数中学到的很像


385
00:13:36,086 --> 00:13:38,936
看起来也完全相同


386
00:13:38,936 --> 00:13:40,106
那么我们一起来看


387
00:13:40,386 --> 00:13:42,166
首先是第一个等式


388
00:13:42,166 --> 00:13:44,146
表明第一个区域的 X 轴坐标是 8


389
00:13:44,486 --> 00:13:47,846
好的 它的宽度为 100 好


390
00:13:48,436 --> 00:13:50,696
好的 这个等式中我们定义


391
00:13:50,696 --> 00:13:52,106
定义第二个区域的 X 轴坐标


392
00:13:52,106 --> 00:13:53,556
等于第一个 X 坐标加上


393
00:13:53,556 --> 00:13:54,406
该宽度再加 20


394
00:13:54,406 --> 00:13:57,096
在代数中你会怎么做


395
00:13:57,096 --> 00:13:59,666
如果有人要求你解出这些变量


396
00:14:00,956 --> 00:14:02,836
你会用已知的


397
00:14:02,836 --> 00:14:03,996
数据来进行替换


398
00:14:04,146 --> 00:14:05,646
这就是接下来即将发生的事情


399
00:14:06,636 --> 00:14:08,486
如果你进行程序剖析


400
00:14:08,486 --> 00:14:10,356
会看到 引擎中确实有一个方法


401
00:14:10,356 --> 00:14:12,186
包含替换这个词


402
00:14:12,186 --> 00:14:13,986
同时还包含了其他的


403
00:14:13,986 --> 00:14:16,956
140 个字符 因为我们是


404
00:14:16,956 --> 00:14:18,776
Cocoa 编程开发者


405
00:14:18,776 --> 00:14:21,716
这就是引擎将要做的


406
00:14:22,266 --> 00:14:23,726
然后 你知道 最后一个


407
00:14:23,726 --> 00:14:26,726
等式进入后 看起来就完成了


408
00:14:27,126 --> 00:14:29,106
看上去这就是全部的


409
00:14:29,106 --> 00:14:30,636
工作 至少针对


410
00:14:30,636 --> 00:14:32,656
这个案例 就可以解出


411
00:14:32,656 --> 00:14:34,466
全部变量 确实如此


412
00:14:35,006 --> 00:14:36,646
这就是我此时要了解的


413
00:14:36,646 --> 00:14:39,856
那就是这些工作


414
00:14:39,856 --> 00:14:40,546
并不复杂


415
00:14:41,046 --> 00:14:42,856
它的过程


416
00:14:42,856 --> 00:14:43,956
和手工计算


417
00:14:43,956 --> 00:14:46,566
非常非常近似


418
00:14:46,566 --> 00:14:47,916
同时 它也并不是高消耗


419
00:14:48,266 --> 00:14:50,296
它只不过是完成替换 就像这样


420
00:14:50,536 --> 00:14:51,626
这就是它所做的工作


421
00:14:52,626 --> 00:14:54,976
好的 那么现在我们已经


422
00:14:55,326 --> 00:14:56,686
在引擎中解出了这些变量


423
00:14:56,686 --> 00:14:57,936
但是这并不是一个布局


424
00:14:58,386 --> 00:15:00,716
下面让我们完成这个过程


425
00:15:02,036 --> 00:15:03,106
接下来的过程中


426
00:15:03,106 --> 00:15:06,506
每当引擎将一个值赋给


427
00:15:06,506 --> 00:15:07,816
其中一个变量


428
00:15:07,816 --> 00:15:09,746
它都会告知视图


429
00:15:09,746 --> 00:15:11,246
变量从何而来 并告知


430
00:15:11,246 --> 00:15:12,036
它已发生变化


431
00:15:12,496 --> 00:15:15,406
那么视图会做什么作为回应呢


432
00:15:16,526 --> 00:15:17,556
如果你想一想


433
00:15:17,556 --> 00:15:20,956
它会调用上级视图


434
00:15:20,956 --> 00:15:23,816
并使用 setNeedsLayout 因为需要发生变动


435
00:15:25,226 --> 00:15:27,196
好的 这就是


436
00:15:27,226 --> 00:15:30,216
更新约束阶段的全部内容


437
00:15:31,136 --> 00:15:32,106
现在我们已经收到了


438
00:15:32,106 --> 00:15:33,716
setNeedsLayout 在某个时间点


439
00:15:33,716 --> 00:15:35,536
就会进入布局阶段


440
00:15:36,696 --> 00:15:39,846
好的 最后一块拼图


441
00:15:39,846 --> 00:15:40,846
就是我们将会收到


442
00:15:40,846 --> 00:15:42,236
UIView 将会收到


443
00:15:42,236 --> 00:15:45,776
layoutSubViews 而它要做的就是


444
00:15:45,776 --> 00:15:47,816
把这部分数据


445
00:15:47,816 --> 00:15:49,096
从引擎中复制到帧


446
00:15:50,336 --> 00:15:52,356
那么它会询问引擎


447
00:15:52,356 --> 00:15:53,956
那些变量的值是多少


448
00:15:54,446 --> 00:15:56,676
引擎将会告知它 该上级视图


449
00:15:56,676 --> 00:15:58,746
就会在下级视图中


450
00:15:58,746 --> 00:16:02,076
调用 setCenter 和 setBounds


451
00:16:03,306 --> 00:16:04,606
这就是全部过程


452
00:16:06,146 --> 00:16:07,686
那么 我们回顾一下


453
00:16:07,686 --> 00:16:09,976
想一想这就是逐步创建布局的过程


454
00:16:10,206 --> 00:16:12,716
如果你能够尝试吸收它


455
00:16:12,716 --> 00:16:13,906
并找到感觉


456
00:16:14,166 --> 00:16:17,066
你将会对性能期望


457
00:16:17,066 --> 00:16:19,586
有更好地理解


458
00:16:20,486 --> 00:16:21,896
事实上 让我们看看


459
00:16:21,896 --> 00:16:23,676
现在是什么情况 因为现在


460
00:16:24,196 --> 00:16:26,886
当我们看到这里 看着这个方法


461
00:16:26,886 --> 00:16:29,506
也就是我们停用约束


462
00:16:29,506 --> 00:16:30,736
以及重新启用约束的地方


463
00:16:31,106 --> 00:16:32,346
回想一下我们刚才所做的


464
00:16:32,346 --> 00:16:33,656
想一想引擎


465
00:16:33,656 --> 00:16:34,206
将会怎么做


466
00:16:35,596 --> 00:16:36,626
它看起来将是这样


467
00:16:40,426 --> 00:16:42,136
我们称之为流失


468
00:16:42,556 --> 00:16:45,226
它的每一次运行


469
00:16:45,226 --> 00:16:47,246
并不是特别的高消耗 但是它


470
00:16:47,246 --> 00:16:49,576
运行的次数很多


471
00:16:49,576 --> 00:16:51,086
而这是完全不必要的


472
00:16:51,086 --> 00:16:52,196
这部分工作被浪费了


473
00:16:52,726 --> 00:16:54,456
那么如果你可以在心里感觉到


474
00:16:54,456 --> 00:16:56,336
如果你可以真正感觉到


475
00:16:56,406 --> 00:16:57,636
当你这么做时 发生的事情


476
00:16:58,046 --> 00:17:00,046
那么你就能够处于一个很好的状态


477
00:17:00,356 --> 00:17:02,046
那么你就会


478
00:17:02,046 --> 00:17:03,036
与接下来我们


479
00:17:03,036 --> 00:17:05,056
要做的处于同一水准


480
00:17:05,056 --> 00:17:05,715
并对此具备一个良好的把握


481
00:17:06,636 --> 00:17:08,935
好的 我希望目前一切都好


482
00:17:08,935 --> 00:17:14,246
我们还有另外一个大话题


483
00:17:14,246 --> 00:17:15,236
希望探讨


484
00:17:15,236 --> 00:17:16,256
如果想要获得一个


485
00:17:16,256 --> 00:17:18,356
较好的性能模型 我们的想法是


486
00:17:18,356 --> 00:17:20,766
你只为你使用的内容消耗性能


487
00:17:20,766 --> 00:17:21,965
这在 Auto Layout 中可以做到


488
00:17:22,086 --> 00:17:23,056
当看过这些以后我认为


489
00:17:23,056 --> 00:17:26,665
我们已经能够理解其中的含义 对吗


490
00:17:26,665 --> 00:17:28,346
为此 我们假设


491
00:17:28,346 --> 00:17:29,476
目前的情况是之前的两倍


492
00:17:29,476 --> 00:17:31,346
那么我们有四个文本框


493
00:17:31,346 --> 00:17:33,076
分别在两个互相独立的层级中


494
00:17:34,496 --> 00:17:36,886
现在你可以做的是


495
00:17:36,886 --> 00:17:38,426
创建一个约束


496
00:17:38,426 --> 00:17:40,606
令其像这样跨越层级


497
00:17:40,976 --> 00:17:42,866
那么你可以说


498
00:17:42,866 --> 00:17:44,286
1 号文本框应该与


499
00:17:44,286 --> 00:17:45,316
3 号文本框对齐


500
00:17:45,316 --> 00:17:46,656
尽管它们的上级视图并不相同


501
00:17:48,186 --> 00:17:50,956
我认为 有时候人们会有


502
00:17:50,956 --> 00:17:52,486
一个印象 就是因为这是


503
00:17:52,516 --> 00:17:54,526
可能完成的 就意味着它会


504
00:17:54,526 --> 00:17:56,606
运行的较为缓慢


505
00:17:56,606 --> 00:17:58,226
因为各个部分可能


506
00:17:58,226 --> 00:17:59,646
随时相互影响


507
00:17:59,646 --> 00:18:00,746
就像一团浆糊


508
00:18:00,746 --> 00:18:04,296
而性能可能很糟糕


509
00:18:05,056 --> 00:18:07,306
好的 但我们了解过


510
00:18:07,306 --> 00:18:08,936
刚才的内容后 再一起来看看


511
00:18:08,936 --> 00:18:11,086
在普通情况下


512
00:18:11,086 --> 00:18:13,136
不会进行这种操作 因为大部分时间


513
00:18:13,136 --> 00:18:14,006
都没有必要


514
00:18:14,506 --> 00:18:16,476
大多数情况下


515
00:18:16,476 --> 00:18:17,906
视图仅受到上级视图或


516
00:18:17,906 --> 00:18:18,916
同级视图的约束


517
00:18:19,736 --> 00:18:23,026
你看到由于我们有两个


518
00:18:23,026 --> 00:18:25,586
互相独立的区块


519
00:18:25,586 --> 00:18:27,036
引擎内部


520
00:18:27,036 --> 00:18:28,366
将会有两个


521
00:18:28,366 --> 00:18:29,926
互相独立的等式块


522
00:18:29,926 --> 00:18:31,206
它们完全不与


523
00:18:31,206 --> 00:18:32,366
对方互动 也不具有任何


524
00:18:32,366 --> 00:18:33,636
互相重合的变量


525
00:18:34,146 --> 00:18:36,776
这样一来


526
00:18:36,776 --> 00:18:38,186
由于它们完全不会


527
00:18:38,186 --> 00:18:39,596
重合 就不会发生互动


528
00:18:39,996 --> 00:18:41,296
如果我们只有一个等式快


529
00:18:41,296 --> 00:18:43,966
就需要花一些时间来进行处理


530
00:18:44,246 --> 00:18:45,536
如果我们有两个这样的等式块


531
00:18:45,536 --> 00:18:47,256
就需要花费两倍的时间


532
00:18:47,556 --> 00:18:48,486
因为它们之间并没有任何关系


533
00:18:49,246 --> 00:18:50,316
如果有三个 就是三倍时间


534
00:18:50,546 --> 00:18:52,566
以此类推 问题在于你


535
00:18:52,626 --> 00:18:54,366
将会看到线性关系


536
00:18:54,366 --> 00:18:56,836
你将会看到线性的


537
00:18:56,836 --> 00:18:58,026
性能 这已经是你可以


538
00:18:58,026 --> 00:18:59,016
得到的最优结果


539
00:18:59,276 --> 00:19:01,106
已经是最好的情况了


540
00:19:01,246 --> 00:19:03,816
我想要再次强调一下


541
00:19:03,816 --> 00:19:05,496
之所以它是线性的


542
00:19:05,496 --> 00:19:06,306
是因为它们之间


543
00:19:06,306 --> 00:19:07,886
不存在任何互相依赖性


544
00:19:08,516 --> 00:19:09,596
如果它们之间存在互相依赖性


545
00:19:10,066 --> 00:19:11,846
那么这些等式块


546
00:19:11,846 --> 00:19:14,106
将会被连在一起


547
00:19:14,106 --> 00:19:15,996
将会有更多的


548
00:19:15,996 --> 00:19:18,096
计算需要处理


549
00:19:18,566 --> 00:19:19,876
但也只是使用的时候


550
00:19:20,396 --> 00:19:22,236
当然如果你确实有这样的情况 你知道


551
00:19:22,236 --> 00:19:23,446
如果你手动处理


552
00:19:23,446 --> 00:19:24,246
当然它会比较


553
00:19:24,246 --> 00:19:25,396
消耗性能


554
00:19:25,396 --> 00:19:27,446
你也能想到 因为这件事情更为复杂


555
00:19:27,546 --> 00:19:29,626
这样常见的情况


556
00:19:29,626 --> 00:19:31,456
是我们在 Cocoa 中的目标


557
00:19:31,456 --> 00:19:32,626
即让简单的事情


558
00:19:32,626 --> 00:19:34,976
保持简单 让复杂的事情成为可能


559
00:19:35,306 --> 00:19:36,476
在这一情况下 它们可能


560
00:19:36,476 --> 00:19:37,176
性能消耗会高一点


561
00:19:37,596 --> 00:19:38,986
但是你不必为此消耗性能


562
00:19:38,986 --> 00:19:41,296
如果你不使用的话


563
00:19:41,296 --> 00:19:44,716
事实上 用直觉理解整个引擎的


564
00:19:44,716 --> 00:19:46,726
正确方法就是 你可以把它


565
00:19:46,726 --> 00:19:49,206
想作一个布局的缓存


566
00:19:49,206 --> 00:19:50,446
和一个依赖关系追踪器


567
00:19:51,296 --> 00:19:52,736
它非常有针对性


568
00:19:52,776 --> 00:19:54,396
它了解哪些约束


569
00:19:54,396 --> 00:19:55,896
会影响哪些视图 而当你


570
00:19:55,896 --> 00:19:58,346
做出改变时 它只会更新


571
00:19:58,346 --> 00:19:59,866
需要改变的内容


572
00:20:00,396 --> 00:20:02,976
这对于你写代码也有启发


573
00:20:04,696 --> 00:20:07,306
有时候我们看到的一个问题是


574
00:20:07,306 --> 00:20:08,886
有一些人会


575
00:20:08,886 --> 00:20:11,236
费很大劲去避免创建


576
00:20:11,236 --> 00:20:13,686
约束 因为他们


577
00:20:13,686 --> 00:20:15,546
认为这样性能消耗太高


578
00:20:16,476 --> 00:20:18,296
然而 事实上约束很有针对性


579
00:20:18,526 --> 00:20:19,736
只要你创建的


580
00:20:19,736 --> 00:20:21,866
约束能够有效对应


581
00:20:21,866 --> 00:20:22,746
你正在解决的问题


582
00:20:22,746 --> 00:20:24,456
那么 就不太可能发生


583
00:20:24,456 --> 00:20:25,556
更好的情况


584
00:20:25,556 --> 00:20:26,646
如果你试图去回避问题


585
00:20:26,646 --> 00:20:27,636
也不会有更好的性能情况


586
00:20:28,126 --> 00:20:29,796
我们经常看到有些人


587
00:20:29,796 --> 00:20:31,036
进行非常复杂的测量


588
00:20:31,036 --> 00:20:33,006
把问题复杂化


589
00:20:33,006 --> 00:20:34,406
然后试图


590
00:20:34,406 --> 00:20:35,756
获取信息 然后再


591
00:20:35,756 --> 00:20:37,496
返回信息 这样往往


592
00:20:37,496 --> 00:20:38,986
消耗更多 相对


593
00:20:38,986 --> 00:20:40,126
直接表达一个


594
00:20:40,126 --> 00:20:41,296
你所需要的约束而言


595
00:20:42,606 --> 00:20:45,456
这个问题的反面是


596
00:20:45,456 --> 00:20:47,286
有时候我们会看到


597
00:20:47,716 --> 00:20:49,366
像这样的层级


598
00:20:49,526 --> 00:20:51,006
在这样的层级中我们看到


599
00:20:51,006 --> 00:20:52,356
非常多的约束


600
00:20:52,356 --> 00:20:54,456
以及非常多的优先级 以至于


601
00:20:54,456 --> 00:20:56,176
过程很不清晰


602
00:20:56,176 --> 00:20:58,146
通常这种情况


603
00:20:58,146 --> 00:21:00,466
表示事实上


604
00:21:00,466 --> 00:21:01,816
情况可能是


605
00:21:01,816 --> 00:21:03,426
这个人心里有两个完全


606
00:21:03,426 --> 00:21:04,896
独立的布局


607
00:21:05,346 --> 00:21:07,406
而试图把它们


608
00:21:07,406 --> 00:21:09,196
打包到一套


609
00:21:09,196 --> 00:21:11,286
约束中 然后一次性解决问题


610
00:21:11,836 --> 00:21:13,906
这也不是一个好主意


611
00:21:14,276 --> 00:21:17,056
那将会产生


612
00:21:17,056 --> 00:21:18,316
许多虚假的依赖关系


613
00:21:18,616 --> 00:21:19,776
它们看起来是


614
00:21:19,776 --> 00:21:20,846
互动的 但事实上


615
00:21:20,846 --> 00:21:21,196
并非如此


616
00:21:21,586 --> 00:21:22,786
而且几乎没办法


617
00:21:22,786 --> 00:21:25,506
进行调试 如果你不注意的话


618
00:21:26,186 --> 00:21:30,406
那么我的总体建议是


619
00:21:30,406 --> 00:21:32,516
试图以最直接的方式对问题建模


620
00:21:32,766 --> 00:21:33,826
Kasia 将会带大家


621
00:21:33,826 --> 00:21:34,786
探讨这类在


622
00:21:34,786 --> 00:21:35,736
不同的布局间切换的例子


623
00:21:35,736 --> 00:21:37,396
并且展示的更为明确


624
00:21:38,186 --> 00:21:40,106
但是这只是一般性建议


625
00:21:40,346 --> 00:21:41,886
你需要自然地使用它


626
00:21:42,036 --> 00:21:43,276
这对于性能


627
00:21:43,606 --> 00:21:45,176
和理解都有好处


628
00:21:45,736 --> 00:21:50,926
好的 这就是我们今天要说的大部分内容


629
00:21:51,186 --> 00:21:52,526
但是由于我们想要建立


630
00:21:52,526 --> 00:21:54,276
一个总体的关于


631
00:21:54,276 --> 00:21:55,336
布局性能特点的心理模型


632
00:21:55,336 --> 00:21:57,146
我希望至少确保


633
00:21:57,146 --> 00:21:59,636
我们谈到了全部主要特征


634
00:21:59,856 --> 00:22:01,546
你还有很多其他的事情可以做


635
00:22:02,676 --> 00:22:04,046
我们讨论一下


636
00:22:04,626 --> 00:22:05,946
那么你可以定义一些


637
00:22:05,946 --> 00:22:07,186
特定的视图


638
00:22:07,186 --> 00:22:08,346
宽度至少为 100


639
00:22:08,466 --> 00:22:09,366
你可以使用不等式


640
00:22:10,106 --> 00:22:10,806
这样做的消耗如何


641
00:22:11,736 --> 00:22:12,816
非常非常低


642
00:22:13,006 --> 00:22:13,876
与仅仅定义


643
00:22:13,876 --> 00:22:15,736
宽度等于 100 相比


644
00:22:15,736 --> 00:22:17,346
由于我们已经对内部问题略有探讨


645
00:22:17,656 --> 00:22:20,636
它的消耗仅仅是多一个变量 仅此而已


646
00:22:21,156 --> 00:22:23,936
你也可以调用设置常量功能


647
00:22:24,436 --> 00:22:26,066
对这个问题的用例


648
00:22:26,066 --> 00:22:27,926
就如同我有一个


649
00:22:27,926 --> 00:22:29,206
手势辨认器 而我


650
00:22:29,266 --> 00:22:31,396
试图将一个视图四处拖拽


651
00:22:31,396 --> 00:22:32,676
要做的是


652
00:22:32,676 --> 00:22:34,976
每一次我从手势辨识器


653
00:22:34,976 --> 00:22:36,196
获得信号时


654
00:22:36,196 --> 00:22:38,416
我会使用它的翻译结果


655
00:22:38,416 --> 00:22:39,296
并将其输入一个


656
00:22:39,296 --> 00:22:41,006
约束 通过为


657
00:22:41,006 --> 00:22:43,866
该约束设置常量的方式


658
00:22:44,626 --> 00:22:45,896
输入翻译值


659
00:22:46,616 --> 00:22:48,966
好的 它接下来要做的是


660
00:22:48,966 --> 00:22:50,616
我们刚才讨论过的引擎如何充当


661
00:22:50,616 --> 00:22:51,786
一个依赖关系追踪器


662
00:22:52,346 --> 00:22:53,976
它将这一点发挥到了


663
00:22:53,976 --> 00:22:55,016
最大水平


664
00:22:55,656 --> 00:22:58,016
这是一个


665
00:22:58,016 --> 00:23:00,266
非常快速的一步更新


666
00:23:00,266 --> 00:23:02,426
由于约束的改变


667
00:23:02,696 --> 00:23:04,106
而改变需要更改的内容


668
00:23:04,916 --> 00:23:06,606
这是一种性能优化


669
00:23:06,606 --> 00:23:07,936
这就是为什么我们要用这么一个


670
00:23:07,936 --> 00:23:08,936
设置常量的方法


671
00:23:09,476 --> 00:23:11,526
最后要讨论的是它的优先级


672
00:23:12,436 --> 00:23:14,536
因此这里你可以定义


673
00:23:14,536 --> 00:23:16,266
你可以定义这个视图


674
00:23:16,266 --> 00:23:18,676
最好宽度为 100 但是


675
00:23:18,876 --> 00:23:20,046
如果达不到


676
00:23:20,046 --> 00:23:22,236
就尽量靠近这个数值


677
00:23:22,956 --> 00:23:24,636
这确实会导致更多的工作


678
00:23:25,326 --> 00:23:26,196
一定量的工作发生


679
00:23:26,196 --> 00:23:28,306
那么让我们进一步讨论一下


680
00:23:28,576 --> 00:23:29,866
另一个考虑的角度


681
00:23:30,206 --> 00:23:31,626
是定义该文本框的宽度


682
00:23:31,626 --> 00:23:35,666
等于 100 加一些误差 并且


683
00:23:35,666 --> 00:23:36,716
最小化该误差


684
00:23:37,436 --> 00:23:38,496
这就是你们想要的部分


685
00:23:39,776 --> 00:23:41,266
因此这里有一个误差


686
00:23:41,266 --> 00:23:42,536
最小化的阶段 我之前


687
00:23:42,536 --> 00:23:43,156
没有讨论过


688
00:23:43,366 --> 00:23:46,816
当视图询问引擎


689
00:23:46,816 --> 00:23:48,086
作为布局子视图的一部分


690
00:23:48,086 --> 00:23:50,446
“这些变量的值是多少?”


691
00:23:50,686 --> 00:23:51,866
引擎需要确保


692
00:23:51,866 --> 00:23:53,366
所有误差值


693
00:23:53,366 --> 00:23:54,626
已经完成最小化


694
00:23:55,386 --> 00:23:58,546
实际上我不会探讨具体


695
00:23:58,546 --> 00:24:00,726
是如何工作的 但我会稍微讨论一下


696
00:24:00,726 --> 00:24:02,006
性能特点


697
00:24:02,056 --> 00:24:03,586
我会说的简洁明了


698
00:24:04,536 --> 00:24:06,746
因此你或许想要


699
00:24:06,746 --> 00:24:07,196
看看这个


700
00:24:07,196 --> 00:24:08,476
这是简单的 X 算法


701
00:24:08,476 --> 00:24:09,526
这是实际的事


702
00:24:09,866 --> 00:24:11,206
非常古老


703
00:24:11,676 --> 00:24:13,186
是第二次世界大战期间开发的


704
00:24:13,576 --> 00:24:17,246
甚至早于电脑的出现


705
00:24:17,416 --> 00:24:19,026
事实上 过去有一些人


706
00:24:19,026 --> 00:24:20,356
被称为电脑


707
00:24:20,356 --> 00:24:21,156
就在机器被称为电脑之前


708
00:24:21,156 --> 00:24:23,016
这就是他们所做的事情


709
00:24:23,486 --> 00:24:25,706
他们手动完成计算


710
00:24:25,856 --> 00:24:27,146
这会给你一些关于


711
00:24:27,146 --> 00:24:28,076
性能特点的感觉


712
00:24:28,316 --> 00:24:29,566
如果你手动计算


713
00:24:29,566 --> 00:24:30,816
应该非常快 而且它确实是


714
00:24:31,126 --> 00:24:33,336
这与我们刚才做的事情


715
00:24:33,336 --> 00:24:34,106
几乎是相同的


716
00:24:34,166 --> 00:24:35,326
更多的是替换过程


717
00:24:35,726 --> 00:24:37,066
这就是你进行思考的方式


718
00:24:38,266 --> 00:24:39,676
不管怎么说 你知道


719
00:24:39,676 --> 00:24:40,986
当你使用优先级时


720
00:24:40,986 --> 00:24:42,116
它确实会产生这么多性能消耗


721
00:24:42,256 --> 00:24:43,146
这一点需要注意


722
00:24:44,226 --> 00:24:46,216
好的 除此之外 它与之前相同


723
00:24:46,616 --> 00:24:50,546
这就是我想说的内容


724
00:24:50,756 --> 00:24:52,556
这就是我们试图建立


725
00:24:52,556 --> 00:24:54,836
这种直观的


726
00:24:54,836 --> 00:24:56,086
对于 Auto Layout 的


727
00:24:56,086 --> 00:24:58,046
性能特点的理解


728
00:24:58,176 --> 00:24:59,746
快速地回顾一下我们刚才讨论的内容


729
00:25:00,226 --> 00:25:01,766
不要使你的约束流失


730
00:25:02,316 --> 00:25:03,036
这在你完成


731
00:25:03,036 --> 00:25:04,826
无意义工作时会发生


732
00:25:05,116 --> 00:25:05,686
因此不要这么做


733
00:25:06,326 --> 00:25:09,876
当你处理约束时 它实际上是基础代数


734
00:25:10,176 --> 00:25:11,566
而这种代数也发生在


735
00:25:11,566 --> 00:25:12,706
你添加约束


736
00:25:12,706 --> 00:25:14,586
移除约束


737
00:25:14,586 --> 00:25:16,706
以及调用设置常量功能时


738
00:25:16,706 --> 00:25:17,466
以上是主要情况


739
00:25:17,956 --> 00:25:20,956
还有 你知道 当我们


740
00:25:20,956 --> 00:25:22,866
处于误差最小化阶段时 也是代数问题


741
00:25:23,436 --> 00:25:26,916
理解 Auto Layout 的工作原理的方法是


742
00:25:26,916 --> 00:25:28,546
把它想做是一个


743
00:25:28,546 --> 00:25:29,806
布局缓存


744
00:25:29,806 --> 00:25:31,226
可以看到引擎包含所有


745
00:25:31,226 --> 00:25:33,016
已解出的值 并且它是一个


746
00:25:33,016 --> 00:25:34,766
依赖关系追踪器 因此当


747
00:25:34,766 --> 00:25:36,916
数据发生改变时我们可以


748
00:25:37,066 --> 00:25:39,296
以一个非常有针对性的方法 更新那些值


749
00:25:39,896 --> 00:25:41,016
这引出了我们最后一个点


750
00:25:41,186 --> 00:25:43,236
那就是你只为


751
00:25:43,236 --> 00:25:44,216
你在使用的功能消耗性能


752
00:25:45,266 --> 00:25:46,916
这就是我们所谈到的内容


753
00:25:47,276 --> 00:25:48,566
你知道 这就是你的直觉判断


754
00:25:48,956 --> 00:25:53,376
接下来的部分我将会交给 Kasia


755
00:25:53,376 --> 00:25:54,556
因为 再次强调 如果你


756
00:25:54,556 --> 00:25:56,586
只是依赖于直觉判断 是无法完成布局的


757
00:25:56,866 --> 00:25:58,336
所以她将会进行


758
00:25:58,336 --> 00:25:59,946
一些分析


759
00:25:59,946 --> 00:26:01,286
避免我们刚才讨论的问题 并把直觉判断


760
00:26:01,286 --> 00:26:02,006
用于实践中


761
00:26:02,336 --> 00:26:03,926
欢迎她


762
00:26:04,516 --> 00:26:11,546
[ 掌声 ]


763
00:26:12,046 --> 00:26:13,096
>> 好的 请让我开始我的部分


764
00:26:14,056 --> 00:26:15,696
谢谢 Ken 大家好


765
00:26:15,956 --> 00:26:17,246
我的名字是 Kasia Wawer


766
00:26:17,796 --> 00:26:20,886
我是 iOS 键盘组的成员 我们使用


767
00:26:20,886 --> 00:26:22,106
Auto Layout 也很喜欢它


768
00:26:22,646 --> 00:26:24,006
所以接下来我想与大家讨论


769
00:26:24,006 --> 00:26:25,206
如何创建有效的布局


770
00:26:26,286 --> 00:26:27,056
好的 让我们快速


771
00:26:27,056 --> 00:26:28,586
回顾一下约束流失问题


772
00:26:29,116 --> 00:26:30,396
正如刚才听到的 约束流失


773
00:26:30,396 --> 00:26:31,876
发生在你改变你的


774
00:26:31,876 --> 00:26:33,726
约束 但是实际视图


775
00:26:33,726 --> 00:26:35,396
并不需要变动时 因此你


776
00:26:35,396 --> 00:26:36,816
向引擎发送了过多工作


777
00:26:37,276 --> 00:26:38,456
而且可能会影响到


778
00:26:38,456 --> 00:26:39,106
你的性能表现


779
00:26:39,106 --> 00:26:40,776
所以你希望避免这种情况


780
00:26:41,636 --> 00:26:43,646
那么让我们探讨一下你什么时候


781
00:26:43,646 --> 00:26:45,746
可能遇到这一问题


782
00:26:45,746 --> 00:26:46,556
以及如何解决它


783
00:26:46,556 --> 00:26:49,056
因此我们将以一个规格说明为例


784
00:26:49,286 --> 00:26:50,866
这是一个社交网络 App 使用的规格说明


785
00:26:51,586 --> 00:26:52,526
有一个头像视图


786
00:26:52,526 --> 00:26:53,566
可以显示谁在分享


787
00:26:53,566 --> 00:26:56,336
有一个标题 一个日期


788
00:26:56,336 --> 00:26:59,206
以及一个日志输入界面


789
00:26:59,206 --> 00:27:00,186
你需要设置一些间隔


790
00:27:00,186 --> 00:27:01,606
可能需要


791
00:27:01,606 --> 00:27:04,516
规定一些尺寸 你也有可能会用到对齐


792
00:27:05,566 --> 00:27:08,036
而事实上这并非一个完全的


793
00:27:08,036 --> 00:27:08,946
社交媒体 App


794
00:27:09,266 --> 00:27:11,036
这是一个半社交媒体 App


795
00:27:11,476 --> 00:27:13,276
你可以选择是否愿意分享内容


796
00:27:14,176 --> 00:27:15,986
因此还有一个可选的


797
00:27:15,986 --> 00:27:16,756
视图 显示你已经


798
00:27:16,756 --> 00:27:18,016
分享的内容 以及分享的用户


799
00:27:18,946 --> 00:27:20,376
而且一个社交媒体 App


800
00:27:20,376 --> 00:27:22,166
如果不能分享猫的图片


801
00:27:22,166 --> 00:27:23,036
就是不完整的


802
00:27:23,936 --> 00:27:24,896
因此你可能会需要


803
00:27:24,896 --> 00:27:25,846
添加另一个布局


804
00:27:26,836 --> 00:27:28,326
也许你根本并不想


805
00:27:28,326 --> 00:27:29,236
分享这个猫的图片 因为


806
00:27:29,236 --> 00:27:30,346
它实在太好了 你想要


807
00:27:30,346 --> 00:27:31,066
自己保留它


808
00:27:32,056 --> 00:27:33,976
那么我们有四个非常相似的布局


809
00:27:34,626 --> 00:27:35,996
它们并不是相同的


810
00:27:35,996 --> 00:27:36,776
需要做一些调整


811
00:27:36,776 --> 00:27:38,196
当这些表格视图


812
00:27:38,196 --> 00:27:39,306
单元格出现在屏幕上时


813
00:27:39,396 --> 00:27:40,396
当做我刚刚没有提到它们


814
00:27:40,396 --> 00:27:41,156
存在于表格视图单元格中


815
00:27:42,026 --> 00:27:43,406
让我们假设你正在


816
00:27:43,406 --> 00:27:45,236
处理这个 App 的性能问题


817
00:27:45,236 --> 00:27:47,026
你第一次运行它


818
00:27:47,026 --> 00:27:49,036
这就是你获得的滑动性能


819
00:27:49,386 --> 00:27:51,316
其中有很多卡顿现象


820
00:27:51,316 --> 00:27:52,976
尤其是当向上滑动 返回顶部时


821
00:27:53,086 --> 00:27:55,666
那么你会想 好的 我要怎样来


822
00:27:55,666 --> 00:27:57,026
提升这个 App 呢


823
00:27:57,026 --> 00:27:57,716
发生什么问题了呢


824
00:27:58,636 --> 00:28:00,986
因此我想介绍


825
00:28:01,096 --> 00:28:02,406
一个新的功能 它可以让你


826
00:28:02,406 --> 00:28:03,416
对我们正在开发的内容先睹为快


827
00:28:03,886 --> 00:28:05,096
目前它在


828
00:28:05,096 --> 00:28:07,486
测试版中尚不可用 但是敬请期待


829
00:28:07,946 --> 00:28:08,886
因为我们很快会


830
00:28:08,886 --> 00:28:10,386
推出一个布局设计的工具


831
00:28:12,076 --> 00:28:12,796
好的


832
00:28:13,516 --> 00:28:18,716
[ 掌声 ]


833
00:28:19,216 --> 00:28:20,086
我很高兴你们对此感到兴奋


834
00:28:20,606 --> 00:28:21,866
让我们很有动力


835
00:28:22,576 --> 00:28:24,526
不管怎么说 我们一起来看看 发生了什么


836
00:28:25,466 --> 00:28:27,186
最顶部的轨迹显示的是


837
00:28:27,226 --> 00:28:28,856
正在使用的 CPU 容量


838
00:28:29,496 --> 00:28:30,646
某种程度上说


839
00:28:30,646 --> 00:28:31,556
这是一个危险信号


840
00:28:31,756 --> 00:28:33,116
如果存在许多峰值


841
00:28:33,446 --> 00:28:34,486
这意味着你


842
00:28:34,486 --> 00:28:35,436
你的布局


843
00:28:35,436 --> 00:28:36,846
可能有一些问题


844
00:28:37,576 --> 00:28:38,686
而如果它较为平滑


845
00:28:39,166 --> 00:28:40,106
可能其它地方


846
00:28:40,106 --> 00:28:41,526
会有别的问题


847
00:28:42,466 --> 00:28:43,906
下面的轨迹则


848
00:28:43,906 --> 00:28:45,756
具体地追踪约束流失


849
00:28:46,446 --> 00:28:47,616
这些柱状图的高度


850
00:28:47,616 --> 00:28:49,846
在这个例子中 反映的是


851
00:28:49,846 --> 00:28:51,196
发生约束流失的


852
00:28:51,196 --> 00:28:52,596
视图数量


853
00:28:53,506 --> 00:28:54,506
因此当你看到很高的柱状图时


854
00:28:54,506 --> 00:28:56,226
你就知道有许多视图受到了影响


855
00:28:57,446 --> 00:28:59,456
我们也会展示如何


856
00:28:59,456 --> 00:29:00,746
移除和改变约束


857
00:29:01,776 --> 00:29:05,326
并最终设定


858
00:29:05,326 --> 00:29:06,716
UILabel 和其他文本视图的尺寸


859
00:29:06,906 --> 00:29:08,286
这里是 UILabel 是因为


860
00:29:08,286 --> 00:29:09,156
这是 App 中的内容


861
00:29:09,956 --> 00:29:11,026
它也可以追踪其他


862
00:29:11,026 --> 00:29:12,186
类型的文本视图


863
00:29:13,786 --> 00:29:16,286
那么这是 App


864
00:29:16,366 --> 00:29:18,816
滑动时的情况 我们需要查看什么呢


865
00:29:19,206 --> 00:29:21,136
有一些峰值发生在


866
00:29:21,136 --> 00:29:24,236
CPU 视图中 但是让我们放大


867
00:29:24,236 --> 00:29:25,776
这一个 因为在它下面


868
00:29:25,776 --> 00:29:27,106
我看到了一个约束流失的


869
00:29:27,106 --> 00:29:28,926
突然上升 这有些令人担忧


870
00:29:29,906 --> 00:29:31,396
那么 如果你选中这个视图


871
00:29:31,526 --> 00:29:32,966
然后进入 Instruments 中的


872
00:29:33,666 --> 00:29:35,486
详细视图 你会看到的是


873
00:29:35,726 --> 00:29:36,846
一个列表 根据视图描述列明


874
00:29:36,846 --> 00:29:38,896
受到约束流失影响的视图


875
00:29:39,586 --> 00:29:40,556
我们依据


876
00:29:40,556 --> 00:29:42,326
上级视图将它们分类 那么


877
00:29:42,326 --> 00:29:44,576
比如说在表格视图单元格中


878
00:29:44,576 --> 00:29:46,486
很容易看出这个问题


879
00:29:46,486 --> 00:29:48,286
一次又一次地发生在


880
00:29:48,286 --> 00:29:50,116
某个特定的情况下 而非不同情况下


881
00:29:51,016 --> 00:29:52,536
那么在这一实例中我们看到


882
00:29:52,536 --> 00:29:54,586
头像视图和三个不同标签


883
00:29:54,966 --> 00:29:55,956
都出现了流失问题


884
00:29:57,316 --> 00:29:59,646
由于是我


885
00:29:59,646 --> 00:30:01,696
负责在 Instruments 中运行的


886
00:30:01,696 --> 00:30:02,386
我知道这些标签


887
00:30:02,426 --> 00:30:03,876
对应的是 标题标签


888
00:30:03,876 --> 00:30:05,686
日期标签和我们的日志输入标签


889
00:30:07,036 --> 00:30:08,516
这几乎是单元格内的


890
00:30:08,516 --> 00:30:09,086
全部视图了


891
00:30:09,086 --> 00:30:10,736
这让人有点担心


892
00:30:11,406 --> 00:30:12,136
我们一起来看看发生了什么


893
00:30:13,766 --> 00:30:15,376
好的 回到我们的规格说明


894
00:30:16,326 --> 00:30:19,626
通过查看代码发现


895
00:30:19,666 --> 00:30:21,566
UpdateConstraints 正在被覆写


896
00:30:22,526 --> 00:30:25,956
并且在该方法中 在发生任何改变或


897
00:30:25,956 --> 00:30:27,426
UpdateConstraints 在运行时


898
00:30:27,896 --> 00:30:28,696
都会移除全部约束


899
00:30:28,696 --> 00:30:30,716
然后再添加


900
00:30:30,716 --> 00:30:32,276
我们认为需要的约束


901
00:30:33,876 --> 00:30:35,956
一切又回到


902
00:30:35,956 --> 00:30:37,206
原来的样子


903
00:30:37,646 --> 00:30:39,436
正是这种移除


904
00:30:39,436 --> 00:30:41,516
导致性能问题


905
00:30:42,486 --> 00:30:44,986
那么 这里的社交标签


906
00:30:44,986 --> 00:30:46,986
也就是社交头像


907
00:30:47,356 --> 00:30:49,176
被反复添加和移除


908
00:30:49,176 --> 00:30:50,626
我们并不需要完全移除


909
00:30:51,806 --> 00:30:52,856
当你查看


910
00:30:52,856 --> 00:30:54,966
这一视图的约束时 你会看到


911
00:30:54,966 --> 00:30:56,036
它们实际上


912
00:30:56,036 --> 00:30:57,316
并不与其他任何东西互动


913
00:30:57,876 --> 00:30:58,946
仅仅是一个单一的视图


914
00:30:59,516 --> 00:31:01,156
此时你可以使用


915
00:31:01,156 --> 00:31:03,366
这个非常简洁的功能叫做


916
00:31:03,566 --> 00:31:05,536
setHidden 也许你听说过


917
00:31:05,656 --> 00:31:07,936
而且由于它并不影响


918
00:31:07,936 --> 00:31:09,686
任何周围的视图


919
00:31:09,686 --> 00:31:10,626
它就会消失


920
00:31:10,626 --> 00:31:11,866
其约束则会得到保留


921
00:31:11,866 --> 00:31:13,656
这是一个非常非常简便的


922
00:31:14,136 --> 00:31:15,846
方法来隐藏和显示视图


923
00:31:16,416 --> 00:31:18,036
而非将它们从层级中移除


924
00:31:18,986 --> 00:31:19,736
因此这是没有问题的


925
00:31:20,246 --> 00:31:21,556
但是这是一个非常简单的例子


926
00:31:21,556 --> 00:31:22,546
那么图像视图呢


927
00:31:23,016 --> 00:31:24,606
好的 对于图像视图


928
00:31:24,606 --> 00:31:25,806
我们可能再一次


929
00:31:25,806 --> 00:31:26,686
试图将所有的


930
00:31:26,686 --> 00:31:28,176
约束移除 而后再添加


931
00:31:28,626 --> 00:31:30,896
已有的约束以及图像视图的约束


932
00:31:31,816 --> 00:31:34,446
一切又回到原来的样子


933
00:31:34,446 --> 00:31:35,356
这就是约束流失


934
00:31:36,566 --> 00:31:37,776
在这样的情况下


935
00:31:38,156 --> 00:31:39,326
我希望你们思考的方式是


936
00:31:39,326 --> 00:31:41,176
分组查看约束


937
00:31:41,896 --> 00:31:43,446
让我们从这个分组开始


938
00:31:43,446 --> 00:31:44,716
我将其高亮为绿色


939
00:31:45,756 --> 00:31:48,256
这些约束在


940
00:31:48,446 --> 00:31:49,476
每个布局都是一样的


941
00:31:50,466 --> 00:31:53,286
我们在隐藏或显示分享视图时


942
00:31:53,286 --> 00:31:54,196
分享视图不需要发生变化


943
00:31:54,196 --> 00:31:56,356
头像视图不会移动


944
00:31:56,356 --> 00:31:59,006
这些标签也不会发生移动


945
00:31:59,006 --> 00:32:00,806
除了日志输入标签会变得更长


946
00:32:01,616 --> 00:32:02,726
因此这些绿色的约束


947
00:32:03,046 --> 00:32:04,866
应该在你创建


948
00:32:04,866 --> 00:32:08,206
视图时添加 然后被保留在原处


949
00:32:08,566 --> 00:32:09,046
不要修改它们


950
00:32:09,276 --> 00:32:10,446
它们要保持不变


951
00:32:12,026 --> 00:32:13,646
现在我们有四个


952
00:32:13,646 --> 00:32:15,586
约束控制着这个图像视图


953
00:32:15,846 --> 00:32:16,926
要如何处理它们呢


954
00:32:17,216 --> 00:32:21,366
我们把它们放入一个数组 然后我们再将


955
00:32:21,366 --> 00:32:22,276
在没有图像时


956
00:32:22,276 --> 00:32:23,746
将出现的约束放入另一个数组


957
00:32:24,126 --> 00:32:25,246
我很有创造性地将它们叫做


958
00:32:25,246 --> 00:32:26,416
imageConstraints 和


959
00:32:26,416 --> 00:32:27,696
noImageConstraints 这样你们就可以


960
00:32:27,696 --> 00:32:28,526
区分它们


961
00:32:29,216 --> 00:32:32,316
当我们即将


962
00:32:32,316 --> 00:32:34,526
需要添加


963
00:32:34,526 --> 00:32:36,366
或删除该图像视图时 让我们看看


964
00:32:36,366 --> 00:32:37,556
现在所处的布局


965
00:32:38,036 --> 00:32:40,546
如果需要的话 停用 noImageConstraints


966
00:32:41,086 --> 00:32:42,776
并且激活那些图像所需的约束


967
00:32:43,786 --> 00:32:45,516
如果我们不需要图像


968
00:32:45,516 --> 00:32:46,716
那么既然全部其他的


969
00:32:46,716 --> 00:32:48,886
约束已经被激活了 我们只需要再激活


970
00:32:49,186 --> 00:32:49,846
我们正在添加的约束即可


971
00:32:50,176 --> 00:32:51,416
现在我把它们都放入数组中


972
00:32:51,416 --> 00:32:53,936
尽管这是一个单一约束 因为这样可以


973
00:32:53,936 --> 00:32:55,226
简化我的代码


974
00:32:55,756 --> 00:32:56,676
我不需要检查


975
00:32:56,676 --> 00:32:57,486
我是在处理一个


976
00:32:57,486 --> 00:32:58,846
数组还是一个单一约束


977
00:32:59,206 --> 00:33:00,846
这样我一直都是在处理约束的数组


978
00:33:01,856 --> 00:33:02,666
只是长度的不同


979
00:33:03,526 --> 00:33:06,406
这样做的好处是


980
00:33:06,406 --> 00:33:08,286
如果你像这样 正确地


981
00:33:08,286 --> 00:33:09,766
追踪你的约束


982
00:33:10,186 --> 00:33:11,716
而且你知道你想要


983
00:33:11,716 --> 00:33:13,276
实时地在用户面前


984
00:33:13,276 --> 00:33:15,876
添加这个图像视图 你可以停用这些


985
00:33:15,876 --> 00:33:17,426
noImageConstraints 启用


986
00:33:17,426 --> 00:33:18,966
ImageConstraints 并调用 


987
00:33:18,966 --> 00:33:20,326
视觉动画模块中的


988
00:33:20,326 --> 00:33:22,026
layoutIfNeeded


989
00:33:22,026 --> 00:33:23,416
它就会很好地出现在你的视图中


990
00:33:24,126 --> 00:33:25,996
如果你试图通过停用全部的


991
00:33:25,996 --> 00:33:26,886
约束然后将它们


992
00:33:26,886 --> 00:33:29,236
再次添加


993
00:33:29,236 --> 00:33:30,756
委婉点说 情况会很有趣


994
00:33:31,696 --> 00:33:33,006
好的 现在我们已经


995
00:33:33,006 --> 00:33:34,296
调试了这个问题 我们正在


996
00:33:34,296 --> 00:33:35,266
处理约束组


997
00:33:35,266 --> 00:33:36,536
而非把所有约束堆在一起


998
00:33:36,536 --> 00:33:38,646
让我们看一下 会是什么样子


999
00:33:38,706 --> 00:33:39,376
提示一下 这是它


1000
00:33:39,376 --> 00:33:40,566
最开始的样子


1001
00:33:41,706 --> 00:33:44,906
我们向上滑动到顶部


1002
00:33:44,906 --> 00:33:45,216
非常糟糕


1003
00:33:45,216 --> 00:33:46,256
这是在我们调试之后


1004
00:33:46,256 --> 00:33:48,876
看起来的样子


1005
00:33:48,966 --> 00:33:50,136
这就顺滑多了


1006
00:33:50,776 --> 00:33:51,676
谢谢


1007
00:33:52,031 --> 00:33:54,031
[ 掌声 ]


1008
00:33:54,046 --> 00:33:54,986
但是等等 还有惊喜


1009
00:33:55,596 --> 00:33:57,936
我实际上是在 iOS 11 上录制的这个视频


1010
00:33:57,936 --> 00:34:00,586
没有利用


1011
00:34:00,586 --> 00:34:02,826
我们在 iOS 12 上的性能提升


1012
00:34:03,826 --> 00:34:05,376
这只不过是一段


1013
00:34:06,366 --> 00:34:07,396
高效运行的客户端代码


1014
00:34:07,396 --> 00:34:09,626
在 iOS 12 中它看起来也非常棒


1015
00:34:09,626 --> 00:34:13,416
而且好的难以置信


1016
00:34:13,416 --> 00:34:14,016
[ 笑声 ]


1017
00:34:14,516 --> 00:34:17,446
[ 掌声 ] 是的 它非常棒


1018
00:34:20,396 --> 00:34:21,815
那么 我们如何避免


1019
00:34:21,815 --> 00:34:22,106
约束流失呢


1020
00:34:23,176 --> 00:34:25,106
避免移除全部约束


1021
00:34:25,106 --> 00:34:26,206
这样通常会让你


1022
00:34:26,206 --> 00:34:27,406
进入一个尴尬境地 你需要


1023
00:34:27,406 --> 00:34:29,036
把一部分的约束重新添加


1024
00:34:29,036 --> 00:34:30,956
而这会让你


1025
00:34:30,956 --> 00:34:32,596
重新布局


1026
00:34:32,596 --> 00:34:33,626
并不需要的帧


1027
00:34:33,626 --> 00:34:34,795
或是重新传送不需要


1028
00:34:34,795 --> 00:34:35,636
被再次展示的视图


1029
00:34:36,866 --> 00:34:38,286
如果你有一系列的约束


1030
00:34:38,315 --> 00:34:39,626
它们对于全部


1031
00:34:39,626 --> 00:34:40,585
你的 App 中可能的布局都是共用的


1032
00:34:40,585 --> 00:34:42,556
一次性将它们添加 然后不要


1033
00:34:42,556 --> 00:34:43,085
再修改它们


1034
00:34:43,156 --> 00:34:44,295
这对于使用 Interface


1035
00:34:44,295 --> 00:34:45,326
Builder 和你的 App 的


1036
00:34:45,326 --> 00:34:46,916
初始布局有好处


1037
00:34:46,916 --> 00:34:47,786
改变那些需要被改变的


1038
00:34:47,786 --> 00:34:48,826
约束 但不要去改变


1039
00:34:48,826 --> 00:34:49,956
那些不需要改变的


1040
00:34:50,886 --> 00:34:52,755
听起来有点像文字游戏 但是效果很不错


1041
00:34:53,186 --> 00:34:54,606
现在你已经有了简便的办法


1042
00:34:54,606 --> 00:34:56,786
隐藏视图而非


1043
00:34:56,786 --> 00:34:58,436
移除视图 可以解决你的需求


1044
00:34:59,076 --> 00:35:00,096
好的 这就是


1045
00:35:00,096 --> 00:35:01,546
Instruments 中的约束流失问题


1046
00:35:01,626 --> 00:35:02,596
Instruments 中还有一个


1047
00:35:02,596 --> 00:35:04,326
底部视图 叫做 UILabel 尺寸计算


1048
00:35:05,236 --> 00:35:07,186
UILabel 尺寸计算追踪的是


1049
00:35:07,186 --> 00:35:08,246
标签计算其尺寸


1050
00:35:08,246 --> 00:35:09,926
所需要的时间


1051
00:35:10,226 --> 00:35:11,566
我们来讨论一下固有


1052
00:35:11,566 --> 00:35:12,236
内容尺寸


1053
00:35:12,566 --> 00:35:15,036
让我走到这边来


1054
00:35:15,886 --> 00:35:17,546
好的 并不是所有的视图


1055
00:35:17,896 --> 00:35:19,096
都需要有固有内容尺寸


1056
00:35:20,716 --> 00:35:21,426
一些视图需要


1057
00:35:21,836 --> 00:35:24,076
具有非视图内容的视图


1058
00:35:24,076 --> 00:35:25,276
会返回一个它们的


1059
00:35:25,276 --> 00:35:26,936
固有内容尺寸的大小


1060
00:35:26,936 --> 00:35:28,086
尺寸是基于该非视图内容的


1061
00:35:28,486 --> 00:35:30,126
举两个例子


1062
00:35:30,126 --> 00:35:32,156
一个是 UIImageView 它利用其


1063
00:35:32,156 --> 00:35:33,826
图像的尺寸来计算其


1064
00:35:33,826 --> 00:35:36,036
固有内容尺寸


1065
00:35:36,036 --> 00:35:38,116
另一个是 UILabel 它测量其文本


1066
00:35:38,576 --> 00:35:39,976
并依据此来返回其


1067
00:35:39,976 --> 00:35:41,056
固有内容尺寸


1068
00:35:41,636 --> 00:35:43,666
固有内容尺寸


1069
00:35:43,666 --> 00:35:45,076
并没有什么神奇之处


1070
00:35:45,486 --> 00:35:47,856
它的用处是通过 UIView 创建约束


1071
00:35:48,486 --> 00:35:49,886
确定约束的尺寸


1072
00:35:49,886 --> 00:35:50,886
仅此而已


1073
00:35:51,596 --> 00:35:52,476
你可以在


1074
00:35:52,476 --> 00:35:54,106
约束中定义全部的尺寸


1075
00:35:54,576 --> 00:35:55,576
并跳过这些内容


1076
00:35:56,436 --> 00:35:57,496
有一些情况下


1077
00:35:57,496 --> 00:35:58,646
它需要被覆写


1078
00:35:58,646 --> 00:36:00,026
这也是它存在的原因


1079
00:36:00,026 --> 00:36:01,156
这样的情况


1080
00:36:01,156 --> 00:36:02,586
以及一些其他的例子


1081
00:36:02,586 --> 00:36:03,776
都在 UIView 子集中


1082
00:36:04,346 --> 00:36:05,786
但是大部分情况下它被


1083
00:36:05,786 --> 00:36:07,026
覆写的原因是


1084
00:36:07,026 --> 00:36:07,986
人们认为这样会


1085
00:36:07,986 --> 00:36:10,136
更快或者更准确


1086
00:36:10,136 --> 00:36:10,946
但事实上都不会


1087
00:36:12,076 --> 00:36:14,546
但是 有一种情况下


1088
00:36:14,546 --> 00:36:16,506
覆写它会提高你的性能


1089
00:36:18,206 --> 00:36:19,926
因为文本测量可能消耗较高


1090
00:36:21,186 --> 00:36:24,106
在我们的这个 App 中 UILabel 尺寸计算


1091
00:36:24,106 --> 00:36:25,626
并没有花费很久


1092
00:36:25,716 --> 00:36:27,386
它的时间是很短的


1093
00:36:27,826 --> 00:36:28,986
因此 纠结这个问题


1094
00:36:28,986 --> 00:36:29,766
并不会提升


1095
00:36:29,766 --> 00:36:31,096
太多的性能


1096
00:36:31,666 --> 00:36:32,956
但如果你有一个文本密集型的


1097
00:36:32,956 --> 00:36:34,586
App 而你多次看到


1098
00:36:34,586 --> 00:36:36,106
在 UILabel 中发生


1099
00:36:36,106 --> 00:36:37,886
文本测量 或者你


1100
00:36:37,886 --> 00:36:38,936
在文本视图中有文本测量过程


1101
00:36:39,066 --> 00:36:39,956
或者其他功能中有文本测量


1102
00:36:40,386 --> 00:36:42,136
你或许能够通过这种方式


1103
00:36:42,136 --> 00:36:43,566
借助其他信息 提高性能


1104
00:36:45,116 --> 00:36:46,296
如果你知道


1105
00:36:46,296 --> 00:36:47,886
该文本所需要的尺寸


1106
00:36:47,886 --> 00:36:49,696
而无需完成文本测量


1107
00:36:49,696 --> 00:36:50,746
你可以返回该尺寸


1108
00:36:50,746 --> 00:36:53,916
和固有内容尺寸 或者是


1109
00:36:53,916 --> 00:36:55,286
在准备将


1110
00:36:55,286 --> 00:36:56,726
视图显示在屏幕时


1111
00:36:56,726 --> 00:36:57,546
完全使用约束


1112
00:36:57,546 --> 00:36:58,706
定义该尺寸


1113
00:36:58,776 --> 00:36:59,976
无论其中的文本


1114
00:37:00,046 --> 00:37:00,846
尺寸如何


1115
00:37:00,946 --> 00:37:02,306
举个例子 约束


1116
00:37:02,306 --> 00:37:03,156
总是会让尺寸


1117
00:37:03,156 --> 00:37:04,706
略大于你的文本量


1118
00:37:05,546 --> 00:37:06,586
然后你就可以直接不返回


1119
00:37:06,586 --> 00:37:07,996
任何固有内容尺寸


1120
00:37:07,996 --> 00:37:10,446
中对于宽度和高度的度量


1121
00:37:11,146 --> 00:37:12,206
这样做就是告诉


1122
00:37:12,206 --> 00:37:13,486
上一层级 “嘿我已经知道了


1123
00:37:13,486 --> 00:37:15,846
我的尺寸 不需要再进行文本测量了”


1124
00:37:16,826 --> 00:37:18,226
很明显 这只在


1125
00:37:18,226 --> 00:37:19,096
你不需要自己进行


1126
00:37:19,096 --> 00:37:21,826
测量时才适用 但是它可以


1127
00:37:21,826 --> 00:37:23,646
帮助一些 App 提高性能


1128
00:37:23,646 --> 00:37:24,886
因此我希望你们了解


1129
00:37:24,886 --> 00:37:26,016
这个小技巧


1130
00:37:26,766 --> 00:37:27,766
我们不能只谈


1131
00:37:27,766 --> 00:37:29,116
固有内容尺寸而不谈


1132
00:37:29,116 --> 00:37:30,566
系统布局适应尺寸


1133
00:37:30,566 --> 00:37:33,326
因为人们


1134
00:37:33,326 --> 00:37:35,666
往往混淆这两个概念


1135
00:37:35,666 --> 00:37:37,846
尽管它们几乎是相反的


1136
00:37:37,846 --> 00:37:41,456
很可惜固有内容尺寸是


1137
00:37:41,456 --> 00:37:42,446
你向引擎传输


1138
00:37:42,446 --> 00:37:44,226
需要添加的尺寸信息的方式


1139
00:37:45,206 --> 00:37:46,796
系统布局配合尺寸是


1140
00:37:47,156 --> 00:37:48,206
你将尺寸


1141
00:37:48,206 --> 00:37:49,826
信息从引擎中提取出来的方式


1142
00:37:50,356 --> 00:37:52,486
事实上它们几乎是相反的


1143
00:37:52,486 --> 00:37:54,696
这用于一些混合布局


1144
00:37:54,696 --> 00:37:56,086
出于有一些原因


1145
00:37:56,086 --> 00:37:57,136
导致你需要


1146
00:37:57,136 --> 00:37:58,816
从一个使用 Auto Layout


1147
00:37:58,816 --> 00:38:00,576
管理其子视图的视图中提取帧信息


1148
00:38:01,876 --> 00:38:03,616
不是很常用 但是


1149
00:38:03,616 --> 00:38:05,306
确实可以这么使用


1150
00:38:05,696 --> 00:38:07,346
我想要告诉你们这个方法


1151
00:38:07,346 --> 00:38:09,096
如何运行 因为它可能


1152
00:38:09,096 --> 00:38:10,306
比你们认为的消耗更高一些


1153
00:38:11,736 --> 00:38:13,046
当你调用 systemLayoutSizeFittingSize 时


1154
00:38:13,046 --> 00:38:15,386
会创建一个引擎


1155
00:38:16,086 --> 00:38:17,006
约束被加入这个该引擎


1156
00:38:17,006 --> 00:38:18,886
计算布局


1157
00:38:19,536 --> 00:38:23,546
然后返回顶部视图的帧尺寸


1158
00:38:23,546 --> 00:38:24,666
之后此引擎被废弃


1159
00:38:25,706 --> 00:38:26,646
所以每次你调用


1160
00:38:26,646 --> 00:38:27,916
这个方法都会


1161
00:38:27,916 --> 00:38:28,946
创建然后废弃一个引擎


1162
00:38:29,856 --> 00:38:31,386
尽管对于小规模使用没问题


1163
00:38:31,386 --> 00:38:33,006
如果你多次使用


1164
00:38:33,286 --> 00:38:34,306
你可以看到它会


1165
00:38:34,306 --> 00:38:35,486
随着时间的流逝而堆积


1166
00:38:35,706 --> 00:38:37,336
因此谨慎使用


1167
00:38:37,336 --> 00:38:38,616
systemLayoutSizeFittingSize


1168
00:38:39,636 --> 00:38:41,486
其中的一个做法是


1169
00:38:41,486 --> 00:38:42,956
有时候看到有些人会


1170
00:38:42,996 --> 00:38:44,646
将这一调用从


1171
00:38:44,646 --> 00:38:45,886
自动调整选项或


1172
00:38:45,886 --> 00:38:47,636
表格视图单元格转到内容视图中


1173
00:38:47,896 --> 00:38:49,186
当你这么做时


1174
00:38:49,186 --> 00:38:50,326
你事实上在覆写一些


1175
00:38:50,326 --> 00:38:51,886
我们刚才做出的优化


1176
00:38:51,886 --> 00:38:53,026
让该视图滑动


1177
00:38:53,026 --> 00:38:54,716
更快的设置


1178
00:38:54,716 --> 00:38:55,706
并且还添加了多余的引擎


1179
00:38:56,026 --> 00:38:57,086
因此如果你目前这么做了


1180
00:38:57,086 --> 00:38:58,106
并且你的滑动不顺滑


1181
00:38:58,106 --> 00:38:59,946
你可以试着解决问题


1182
00:39:01,026 --> 00:39:02,266
好了 现在我们到了


1183
00:39:02,266 --> 00:39:03,366
我最喜欢的话题


1184
00:39:03,836 --> 00:39:05,216
不可满足约束


1185
00:39:06,226 --> 00:39:10,146
好的 那么什么是不可满足约束呢


1186
00:39:10,226 --> 00:39:11,116
如果你还未遇到过这个问题


1187
00:39:11,116 --> 00:39:13,216
这个问题发生的情况是


1188
00:39:13,216 --> 00:39:14,856
当你定义


1189
00:39:15,396 --> 00:39:16,806
这个视图的宽度应该是 50


1190
00:39:16,806 --> 00:39:18,936
同时也要是 200 的宽度


1191
00:39:19,836 --> 00:39:21,606
这不可能满足


1192
00:39:21,976 --> 00:39:24,116
事实上 量子手机不存在


1193
00:39:25,276 --> 00:39:26,436
你知道 我不能断言未来有没有


1194
00:39:26,436 --> 00:39:30,696
但是引擎不得不


1195
00:39:30,696 --> 00:39:31,876
计算得出结果


1196
00:39:31,876 --> 00:39:33,906
即不存在可用布局


1197
00:39:33,906 --> 00:39:35,566
于是破坏一个约束以


1198
00:39:35,956 --> 00:39:37,556
为你产生布局


1199
00:39:38,536 --> 00:39:39,626
它破坏约束时


1200
00:39:40,246 --> 00:39:42,026
会发送一个详细的日志


1201
00:39:42,386 --> 00:39:43,496
到你的调试器 也许你已经


1202
00:39:43,496 --> 00:39:46,026
见到过了 并且显示


1203
00:39:46,026 --> 00:39:47,316
不可满足约束


1204
00:39:47,636 --> 00:39:49,876
这是我破坏的约束 这些是其他


1205
00:39:49,876 --> 00:39:51,476
受到影响的约束 因此我


1206
00:39:51,476 --> 00:39:52,186
不得不破坏它


1207
00:39:53,146 --> 00:39:54,836
有时候这样会


1208
00:39:55,366 --> 00:39:56,856
直接影响性能


1209
00:39:56,856 --> 00:39:57,986
同时也可能掩盖其他问题


1210
00:39:57,986 --> 00:39:59,596
因此最好是调试解决此类情况


1211
00:40:00,206 --> 00:40:01,346
Auto Layout 的秘密 第二部分


1212
00:40:01,346 --> 00:40:02,756
提供了一些很好的


1213
00:40:02,756 --> 00:40:04,566
调试纠错信息


1214
00:40:04,566 --> 00:40:05,706
你可以看看


1215
00:40:05,936 --> 00:40:06,786
如果你在处理


1216
00:40:06,786 --> 00:40:08,236
不可满足约束时遇到了问题的话


1217
00:40:09,806 --> 00:40:11,556
好的 你们已经毕业了


1218
00:40:11,556 --> 00:40:12,346
恭喜你们


1219
00:40:12,346 --> 00:40:13,946
你们现在全部是 Auto Layout 专家了


1220
00:40:14,746 --> 00:40:17,856
你知道 我希望你们真正享受学习


1221
00:40:17,856 --> 00:40:19,236
它运作的内在问题


1222
00:40:19,866 --> 00:40:21,736
现在你们能够更好的了解


1223
00:40:21,736 --> 00:40:23,056
如何在更新约束之前思考


1224
00:40:23,256 --> 00:40:24,416
并且理解它们


1225
00:40:24,416 --> 00:40:25,826
所经历的过程 你们已经获得了一些


1226
00:40:25,826 --> 00:40:27,916
最新的关于尺寸


1227
00:40:27,916 --> 00:40:29,846
优先级和不等式的信息


1228
00:40:29,846 --> 00:40:32,056
你们的布局在 iOS 12 中会更快


1229
00:40:32,056 --> 00:40:32,726
这非常棒


1230
00:40:33,416 --> 00:40:34,426
我们明天会在实验室


1231
00:40:34,496 --> 00:40:35,886
如果任何人有问题的话


1232
00:40:35,926 --> 00:40:36,386
可以进行交流


1233
00:40:37,006 --> 00:40:39,696
这些是相关会议信息的链接


1234
00:40:40,286 --> 00:40:40,976
希望你们享受本周接下来的时间


1235
00:40:41.516 --> 00:40:45.500 A:
[ 掌声 ]

