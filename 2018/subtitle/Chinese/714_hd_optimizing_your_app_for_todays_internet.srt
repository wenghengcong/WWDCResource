1
00:00:06,516 --> 00:00:15,500
[ 音乐 ]


2
00:00:19,516 --> 00:00:26,386
[ 掌声 ]


3
00:00:26,886 --> 00:00:28,196
>> 女士们 先生们 早上好


4
00:00:28,986 --> 00:00:29,986
你们中有多少人


5
00:00:29,986 --> 00:00:31,706
是第一次来 WWDC 


6
00:00:33,666 --> 00:00:34,806
非常棒


7
00:00:34,806 --> 00:00:36,536
每年都能见到一些新面孔


8
00:00:36,536 --> 00:00:37,336
实在是太好了


9
00:00:38,046 --> 00:00:39,146
我是 Stuart Cheshire


10
00:00:39,266 --> 00:00:41,166
我们将会讨论网络


11
00:00:42,176 --> 00:00:45,946
我会先从影响你的 App 性能的


12
00:00:45,946 --> 00:00:47,296
一些话题开始


13
00:00:47,886 --> 00:00:48,806
如今完全不利用网络的


14
00:00:48,806 --> 00:00:51,766
App 已经几乎没有了


15
00:00:52,246 --> 00:00:54,026
而让网络性能


16
00:00:54,026 --> 00:00:55,856
达到最优非常重要


17
00:00:56,386 --> 00:00:57,236
我们会讲到


18
00:00:57,236 --> 00:00:58,806
可以帮助你优化


19
00:00:58,806 --> 00:00:59,896
网络性能的一些技术


20
00:01:00,936 --> 00:01:05,296
也会讲到一些有用的提示和方法


21
00:01:05,716 --> 00:01:07,656
来指导你如何最大程度地利用


22
00:01:07,696 --> 00:01:10,176
Apple 的 API 以及关于


23
00:01:10,176 --> 00:01:12,346
即将到来的新技术的一些信息


24
00:01:12,346 --> 00:01:14,716
然后我的同事


25
00:01:14,716 --> 00:01:16,556
Jiten 将会更详细地


26
00:01:16,556 --> 00:01:18,106
讲解 URLSession


27
00:01:21,066 --> 00:01:23,956
我们先从互联网的


28
00:01:23,956 --> 00:01:24,796
近况说起


29
00:01:25,416 --> 00:01:27,666
今年早些时候


30
00:01:27,666 --> 00:01:30,476
使用互联网的人数


31
00:01:30,476 --> 00:01:30,966
达到了 40 亿


32
00:01:31,256 --> 00:01:33,626
超过了世界人口的一半


33
00:01:34,166 --> 00:01:35,876
我们早已习惯了


34
00:01:35,876 --> 00:01:36,846
互联网使用人数的不断翻倍


35
00:01:37,696 --> 00:01:39,286
而当已经超过一半时


36
00:01:39,776 --> 00:01:40,606
显然互联网使用人数


37
00:01:40,606 --> 00:01:42,766
不可能继续翻倍 所以


38
00:01:43,096 --> 00:01:45,316
互联网使用人数增长的速度在减缓


39
00:01:45,316 --> 00:01:46,306
但并不意味着


40
00:01:46,396 --> 00:01:47,576
互联网的发展会减缓


41
00:01:48,426 --> 00:01:49,626
在机器对机器通讯


42
00:01:49,626 --> 00:01:50,426
物联网以及


43
00:01:50,426 --> 00:01:51,996
智能家庭方面


44
00:01:51,996 --> 00:01:53,536
仍然有很高的增长率


45
00:01:54,256 --> 00:01:55,546
另外 在一些地方 例如印度和中国


46
00:01:55,546 --> 00:01:57,046
仍然有很高的增长率


47
00:01:58,276 --> 00:01:59,826
并且仍然有很多人


48
00:01:59,826 --> 00:02:01,256
从未拥有过一台桌面计算机


49
00:02:01,296 --> 00:02:03,646
甚至未来也不会拥有


50
00:02:03,646 --> 00:02:04,596
自己的桌面计算机


51
00:02:05,016 --> 00:02:06,926
他们主要的计算


52
00:02:06,926 --> 00:02:08,675
和通讯设备


53
00:02:08,675 --> 00:02:09,356
是他们的智能手机


54
00:02:09,895 --> 00:02:12,356
而这些智能手机中


55
00:02:12,396 --> 00:02:14,166
很多都仍在使用 2G 网络


56
00:02:15,066 --> 00:02:17,486
我相信这间屋子里的绝大多数


57
00:02:17,486 --> 00:02:20,166
都足够幸运


58
00:02:20,166 --> 00:02:21,916
居住的地方 工作的地方


59
00:02:21,916 --> 00:02:23,406
以及开发我们的 App 的地方


60
00:02:23,406 --> 00:02:24,946
都有快速的 LTE 网络


61
00:02:25,396 --> 00:02:27,266
而这可能会成为一个短板


62
00:02:27,736 --> 00:02:31,076
因为如果你开发 App 时


63
00:02:31,076 --> 00:02:33,896
考虑的是它在 LTE 下运行良好


64
00:02:33,896 --> 00:02:35,996
它可能在 2G 下表现得非常糟糕


65
00:02:36,916 --> 00:02:37,956
在世界的另一个角落


66
00:02:37,956 --> 00:02:39,106
你的某个竞争对手


67
00:02:39,106 --> 00:02:40,476
开发的 App 在 2G 下运行良好


68
00:02:40,476 --> 00:02:43,366
那么在 LTE 下会表现得更为出色


69
00:02:43,976 --> 00:02:46,436
所以我们有了一个工具


70
00:02:46,436 --> 00:02:48,946
可以让所有人都模拟


71
00:02:48,946 --> 00:02:50,766
那些较慢网络的


72
00:02:50,766 --> 00:02:52,476
一些特性


73
00:02:52,476 --> 00:02:53,056
这就是 Network Link Conditioner


74
00:02:54,016 --> 00:02:55,266
从开发 App 的第一刻起


75
00:02:55,446 --> 00:02:57,026
就应该运行


76
00:02:57,026 --> 00:02:57,946
Network Link Conditioner


77
00:02:58,206 --> 00:02:59,476
不要认为你可以


78
00:02:59,476 --> 00:03:02,046
到最后再来改善性能


79
00:03:02,046 --> 00:03:02,716
因为到时就来不及了


80
00:03:03,456 --> 00:03:05,176
请一定一直记得


81
00:03:05,176 --> 00:03:06,646
使用 Network Link Conditioner


82
00:03:06,646 --> 00:03:08,266
来运行和测试你的 App


83
00:03:08,266 --> 00:03:10,266
这样的话 如果程序中有个错误


84
00:03:10,266 --> 00:03:11,276
带来了糟糕的性能问题


85
00:03:11,276 --> 00:03:12,726
你马上就能发现它


86
00:03:12,726 --> 00:03:14,186
并且立刻修复


87
00:03:15,476 --> 00:03:16,986
使用像 Wireshark 和


88
00:03:16,986 --> 00:03:19,036
tcptrace 的工具


89
00:03:19,036 --> 00:03:20,336
来弄清楚你的 App 的网络性能


90
00:03:20,906 --> 00:03:21,746
这很像是用


91
00:03:21,746 --> 00:03:23,046
Instruments 来查看


92
00:03:23,046 --> 00:03:24,166
内存和 CPU 的占用情况


93
00:03:25,056 --> 00:03:26,866
如果你还没用过 tcptrace


94
00:03:26,866 --> 00:03:28,186
这个工具可以


95
00:03:28,186 --> 00:03:29,976
生成像这样的图表


96
00:03:29,976 --> 00:03:31,476
让你一眼就看清楚


97
00:03:31,476 --> 00:03:32,486
网络上进行中的事


98
00:03:33,356 --> 00:03:34,566
如果你想要了解更多


99
00:03:34,566 --> 00:03:38,546
请查看三年前的视频


100
00:03:39,456 --> 00:03:41,566
IPv6 的使用率持续上升


101
00:03:42,426 --> 00:03:43,816
为什么这很重要


102
00:03:43,986 --> 00:03:46,006
这是因为 IPv6


103
00:03:46,356 --> 00:03:47,946
比 IPv4 的性能


104
00:03:47,946 --> 00:03:48,846
表现更好


105
00:03:48,906 --> 00:03:50,286
所以如果你在意性能


106
00:03:50,286 --> 00:03:51,796
你应该确保


107
00:03:51,796 --> 00:03:53,596
不仅你的 App


108
00:03:53,596 --> 00:03:55,236
还有你的 App 使用的网络服务


109
00:03:55,426 --> 00:03:56,836
支持原生 IPv6


110
00:03:57,716 --> 00:03:59,156
在这方面


111
00:03:59,156 --> 00:04:01,086
有些地方的情况比其他地方好一些


112
00:04:01,906 --> 00:04:04,006
在美国 已经有 87% 的


113
00:04:04,006 --> 00:04:05,996
移动运营商支持 IPv6


114
00:04:06,036 --> 00:04:08,456
其他地方 例如印度


115
00:04:08,456 --> 00:04:09,546
也非常好


116
00:04:10,256 --> 00:04:11,696
那么我们现在来看看印度


117
00:04:12,596 --> 00:04:14,596
这里是今年早些时候


118
00:04:14,596 --> 00:04:15,766
Apple 的网络团队


119
00:04:15,766 --> 00:04:18,326
收集到的一些数据


120
00:04:18,466 --> 00:04:21,086
有关印度蜂窝移动网络下


121
00:04:21,516 --> 00:04:24,566
TCP 网络连接建立时长


122
00:04:25,256 --> 00:04:26,606
以及持续的往返延迟


123
00:04:27,266 --> 00:04:28,756
蓝色的线是 IPv6


124
00:04:29,486 --> 00:04:31,416
举例来说 如果我们


125
00:04:31,416 --> 00:04:33,946
观察 75% 这里


126
00:04:34,226 --> 00:04:39,316
可以看出 IPv6 上 75% 的 TCP 连接


127
00:04:39,376 --> 00:04:41,746
在 150 毫秒内建立完成


128
00:04:42,446 --> 00:04:44,576
而相应的


129
00:04:44,576 --> 00:04:46,796
在 IPv4 上则超过 325 毫秒


130
00:04:47,336 --> 00:04:48,636
比 IPv6 慢了不止一倍


131
00:04:49,036 --> 00:04:50,976
因此如果你想要为你的用户


132
00:04:50,976 --> 00:04:53,526
提供响应速度快的 App


133
00:04:53,526 --> 00:04:55,166
请采用 IPv6


134
00:04:56,926 --> 00:04:58,516
另一项通过


135
00:04:58,566 --> 00:05:00,526
降低丢包率和重发率


136
00:05:00,526 --> 00:05:02,286
来提升性能的技术


137
00:05:02,286 --> 00:05:03,266
是 Explicit Congestion


138
00:05:03,266 --> 00:05:04,026
Notification


139
00:05:04,836 --> 00:05:06,056
我们在 macOS 和 iOS 上


140
00:05:06,056 --> 00:05:08,026
默认启用这项技术


141
00:05:08,026 --> 00:05:09,496
已经有些年了


142
00:05:09,496 --> 00:05:10,306
因此想要利用这项技术


143
00:05:10,306 --> 00:05:12,376
你不需要在你的 App 中


144
00:05:12,376 --> 00:05:12,726
进行额外操作


145
00:05:13,706 --> 00:05:16,506
不过要确保你的服务支持 ECN


146
00:05:17,296 --> 00:05:20,026
我们调研了 Alexa


147
00:05:20,026 --> 00:05:22,076
前一百万网站


148
00:05:22,076 --> 00:05:24,276
发现截止上月


149
00:05:24,276 --> 00:05:25,316
前一百万服务中有 77% 已经


150
00:05:25,316 --> 00:05:27,226
支持了 ECN


151
00:05:27,226 --> 00:05:28,666
相比几年前


152
00:05:28,666 --> 00:05:32,206
这是个很大的进步


153
00:05:32,936 --> 00:05:34,936
另一项帮助你提升


154
00:05:34,936 --> 00:05:36,506
连接的性能和


155
00:05:36,506 --> 00:05:37,766
弹性的技术


156
00:05:37,766 --> 00:05:39,016
是多路 TCP


157
00:05:39,796 --> 00:05:41,336
用户常常可能在


158
00:05:41,336 --> 00:05:43,426
办公室的 Wi-Fi 下发起连接


159
00:05:43,426 --> 00:05:45,676
然后走出办公室


160
00:05:46,436 --> 00:05:47,896
就丢失了 Wi-Fi 信号


161
00:05:47,896 --> 00:05:49,516
如果是传统 TCP


162
00:05:49,516 --> 00:05:50,666
连接就断了


163
00:05:50,666 --> 00:05:51,506
必须重新连接


164
00:05:51,506 --> 00:05:52,516
重新开始发起


165
00:05:53,176 --> 00:05:55,356
多路 TCP 以包为单位


166
00:05:55,356 --> 00:05:56,716
做数据包的路由选择


167
00:05:56,716 --> 00:05:58,636
而不是以连接为单位


168
00:05:59,236 --> 00:06:01,976
所以可以即时把连接


169
00:06:01,976 --> 00:06:03,846
转向另一个接口


170
00:06:05,876 --> 00:06:08,416
去年我们讨论了如何
 
00:06:08,416 --> 00:06:09,876
在你的 App 中启用这项技术


171
00:06:10,016 --> 00:06:11,706
当然 请和你的


172
00:06:11,706 --> 00:06:13,076
服务器运营商


173
00:06:13,076 --> 00:06:14,976
确认你的服务器也支持多路


174
00:06:16,146 --> 00:06:18,246
我们最近调查了


175
00:06:18,246 --> 00:06:20,196
全世界与 Apple 合作的


176
00:06:20,196 --> 00:06:22,036
移动运营商


177
00:06:22,036 --> 00:06:28,226
其中 78% 支持多路 TCP


178
00:06:28,696 --> 00:06:30,496
只有 22% 的运营商


179
00:06:30,496 --> 00:06:32,016
仍限制多路连接


180
00:06:32,536 --> 00:06:37,456
TCP Fast Open 是一项


181
00:06:37,706 --> 00:06:39,536
可以让你避免通常情况下


182
00:06:39,536 --> 00:06:41,446
TCP 连接建立时的


183
00:06:41,446 --> 00:06:42,426
往返延迟的技术


184
00:06:42,906 --> 00:06:46,216
TCP Fast Open 可以让你


185
00:06:46,216 --> 00:06:48,766
把初始数据放在


186
00:06:48,766 --> 00:06:50,706
连接建立数据包里


187
00:06:52,546 --> 00:06:53,856
你可以在三年前的


188
00:06:53,856 --> 00:06:55,976
视频中找到更多相关信息


189
00:06:56,476 --> 00:06:57,856
也请和你的


190
00:06:57,856 --> 00:06:59,286
服务器运营商


191
00:06:59,286 --> 00:07:03,256
确认支持 TCP Fast Open


192
00:07:03,476 --> 00:07:05,586
现在我们来说讲一些新消息


193
00:07:06,216 --> 00:07:09,176
你们中很多人应该


194
00:07:09,176 --> 00:07:10,776
听说过一个技术


195
00:07:10,836 --> 00:07:11,106
叫做 QUIC


196
00:07:11,986 --> 00:07:13,326
这是一种新的传输协议


197
00:07:13,326 --> 00:07:15,856
也是近 30 年来


198
00:07:15,856 --> 00:07:17,516
第一个真正意义上的


199
00:07:17,516 --> 00:07:19,246
可能取代 TCP 的候选者


200
00:07:19,796 --> 00:07:21,576
它起源于 Google 的一些工程师


201
00:07:21,676 --> 00:07:23,086
做的一项实验


202
00:07:23,566 --> 00:07:25,366
这项实验很成功


203
00:07:25,366 --> 00:07:29,876
现在已成为 IETF


204
00:07:29,876 --> 00:07:30,766
为了标准化的一项工作


205
00:07:31,966 --> 00:07:33,256
Apple 的工程师


206
00:07:33,256 --> 00:07:34,446
也参与其中


207
00:07:34,446 --> 00:07:35,816
实际上 此时此刻我们的工程师


208
00:07:35,816 --> 00:07:37,786
就在瑞典的


209
00:07:37,786 --> 00:07:38,596
QUIC 会议上


210
00:07:39,996 --> 00:07:42,286
不过这项技术还没有完全准备好


211
00:07:42,286 --> 00:07:43,506
标准尚未完成


212
00:07:44,016 --> 00:07:45,416
但是 Apple 正在为之努力


213
00:07:45,416 --> 00:07:47,146
一旦准备好了


214
00:07:47,146 --> 00:07:48,306
你会看到 Apple 有 API


215
00:07:48,436 --> 00:07:50,916
来支持这项技术


216
00:07:51,266 --> 00:07:52,256
继续有关性能的话题


217
00:07:52,306 --> 00:07:55,406
我们观察到了一些


218
00:07:55,406 --> 00:07:56,656
非常常见的行为


219
00:07:57,356 --> 00:07:59,336
相当多的网站和


220
00:07:59,336 --> 00:08:01,036
互联网服务 使用


221
00:08:01,036 --> 00:08:04,266
生命周期短的 DNS 记录


222
00:08:04,666 --> 00:08:06,596
他们之所以这样做


223
00:08:06,596 --> 00:08:08,736
是因为如果一个数据中心出了故障


224
00:08:08,736 --> 00:08:10,496
他们希望能够更新 DNS


225
00:08:10,496 --> 00:08:12,686
从而迅速地把流量导向


226
00:08:12,686 --> 00:08:13,666
另一个不同的数据中心


227
00:08:15,266 --> 00:08:16,636
这个方法的问题在于


228
00:08:17,076 --> 00:08:19,166
你在为一个


229
00:08:19,166 --> 00:08:21,506
几乎从未发生过的情况牺牲性能


230
00:08:21,596 --> 00:08:24,186
数据中心极少出故障


231
00:08:25,066 --> 00:08:27,316
这意味着


232
00:08:27,316 --> 00:08:29,276
每当一个 DNS 地址记录过期


233
00:08:29,276 --> 00:08:31,096
你的客户端不得不


234
00:08:31,096 --> 00:08:32,736
再用一个往返延迟


235
00:08:33,046 --> 00:08:35,496
去等候来自 DNS 服务器的回应


236
00:08:35,496 --> 00:08:37,306
而这个回应


237
00:08:37,306 --> 00:08:39,155
和它上次获知的一模一样


238
00:08:39,756 --> 00:08:42,736
所以 考虑到这点


239
00:08:42,736 --> 00:08:44,826
我们做了一个


240
00:08:44,826 --> 00:08:45,216
可以实现的优化


241
00:08:45,866 --> 00:08:47,856
如果你传了参与这种新方式的标记


242
00:08:47,856 --> 00:08:50,866
那么当你发起 DNS 请求时


243
00:08:50,866 --> 00:08:52,846
如果我们的缓存中


244
00:08:52,846 --> 00:08:54,446
有一个此前过期的回应


245
00:08:54,446 --> 00:08:56,956
我们会把它立即给你


246
00:08:57,056 --> 00:08:59,286
与此同时


247
00:08:59,286 --> 00:09:00,876
进行原本就会做的


248
00:09:00,876 --> 00:09:03,476
普通的 DNS 请求


249
00:09:04,576 --> 00:09:05,796
如果请求到相同的结果


250
00:09:05,796 --> 00:09:07,636
我们预计大多数时候都是如此


251
00:09:07,636 --> 00:09:09,586
那么一切正常


252
00:09:09,586 --> 00:09:12,516
你就省了一次往返时长


253
00:09:12,516 --> 00:09:13,766
从而更快速地建立连接


254
00:09:14,426 --> 00:09:15,856
如果请求到一个不同的地址


255
00:09:15,856 --> 00:09:18,156
我们就会给你的


256
00:09:18,156 --> 00:09:19,356
客户端发另一个异步的通知


257
00:09:19,356 --> 00:09:21,416
来告诉它


258
00:09:21,416 --> 00:09:22,666
这里有一个新的地址


259
00:09:22,696 --> 00:09:23,926
也需要进行尝试


260
00:09:24,706 --> 00:09:26,096
想要利用这个特性


261
00:09:26,096 --> 00:09:27,446
你需要与 Happy Eyeballs 算法


262
00:09:27,446 --> 00:09:28,946
一起使用


263
00:09:29,436 --> 00:09:30,996
这意味着你需要


264
00:09:30,996 --> 00:09:32,126
同期进行多个连接


265
00:09:32,996 --> 00:09:33,976
你需要尝试 IPv4 IPv6


266
00:09:34,006 --> 00:09:36,886
多个地址


267
00:09:36,886 --> 00:09:37,756
多个接口


268
00:09:38,566 --> 00:09:39,846
这听起来工作量很大


269
00:09:39,846 --> 00:09:41,356
也很难正确完成


270
00:09:41,516 --> 00:09:42,606
确实如此


271
00:09:42,606 --> 00:09:43,496
确实有很多工作要做


272
00:09:44,096 --> 00:09:46,246
中场休息后回来


273
00:09:46,246 --> 00:09:48,686
我们会告诉你一些新的 API


274
00:09:48,966 --> 00:09:50,406
可以让你在无需做


275
00:09:50,406 --> 00:09:52,346
所有麻烦的工作的情况下 利用此特性


276
00:09:54,526 --> 00:09:56,056
现在我们看一些指导信息


277
00:09:56,726 --> 00:09:58,836
我们见到


278
00:09:59,246 --> 00:10:02,296
很多开发者


279
00:10:02,446 --> 00:10:04,426
都把 SCNetworkReachability


280
00:10:04,556 --> 00:10:05,326
用作预检查


281
00:10:06,396 --> 00:10:07,686
他们想要预测将来


282
00:10:07,916 --> 00:10:09,076
他们想知道


283
00:10:09,076 --> 00:10:10,936
下一个要做的网络操作


284
00:10:10,936 --> 00:10:12,096
会成功还是会失败


285
00:10:12,626 --> 00:10:14,956
然后 不幸的是


286
00:10:14,956 --> 00:10:16,116
预测将来总是


287
00:10:16,116 --> 00:10:16,666
一件困难的事情


288
00:10:17,216 --> 00:10:18,786
现在你可能连着网


289
00:10:19,476 --> 00:10:20,966
但是两秒后


290
00:10:21,026 --> 00:10:22,366
用户走出了这栋建筑


291
00:10:22,366 --> 00:10:24,496
就没有 Wi-Fi 信号了


292
00:10:24,886 --> 00:10:27,656
所以并没有一种方式


293
00:10:27,656 --> 00:10:29,566
可以保证下一个操作能成功


294
00:10:30,486 --> 00:10:32,356
我们常常会看到这样的情况


295
00:10:32,356 --> 00:10:34,326
他们检查预检成功


296
00:10:34,406 --> 00:10:35,686
于是他们去做 结果失败了


297
00:10:36,126 --> 00:10:37,716
他们又回来重新检查


298
00:10:38,526 --> 00:10:41,016
这也有很多工作量


299
00:10:41,016 --> 00:10:42,546
很多临界情况


300
00:10:42,546 --> 00:10:44,026
很多麻烦的事情要处理


301
00:10:44,606 --> 00:10:46,426
比如使用代理的网络


302
00:10:47,606 --> 00:10:48,776
我们可以帮你搞定


303
00:10:50,506 --> 00:10:53,746
只需要使用


304
00:10:53,746 --> 00:10:56,006
waitsForConnectivity 选项来


305
00:10:56,006 --> 00:10:58,616
建立连接就行


306
00:10:58,816 --> 00:11:00,326
你可以从去年的视频中


307
00:11:00,326 --> 00:11:01,526
了解更多


308
00:11:01,966 --> 00:11:03,956
意思是说 如果你需要


309
00:11:03,956 --> 00:11:05,566
一个连接 你告诉系统


310
00:11:05,566 --> 00:11:06,566
说你需要一个连接


311
00:11:06,806 --> 00:11:09,006
如果可以 现在就需要 如果不行 就之后


312
00:11:09,326 --> 00:11:10,976
如果设备当前在飞行模式


313
00:11:10,976 --> 00:11:12,396
那么当它关闭飞行模式时


314
00:11:12,396 --> 00:11:14,216
你的连接就会成功


315
00:11:14,686 --> 00:11:16,266
这比你自己


316
00:11:16,266 --> 00:11:17,866
创建一个重试循环 要简单得多


317
00:11:18,876 --> 00:11:20,466
我们发现开发者会遇到


318
00:11:20,466 --> 00:11:22,456
这样一种情况


319
00:11:22,456 --> 00:11:24,516
如果你需要让用户


320
00:11:24,516 --> 00:11:27,876
在一个表格里提供很多信息


321
00:11:27,876 --> 00:11:29,146
而你又有足够的理由相信


322
00:11:29,146 --> 00:11:31,186
接下来用户会提交失败


323
00:11:31,186 --> 00:11:33,096
所以不想浪费用户的时间


324
00:11:34,126 --> 00:11:35,736
如果你在意这种情况


325
00:11:35,736 --> 00:11:37,366
请在中场休息后回来


326
00:11:37,606 --> 00:11:39,076
因为我们有一种更好的


327
00:11:39,076 --> 00:11:43,166
处理这种问题的办法


328
00:11:43,356 --> 00:11:46,286
一直以来 安全问题都很重要


329
00:11:47,316 --> 00:11:49,696
TLS 1.2 已经十年了 


330
00:11:49,736 --> 00:11:52,256
互联网现在准备转向


331
00:11:52,256 --> 00:11:54,646
它的继承者 TLS 1.3


332
00:11:55,286 --> 00:11:57,566
它有很多提升安全性的特性


333
00:11:58,146 --> 00:12:00,066
类似 TCP Fast Open


334
00:12:00,106 --> 00:12:02,576
会减少连接建立时间


335
00:12:03,496 --> 00:12:05,536
这项标准已经完成


336
00:12:05,716 --> 00:12:07,506
今年早些时候


337
00:12:07,506 --> 00:12:09,286
互联网工程指导小组


338
00:12:09,286 --> 00:12:10,616
批准发布


339
00:12:10,906 --> 00:12:11,726
最终草案


340
00:12:12,586 --> 00:12:14,766
我们在等待


341
00:12:14,766 --> 00:12:16,366
RFC 编辑者


342
00:12:16,366 --> 00:12:17,406
公布正式文档


343
00:12:17,836 --> 00:12:22,246
到那时 我们会默认打开 TLS 1.3


344
00:12:23,326 --> 00:12:25,026
目前在你的配置文件里


345
00:12:25,026 --> 00:12:25,976
还是默认关闭的


346
00:12:27,166 --> 00:12:28,426
你可以按照这里的说明


347
00:12:28,426 --> 00:12:32,636
在你 iOS 和 macOS


348
00:12:32,896 --> 00:12:35,726
App 中启用 TLS 1.3


349
00:12:36,016 --> 00:12:37,386
并且我们希望你现在就启用


350
00:12:37,386 --> 00:12:39,696
因为这样一来 今年晚些时候


351
00:12:39,696 --> 00:12:41,926
当 TLS 1.3 默认打开时


352
00:12:41,926 --> 00:12:45,936
你不会有服务不兼容的问题


353
00:12:46,236 --> 00:12:48,346
所以现在就测试好


354
00:12:48,346 --> 00:12:49,896
确保当今年晚些时候


355
00:12:50,166 --> 00:12:51,946
切换的时候一切正常


356
00:12:56,046 --> 00:12:57,446
有关安全的另一个


357
00:12:57,446 --> 00:12:58,956
新要素是


358
00:12:58,956 --> 00:12:59,676
证书透明度


359
00:12:59,676 --> 00:13:02,116
你可能听说过


360
00:13:02,366 --> 00:13:05,666
有时证书颁发机构


361
00:13:06,036 --> 00:13:07,026
可能是恶意


362
00:13:07,026 --> 00:13:08,986
也可能是无能


363
00:13:08,986 --> 00:13:10,646
会给不符合要求的机构


364
00:13:10,646 --> 00:13:11,196
颁发证书


365
00:13:12,556 --> 00:13:14,046
解决这个问题的方法是


366
00:13:14,046 --> 00:13:16,766
一种叫做 证书透明日志的东西


367
00:13:17,556 --> 00:13:19,426
每个合法的证书颁发机构


368
00:13:19,426 --> 00:13:22,326
每颁发一个证书


369
00:13:22,926 --> 00:13:24,766
现在都需要


370
00:13:24,766 --> 00:13:25,516
公开声明


371
00:13:25,596 --> 00:13:27,076
这些公开声明会记录在公共日志中


372
00:13:27,076 --> 00:13:29,296
供任何人检查


373
00:13:30,236 --> 00:13:31,836
这意味着如果


374
00:13:32,406 --> 00:13:34,436
资质较差的证书颁发机构


375
00:13:34,436 --> 00:13:36,596
颁发了一张假证书


376
00:13:36,596 --> 00:13:37,786
一旦公布


377
00:13:37,786 --> 00:13:40,656
立刻会被发现


378
00:13:40,656 --> 00:13:41,856
如果它们不公布的话


379
00:13:42,186 --> 00:13:43,486
会被客户端发现


380
00:13:44,966 --> 00:13:46,596
这也许是你


381
00:13:46,596 --> 00:13:47,966
很熟悉的一种办法


382
00:13:48,436 --> 00:13:50,356
这里新增的实体是日志


383
00:13:51,186 --> 00:13:52,736
当一个证书颁发机构


384
00:13:52,936 --> 00:13:54,786
给一个服务器颁发证书


385
00:13:54,786 --> 00:13:57,616
它也会在日志上记录


386
00:13:57,616 --> 00:13:59,896
然后日志给服务器


387
00:13:59,896 --> 00:14:01,776
一张签名的宣誓书


388
00:14:02,146 --> 00:14:03,656
证明它的证书已经


389
00:14:03,656 --> 00:14:04,646
被公开记录


390
00:14:04,926 --> 00:14:06,076
然后当客户端连接时


391
00:14:06,166 --> 00:14:08,066
服务器可以把这些信息


392
00:14:08,066 --> 00:14:09,096
提供给客户端


393
00:14:09,096 --> 00:14:11,046
客户端就能够确认


394
00:14:11,046 --> 00:14:12,256
这不仅是签名证书


395
00:14:12,256 --> 00:14:14,236
更是一个被公开记录了的


396
00:14:14,236 --> 00:14:15,786
签名证书


397
00:14:16,916 --> 00:14:18,156
现在假设有一个


398
00:14:18,156 --> 00:14:20,226
资质较差的证书颁发机构


399
00:14:20,326 --> 00:14:23,836
不公开它颁发的异常证书


400
00:14:24,726 --> 00:14:26,426
客户端就会拒绝它


401
00:14:26,426 --> 00:14:27,916
因为它没有宣誓书


402
00:14:27,916 --> 00:14:30,386
能够证明


403
00:14:30,476 --> 00:14:31,826
这张证书存在于公开记录


404
00:14:33,006 --> 00:14:34,286
今年晚些时候起


405
00:14:34,596 --> 00:14:35,896
我们会强制实施这个机制


406
00:14:37,456 --> 00:14:39,806
所有新颁发的 TLS


407
00:14:39,806 --> 00:14:41,726
证书必须包含


408
00:14:41,726 --> 00:14:44,096
确认他们被公开记录的证明


409
00:14:44,486 --> 00:14:46,036
那么如果他们没有被记录


410
00:14:46,036 --> 00:14:47,056
客户端就会拒绝它


411
00:14:47,536 --> 00:14:49,686
你的 App 不需要做任何改动


412
00:14:49,686 --> 00:14:51,926
但是如果你的


413
00:14:51,926 --> 00:14:53,006
服务器有专门的证书


414
00:14:53,006 --> 00:14:56,686
确保你的证书颁发机构


415
00:14:56,686 --> 00:14:58,186
在公开的证书透明日志中


416
00:14:58,306 --> 00:14:59,906
留下了记录


417
00:15:00,486 --> 00:15:03,686
现在 针对硬件开发者


418
00:15:04,246 --> 00:15:05,286
我们有一些新消息


419
00:15:06,286 --> 00:15:08,396
Bonjour Conformance Test 工具


420
00:15:08,396 --> 00:15:10,776
可以让你确认


421
00:15:10,776 --> 00:15:12,386
你的硬件设备


422
00:15:12,386 --> 00:15:13,376
是否正确使用 Bonjour


423
00:15:14,466 --> 00:15:15,946
如果你想要


424
00:15:15,946 --> 00:15:17,086
在你的包装上


425
00:15:17,086 --> 00:15:18,796
使用 Bonjour 商标的名字和标识


426
00:15:18,796 --> 00:15:19,376
你需要运行这个测试


427
00:15:20,256 --> 00:15:21,796
如果你想把 Bonjour for Windows 安装包


428
00:15:21,796 --> 00:15:23,826
与 Windows App 捆绑


429
00:15:23,866 --> 00:15:27,086
也需要运行这个测试


430
00:15:27,696 --> 00:15:28,896
如果你想在包装上使用


431
00:15:28,896 --> 00:15:30,736
隔空打印 隔空播放 CarPlay 车载


432
00:15:30,736 --> 00:15:32,506
HomeKit 标识


433
00:15:33,046 --> 00:15:34,356
通过 Bonjour Conformance Test


434
00:15:34,356 --> 00:15:36,136
是标识授权过程的


435
00:15:36,136 --> 00:15:37,976
一部分 因为


436
00:15:37,976 --> 00:15:39,916
可靠的 Bonjour 是这些产品的


437
00:15:39,916 --> 00:15:41,006
重要组成部分


438
00:15:41,926 --> 00:15:44,056
但更重要的是


439
00:15:44,056 --> 00:15:44,966
运行 Bonjour Conformance Test 的价值


440
00:15:44,966 --> 00:15:46,996
在于它帮你


441
00:15:46,996 --> 00:15:48,136
提升了产品质量


442
00:15:48,136 --> 00:15:50,096
让产品更可靠


443
00:15:50,096 --> 00:15:53,996
从而让你的顾客满意


444
00:15:53,996 --> 00:15:55,536
而不会因为


445
00:15:55,536 --> 00:15:57,756
无法使用你的产品而退货


446
00:15:58,226 --> 00:16:00,196
这正是你的顾客想要的


447
00:16:00,296 --> 00:16:01,066
也是你想要的


448
00:16:01,146 --> 00:16:01,996
更是我们想要的


449
00:16:02,046 --> 00:16:04,426
我们想让顾客开心


450
00:16:04,426 --> 00:16:05,606
与可靠的产品


451
00:16:05,606 --> 00:16:06,436
度过美好的时光


452
00:16:06,436 --> 00:16:11,556
现在我想讲一下对 API 的选择


453
00:16:12,596 --> 00:16:15,776
30 年前我们有了 BSD Sockets


454
00:16:16,396 --> 00:16:18,616
30 年前它是个很棒的 API


455
00:16:19,046 --> 00:16:21,616
但是 30 年前我们口袋里


456
00:16:22,426 --> 00:16:24,476
没有移动计算机


457
00:16:24,546 --> 00:16:26,216
也没有无线网络


458
00:16:26,216 --> 00:16:29,126
没有 IPv6


459
00:16:29,326 --> 00:16:31,026
很多计算机


460
00:16:31,026 --> 00:16:32,746
只有一个网络接口


461
00:16:32,896 --> 00:16:34,936
如果那时候你的电脑上有一个以太网接口


462
00:16:34,936 --> 00:16:36,716
那一定是台很不错的电脑


463
00:16:37,376 --> 00:16:40,236
现在世界上有 40 亿人


464
00:16:40,236 --> 00:16:42,806
拥有多宿主的 IPv6 的


465
00:16:43,136 --> 00:16:46,226
无线的 内置电池的计算设备


466
00:16:46,226 --> 00:16:47,456
具备电池管理功能


467
00:16:47,456 --> 00:16:48,116
可以休眠以节省电量


468
00:16:48,496 --> 00:16:49,716
这个世界变得


469
00:16:49,716 --> 00:16:50,376
复杂了许多


470
00:16:52,056 --> 00:16:53,246
你们中很多人可能


471
00:16:53,246 --> 00:16:55,326
正在使用一些基于


472
00:16:55,376 --> 00:16:57,016
Sockets 的第三方库


473
00:16:57,686 --> 00:16:59,996
而更多人可能在用


474
00:16:59,996 --> 00:17:00,816
URLSession


475
00:17:01,306 --> 00:17:03,006
而你可能会以为


476
00:17:03,006 --> 00:17:05,626
URLSession 也只是在


477
00:17:05,626 --> 00:17:06,556
Sockets 外面包了一层


478
00:17:07,906 --> 00:17:09,526
好吧 并不太一样


479
00:17:11,006 --> 00:17:13,046
URLSession 实际上建立在


480
00:17:13,326 --> 00:17:15,445
Apple 的用户空间


481
00:17:15,656 --> 00:17:17,856
网络代码 Network.framework 上的


482
00:17:18,346 --> 00:17:21,306
从现在开始 在 iOS 12 上


483
00:17:21,306 --> 00:17:23,976
我们会把 URLSession 使用的 API


484
00:17:23,976 --> 00:17:26,056
开放出来 这样你的


485
00:17:26,056 --> 00:17:29,316
App 可以直接用这个 API


486
00:17:29,486 --> 00:17:31,986
建立 TCP 连接


487
00:17:31,986 --> 00:17:33,266
或者做其他合理的事情


488
00:17:33,526 --> 00:17:35,266
如果你在使用 URL


489
00:17:35,266 --> 00:17:37,356
和 HTTP GET


490
00:17:37,356 --> 00:17:38,716
URLSession 仍然是 API 中的不二选择


491
00:17:39,056 --> 00:17:41,116
而对于 URLSession 做不了的事情


492
00:17:41,116 --> 00:17:43,316
我们现在开放了


493
00:17:43,316 --> 00:17:45,766
Network.framework


494
00:17:45,766 --> 00:17:46,896
你的 App 可以直接使用


495
00:17:47,876 --> 00:17:49,816
并且如果你是某个


496
00:17:49,816 --> 00:17:50,896
基于 BSD Sockets 的


497
00:17:50,896 --> 00:17:54,156
第三方库的开发者


498
00:17:54,156 --> 00:17:56,606
希望你可以


499
00:17:56,606 --> 00:17:59,216
关注 Network.framework 的 API


500
00:17:59,596 --> 00:18:02,016
把你的库转移到


501
00:18:02,016 --> 00:18:04,326
基于这些优化的高性能 API 上


502
00:18:04,926 --> 00:18:07,886
然后告诉我们效果如何


503
00:18:08,866 --> 00:18:11,086
总结一下


504
00:18:11,086 --> 00:18:13,786
我们在此强烈建议


505
00:18:14,076 --> 00:18:18,296
现在是 2018 年了 应该避免使用 BSD Sockets


506
00:18:18,686 --> 00:18:20,756
不要使用那些仅仅在


507
00:18:20,756 --> 00:18:22,706
BSD Sockets 外面


508
00:18:22,706 --> 00:18:23,316
包了一层的库


509
00:18:23,766 --> 00:18:25,146
而如果你是使用这些


510
00:18:25,146 --> 00:18:27,146
老旧的 API 的库的作者


511
00:18:27,146 --> 00:18:30,116
请考虑一下切换过来


512
00:18:30,116 --> 00:18:32,056
今天下午或者明天


513
00:18:32,106 --> 00:18:34,106
请来实验室和我们交流


514
00:18:34,236 --> 00:18:36,246
告诉我们如果把你的库转移到


515
00:18:36,246 --> 00:18:37,816
新的 API 上


516
00:18:38,046 --> 00:18:39,076
都需要做什么


517
00:18:40,076 --> 00:18:41,316
说到这里


518
00:18:41,316 --> 00:18:43,106
我想请我的同事 Jiten


519
00:18:43,106 --> 00:18:44,996
来到台上与你们分享


520
00:18:45,166 --> 00:18:46,816
更多关于 URLSession 的细节


521
00:18:47,516 --> 00:18:51,976
[ 掌声 ]


522
00:18:52,476 --> 00:18:53,086
>> 谢谢 Stuart


523
00:18:53,686 --> 00:18:55,176
大家早上好


524
00:18:55,726 --> 00:18:57,416
我叫 Jiten Mehta


525
00:18:57,416 --> 00:18:59,316
我是 CFNetwork 团队的一名工程师


526
00:19:00,266 --> 00:19:01,326
今天我想和你们聊聊


527
00:19:01,326 --> 00:19:02,666
关于你们 App 的


528
00:19:02,666 --> 00:19:03,956
一些网络最佳实践


529
00:19:05,396 --> 00:19:07,076
网络是每个 App


530
00:19:07,076 --> 00:19:08,386
必不可少的一部分


531
00:19:09,346 --> 00:19:10,616
每年你们都会给


532
00:19:10,616 --> 00:19:12,276
你们的 App 增加一些


533
00:19:12,276 --> 00:19:12,986
非常棒的功能


534
00:19:13,406 --> 00:19:14,976
那么今天我会与你们聊聊


535
00:19:15,136 --> 00:19:16,706
一些简单的


536
00:19:16,706 --> 00:19:19,086
有关网络的细节


537
00:19:19,086 --> 00:19:20,236
让你的 App 更好


538
00:19:20,796 --> 00:19:24,836
我们今天计划


539
00:19:24,836 --> 00:19:27,296
讲四类问题


540
00:19:27,296 --> 00:19:29,926
减少延迟 最大化吞吐量


541
00:19:31,036 --> 00:19:33,396
提升响应度


542
00:19:33,396 --> 00:19:34,876
更好地利用


543
00:19:34,876 --> 00:19:35,596
系统资源


544
00:19:36,806 --> 00:19:38,506
在这之前


545
00:19:38,506 --> 00:19:40,386
我们快速回顾一下


546
00:19:40,386 --> 00:19:40,976
你们一直在用的 API URLSession


547
00:19:45,526 --> 00:19:47,956
URLSession 是一个


548
00:19:48,106 --> 00:19:50,306
Apple 的全平台可用的


549
00:19:50,686 --> 00:19:52,976
高级网络 API


550
00:19:54,426 --> 00:19:56,766
URLSession 对 HTTP/2 和 HTTP/1.1


551
00:19:56,766 --> 00:20:00,746
的支持是一流的


552
00:20:02,056 --> 00:20:04,136
如果你的 App 不使用 HTTP


553
00:20:04,136 --> 00:20:05,966
我们也支持


554
00:20:06,066 --> 00:20:09,226
URLSessionStreamTask


555
00:20:09,226 --> 00:20:11,056
这个 API 让你确保


556
00:20:11,056 --> 00:20:12,946
你可以在与服务器的 TCP 连接中


557
00:20:13,256 --> 00:20:15,796
建立任意的协议


558
00:20:17,136 --> 00:20:18,656
这是 URLSession


559
00:20:19,716 --> 00:20:20,866
我们来说说第一项


560
00:20:20,866 --> 00:20:23,926
减少延迟


561
00:20:25,296 --> 00:20:26,246
假设你和你的朋友


562
00:20:26,246 --> 00:20:28,096
去一个餐馆


563
00:20:28,226 --> 00:20:29,706
服务员走向你们 


564
00:20:29,706 --> 00:20:31,866
你说 “请给我一杯水可以吗？”


565
00:20:32,746 --> 00:20:34,576
服务员说 “没问题” 后离开


566
00:20:34,576 --> 00:20:36,196
然后给你拿了一杯水


567
00:20:37,016 --> 00:20:38,366
你的朋友说 


568
00:20:38,366 --> 00:20:39,406
“也请给我一杯水 可以吗？”


569
00:20:40,066 --> 00:20:41,386
服务员说 “没问题” 后离开


570
00:20:41,386 --> 00:20:43,876
然后给你的朋友拿了一杯水


571
00:20:44,526 --> 00:20:45,576
如果服务员一次性获知


572
00:20:45,576 --> 00:20:46,836
每个人想要的东西


573
00:20:46,836 --> 00:20:48,556
从而减少来回当趟数


574
00:20:48,556 --> 00:20:49,486
不是会更快吗


575
00:20:50,816 --> 00:20:52,746
减少延迟的方法很简单


576
00:20:53,536 --> 00:20:54,966
当你获取一项资源时


577
00:20:54,966 --> 00:20:56,696
减少往返的次数即可


578
00:20:57,626 --> 00:21:01,936
现在我们看看你的 App 如何做到这点


579
00:21:02,136 --> 00:21:03,796
首先我们看一下


580
00:21:03,796 --> 00:21:05,446
HTTP/1.1 的一些问题


581
00:21:06,896 --> 00:21:07,846
你的 App 需要获取资源


582
00:21:07,846 --> 00:21:10,486
你可以创建一个 URLSession 任务


583
00:21:10,486 --> 00:21:13,196
然后调用 resume


584
00:21:14,146 --> 00:21:16,626
URLSession 会为你创建


585
00:21:16,626 --> 00:21:21,136
一个包含 DNS TCP 和 TLS 的新连接


586
00:21:22,626 --> 00:21:25,606
一旦和服务器的连接被建立 


587
00:21:25,606 --> 00:21:26,656
你的请求会被发出


588
00:21:27,256 --> 00:21:30,046
然后等待从服务器


589
00:21:30,046 --> 00:21:32,446
返回的回应


590
00:21:32,656 --> 00:21:34,176
这就是网络的闲时


591
00:21:34,356 --> 00:21:35,666
你的 App 没有做任何跟


592
00:21:35,666 --> 00:21:37,096
网络相关的事情


593
00:21:37,096 --> 00:21:40,486
只是在等服务器的回应


594
00:21:40,596 --> 00:21:42,616
一旦得到回应


595
00:21:42,616 --> 00:21:44,376
我们会调用你的完成代码块


596
00:21:44,376 --> 00:21:46,156
或向你的 Delegate 发消息


597
00:21:46,156 --> 00:21:47,366
告知已经完成加载


598
00:21:47,946 --> 00:21:50,446
假设在加载的过程中


599
00:21:50,446 --> 00:21:51,676
你的 App 想要从


600
00:21:51,676 --> 00:21:53,756
同一服务器获取另一项资源


601
00:21:54,376 --> 00:21:56,346
你可以再创建一个


602
00:21:56,406 --> 00:21:58,776
URLSession 任务并调用 resume


603
00:21:59,346 --> 00:22:01,766
然后 URLSession 会创建一个新的


604
00:22:01,766 --> 00:22:03,126
连接以获取这个资源


605
00:22:03,126 --> 00:22:04,726
因为它在连接池中


606
00:22:04,726 --> 00:22:06,676
并没有空闲的连接


607
00:22:08,136 --> 00:22:09,336
如果你的 App 又要


608
00:22:09,336 --> 00:22:10,576
从同一服务器再获取


609
00:22:10,576 --> 00:22:12,616
一项资源 你可以再创建


610
00:22:12,616 --> 00:22:14,726
一个 URLSession 任务并调用 resume


611
00:22:15,126 --> 00:22:16,196
然后为了获取资源


612
00:22:16,196 --> 00:22:17,856
会再创建一个新的连接


613
00:22:18,376 --> 00:22:21,236
在这个例子中


614
00:22:21,236 --> 00:22:24,236
我们为了从同一个服务器获取资源


615
00:22:24,306 --> 00:22:26,356
创建了 3 个不同的连接


616
00:22:27,726 --> 00:22:29,246
你可能注意到了


617
00:22:29,246 --> 00:22:31,076
我们花了很多时间创建新连接


618
00:22:31,606 --> 00:22:33,466
我们再看看如果


619
00:22:33,466 --> 00:22:35,716
你只用一个连接会怎样


620
00:22:38,416 --> 00:22:40,306
这是单一连接的情况


621
00:22:41,006 --> 00:22:42,436
因为没有不断创建新连接


622
00:22:42,436 --> 00:22:44,366
我们省了很多时间


623
00:22:44,366 --> 00:22:45,456
但这里有另一个问题


624
00:22:46,636 --> 00:22:48,406
请求 2 也就是绿色的请求


625
00:22:48,406 --> 00:22:50,416
必须要等待


626
00:22:50,586 --> 00:22:52,316
请求 1 的回应


627
00:22:52,316 --> 00:22:53,056
被完全接收


628
00:22:54,216 --> 00:22:57,196
请求 3 也有同样的问题


629
00:22:57,196 --> 00:22:59,016
也就是橘黄色的请求


630
00:22:59,016 --> 00:23:01,116
必须等请求 2 的回应


631
00:23:01,356 --> 00:23:02,286
被完全接收


632
00:23:03,436 --> 00:23:05,666
这个问题被称为


633
00:23:05,666 --> 00:23:06,746
HTTP 队头阻塞


634
00:23:08,096 --> 00:23:10,406
现在来考虑 HTTP/2 


635
00:23:11,676 --> 00:23:14,126
HTTP/2 使用单一连接


636
00:23:14,496 --> 00:23:16,166
并且也解决了


637
00:23:16,166 --> 00:23:17,866
HTTP 队头阻塞的问题


638
00:23:18,396 --> 00:23:21,956
HTTP/2 在一条连接上


639
00:23:21,956 --> 00:23:24,156
多路传输多条数据流


640
00:23:24,696 --> 00:23:29,136
让你可以同时收到多个回应


641
00:23:29,666 --> 00:23:32,456
我们再来仔细分析一下这个例子


642
00:23:32,456 --> 00:23:34,966
看看 HTTP/2


643
00:23:35,026 --> 00:23:37,166
是怎样比 HTTP/1.1 表现得更好的


644
00:23:39,456 --> 00:23:41,406
注意以下这些时间节点


645
00:23:41,406 --> 00:23:42,656
当你的 App 试图


646
00:23:42,656 --> 00:23:44,806
获取资源的时候


647
00:23:44,806 --> 00:23:45,966
当请求被发送出去的时候


648
00:23:47,206 --> 00:23:50,156
如果使用 HTTP/1.1


649
00:23:50,156 --> 00:23:52,306
从你的 App


650
00:23:52,306 --> 00:23:53,676
需要资源起


651
00:23:53,676 --> 00:23:55,126
到请求被发送之间


652
00:23:55,126 --> 00:23:56,106
有明显的延迟


653
00:23:57,336 --> 00:24:00,336
HTTP/2 能显著减少


654
00:24:00,336 --> 00:24:02,916
这个延迟


655
00:24:02,916 --> 00:24:04,636
在每当 App 需要资源时


656
00:24:04,636 --> 00:24:06,866
基本上立刻发送请求


657
00:24:07,306 --> 00:24:12,576
再来看一下这些灰色的方块


658
00:24:13,446 --> 00:24:14,946
如果你还记得


659
00:24:14,946 --> 00:24:17,016
这是你的 App 没有做任何


660
00:24:17,016 --> 00:24:18,546
跟网络相关的事时的空闲时间


661
00:24:18,836 --> 00:24:21,476
只是在等待服务器的回应


662
00:24:22,736 --> 00:24:25,606
HTTP/2 能显著减少


663
00:24:25,656 --> 00:24:27,876
这样的网络闲时


664
00:24:27,876 --> 00:24:29,376
允许你更充分地利用带宽


665
00:24:35,476 --> 00:24:37,236
我们刚才讨论了


666
00:24:37,236 --> 00:24:40,186
HTTP/2 相比 HTTP/1.1 的


667
00:24:40,636 --> 00:24:41,726
许多优点


668
00:24:41,726 --> 00:24:41,926
简单总结一下


669
00:24:43,166 --> 00:24:45,086
HTTP/2 在 HTTP 层面


670
00:24:45,086 --> 00:24:47,146
解决了队头阻塞问题


671
00:24:47,476 --> 00:24:49,696
它同时允许你更充分地


672
00:24:49,696 --> 00:24:50,686
利用带宽


673
00:24:52,286 --> 00:24:54,786
如果你的 App 使用 URLSession


674
00:24:54,786 --> 00:24:55,826
你不需要对客户端


675
00:24:55,826 --> 00:24:57,016
做任何改动


676
00:24:57,926 --> 00:25:00,556
仅需在服务器上启用 HTTP/2


677
00:25:00,556 --> 00:25:02,246
你就能看到这些改善


678
00:25:03,736 --> 00:25:06,246
采用 HTTP/2 同时也能使你


679
00:25:06,246 --> 00:25:07,996
在服务器端有所改善


680
00:25:08,466 --> 00:25:10,296
因为那些运行你的 App 的设备


681
00:25:10,296 --> 00:25:15,066
与服务器连接次数变少了


682
00:25:15,166 --> 00:25:17,286
今年 我们在 URLSession 里有一些


683
00:25:17,386 --> 00:25:19,346
新东西 可以作为


684
00:25:19,346 --> 00:25:23,946
HTTP/2 优势的补充


685
00:25:24,196 --> 00:25:26,496
下面我们介绍针对 URLSession 的 


686
00:25:26,496 --> 00:25:28,106
HTTP/2 Connection Coalescing


687
00:25:28,586 --> 00:25:32,376
HTTP/2 Connection Coalescing 将会


688
00:25:32,376 --> 00:25:35,036
让连接被更充分利用


689
00:25:36,556 --> 00:25:39,226
因为你的 App 不会再一直


690
00:25:39,226 --> 00:25:40,886
建立新连接


691
00:25:40,886 --> 00:25:44,276
对用户的响应会更加及时


692
00:25:45,636 --> 00:25:46,906
从 WWDC 配置文件开始


693
00:25:46,906 --> 00:25:50,866
HTTP/2 Connection Coalescing


694
00:25:50,866 --> 00:25:52,246
会自动在所有使用


695
00:25:52,246 --> 00:25:55,026
URLSession 的 App 上启用


696
00:25:56,296 --> 00:25:57,976
现在我们来看看 HTTP/2


697
00:25:57,976 --> 00:25:59,676
Connection Coalescing


698
00:25:59,676 --> 00:26:00,356
怎样决定重用连接的


699
00:26:00,886 --> 00:26:05,516
假设你有一个 App


700
00:26:05,516 --> 00:26:06,806
这个 App 想要获得


701
00:26:06,806 --> 00:26:09,586
来自 menu.example.com 的资源


702
00:26:10,746 --> 00:26:12,526
我们建立一个与服务器的连接


703
00:26:12,606 --> 00:26:14,806
然后服务器给我们一个证书


704
00:26:16,076 --> 00:26:18,206
如果你的 App 想要获得另一项


705
00:26:18,446 --> 00:26:21,026
处于 delivery.example.com 上的资源


706
00:26:21,026 --> 00:26:22,486
我们建立另一个连接


707
00:26:22,486 --> 00:26:24,066
服务器再给我们另一个证书


708
00:26:25,436 --> 00:26:27,526
在这种旧的运作模式下


709
00:26:27,646 --> 00:26:29,556
URLSession 会从给定的主机名上


710
00:26:29,556 --> 00:26:31,366
创建两个连接


711
00:26:31,366 --> 00:26:33,236
来获取这些资源


712
00:26:33,726 --> 00:26:36,836
但如果你细想一下


713
00:26:36,936 --> 00:26:39,016
提供给我们的第一个证书


714
00:26:39,016 --> 00:26:41,596
覆盖了 example.com 下的所有子域名


715
00:26:41,796 --> 00:26:44,606
这意味着


716
00:26:44,946 --> 00:26:48,536
delivery.example.com 也被


717
00:26:48,566 --> 00:26:50,316
第一个证书包含在内


718
00:26:50,356 --> 00:26:51,506
同时也注意到


719
00:26:51,716 --> 00:26:54,146
delivery.example.com 和第一个连接


720
00:26:54,146 --> 00:26:56,886
导向的 IP 地址一样


721
00:26:57,426 --> 00:27:00,406
到这里 我们完全可以


722
00:27:00,406 --> 00:27:01,486
假定与我们对话的是同一个端点


723
00:27:01,486 --> 00:27:03,796
那么当我们需要获取


724
00:27:03,796 --> 00:27:05,726
第二个资源时可以重用连接 


725
00:27:05,726 --> 00:27:07,346
而不是重新建立


726
00:27:07,346 --> 00:27:08,406
一个新的连接 


727
00:27:09,126 --> 00:27:10,506
这么做节省了时间


728
00:27:10,506 --> 00:27:11,936
因为不需要建立一个新的连接


729
00:27:11,936 --> 00:27:13,316
这会让加载速度快很多


730
00:27:13,896 --> 00:27:16,086
这就是 HTTP/2 Connection Coalescing


731
00:27:16,086 --> 00:27:22,156
在 iOS 12 和 macOS Mojave 中的新特性


732
00:27:23,416 --> 00:27:26,296
现在让我们看一下


733
00:27:26,386 --> 00:27:28,716
如何通过减少 URLSession 对象的使用


734
00:27:28,716 --> 00:27:29,826
来减少延迟


735
00:27:30,356 --> 00:27:34,656
在刚才的几页幻灯片中


736
00:27:34,656 --> 00:27:36,876
我们讨论的所有


737
00:27:36,876 --> 00:27:38,876
有关连接的好处


738
00:27:38,876 --> 00:27:41,306
都只在你用同一个


739
00:27:41,306 --> 00:27:43,546
URLSession 对象


740
00:27:43,546 --> 00:27:44,916
创建任务的情况下生效


741
00:27:47,016 --> 00:27:48,876
以下这点也同样重要


742
00:27:48,936 --> 00:27:51,586
每个 URLSession 对象都有


743
00:27:51,586 --> 00:27:53,206
一个连接池


744
00:27:53,206 --> 00:27:54,506
当你创建多个


745
00:27:54,506 --> 00:27:56,106
URLSession 对象


746
00:27:56,106 --> 00:27:57,606
你无法得到任何有关


747
00:27:57,606 --> 00:27:58,026
连接的好处


748
00:27:59,066 --> 00:28:01,306
同时也需要说明的是


749
00:28:01,356 --> 00:28:02,726
创建 URLSession 对象


750
00:28:02,726 --> 00:28:04,846
相对来说性能消耗不低


751
00:28:04,846 --> 00:28:06,206
并且在内存方面的占用


752
00:28:06,206 --> 00:28:06,676
不能忽略不计


753
00:28:08,036 --> 00:28:09,776
和以前一样


754
00:28:09,816 --> 00:28:11,726
我们仍然建议你使用


755
00:28:11,726 --> 00:28:13,466
尽可能少的 URLSession 对象


756
00:28:13,986 --> 00:28:17,496
让我们开始今天的下一个话题


757
00:28:17,496 --> 00:28:19,796
最大化吞吐量


758
00:28:19,796 --> 00:28:23,156
回到我们那个餐馆的例子


759
00:28:23,986 --> 00:28:25,956
服务员问你要什么


760
00:28:25,956 --> 00:28:30,206
然后你说 “来一份烤鸡拌酱汁


761
00:28:30,206 --> 00:28:32,006
酱汁要奶油番茄洋葱肉汁


762
00:28:32,006 --> 00:28:32,646
要用大量黄油做”


763
00:28:33,906 --> 00:28:34,846
那真是相当绕口


764
00:28:35,656 --> 00:28:36,596
如果这样会不会就简单得多


765
00:28:36,596 --> 00:28:38,356
就说“我要一份黄油鸡”


766
00:28:39,936 --> 00:28:41,556
最大化吞吐量的方法


767
00:28:41,556 --> 00:28:43,216
也是一样的


768
00:28:43,216 --> 00:28:44,296
每当你想要获取资源


769
00:28:44,296 --> 00:28:46,536
减少你传输的数据量


770
00:28:47,306 --> 00:28:48,686
我们来看看你的 App


771
00:28:48,686 --> 00:28:49,036
如何做到这点


772
00:28:49,116 --> 00:28:52,796
有几种方法


773
00:28:52,796 --> 00:28:55,086
来减少请求的大小


774
00:28:55,956 --> 00:28:58,246
请注意 HTTP Cookies


775
00:28:59,076 --> 00:29:01,646
不是无代价的


776
00:29:01,646 --> 00:29:03,216
储存和查找他们


777
00:29:03,216 --> 00:29:03,846
都消耗空间和时间


778
00:29:05,256 --> 00:29:08,676
Cookies 附加于所有符合域


779
00:29:08,676 --> 00:29:09,946
和路径的属性的请求上


780
00:29:10,506 --> 00:29:11,856
这会极大增加


781
00:29:11,856 --> 00:29:12,636
你的请求大小


782
00:29:13,996 --> 00:29:17,966
请善用域和路径的属性


783
00:29:17,966 --> 00:29:19,826
来确保服务器需要的 Cookies 


784
00:29:19,896 --> 00:29:21,306
附在你的请求上


785
00:29:22,526 --> 00:29:23,756
使用尽可能少的 Cookies


786
00:29:23,756 --> 00:29:25,336
并当你不再需要


787
00:29:25,336 --> 00:29:26,606
它们的时候


788
00:29:26,606 --> 00:29:26,846
及时删除


789
00:29:28,226 --> 00:29:29,896
试着把一些状态保存在服务器上


790
00:29:29,896 --> 00:29:31,686
这样你就能减少


791
00:29:31,686 --> 00:29:33,246
客户端上的 Cookies


792
00:29:33,716 --> 00:29:36,856
同时也请考虑转换到 HTTP/2


793
00:29:37,326 --> 00:29:39,356
从而获得头部压缩的好处


794
00:29:39,906 --> 00:29:43,176
我们再来多聊聊压缩


795
00:29:43,706 --> 00:29:48,646
HTTP 压缩


796
00:29:48,646 --> 00:29:51,126
即储存信息与编码


797
00:29:51,176 --> 00:29:53,026
其实就是压缩那些


798
00:29:53,026 --> 00:29:56,096
穿梭于客户端与服务器之间的数据


799
00:29:56,096 --> 00:29:58,276
这使得我们可以更好地利用带宽


800
00:29:59,706 --> 00:30:02,046
URLSession 支持与推荐的


801
00:30:02,246 --> 00:30:05,796
算法是 Gzip 和 Brotli


802
00:30:07,226 --> 00:30:09,756
Gzip 被广泛支持


803
00:30:09,756 --> 00:30:10,706
而且相对较快


804
00:30:11,906 --> 00:30:13,616
Brotli 的支持出现在


805
00:30:13,616 --> 00:30:16,686
去年发布 iOS 11 和 macOS


806
00:30:16,686 --> 00:30:17,356
High Sierra 时


807
00:30:18,626 --> 00:30:20,076
Brotli 为结构化的文本


808
00:30:20,076 --> 00:30:22,136
和 HTML 做了优化


809
00:30:22,136 --> 00:30:24,356
而且它在短数据上


810
00:30:24,356 --> 00:30:26,726
具有最优的压缩率


811
00:30:27,416 --> 00:30:29,196
如果你还没有启用压缩的话


812
00:30:29,196 --> 00:30:31,476
请在你的服务器上启用


813
00:30:32,016 --> 00:30:34,986
让我们继续今天的下一个话题


814
00:30:34,986 --> 00:30:37,926
提升响应度


815
00:30:39,146 --> 00:30:40,926
回到我们餐馆的例子


816
00:30:40,926 --> 00:30:42,906
你来圣何塞参加 WWDC


817
00:30:42,906 --> 00:30:44,656
你决定去见见


818
00:30:44,656 --> 00:30:45,986
一些老朋友


819
00:30:46,116 --> 00:30:48,086
你和你的朋友就坐在


820
00:30:48,086 --> 00:30:49,056
餐馆的餐桌旁


821
00:30:49,636 --> 00:30:51,456
你的饮料上来了


822
00:30:51,456 --> 00:30:52,746
但是你想要更多时间


823
00:30:52,746 --> 00:30:53,866
来和你的朋友们叙叙旧


824
00:30:53,966 --> 00:30:55,216
而不是直接上菜吃饭


825
00:30:56,216 --> 00:30:57,346
你可以简单地跟服务员说


826
00:30:58,076 --> 00:30:58,956
“请你过一会


827
00:30:58,956 --> 00:30:59,926
再上菜可以吗？


828
00:30:59,926 --> 00:31:01,216
我们不赶时间”


829
00:31:02,226 --> 00:31:03,646
这里有一个同样的理念


830
00:31:03,646 --> 00:31:05,366
可以被应用在响应度上


831
00:31:05,366 --> 00:31:06,866
你根据你正在进行的


832
00:31:07,096 --> 00:31:09,166
其它任务给你的任务标上优先级


833
00:31:10,106 --> 00:31:11,306
我们来看看你的 App


834
00:31:11,306 --> 00:31:12,186
可以如何从中获益


835
00:31:12,566 --> 00:31:16,936
你也许很熟悉


836
00:31:16,936 --> 00:31:19,756
跟派遣队列和 NSOperation


837
00:31:19,756 --> 00:31:22,026
对象有关的


838
00:31:22,026 --> 00:31:22,666
这五个 QoS 类


839
00:31:23,616 --> 00:31:24,976
数据需要依靠


840
00:31:24,976 --> 00:31:26,096
CPU 的调度策略


841
00:31:27,656 --> 00:31:31,156
URLSession 是对 QoS 敏感的


842
00:31:31,156 --> 00:31:33,356
意味着它可以在


843
00:31:33,426 --> 00:31:36,146
你调用 task.resume 的队列中采集 QoS


844
00:31:37,156 --> 00:31:38,646
它发给你的 Delegate 的


845
00:31:38,646 --> 00:31:41,086
所有消息都会遵守这个 QoS


846
00:31:41,086 --> 00:31:44,196
举个例子


847
00:31:45,246 --> 00:31:46,986
如果你的 App 想要获取一些


848
00:31:46,986 --> 00:31:48,786
与时间无关的数据


849
00:31:49,406 --> 00:31:51,476
考虑在一个有后台 QoS 的队列上


850
00:31:51,476 --> 00:31:53,356
继续这个任务


851
00:31:54,026 --> 00:31:56,056
保证这个任务不会


852
00:31:56,056 --> 00:31:58,066
与其他正在做的


853
00:31:58,066 --> 00:31:59,436
更高优先级的工作


854
00:31:59,436 --> 00:32:04,016
争夺 CPU 资源


855
00:32:04,186 --> 00:32:06,086
网络服务类型


856
00:32:06,086 --> 00:32:08,156
是 URLSession 配置对象上的


857
00:32:08,226 --> 00:32:10,946
一个属性 可以让你


858
00:32:10,946 --> 00:32:12,916
将你的网络流量分类


859
00:32:12,916 --> 00:32:15,596
从而帮助系统提升


860
00:32:15,596 --> 00:32:17,926
将要离开设备的数据的优先级


861
00:32:19,276 --> 00:32:21,236
今年 我们有了一个


862
00:32:21,236 --> 00:32:22,276
新的网络服务类型


863
00:32:22,276 --> 00:32:23,346
就是 responsiveData


864
00:32:24,656 --> 00:32:26,676
responsiveData 比默认的类型


865
00:32:26,676 --> 00:32:28,596
优先级稍高


866
00:32:28,596 --> 00:32:30,416
但是应该被合理利用


867
00:32:31,446 --> 00:32:32,906
举个你应该使用


868
00:32:32,906 --> 00:32:35,606
responsiveData 的例子


869
00:32:35,606 --> 00:32:37,856
如果你有个购物的 App


870
00:32:37,856 --> 00:32:38,786
在结算页面


871
00:32:39,586 --> 00:32:40,816
你应该把支付请求


872
00:32:40,886 --> 00:32:42,346
标记为 responsiveData


873
00:32:42,346 --> 00:32:44,376
来保证可以从


874
00:32:44,376 --> 00:32:46,636
服务器得到响应


875
00:32:48,096 --> 00:32:49,766
用网络服务类型属性


876
00:32:49,766 --> 00:32:51,676
标记的流量


877
00:32:51,676 --> 00:32:53,986
在 Cisco Fast Lane 上跳转时


878
00:32:53,986 --> 00:32:56,886
会一直保留这个标记


879
00:32:58,026 --> 00:32:59,516
有关这个 API 的更多信息


880
00:32:59,516 --> 00:33:02,226
请查看 2016 年的


881
00:33:02,226 --> 00:33:08,086
有关部分


882
00:33:08,086 --> 00:33:09,736
去年我们介绍了


883
00:33:09,736 --> 00:33:11,556
URLSession 自适应


884
00:33:11,556 --> 00:33:12,896
连接 API


885
00:33:13,376 --> 00:33:14,596
waitsForConnectivity


886
00:33:15,976 --> 00:33:18,106
waitsForConnectivity 会一直等待


887
00:33:18,106 --> 00:33:20,736
而不是在你的任务没有


888
00:33:21,176 --> 00:33:22,616
连接的时候


889
00:33:22,666 --> 00:33:23,246
直接加载失败


890
00:33:24,606 --> 00:33:26,006
过去 你们一直在用


891
00:33:26,006 --> 00:33:28,016
STNeworkReachability


892
00:33:28,016 --> 00:33:30,426
来完成发送请求前的预先检查


893
00:33:31,126 --> 00:33:32,486
但是正如 Stuart 刚指出的


894
00:33:32,486 --> 00:33:34,296
这其实是一场赛跑


895
00:33:34,296 --> 00:33:37,046
因为系统可能告诉你


896
00:33:37,046 --> 00:33:39,186
你连上了一个服务器


897
00:33:39,186 --> 00:33:40,406
但是当你创建并发出请求的时候


898
00:33:40,406 --> 00:33:41,946
你已经失去了机会


899
00:33:41,946 --> 00:33:45,826
你不再与服务器连接着了


900
00:33:45,826 --> 00:33:46,776
我们推荐使用


901
00:33:46,776 --> 00:33:48,406
waitsForConnectivity


902
00:33:48,406 --> 00:33:50,316
它会在连接一旦可用时


903
00:33:50,316 --> 00:33:52,496
把你的请求发出去


904
00:33:53,946 --> 00:33:58,066
你也可以执行 taskIsWaitigForConnectivity


905
00:33:58,066 --> 00:33:59,786
Delegate 方法


906
00:33:59,786 --> 00:34:01,896
它会在你的任务无连接时被调用


907
00:34:03,286 --> 00:34:04,876
这会在为用户呈现


908
00:34:04,876 --> 00:34:06,426
另一个流程或者离线的 UI 时


909
00:34:06,686 --> 00:34:09,766
带来更好的用户体验


910
00:34:11,376 --> 00:34:13,085
有关这个 API 的更多信息


911
00:34:13,085 --> 00:34:15,396
请看去年 WWDC


912
00:34:15,396 --> 00:34:18,246
介绍这个 API 的有关会谈


913
00:34:18,246 --> 00:34:21,716
现在我们来看今天的


914
00:34:21,716 --> 00:34:23,676
最后一个话题


915
00:34:23,676 --> 00:34:25,496
更好地利用系统资源


916
00:34:26,606 --> 00:34:28,045
回到我们餐馆的例子


917
00:34:28,496 --> 00:34:30,896
你很喜欢这里的食物


918
00:34:31,036 --> 00:34:32,505
你决定第二天


919
00:34:32,505 --> 00:34:33,755
来这里吃晚饭


920
00:34:35,025 --> 00:34:36,366
餐馆有外送服务


921
00:34:36,366 --> 00:34:38,255
你可以今天下单


922
00:34:38,255 --> 00:34:40,166
他们第二天会


923
00:34:40,166 --> 00:34:41,896
把餐品送到你家


924
00:34:42,735 --> 00:34:44,616
这不仅帮你省掉了


925
00:34:44,616 --> 00:34:46,376
去取食物耗费的时间和精力


926
00:34:46,376 --> 00:34:48,366
还帮助餐馆


927
00:34:48,366 --> 00:34:50,056
根据你的截止时间


928
00:34:50,226 --> 00:34:51,295
更好地确定工作的优先级


929
00:34:52,496 --> 00:34:54,366
让我们来看看你的 App 如何


930
00:34:54,366 --> 00:34:56,266
更好地利用系统资源


931
00:34:56,266 --> 00:34:57,326
从而提升效率


932
00:35:00,056 --> 00:35:02,206
后台会话有上传


933
00:35:02,206 --> 00:35:03,456
和下载的任务


934
00:35:04,456 --> 00:35:06,156
这些任务让


935
00:35:06,156 --> 00:35:08,046
系统智能地决定何时开始


936
00:35:08,046 --> 00:35:09,876
以及何时结束下载


937
00:35:09,876 --> 00:35:11,926
这个决定基于很多因素


938
00:35:11,926 --> 00:35:15,726
例如电量 CPU Wi-Fi 等等


939
00:35:17,616 --> 00:35:19,276
如果你的 App 想要下载


940
00:35:19,276 --> 00:35:21,416
一个大文件


941
00:35:21,416 --> 00:35:22,346
考虑使用后台会话


942
00:35:23,736 --> 00:35:26,036
这些任务在进程外运行


943
00:35:26,836 --> 00:35:28,276
意味着即使你的 App


944
00:35:28,276 --> 00:35:30,676
在暂停状态


945
00:35:30,676 --> 00:35:31,766
下载也会继续


946
00:35:33,036 --> 00:35:34,476
与后台会话有关的


947
00:35:34,476 --> 00:35:36,246
更多信息 


948
00:35:36,246 --> 00:35:42,676
参见 2014 年的 WWDC 会议


949
00:35:42,796 --> 00:35:46,576
缓存是减少延迟的好方法


950
00:35:46,576 --> 00:35:48,526
但是需要注意的是


951
00:35:48,526 --> 00:35:50,076
缓存可能会导致磁盘存取问题


952
00:35:51,366 --> 00:35:52,816
在现实世界里


953
00:35:52,816 --> 00:35:54,596
我们看到有些 App


954
00:35:54,596 --> 00:35:56,746
每天往磁盘里写入若干 GB 的数据


955
00:35:56,746 --> 00:35:58,656
会引起严重的


956
00:35:58,656 --> 00:35:59,706
闪存劣化


957
00:36:01,076 --> 00:36:02,746
请不要缓存唯一的信息


958
00:36:04,196 --> 00:36:05,166
举个例子


959
00:36:06,096 --> 00:36:08,246
假设你有个 App


960
00:36:08,246 --> 00:36:09,856
约会的 App


961
00:36:09,856 --> 00:36:11,076
而你负责其中


962
00:36:11,076 --> 00:36:13,086
网络部分的代码


963
00:36:13,086 --> 00:36:15,136
这个 App 加载高分辨率的


964
00:36:15,486 --> 00:36:17,356
用户照片


965
00:36:18,516 --> 00:36:20,206
缓存这些高分辨率图像


966
00:36:20,206 --> 00:36:21,826
可能有些浪费


967
00:36:22,346 --> 00:36:23,636
因为用户会向左滑动


968
00:36:23,666 --> 00:36:25,286
去看下一个


969
00:36:25,286 --> 00:36:28,786
意味着你刚才缓存的图像


970
00:36:28,846 --> 00:36:30,756
可能再也不会被请求到


971
00:36:32,076 --> 00:36:33,446
请考虑做些


972
00:36:33,476 --> 00:36:35,396
客户端侧的修改 比如


973
00:36:35,396 --> 00:36:37,296
采用 willChacheResponse Delegate 方法


974
00:36:37,296 --> 00:36:39,596
来决定哪些资源


975
00:36:39,596 --> 00:36:40,396
应该被缓存


976
00:36:41,886 --> 00:36:43,896
如果你拥有服务器的话


977
00:36:43,896 --> 00:36:45,436
请考虑在请求头中使用缓存控制


978
00:36:45,436 --> 00:36:48,016
来决定哪些资源


979
00:36:48,016 --> 00:36:48,826
可以被缓存


980
00:36:49,346 --> 00:36:53,006
我们迅速地过一遍


981
00:36:53,006 --> 00:36:54,506
今天讨论过的关键点


982
00:36:55,346 --> 00:36:57,286
第一点 当你去餐馆时


983
00:36:57,286 --> 00:36:58,836
一次性把所有要点的菜都点完


984
00:36:59,166 --> 00:37:00,766
我开个玩笑


985
00:37:01,666 --> 00:37:03,976
转移到 HTTP/2


986
00:37:03,976 --> 00:37:05,326
从而利用头部压缩


987
00:37:05,546 --> 00:37:07,116
Connection Coalescing


988
00:37:07,116 --> 00:37:07,986
以及无队头阻塞问题等等好处


989
00:37:08,506 --> 00:37:12,596
用更少的 URLSession 对象


990
00:37:12,596 --> 00:37:15,076
通过重用连接来减少延迟


991
00:37:15,826 --> 00:37:17,816
这也减少了内存占用


992
00:37:17,816 --> 00:37:20,726
所以也更好地利用了系统资源


993
00:37:21,176 --> 00:37:23,936
减小请求的大小


994
00:37:24,236 --> 00:37:25,456
来最大化吞吐量


995
00:37:27,316 --> 00:37:29,736
注意 QoS


996
00:37:29,736 --> 00:37:31,386
提高你的 App 的响应灵敏度


997
00:37:32,216 --> 00:37:34,146
最后 使用后台会话


998
00:37:34,146 --> 00:37:35,896
从而可以更好地


999
00:37:35,896 --> 00:37:37,856
利用系统资源


1000
00:37:39,536 --> 00:37:40,936
关于这个会议的更多信息


1001
00:37:40,936 --> 00:37:42,726
请访问这个网站


1002
00:37:43,766 --> 00:37:45,006
现在我们短暂休息一下


1003
00:37:45,696 --> 00:37:46,796
休息过后


1004
00:37:46,796 --> 00:37:47,856
我们会向你介绍


1005
00:37:47,856 --> 00:37:49,856
Sockets 的现代替代者


1006
00:37:49,856 --> 00:37:50,556
Network.framework


1007
00:37:51,246 --> 00:37:52,596
我很希望在


1008
00:37:52,596 --> 00:37:54,426
今天和明天举办的


1009
00:37:54,426 --> 00:37:55,856
网络实验室里见到各位


1010
00:37:57,236 --> 00:37:58,546
感谢各位来到这里


1011
00:37:58,546 --> 00:38:00,326
希望大家享受


1012
00:38:00,326 --> 00:38:01,306
大会的其他部分


1013
00:38:02,508 --> 00:38:04,508
[ 掌声 ]
 

