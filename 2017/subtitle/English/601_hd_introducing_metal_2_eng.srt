WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:21.516 --> 00:00:27.906 A:middle
[ Applause ]

00:00:28.406 --> 00:00:28.846 A:middle
&gt;&gt; Welcome.

00:00:29.366 --> 00:00:30.936 A:middle
We introduced the host of new

00:00:30.936 --> 00:00:32.496 A:middle
technologies with Metal 2 to

00:00:32.796 --> 00:00:34.416 A:middle
allow you to make better,

00:00:34.416 --> 00:00:36.876 A:middle
faster, and more efficient

00:00:36.876 --> 00:00:37.646 A:middle
applications.

00:00:38.146 --> 00:00:39.336 A:middle
My name is Michal and together

00:00:39.336 --> 00:00:40.786 A:middle
with my colleague Richard we'll

00:00:40.786 --> 00:00:42.696 A:middle
explore three main themes today.

00:00:44.476 --> 00:00:46.486 A:middle
With Metal 2 we are continuing

00:00:46.696 --> 00:00:48.576 A:middle
our direction of moving the

00:00:48.576 --> 00:00:50.466 A:middle
expensive things to happen less

00:00:50.466 --> 00:00:52.096 A:middle
frequently and to making sure

00:00:52.096 --> 00:00:53.636 A:middle
that the frequent things are

00:00:53.676 --> 00:00:55.116 A:middle
really, really cheap.

00:00:55.596 --> 00:00:57.336 A:middle
Over the years we introduced

00:00:57.586 --> 00:01:00.166 A:middle
precompiled shaders, render

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:57.586 --> 00:01:00.166 A:middle
precompiled shaders, render

00:01:00.166 --> 00:01:02.226 A:middle
state objects, Metal Heap last

00:01:02.226 --> 00:01:04.506 A:middle
year all to make sure that you

00:01:04.506 --> 00:01:06.366 A:middle
can move the costly operations

00:01:06.516 --> 00:01:08.726 A:middle
outside of your main application

00:01:09.286 --> 00:01:09.386 A:middle
loop.

00:01:10.016 --> 00:01:13.776 A:middle
We gave you 10 times more draw

00:01:13.776 --> 00:01:15.826 A:middle
calls by switching from open GL

00:01:16.136 --> 00:01:16.636 A:middle
to Metal.

00:01:17.536 --> 00:01:18.926 A:middle
And this year we are introducing

00:01:18.926 --> 00:01:21.436 A:middle
our new binding API that gives

00:01:21.436 --> 00:01:22.796 A:middle
you some more.

00:01:22.796 --> 00:01:24.366 A:middle
And so we will talk about it a

00:01:24.366 --> 00:01:24.886 A:middle
bit further.

00:01:26.376 --> 00:01:28.946 A:middle
We are also putting GPU more in

00:01:28.946 --> 00:01:31.956 A:middle
a driving seat with GPU driven

00:01:31.956 --> 00:01:32.796 A:middle
pipelines.

00:01:33.356 --> 00:01:35.266 A:middle
And you will be able to create

00:01:35.266 --> 00:01:37.906 A:middle
new, novel algorithms, new

00:01:37.906 --> 00:01:40.256 A:middle
rendering techniques, and whole

00:01:40.856 --> 00:01:43.216 A:middle
unique experiences utilizing

00:01:43.216 --> 00:01:45.116 A:middle
Metal 2 on modern GPUs.

00:01:45.486 --> 00:01:46.296 A:middle
Well, speaking of the

00:01:46.296 --> 00:01:49.026 A:middle
experiences, we have a lot of

00:01:49.026 --> 00:01:50.246 A:middle
new features in Metal and we

00:01:50.246 --> 00:01:51.666 A:middle
have three other sessions that I

00:01:51.666 --> 00:01:52.686 A:middle
would love you to attend.

00:01:53.526 --> 00:01:56.716 A:middle
VR is coming to Mac this year

00:01:56.716 --> 00:01:58.916 A:middle
and with the new iMacs we are

00:01:58.916 --> 00:02:01.426 A:middle
giving you really powerful GPUs.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:58.916 --> 00:02:01.426 A:middle
giving you really powerful GPUs.

00:02:01.906 --> 00:02:03.996 A:middle
The external GPU is coming to

00:02:04.046 --> 00:02:05.586 A:middle
MacBook Pro to give you the same

00:02:05.586 --> 00:02:05.946 A:middle
power.

00:02:06.666 --> 00:02:09.106 A:middle
And this all enables your users

00:02:09.455 --> 00:02:11.496 A:middle
and your content creators to

00:02:11.496 --> 00:02:14.096 A:middle
experience VR in ways not

00:02:14.096 --> 00:02:14.876 A:middle
possible before.

00:02:15.506 --> 00:02:17.676 A:middle
Tomorrow's session will show you

00:02:18.426 --> 00:02:22.076 A:middle
how to use our display -- direct

00:02:22.076 --> 00:02:23.816 A:middle
display technology -- to get

00:02:23.816 --> 00:02:25.936 A:middle
your content to HMD quick and

00:02:25.936 --> 00:02:26.776 A:middle
with low latency.

00:02:28.116 --> 00:02:29.846 A:middle
You'll learn about the new Metal

00:02:29.846 --> 00:02:32.006 A:middle
API editions for VR and our new

00:02:32.006 --> 00:02:33.006 A:middle
Tools editions.

00:02:35.796 --> 00:02:38.206 A:middle
Machine learning is quickly

00:02:38.206 --> 00:02:40.236 A:middle
becoming a key feature of our

00:02:40.236 --> 00:02:42.016 A:middle
devices in many, many

00:02:42.016 --> 00:02:42.906 A:middle
applications.

00:02:42.906 --> 00:02:44.976 A:middle
And with Metal 2 you can use

00:02:44.976 --> 00:02:47.726 A:middle
Metal performance shaders to

00:02:47.816 --> 00:02:49.656 A:middle
utilize the power of the GPU for

00:02:49.656 --> 00:02:53.376 A:middle
machine learning on both test up

00:02:53.486 --> 00:02:54.466 A:middle
and mobile devices.

00:02:55.306 --> 00:02:56.786 A:middle
And you're probably staring at

00:02:56.846 --> 00:02:58.186 A:middle
that picture behind me and

00:02:58.186 --> 00:02:59.436 A:middle
thinking, "How's that done?"

00:02:59.716 --> 00:03:01.266 A:middle
Well, we have a session for you

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:59.716 --> 00:03:01.266 A:middle
Well, we have a session for you

00:03:01.266 --> 00:03:03.706 A:middle
on Thursday where you will learn

00:03:03.706 --> 00:03:05.346 A:middle
about this and about the machine

00:03:05.346 --> 00:03:07.196 A:middle
learning primitives -- the image

00:03:07.196 --> 00:03:08.736 A:middle
processing primitives -- we have

00:03:08.976 --> 00:03:10.906 A:middle
in our Metal performance

00:03:10.906 --> 00:03:11.446 A:middle
shaders.

00:03:12.976 --> 00:03:15.506 A:middle
Lastly, our tools have seen the

00:03:15.506 --> 00:03:17.506 A:middle
biggest advancement yet with

00:03:17.506 --> 00:03:18.076 A:middle
Metal 2.

00:03:18.196 --> 00:03:19.796 A:middle
You'll be able to debug your

00:03:19.796 --> 00:03:20.946 A:middle
applications quicker.

00:03:21.496 --> 00:03:23.206 A:middle
You can drill down to problems

00:03:23.626 --> 00:03:26.736 A:middle
easier and we are exposing, for

00:03:26.736 --> 00:03:28.156 A:middle
example GPU performance

00:03:28.156 --> 00:03:29.816 A:middle
counters, to make sure that you

00:03:29.816 --> 00:03:33.506 A:middle
can find your hotspots and your

00:03:33.506 --> 00:03:36.056 A:middle
application fast pass quicker.

00:03:37.346 --> 00:03:39.726 A:middle
So I hope I got you excited

00:03:39.986 --> 00:03:41.886 A:middle
about the few days ahead and

00:03:41.886 --> 00:03:44.006 A:middle
let's get back to the present

00:03:44.006 --> 00:03:45.336 A:middle
with the content of today's

00:03:45.336 --> 00:03:45.676 A:middle
session.

00:03:51.286 --> 00:03:53.416 A:middle
So we'll start with argument

00:03:53.416 --> 00:03:55.736 A:middle
buffers, probably our biggest

00:03:55.826 --> 00:03:57.516 A:middle
core framework addition this

00:03:57.516 --> 00:03:57.736 A:middle
year.

00:03:58.536 --> 00:04:00.586 A:middle
argument buffers provide an

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:58.536 --> 00:04:00.586 A:middle
argument buffers provide an

00:04:00.586 --> 00:04:03.266 A:middle
efficient new way of configuring

00:04:03.266 --> 00:04:05.776 A:middle
which buffers, textures, and

00:04:06.256 --> 00:04:07.826 A:middle
samplers your application can

00:04:07.826 --> 00:04:11.186 A:middle
use freeing up considerable

00:04:11.186 --> 00:04:13.076 A:middle
amount of CPU resources and

00:04:13.076 --> 00:04:14.856 A:middle
actually enabling completely new

00:04:14.856 --> 00:04:16.206 A:middle
schedules for the GPU at the

00:04:16.206 --> 00:04:16.916 A:middle
same time.

00:04:19.245 --> 00:04:20.565 A:middle
Then we'll talk about Raster

00:04:20.565 --> 00:04:22.816 A:middle
Order Groups, a new fragment

00:04:22.816 --> 00:04:24.356 A:middle
shader synchronization primitive

00:04:24.846 --> 00:04:26.696 A:middle
that allows you to precisely

00:04:26.696 --> 00:04:28.396 A:middle
control the order in which

00:04:28.616 --> 00:04:30.296 A:middle
fragment shaders access common

00:04:30.296 --> 00:04:32.866 A:middle
memory, enabling you new use

00:04:32.866 --> 00:04:34.566 A:middle
cases for example of

00:04:35.126 --> 00:04:37.026 A:middle
programmable blending on MacOS

00:04:37.076 --> 00:04:41.306 A:middle
or voxelization [phonetic] order

00:04:41.346 --> 00:04:42.446 A:middle
independent transparency.

00:04:43.306 --> 00:04:44.706 A:middle
And then we'll switch to the

00:04:44.706 --> 00:04:46.496 A:middle
topic of display and we talk

00:04:46.496 --> 00:04:48.226 A:middle
about the new ProMotion Displays

00:04:48.226 --> 00:04:50.336 A:middle
on iPads and how to best drive

00:04:50.336 --> 00:04:51.356 A:middle
them using Metal.

00:04:51.356 --> 00:04:54.236 A:middle
And we'll also give you a recap

00:04:54.286 --> 00:04:57.216 A:middle
of our best practices of getting

00:04:57.216 --> 00:04:58.716 A:middle
your content from your render

00:04:58.716 --> 00:05:02.446 A:middle
targets to the glass as quickly

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:58.716 --> 00:05:02.446 A:middle
targets to the glass as quickly

00:05:02.446 --> 00:05:03.886 A:middle
as possible and with the least

00:05:03.886 --> 00:05:04.826 A:middle
amount of latency.

00:05:05.406 --> 00:05:07.546 A:middle
And finally we'll finish with a

00:05:07.946 --> 00:05:09.876 A:middle
survey of all the other Metal

00:05:09.876 --> 00:05:12.156 A:middle
features that we added to align

00:05:12.396 --> 00:05:15.276 A:middle
iOS and MacOS platforms into one

00:05:15.626 --> 00:05:16.976 A:middle
big, common Metal ecosystem.

00:05:22.156 --> 00:05:26.006 A:middle
So the argument buffers.

00:05:26.366 --> 00:05:28.386 A:middle
Let's look at what they are and

00:05:28.546 --> 00:05:29.096 A:middle
how they work.

00:05:29.146 --> 00:05:30.636 A:middle
And I will need an example for

00:05:30.636 --> 00:05:33.606 A:middle
that so let's think of a simple

00:05:33.606 --> 00:05:35.996 A:middle
material that those who actually

00:05:35.996 --> 00:05:39.276 A:middle
wrote any sort of 3D render

00:05:39.276 --> 00:05:39.876 A:middle
program would know.

00:05:40.296 --> 00:05:42.156 A:middle
In your material you have a

00:05:42.156 --> 00:05:44.956 A:middle
bunch of numerical constants, a

00:05:44.956 --> 00:05:46.066 A:middle
bunch of textures -- probably

00:05:46.066 --> 00:05:47.246 A:middle
more than two now a days --

00:05:47.306 --> 00:05:47.836 A:middle
assembler.

00:05:48.516 --> 00:05:53.026 A:middle
And this is what you need to

00:05:53.026 --> 00:05:54.556 A:middle
send to the GPU to be able to

00:05:54.556 --> 00:05:55.886 A:middle
render your primitive.

00:05:56.346 --> 00:05:58.396 A:middle
Now the texture objects are

00:05:59.276 --> 00:06:00.856 A:middle
interesting because they contain

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:59.276 --> 00:06:00.856 A:middle
interesting because they contain

00:06:01.006 --> 00:06:03.336 A:middle
both texture properties such as

00:06:03.336 --> 00:06:06.456 A:middle
width, height, pixel format

00:06:06.456 --> 00:06:08.696 A:middle
perhaps, and then a pointer to a

00:06:08.696 --> 00:06:09.996 A:middle
blob of memory which contains

00:06:09.996 --> 00:06:11.036 A:middle
all the pretty pixels.

00:06:11.036 --> 00:06:13.726 A:middle
Well, unfortunately we are not

00:06:13.726 --> 00:06:14.596 A:middle
really interested in those

00:06:14.626 --> 00:06:15.766 A:middle
pixels in this presentation.

00:06:15.766 --> 00:06:18.456 A:middle
So off it goes and we'll only be

00:06:18.456 --> 00:06:20.256 A:middle
talking about boring texture

00:06:20.256 --> 00:06:20.756 A:middle
states.

00:06:21.986 --> 00:06:24.326 A:middle
So with traditional argument

00:06:24.326 --> 00:06:26.396 A:middle
model we allow you to put all

00:06:26.396 --> 00:06:28.926 A:middle
the constants into a Metal

00:06:28.926 --> 00:06:30.046 A:middle
buffer and we created this

00:06:30.046 --> 00:06:31.956 A:middle
indirection so that it's easy

00:06:31.956 --> 00:06:33.676 A:middle
for you to use and also it gives

00:06:33.676 --> 00:06:35.966 A:middle
GPU the unfiltered, direct

00:06:35.966 --> 00:06:37.766 A:middle
access to all the data.

00:06:38.956 --> 00:06:40.996 A:middle
However, when it comes to things

00:06:40.996 --> 00:06:43.216 A:middle
like textures or samplers you

00:06:43.216 --> 00:06:44.276 A:middle
still need to go through quite

00:06:44.276 --> 00:06:46.096 A:middle
about of an API and in your

00:06:46.096 --> 00:06:47.516 A:middle
rendering loop you'll set the

00:06:47.516 --> 00:06:49.886 A:middle
buffer, set all the textures,

00:06:50.506 --> 00:06:51.976 A:middle
samplers, and only after that

00:06:51.976 --> 00:06:53.226 A:middle
you can finally draw.

00:06:53.266 --> 00:06:55.506 A:middle
And even though Metal is really

00:06:55.506 --> 00:06:57.506 A:middle
optimized this is quite a few

00:06:57.506 --> 00:06:59.166 A:middle
API codes and if you multiply it

00:06:59.166 --> 00:07:00.116 A:middle
with the number of objects you

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:59.166 --> 00:07:00.116 A:middle
with the number of objects you

00:07:00.116 --> 00:07:02.596 A:middle
need to render, every frame, and

00:07:02.596 --> 00:07:03.876 A:middle
the fact that you need to do all

00:07:03.876 --> 00:07:05.986 A:middle
this work every frame, it

00:07:05.986 --> 00:07:08.856 A:middle
actually at some point limits

00:07:08.856 --> 00:07:09.966 A:middle
the amount of objects that you

00:07:09.966 --> 00:07:13.656 A:middle
can put on the screen.

00:07:13.656 --> 00:07:16.966 A:middle
With argument buffers we decided

00:07:16.966 --> 00:07:18.906 A:middle
that we would like to extend

00:07:19.316 --> 00:07:21.306 A:middle
this very convenient indirection

00:07:21.606 --> 00:07:22.866 A:middle
that we have for constants to

00:07:22.866 --> 00:07:23.456 A:middle
everything.

00:07:23.456 --> 00:07:25.886 A:middle
So you can actually put texture

00:07:25.886 --> 00:07:28.046 A:middle
state, samplers, pointers to

00:07:28.046 --> 00:07:29.536 A:middle
another buffer into an argument

00:07:29.536 --> 00:07:31.276 A:middle
buffer and this really

00:07:31.276 --> 00:07:33.866 A:middle
simplifies your rendering

00:07:33.866 --> 00:07:35.486 A:middle
pipeline because -- well,

00:07:35.486 --> 00:07:37.786 A:middle
suddenly the only thing you need

00:07:37.786 --> 00:07:40.226 A:middle
to do is set the buffer and

00:07:40.936 --> 00:07:41.636 A:middle
draw.

00:07:41.846 --> 00:07:43.146 A:middle
And you probably figured out

00:07:43.146 --> 00:07:46.026 A:middle
that with this few API calls you

00:07:46.026 --> 00:07:46.946 A:middle
can put more objects on the

00:07:46.946 --> 00:07:49.816 A:middle
screen, and as you'll see later,

00:07:50.066 --> 00:07:51.526 A:middle
you can do actually even better

00:07:51.566 --> 00:07:53.836 A:middle
with argument buffers.

00:07:54.476 --> 00:07:55.356 A:middle
So we've done a bunch of

00:07:55.356 --> 00:07:58.576 A:middle
benchmarks and run argument

00:07:58.576 --> 00:07:59.976 A:middle
buffers on our devices.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:04.246 --> 00:08:05.716 A:middle
And this is for example what you

00:08:05.716 --> 00:08:07.436 A:middle
get on iPhone 7.

00:08:08.026 --> 00:08:10.026 A:middle
While with traditional model,

00:08:10.356 --> 00:08:13.506 A:middle
quite unsurprisingly, the cost

00:08:13.506 --> 00:08:16.196 A:middle
of your draw call scales, with

00:08:16.196 --> 00:08:17.576 A:middle
the amount of resources you use

00:08:18.076 --> 00:08:21.846 A:middle
in a draw call, with argument

00:08:21.846 --> 00:08:24.926 A:middle
buffers the cost stays pretty

00:08:24.926 --> 00:08:26.566 A:middle
low and almost flat.

00:08:26.566 --> 00:08:29.806 A:middle
So this already shows that for

00:08:29.806 --> 00:08:31.276 A:middle
example with a very simple

00:08:31.276 --> 00:08:33.326 A:middle
shader, with just two resources,

00:08:33.326 --> 00:08:35.785 A:middle
with texture and a buffer, or

00:08:35.936 --> 00:08:37.616 A:middle
two textures, you're getting

00:08:37.616 --> 00:08:39.366 A:middle
seven times the performance

00:08:39.366 --> 00:08:39.966 A:middle
improvement.

00:08:39.966 --> 00:08:42.015 A:middle
With eight textures or eight

00:08:42.015 --> 00:08:45.076 A:middle
resources, however you want to

00:08:45.076 --> 00:08:47.116 A:middle
mix it up, you are getting 18

00:08:47.116 --> 00:08:48.826 A:middle
times performance improvement on

00:08:48.826 --> 00:08:50.796 A:middle
iPhone 7 and it goes even better

00:08:50.796 --> 00:08:52.516 A:middle
with 16 resources, obviously.

00:08:55.036 --> 00:08:57.946 A:middle
So I already talked about the

00:08:57.946 --> 00:08:58.726 A:middle
performance.

00:08:58.806 --> 00:09:01.146 A:middle
I hinted toward a new use -- new

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:58.806 --> 00:09:01.146 A:middle
I hinted toward a new use -- new

00:09:01.146 --> 00:09:01.736 A:middle
use schedules.

00:09:01.736 --> 00:09:04.316 A:middle
And we'll talk about this in a

00:09:04.316 --> 00:09:04.696 A:middle
minute.

00:09:04.886 --> 00:09:06.286 A:middle
And the last point -- the last

00:09:06.286 --> 00:09:07.986 A:middle
benefit of argument buffers I

00:09:07.986 --> 00:09:09.446 A:middle
would like to bring up is the

00:09:09.446 --> 00:09:10.206 A:middle
ease of use.

00:09:10.806 --> 00:09:13.686 A:middle
And it comes from the fact that

00:09:13.686 --> 00:09:15.376 A:middle
argument buffers are ultimately

00:09:15.536 --> 00:09:16.516 A:middle
an extension of buffers.

00:09:16.516 --> 00:09:17.796 A:middle
So you can, for example go ahead

00:09:17.796 --> 00:09:19.246 A:middle
and prepare them ahead of the

00:09:19.246 --> 00:09:20.936 A:middle
time, let's say when your game

00:09:20.936 --> 00:09:23.246 A:middle
is loading, and then don't have

00:09:23.296 --> 00:09:25.056 A:middle
to worry about it anymore during

00:09:25.056 --> 00:09:26.216 A:middle
your rendering loop, further

00:09:26.386 --> 00:09:27.676 A:middle
improving your performance.

00:09:28.616 --> 00:09:30.186 A:middle
Or you can mix them with a

00:09:30.186 --> 00:09:31.446 A:middle
traditional binding model, for

00:09:31.446 --> 00:09:33.696 A:middle
example even within a single

00:09:33.896 --> 00:09:36.206 A:middle
draw call, which means that your

00:09:36.206 --> 00:09:38.006 A:middle
adoption can be as simple as

00:09:38.196 --> 00:09:39.576 A:middle
using our new tools to figure

00:09:39.576 --> 00:09:40.816 A:middle
out what is your most expensive

00:09:41.086 --> 00:09:43.456 A:middle
loop in our application and

00:09:43.456 --> 00:09:44.776 A:middle
optimizing that and then maybe

00:09:44.776 --> 00:09:46.476 A:middle
return to the rest in a year

00:09:46.736 --> 00:09:49.446 A:middle
when you have time.

00:09:49.576 --> 00:09:52.766 A:middle
And lastly, the argument buffers

00:09:52.766 --> 00:09:55.076 A:middle
are supported across all Metal

00:09:55.076 --> 00:09:55.616 A:middle
devices.

00:09:55.616 --> 00:09:57.816 A:middle
So once you take this adoption

00:09:57.816 --> 00:09:59.196 A:middle
step and you get all the

00:09:59.196 --> 00:10:00.786 A:middle
performance you can keep using

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:59.196 --> 00:10:00.786 A:middle
performance you can keep using

00:10:00.786 --> 00:10:02.386 A:middle
it on all Metal devices.

00:10:02.816 --> 00:10:03.906 A:middle
The ease of use actually

00:10:03.906 --> 00:10:05.626 A:middle
translates really well to the

00:10:05.626 --> 00:10:06.256 A:middle
shaders.

00:10:06.256 --> 00:10:07.666 A:middle
And since we will be looking at

00:10:07.666 --> 00:10:10.506 A:middle
the shaders quite a bit during

00:10:10.506 --> 00:10:12.406 A:middle
this section -- this is an

00:10:12.406 --> 00:10:14.636 A:middle
example of the material I gave

00:10:14.636 --> 00:10:15.506 A:middle
you in the beginning.

00:10:16.496 --> 00:10:19.096 A:middle
And as you can see, the textures

00:10:19.096 --> 00:10:21.426 A:middle
in the sampler are part of the

00:10:21.426 --> 00:10:23.196 A:middle
structure, and that's the main

00:10:23.196 --> 00:10:24.576 A:middle
thing to take away from this is

00:10:25.126 --> 00:10:28.406 A:middle
that your argument buffer is

00:10:28.436 --> 00:10:29.806 A:middle
just a structure in a shader and

00:10:29.806 --> 00:10:31.156 A:middle
you can use all the language

00:10:31.516 --> 00:10:32.836 A:middle
that you have at your disposal

00:10:32.836 --> 00:10:35.096 A:middle
to make embedded structures, to

00:10:35.096 --> 00:10:38.686 A:middle
organize your data, or use erase

00:10:38.686 --> 00:10:39.386 A:middle
or pointers.

00:10:39.596 --> 00:10:40.806 A:middle
It just really works.

00:10:42.046 --> 00:10:44.306 A:middle
So let's now look at the three

00:10:44.596 --> 00:10:46.046 A:middle
main new features of argument

00:10:46.046 --> 00:10:47.426 A:middle
buffers, the first one being

00:10:47.516 --> 00:10:48.736 A:middle
dynamic indexing.

00:10:50.106 --> 00:10:53.176 A:middle
And great example of it is crowd

00:10:53.176 --> 00:10:53.656 A:middle
rendering.

00:10:53.656 --> 00:10:55.886 A:middle
If you played some of the recent

00:10:55.886 --> 00:10:57.266 A:middle
Open World games you've seen

00:10:57.266 --> 00:11:00.516 A:middle
that games try to render large

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:57.266 --> 00:11:00.516 A:middle
that games try to render large

00:11:00.516 --> 00:11:02.336 A:middle
crowds full of unique, varying

00:11:02.816 --> 00:11:04.856 A:middle
characters in order to make

00:11:04.856 --> 00:11:07.376 A:middle
these beautiful, immersive

00:11:07.436 --> 00:11:07.996 A:middle
worlds.

00:11:08.526 --> 00:11:09.946 A:middle
Well, actually that's quite a

00:11:09.946 --> 00:11:12.076 A:middle
costly thing to do if you need

00:11:12.076 --> 00:11:13.556 A:middle
to create so many draw calls.

00:11:14.906 --> 00:11:16.756 A:middle
With argument buffers we already

00:11:16.756 --> 00:11:19.246 A:middle
said that we could put all the

00:11:19.246 --> 00:11:20.706 A:middle
properties required for let's

00:11:20.706 --> 00:11:21.926 A:middle
say a character into a single

00:11:21.926 --> 00:11:23.836 A:middle
argument buffer, bind it, and

00:11:23.836 --> 00:11:25.396 A:middle
save all that performance on the

00:11:25.396 --> 00:11:27.516 A:middle
CPU, but actually we can do

00:11:27.516 --> 00:11:27.796 A:middle
better.

00:11:27.796 --> 00:11:30.076 A:middle
We can for example create an

00:11:30.246 --> 00:11:32.026 A:middle
array of argument buffers where

00:11:32.366 --> 00:11:35.096 A:middle
each element represents single

00:11:35.096 --> 00:11:35.556 A:middle
character.

00:11:36.136 --> 00:11:37.306 A:middle
And then it suddenly becomes

00:11:37.306 --> 00:11:38.526 A:middle
very, very simple because what

00:11:38.526 --> 00:11:40.676 A:middle
you need to do is set this big

00:11:40.676 --> 00:11:43.836 A:middle
buffer, this one API call, issue

00:11:43.956 --> 00:11:45.876 A:middle
single instance draw call, let's

00:11:45.876 --> 00:11:47.476 A:middle
say with 1,000 instances because

00:11:47.476 --> 00:11:48.956 A:middle
I would like 1,000 characters on

00:11:48.956 --> 00:11:49.326 A:middle
screen.

00:11:49.926 --> 00:11:51.026 A:middle
That's second API call.

00:11:51.086 --> 00:11:53.456 A:middle
And after that it's all on the

00:11:53.456 --> 00:11:54.006 A:middle
GPU.

00:11:54.006 --> 00:11:55.406 A:middle
In a vertex shader you use

00:11:55.406 --> 00:11:57.256 A:middle
instance ID to pick the right

00:11:57.256 --> 00:12:00.756 A:middle
element from the array, get the

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:57.256 --> 00:12:00.756 A:middle
element from the array, get the

00:12:00.756 --> 00:12:02.086 A:middle
character, put it somewhere

00:12:02.086 --> 00:12:02.866 A:middle
where it needs to be in the

00:12:02.866 --> 00:12:04.326 A:middle
world, give it the right pose,

00:12:04.326 --> 00:12:05.486 A:middle
if it's for example mid-walk

00:12:05.486 --> 00:12:07.596 A:middle
cycle, and then in the fragment

00:12:07.596 --> 00:12:10.006 A:middle
shader again you use the

00:12:10.006 --> 00:12:11.976 A:middle
instance ID and pick the right

00:12:11.976 --> 00:12:13.336 A:middle
materials, the right hair color

00:12:13.336 --> 00:12:14.266 A:middle
to finalize the look.

00:12:14.546 --> 00:12:16.886 A:middle
So we are suddenly getting from

00:12:17.406 --> 00:12:19.746 A:middle
tens, hundreds, maybe thousands

00:12:19.746 --> 00:12:22.146 A:middle
of draw calls to a single one.

00:12:22.426 --> 00:12:24.246 A:middle
And it's faster on the CPU.

00:12:24.246 --> 00:12:25.256 A:middle
It's faster on the GPU.

00:12:25.866 --> 00:12:29.296 A:middle
And this is how simple it looks

00:12:29.296 --> 00:12:29.866 A:middle
in a shader.

00:12:30.996 --> 00:12:32.896 A:middle
Pretty much your argument buffer

00:12:32.896 --> 00:12:35.966 A:middle
becomes an array of structures.

00:12:36.796 --> 00:12:39.976 A:middle
You pick the right element using

00:12:39.976 --> 00:12:41.336 A:middle
instance ID referenced within

00:12:41.336 --> 00:12:42.686 A:middle
and you can, for example take

00:12:42.686 --> 00:12:44.356 A:middle
the pointer and pass it to your

00:12:44.356 --> 00:12:45.856 A:middle
helper methods or whatever you

00:12:45.856 --> 00:12:47.076 A:middle
need to do to process data.

00:12:48.756 --> 00:12:51.326 A:middle
The second great feature of

00:12:51.366 --> 00:12:53.156 A:middle
argument buffers is the ability

00:12:53.636 --> 00:12:56.276 A:middle
of the GPU to set resources.

00:12:56.276 --> 00:12:57.486 A:middle
And we actually created an

00:12:57.486 --> 00:12:58.376 A:middle
example for this.

00:12:59.316 --> 00:13:01.416 A:middle
We created a particle simulation

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:59.316 --> 00:13:01.416 A:middle
We created a particle simulation

00:13:01.416 --> 00:13:03.706 A:middle
running completely on the GPU.

00:13:04.296 --> 00:13:05.866 A:middle
And I'll tell you how we done

00:13:05.866 --> 00:13:08.046 A:middle
that and we'll see the -- we'll

00:13:08.046 --> 00:13:09.326 A:middle
see it in action later.

00:13:10.086 --> 00:13:11.666 A:middle
So we created an array of

00:13:11.926 --> 00:13:13.156 A:middle
argument buffers where each

00:13:13.196 --> 00:13:16.126 A:middle
element is single particle --

00:13:16.126 --> 00:13:17.586 A:middle
and I guess you already spotted

00:13:17.586 --> 00:13:18.926 A:middle
a trend here.

00:13:19.596 --> 00:13:23.546 A:middle
Our simulation kernel then

00:13:24.426 --> 00:13:26.526 A:middle
treats and simulates one

00:13:26.526 --> 00:13:28.616 A:middle
particle per thread, but we want

00:13:28.616 --> 00:13:29.806 A:middle
to actually go further and we

00:13:29.806 --> 00:13:32.736 A:middle
want it to be able to create the

00:13:32.736 --> 00:13:36.236 A:middle
particles in the kernel as well,

00:13:36.236 --> 00:13:36.846 A:middle
on the GPU.

00:13:36.846 --> 00:13:38.936 A:middle
So in order to do that, and to

00:13:38.936 --> 00:13:41.136 A:middle
give it the right materials, we

00:13:41.136 --> 00:13:42.856 A:middle
also have argument buffer with

00:13:42.896 --> 00:13:44.516 A:middle
all the different materials that

00:13:44.516 --> 00:13:45.636 A:middle
we would like our particles to

00:13:45.636 --> 00:13:46.006 A:middle
have.

00:13:46.736 --> 00:13:48.716 A:middle
And our simulation kernel then,

00:13:49.216 --> 00:13:50.696 A:middle
every time you do an action in

00:13:50.976 --> 00:13:53.646 A:middle
our little demo, the simulation

00:13:53.646 --> 00:13:54.606 A:middle
kernel looks into the

00:13:54.606 --> 00:13:56.906 A:middle
environment and sees what's the

00:13:57.646 --> 00:13:59.276 A:middle
correct, most appropriate

00:13:59.276 --> 00:13:59.736 A:middle
material.

00:13:59.836 --> 00:14:01.426 A:middle
And let's say if you are in the

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:59.836 --> 00:14:01.426 A:middle
And let's say if you are in the

00:14:01.426 --> 00:14:03.956 A:middle
forest, we pick moss as the

00:14:04.116 --> 00:14:05.616 A:middle
right, appropriate material for

00:14:05.616 --> 00:14:08.666 A:middle
a rock and copy it to the

00:14:08.956 --> 00:14:09.966 A:middle
particle itself.

00:14:10.746 --> 00:14:13.056 A:middle
If you're on the rocks we pick

00:14:13.056 --> 00:14:13.936 A:middle
the rock material.

00:14:13.936 --> 00:14:15.776 A:middle
On the hill we pick grass.

00:14:16.656 --> 00:14:18.366 A:middle
So this way everything stays on

00:14:18.366 --> 00:14:22.626 A:middle
the GPU and it actually looks in

00:14:22.626 --> 00:14:23.926 A:middle
the shader just as simple as I

00:14:24.006 --> 00:14:24.776 A:middle
describe it.

00:14:25.166 --> 00:14:26.586 A:middle
If you want to modify data on

00:14:26.586 --> 00:14:29.986 A:middle
your GPU you bind it as a device

00:14:29.986 --> 00:14:31.316 A:middle
buffer and start assigning

00:14:31.316 --> 00:14:33.696 A:middle
values as you are used to, but

00:14:33.696 --> 00:14:34.816 A:middle
also this time around you can

00:14:34.816 --> 00:14:36.956 A:middle
copy textures or copy the whole

00:14:36.956 --> 00:14:38.496 A:middle
structure and it's really this

00:14:38.496 --> 00:14:38.796 A:middle
simple.

00:14:39.936 --> 00:14:42.166 A:middle
And the last great feature I

00:14:42.166 --> 00:14:44.406 A:middle
would like to mention is ability

00:14:44.406 --> 00:14:46.946 A:middle
of argument buffers to reference

00:14:46.946 --> 00:14:47.956 A:middle
another argument buffer.

00:14:47.956 --> 00:14:49.936 A:middle
So this way you can actually go

00:14:49.936 --> 00:14:52.776 A:middle
ahead and create a reusable and

00:14:52.856 --> 00:14:55.636 A:middle
complex object hierarchy just as

00:14:55.636 --> 00:14:58.906 A:middle
you are used to from C++ Swift,

00:14:59.126 --> 00:14:59.876 A:middle
Objective-C.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:01.696 --> 00:15:03.516 A:middle
Let's say in the example of our

00:15:04.196 --> 00:15:06.386 A:middle
renderer, if you have a ton of

00:15:06.386 --> 00:15:08.906 A:middle
objects, but you probably have

00:15:09.566 --> 00:15:10.866 A:middle
very few materials, so what you

00:15:10.866 --> 00:15:14.386 A:middle
can do is reference the material

00:15:14.386 --> 00:15:15.696 A:middle
from each object and save some

00:15:15.696 --> 00:15:18.166 A:middle
memory or you can build your

00:15:18.166 --> 00:15:19.556 A:middle
scene graph as a binary tree

00:15:19.556 --> 00:15:21.396 A:middle
where actually you point to the

00:15:21.396 --> 00:15:25.016 A:middle
objects and the tree nodes as

00:15:25.016 --> 00:15:26.266 A:middle
you need them, as you would be

00:15:26.266 --> 00:15:27.356 A:middle
used to from the CPU.

00:15:27.746 --> 00:15:29.226 A:middle
And you can share this data with

00:15:29.226 --> 00:15:29.916 A:middle
the CPU as well.

00:15:31.386 --> 00:15:32.676 A:middle
So these are the main features.

00:15:32.676 --> 00:15:34.366 A:middle
And let's look at the support

00:15:34.366 --> 00:15:34.846 A:middle
matrix.

00:15:35.426 --> 00:15:36.856 A:middle
We have two tiers.

00:15:37.096 --> 00:15:39.626 A:middle
The tier one is supported across

00:15:39.626 --> 00:15:42.296 A:middle
all Metal devices and you get

00:15:42.296 --> 00:15:43.216 A:middle
the CPU performance

00:15:43.216 --> 00:15:43.756 A:middle
improvements.

00:15:43.756 --> 00:15:44.696 A:middle
You get the new schedule

00:15:44.696 --> 00:15:45.106 A:middle
language.

00:15:45.596 --> 00:15:48.926 A:middle
But because of the limitations

00:15:48.926 --> 00:15:52.126 A:middle
of the GPUs this tier does not

00:15:52.706 --> 00:15:54.346 A:middle
-- is not able to utilize the

00:15:54.846 --> 00:15:56.316 A:middle
GPU driven use cases that I

00:15:56.316 --> 00:15:57.176 A:middle
mentioned earlier.

00:15:57.606 --> 00:15:58.746 A:middle
With tier two however you are

00:15:58.746 --> 00:16:00.416 A:middle
getting all of this -- so you

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:58.746 --> 00:16:00.416 A:middle
getting all of this -- so you

00:16:00.416 --> 00:16:02.226 A:middle
get all the new use cases -- and

00:16:02.226 --> 00:16:03.946 A:middle
we are also really increasing

00:16:03.946 --> 00:16:05.566 A:middle
the amount of resources you can

00:16:05.566 --> 00:16:06.006 A:middle
access.

00:16:06.006 --> 00:16:07.236 A:middle
Your shaders can access half a

00:16:07.286 --> 00:16:10.236 A:middle
million textures and buffers to

00:16:10.236 --> 00:16:11.516 A:middle
-- for you to do this -- do

00:16:11.516 --> 00:16:12.626 A:middle
these new algorithms.

00:16:13.616 --> 00:16:15.526 A:middle
While tier one is supported on

00:16:15.686 --> 00:16:18.346 A:middle
all Metal devices, tier two is

00:16:18.346 --> 00:16:19.656 A:middle
something you need to query for.

00:16:20.136 --> 00:16:22.046 A:middle
But don't worry, the support is

00:16:22.046 --> 00:16:22.686 A:middle
really wide.

00:16:23.386 --> 00:16:24.646 A:middle
All the Macs with these three

00:16:24.646 --> 00:16:25.996 A:middle
GPUs are tier two.

00:16:26.456 --> 00:16:28.276 A:middle
All the new MacBook Pros, the

00:16:28.276 --> 00:16:29.506 A:middle
latest MacBook, the last tier

00:16:29.506 --> 00:16:31.426 A:middle
MacBooks Pros are tier two.

00:16:31.426 --> 00:16:32.896 A:middle
So you can go ahead and have

00:16:32.896 --> 00:16:33.156 A:middle
fun.

00:16:33.936 --> 00:16:35.376 A:middle
Now let's look at the demo I

00:16:35.376 --> 00:16:35.966 A:middle
promised you.

00:16:36.056 --> 00:16:38.946 A:middle
We will be showing three videos

00:16:39.256 --> 00:16:41.236 A:middle
with three different features.

00:16:41.816 --> 00:16:43.766 A:middle
The real time rendered terrain,

00:16:43.966 --> 00:16:45.676 A:middle
with material that changes

00:16:45.676 --> 00:16:48.176 A:middle
dynamically, we place some

00:16:48.176 --> 00:16:50.436 A:middle
vegetation by the GPU on the

00:16:50.436 --> 00:16:51.546 A:middle
terrain to make it interesting,

00:16:51.946 --> 00:16:53.136 A:middle
and we have all these nice

00:16:53.136 --> 00:16:55.906 A:middle
particles that I mentioned

00:16:55.906 --> 00:16:56.276 A:middle
before.

00:16:56.546 --> 00:16:59.346 A:middle
So, as you see, we are painting

00:16:59.836 --> 00:17:01.076 A:middle
high on the terrain.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:59.836 --> 00:17:01.076 A:middle
high on the terrain.

00:17:01.076 --> 00:17:02.326 A:middle
We can changing sculpting the

00:17:02.326 --> 00:17:03.296 A:middle
terrain and the material

00:17:03.296 --> 00:17:04.165 A:middle
actually follows.

00:17:04.455 --> 00:17:05.626 A:middle
And this is a great thing about

00:17:05.626 --> 00:17:08.256 A:middle
argument buffers because they

00:17:08.256 --> 00:17:10.796 A:middle
allowed us to create a one big

00:17:11.496 --> 00:17:13.256 A:middle
argument buffer with all the

00:17:13.256 --> 00:17:16.236 A:middle
possible materials as layers in

00:17:16.236 --> 00:17:18.276 A:middle
there and when we are rendering

00:17:18.276 --> 00:17:20.406 A:middle
the terrain in a pixel shader we

00:17:20.406 --> 00:17:21.566 A:middle
are looking at things like

00:17:21.906 --> 00:17:24.776 A:middle
terrain height, slope, the

00:17:24.945 --> 00:17:27.236 A:middle
amount of sun that reaches

00:17:27.435 --> 00:17:28.996 A:middle
certain pixels, and based on

00:17:28.996 --> 00:17:30.806 A:middle
these properties and some others

00:17:30.806 --> 00:17:33.696 A:middle
we do decide what are the best

00:17:33.856 --> 00:17:35.276 A:middle
and most appropriate materials

00:17:35.276 --> 00:17:36.306 A:middle
for that given pixel.

00:17:36.736 --> 00:17:37.876 A:middle
And this is all happening in

00:17:37.876 --> 00:17:40.576 A:middle
real time, whereas previously we

00:17:40.576 --> 00:17:42.266 A:middle
would have to go ahead and split

00:17:42.266 --> 00:17:44.176 A:middle
the terrain in small pieces

00:17:44.586 --> 00:17:47.316 A:middle
offline, analyze which pieces

00:17:47.316 --> 00:17:49.036 A:middle
need which textures in order to

00:17:49.036 --> 00:17:50.516 A:middle
make it as optimal as possible,

00:17:51.066 --> 00:17:52.986 A:middle
and only then render it.

00:17:52.986 --> 00:17:55.216 A:middle
So we are going from a

00:17:55.286 --> 00:17:56.366 A:middle
pre-processing step, which is

00:17:56.366 --> 00:17:58.196 A:middle
heavy and prevents real time

00:17:58.196 --> 00:18:00.326 A:middle
modification, to something that

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:58.196 --> 00:18:00.326 A:middle
modification, to something that

00:18:00.326 --> 00:18:02.016 A:middle
is real time, without -- sorry

00:18:02.106 --> 00:18:04.556 A:middle
-- without preprocessing and

00:18:04.556 --> 00:18:05.456 A:middle
completely dynamic.

00:18:08.806 --> 00:18:11.816 A:middle
And we added vegetation on it

00:18:12.116 --> 00:18:13.896 A:middle
and as you see the vegetation is

00:18:13.896 --> 00:18:16.026 A:middle
also context sensitive.

00:18:16.856 --> 00:18:18.596 A:middle
You see the palm trees on the

00:18:18.596 --> 00:18:18.966 A:middle
sand.

00:18:18.966 --> 00:18:20.646 A:middle
You see the little tiny apple

00:18:20.646 --> 00:18:21.646 A:middle
trees on the hills.

00:18:23.276 --> 00:18:25.366 A:middle
And while the vegetation itself

00:18:25.366 --> 00:18:28.006 A:middle
is fairly traditional instance

00:18:28.006 --> 00:18:29.646 A:middle
rendering, the power of the

00:18:29.646 --> 00:18:32.216 A:middle
argument buffers here is that it

00:18:32.216 --> 00:18:33.916 A:middle
allows us to share the same

00:18:34.246 --> 00:18:35.836 A:middle
terrain material with all the

00:18:35.836 --> 00:18:37.676 A:middle
same properties and the same

00:18:37.676 --> 00:18:39.476 A:middle
terrain analysis function

00:18:39.956 --> 00:18:41.306 A:middle
between two completely separate

00:18:41.306 --> 00:18:43.276 A:middle
pieces of code.

00:18:43.476 --> 00:18:45.076 A:middle
While terrain rendering uses all

00:18:45.076 --> 00:18:47.156 A:middle
this data to render pixels, the

00:18:47.156 --> 00:18:48.626 A:middle
computer that places the

00:18:48.626 --> 00:18:50.146 A:middle
geometry, the vegetation,

00:18:50.506 --> 00:18:51.786 A:middle
actually analyzes the same

00:18:51.786 --> 00:18:53.606 A:middle
materials to figure out what is

00:18:53.606 --> 00:18:56.096 A:middle
the best type of tree to place

00:18:56.096 --> 00:18:56.856 A:middle
in the given spot.

00:18:57.306 --> 00:18:58.446 A:middle
And this is very easy because

00:18:58.446 --> 00:18:59.656 A:middle
every time we make a change

00:18:59.996 --> 00:19:01.396 A:middle
nothing actually changes in our

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:59.996 --> 00:19:01.396 A:middle
nothing actually changes in our

00:19:01.396 --> 00:19:02.526 A:middle
code because we just add new

00:19:02.526 --> 00:19:04.346 A:middle
layers or change our analysis

00:19:04.346 --> 00:19:06.636 A:middle
function, whereas previously we

00:19:06.636 --> 00:19:08.346 A:middle
would have to maybe juggle 70

00:19:08.346 --> 00:19:10.066 A:middle
textures between two completely

00:19:10.066 --> 00:19:11.646 A:middle
separate code basis in order to

00:19:11.646 --> 00:19:16.866 A:middle
make them run in sync.

00:19:17.046 --> 00:19:19.236 A:middle
Lastly, we have the particles.

00:19:19.236 --> 00:19:22.066 A:middle
I hope you can see that they

00:19:22.066 --> 00:19:24.976 A:middle
nicely get the material of the

00:19:24.976 --> 00:19:25.746 A:middle
terrain there.

00:19:26.706 --> 00:19:28.436 A:middle
Now what I did not mention is

00:19:28.436 --> 00:19:30.696 A:middle
that this all is rendered with

00:19:30.956 --> 00:19:32.636 A:middle
again a single draw call.

00:19:32.636 --> 00:19:34.586 A:middle
We are rendering 16,000

00:19:34.926 --> 00:19:37.836 A:middle
particles here with single draw

00:19:37.836 --> 00:19:39.466 A:middle
call, with absolutely no

00:19:39.646 --> 00:19:41.416 A:middle
involvement on the CPU.

00:19:42.236 --> 00:19:44.316 A:middle
And not only do particles have

00:19:44.656 --> 00:19:46.146 A:middle
unique materials, they actually

00:19:46.146 --> 00:19:47.326 A:middle
have unique shapes because

00:19:47.606 --> 00:19:48.766 A:middle
argument buffers allow --

00:19:48.766 --> 00:19:50.006 A:middle
actually allow you to change

00:19:50.006 --> 00:19:51.996 A:middle
your vertex buffer per draw

00:19:51.996 --> 00:19:52.246 A:middle
call.

00:19:53.356 --> 00:19:55.916 A:middle
This is something where if you

00:19:55.916 --> 00:19:58.296 A:middle
try to do that without argument

00:19:58.296 --> 00:20:01.786 A:middle
buffers, we had to create a

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:58.296 --> 00:20:01.786 A:middle
buffers, we had to create a

00:20:01.786 --> 00:20:04.326 A:middle
complicated control hand over

00:20:04.326 --> 00:20:06.686 A:middle
between GPU that simulates and

00:20:06.686 --> 00:20:07.866 A:middle
the CPU that tries to come up

00:20:07.866 --> 00:20:09.686 A:middle
with the best set of draw calls

00:20:09.686 --> 00:20:11.186 A:middle
to represent all this variety.

00:20:11.606 --> 00:20:13.226 A:middle
So with argument buffers this

00:20:13.226 --> 00:20:16.976 A:middle
became just very, very simple.

00:20:18.176 --> 00:20:21.536 A:middle
Okay, so enough pretty pictures.

00:20:22.146 --> 00:20:25.056 A:middle
And let's wrap my portion of the

00:20:25.056 --> 00:20:28.236 A:middle
session with a look at some APIs

00:20:28.236 --> 00:20:29.546 A:middle
and some best practices.

00:20:29.836 --> 00:20:33.256 A:middle
As I mentioned before, argument

00:20:33.256 --> 00:20:34.756 A:middle
buffers are an extension of

00:20:34.756 --> 00:20:37.246 A:middle
Metal buffers and that means all

00:20:37.246 --> 00:20:39.116 A:middle
of our API related to buffers

00:20:39.116 --> 00:20:39.606 A:middle
just works.

00:20:39.606 --> 00:20:40.776 A:middle
You can go ahead and take

00:20:40.776 --> 00:20:42.026 A:middle
argument buffer, copy it

00:20:42.026 --> 00:20:43.286 A:middle
somewhere else; you can blitz it

00:20:43.286 --> 00:20:44.816 A:middle
between CPU and GPU.

00:20:45.626 --> 00:20:47.936 A:middle
And while argument buffers look

00:20:47.936 --> 00:20:51.096 A:middle
like structures on the GPU for

00:20:51.096 --> 00:20:54.626 A:middle
shaders, on the CPU you will use

00:20:54.626 --> 00:20:56.646 A:middle
MTLArgumentEncoder objects to

00:20:56.646 --> 00:20:57.546 A:middle
fill up the content.

00:20:58.506 --> 00:21:02.026 A:middle
This abstraction allows Metal to

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:58.506 --> 00:21:02.026 A:middle
This abstraction allows Metal to

00:21:02.026 --> 00:21:04.526 A:middle
create the most optimal memory

00:21:05.016 --> 00:21:06.496 A:middle
representation for any given

00:21:06.496 --> 00:21:08.026 A:middle
argument buffer on that specific

00:21:08.026 --> 00:21:09.206 A:middle
GPU that you are actually

00:21:09.206 --> 00:21:09.536 A:middle
running.

00:21:10.026 --> 00:21:11.326 A:middle
So you get the best performance.

00:21:11.726 --> 00:21:13.106 A:middle
It also frees you, as the

00:21:13.106 --> 00:21:14.526 A:middle
developer, from all these

00:21:15.476 --> 00:21:19.776 A:middle
details and worries about, for

00:21:19.776 --> 00:21:21.786 A:middle
example how each GPU represents

00:21:21.926 --> 00:21:22.796 A:middle
what the texture is.

00:21:22.796 --> 00:21:23.816 A:middle
Where does it live in memory?

00:21:24.436 --> 00:21:26.576 A:middle
All of this changes from

00:21:26.716 --> 00:21:28.606 A:middle
platform to platform and we hide

00:21:28.606 --> 00:21:31.186 A:middle
it between a simple interface so

00:21:31.186 --> 00:21:32.446 A:middle
that you can write very simple

00:21:32.446 --> 00:21:33.656 A:middle
and effective applications.

00:21:34.346 --> 00:21:36.936 A:middle
So I hope you're not worried

00:21:36.936 --> 00:21:37.836 A:middle
about the encoder that I

00:21:37.836 --> 00:21:38.196 A:middle
mentioned.

00:21:38.196 --> 00:21:39.716 A:middle
It's really, really simple to

00:21:39.716 --> 00:21:40.116 A:middle
use.

00:21:41.176 --> 00:21:42.156 A:middle
For example, if you want to

00:21:42.156 --> 00:21:43.686 A:middle
create an argument encoder for

00:21:43.686 --> 00:21:46.216 A:middle
this argument buffer all you

00:21:46.216 --> 00:21:49.716 A:middle
need to do is get your Metal

00:21:49.716 --> 00:21:51.216 A:middle
function that uses the argument

00:21:51.216 --> 00:21:53.566 A:middle
buffer and ask the Metal

00:21:53.566 --> 00:21:55.216 A:middle
function for the encoder and

00:21:55.216 --> 00:21:55.946 A:middle
that's about this.

00:21:55.946 --> 00:21:57.216 A:middle
This is all you needed to do.

00:21:57.216 --> 00:21:59.356 A:middle
You get an object and you start

00:21:59.356 --> 00:22:01.896 A:middle
using a familiar set texture or

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:59.356 --> 00:22:01.896 A:middle
using a familiar set texture or

00:22:02.286 --> 00:22:04.416 A:middle
filling constant API that is

00:22:04.416 --> 00:22:05.746 A:middle
very, very similar to how you've

00:22:05.746 --> 00:22:08.496 A:middle
been using Metal with command

00:22:08.496 --> 00:22:08.846 A:middle
encoder.

00:22:08.846 --> 00:22:11.746 A:middle
So this also plays into what I

00:22:11.746 --> 00:22:14.946 A:middle
said about ease of use and

00:22:14.946 --> 00:22:15.676 A:middle
transition.

00:22:16.686 --> 00:22:18.566 A:middle
There are multiple other ways of

00:22:18.566 --> 00:22:20.326 A:middle
creating the encoder.

00:22:20.326 --> 00:22:21.616 A:middle
You can go more explicit with

00:22:21.616 --> 00:22:22.516 A:middle
the descriptor, but that's

00:22:22.516 --> 00:22:24.526 A:middle
something you should look into

00:22:24.726 --> 00:22:25.866 A:middle
in documentation if you need

00:22:25.866 --> 00:22:26.506 A:middle
such thing.

00:22:26.706 --> 00:22:28.786 A:middle
We advise you to actually go and

00:22:29.396 --> 00:22:30.696 A:middle
get argument encoders from the

00:22:30.696 --> 00:22:31.206 A:middle
shaders.

00:22:33.676 --> 00:22:36.496 A:middle
Now with all those interactions,

00:22:36.496 --> 00:22:38.226 A:middle
GPU being able to step in and

00:22:38.226 --> 00:22:40.266 A:middle
modify the argument buffers or

00:22:40.866 --> 00:22:42.116 A:middle
you know dynamic indexing and

00:22:42.116 --> 00:22:44.186 A:middle
half a million textures, all

00:22:44.186 --> 00:22:47.346 A:middle
that in a mix, it's not really

00:22:47.736 --> 00:22:49.196 A:middle
possible for Metal to figure out

00:22:49.196 --> 00:22:50.296 A:middle
what -- for example what

00:22:50.296 --> 00:22:52.046 A:middle
textures or buffers do actually

00:22:52.046 --> 00:22:55.226 A:middle
intend to use in your rendering,

00:22:55.226 --> 00:22:56.836 A:middle
but luckily you as a developer

00:22:56.836 --> 00:22:58.746 A:middle
have pretty good idea about

00:22:58.746 --> 00:22:58.956 A:middle
that.

00:22:58.956 --> 00:23:01.106 A:middle
So we ask you with argument

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:58.956 --> 00:23:01.106 A:middle
So we ask you with argument

00:23:01.106 --> 00:23:02.546 A:middle
buffers to be quite explicit

00:23:02.546 --> 00:23:02.896 A:middle
about it.

00:23:04.096 --> 00:23:05.606 A:middle
If you are using Heaps, and

00:23:06.476 --> 00:23:08.166 A:middle
absolutely you should use Heaps

00:23:08.166 --> 00:23:09.726 A:middle
to get the best performance out

00:23:09.726 --> 00:23:12.346 A:middle
of your platform and the best

00:23:12.346 --> 00:23:13.596 A:middle
way of organizing your data, the

00:23:14.196 --> 00:23:15.416 A:middle
only thing you need to do is

00:23:15.416 --> 00:23:16.766 A:middle
tell Metal that you intend to

00:23:16.766 --> 00:23:18.716 A:middle
use a Heap , or multiple Heaps,

00:23:18.716 --> 00:23:19.646 A:middle
it's up to you.

00:23:19.646 --> 00:23:22.176 A:middle
And -- this is -- this makes

00:23:22.176 --> 00:23:24.026 A:middle
sure that the textures are

00:23:24.026 --> 00:23:25.376 A:middle
available for you in the

00:23:25.376 --> 00:23:25.966 A:middle
rendering loop.

00:23:26.226 --> 00:23:28.896 A:middle
If you want to do something more

00:23:28.896 --> 00:23:29.906 A:middle
specific, let's say you would

00:23:29.906 --> 00:23:32.416 A:middle
like to write to a render target

00:23:32.416 --> 00:23:34.386 A:middle
from inside a shader, or you

00:23:34.386 --> 00:23:35.456 A:middle
would like to read from a dev

00:23:35.456 --> 00:23:38.296 A:middle
buffer, you use a more specific

00:23:38.296 --> 00:23:40.296 A:middle
API and tell Metal that you

00:23:40.296 --> 00:23:42.306 A:middle
intend to change resource and --

00:23:43.306 --> 00:23:44.346 A:middle
with a specific way.

00:23:44.346 --> 00:23:45.906 A:middle
And again, it's as simple as

00:23:45.906 --> 00:23:45.996 A:middle
this.

00:23:45.996 --> 00:23:46.846 A:middle
You don't need to do anything

00:23:46.846 --> 00:23:46.976 A:middle
else.

00:23:50.336 --> 00:23:52.026 A:middle
So let's start out with a couple

00:23:52.026 --> 00:23:52.936 A:middle
of best practices.

00:23:52.936 --> 00:23:55.816 A:middle
I think if you know Metal they

00:23:55.816 --> 00:23:57.906 A:middle
are very, very similar to what

00:23:57.906 --> 00:23:59.906 A:middle
we are telling you about using

00:23:59.906 --> 00:24:00.556 A:middle
Metal buffers.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:59.906 --> 00:24:00.556 A:middle
Metal buffers.

00:24:00.986 --> 00:24:02.416 A:middle
The best way to organize your

00:24:02.416 --> 00:24:04.536 A:middle
data is by usage pattern.

00:24:04.536 --> 00:24:05.686 A:middle
And you probably have a ton of

00:24:05.686 --> 00:24:08.236 A:middle
properties that do not change

00:24:08.516 --> 00:24:09.186 A:middle
per frame.

00:24:09.236 --> 00:24:10.366 A:middle
So put them into an argument

00:24:10.366 --> 00:24:11.786 A:middle
buffer and share it with all the

00:24:11.786 --> 00:24:12.996 A:middle
objects so you will save memory

00:24:12.996 --> 00:24:13.366 A:middle
this way.

00:24:14.116 --> 00:24:15.906 A:middle
The same -- on the same -- on

00:24:15.906 --> 00:24:17.586 A:middle
the other hand you will probably

00:24:17.586 --> 00:24:19.396 A:middle
have a lot of properties that

00:24:19.396 --> 00:24:20.926 A:middle
actually do change for every

00:24:20.926 --> 00:24:23.326 A:middle
object and you need to manage

00:24:23.326 --> 00:24:24.176 A:middle
them every frame.

00:24:24.176 --> 00:24:26.776 A:middle
And for these I think the best

00:24:26.776 --> 00:24:27.896 A:middle
way is to put those into

00:24:27.896 --> 00:24:29.066 A:middle
separate argument buffers so

00:24:29.066 --> 00:24:30.226 A:middle
that you can double buffer it or

00:24:30.226 --> 00:24:31.896 A:middle
whatever is your management

00:24:31.896 --> 00:24:34.636 A:middle
scheme and you don't need to do

00:24:34.636 --> 00:24:36.406 A:middle
all the other copies to keep all

00:24:36.406 --> 00:24:37.086 A:middle
the data in there.

00:24:37.536 --> 00:24:39.016 A:middle
And then you will likely have a

00:24:39.016 --> 00:24:41.106 A:middle
ton of argument buffers that

00:24:41.616 --> 00:24:43.116 A:middle
just don't change at all.

00:24:43.116 --> 00:24:44.276 A:middle
Let's say the materials, or

00:24:44.856 --> 00:24:46.636 A:middle
maybe some other properties, and

00:24:46.786 --> 00:24:49.126 A:middle
for these just create them at

00:24:49.126 --> 00:24:50.126 A:middle
the initialization of your

00:24:50.126 --> 00:24:53.636 A:middle
application and keep using them.

00:24:53.846 --> 00:24:57.406 A:middle
Similar to Metal buffers, think

00:24:57.406 --> 00:24:59.646 A:middle
about your data locality and how

00:24:59.646 --> 00:25:01.396 A:middle
you actually use your argument

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:59.646 --> 00:25:01.396 A:middle
you actually use your argument

00:25:01.396 --> 00:25:01.746 A:middle
buffers.

00:25:02.076 --> 00:25:03.636 A:middle
If, for example you have three

00:25:03.636 --> 00:25:05.906 A:middle
textures that are accessed in a

00:25:05.906 --> 00:25:08.606 A:middle
shader, one after another, then

00:25:09.136 --> 00:25:10.666 A:middle
the best thing you can do is

00:25:10.666 --> 00:25:11.876 A:middle
actually put those textures

00:25:11.876 --> 00:25:13.056 A:middle
close to each other in argument

00:25:13.056 --> 00:25:14.406 A:middle
buffers so that you maximize the

00:25:14.406 --> 00:25:16.296 A:middle
use of GPU caches.

00:25:17.206 --> 00:25:17.976 A:middle
And as I mentioned at the

00:25:17.976 --> 00:25:20.566 A:middle
beginning, traditional argument

00:25:20.566 --> 00:25:23.536 A:middle
model is not going anywhere and

00:25:23.536 --> 00:25:25.406 A:middle
you should take advantage of it

00:25:25.406 --> 00:25:26.606 A:middle
and mix it with the argument

00:25:26.606 --> 00:25:27.936 A:middle
buffers whenever it's more

00:25:27.936 --> 00:25:28.616 A:middle
convenient.

00:25:29.136 --> 00:25:30.456 A:middle
So let's say if you need to

00:25:30.456 --> 00:25:32.086 A:middle
change a single texture for

00:25:33.216 --> 00:25:35.616 A:middle
every object, for example a cube

00:25:35.616 --> 00:25:37.446 A:middle
reflection, it probably would be

00:25:37.446 --> 00:25:38.616 A:middle
an overhead to create argument

00:25:38.616 --> 00:25:39.926 A:middle
buffer just for that and upload

00:25:39.926 --> 00:25:40.726 A:middle
it every frame.

00:25:40.726 --> 00:25:42.646 A:middle
So just use the traditional

00:25:42.646 --> 00:25:43.356 A:middle
model for this.

00:25:43.496 --> 00:25:46.046 A:middle
That's it about argument

00:25:46.046 --> 00:25:46.406 A:middle
buffers.

00:25:46.406 --> 00:25:50.086 A:middle
I really hope you will adopt our

00:25:50.086 --> 00:25:52.356 A:middle
new API and get some creative

00:25:52.636 --> 00:25:53.446 A:middle
use cases out of it.

00:25:53.966 --> 00:25:57.286 A:middle
And please welcome Richard, who

00:25:57.396 --> 00:25:58.976 A:middle
will talk about the Raster Order

00:25:58.976 --> 00:25:59.336 A:middle
Groups.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:00.516 --> 00:26:02.436 A:middle
[ Applause ]

00:26:02.436 --> 00:26:02.856 A:middle
&gt;&gt; Thank you.

00:26:04.866 --> 00:26:06.536 A:middle
Hello. So thank you Michal.

00:26:06.656 --> 00:26:07.606 A:middle
So I'm going to take you through

00:26:07.606 --> 00:26:08.266 A:middle
the rest of the day's

00:26:08.266 --> 00:26:09.836 A:middle
presentation, starting with

00:26:09.876 --> 00:26:10.766 A:middle
Raster Order Groups.

00:26:12.316 --> 00:26:14.016 A:middle
So this is a new feature that

00:26:14.016 --> 00:26:16.486 A:middle
gives you control over the GPU's

00:26:16.556 --> 00:26:17.696 A:middle
thread scheduling to run

00:26:18.026 --> 00:26:19.516 A:middle
fragment shooter threads, in

00:26:19.576 --> 00:26:19.916 A:middle
order.

00:26:20.516 --> 00:26:21.926 A:middle
This allows overlapping fragment

00:26:21.926 --> 00:26:23.096 A:middle
shooter threads to communicate

00:26:23.156 --> 00:26:24.706 A:middle
through memory, where before it

00:26:24.706 --> 00:26:27.226 A:middle
wasn't always really possible to

00:26:27.226 --> 00:26:28.106 A:middle
do in most cases.

00:26:28.486 --> 00:26:30.076 A:middle
So this opens up a whole new set

00:26:30.076 --> 00:26:31.086 A:middle
of graphics algorithms that were

00:26:31.086 --> 00:26:32.796 A:middle
not practically achievable with

00:26:32.986 --> 00:26:34.036 A:middle
just write only access to your

00:26:34.036 --> 00:26:36.026 A:middle
frame buffers or onward access

00:26:36.026 --> 00:26:37.046 A:middle
memory to device memory.

00:26:38.296 --> 00:26:40.826 A:middle
For example, one of our key --

00:26:40.826 --> 00:26:41.996 A:middle
one of the key applications for

00:26:41.996 --> 00:26:42.986 A:middle
this is Order-independent

00:26:42.986 --> 00:26:43.756 A:middle
transparency.

00:26:44.576 --> 00:26:45.936 A:middle
We've been -- already talked a

00:26:45.936 --> 00:26:47.286 A:middle
lot today about how to reduce

00:26:47.286 --> 00:26:48.426 A:middle
the CP usage of your Metal

00:26:48.426 --> 00:26:50.186 A:middle
application and this feature

00:26:50.186 --> 00:26:51.846 A:middle
lets you build or an algorithm

00:26:52.306 --> 00:26:54.286 A:middle
to include blending back to

00:26:54.286 --> 00:26:55.946 A:middle
front without having to pay the

00:26:55.946 --> 00:26:57.356 A:middle
CPU cost of triangle level

00:26:57.356 --> 00:26:57.726 A:middle
sorting.

00:26:59.366 --> 00:27:00.566 A:middle
There's also been lots of

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:59.366 --> 00:27:00.566 A:middle
There's also been lots of

00:27:00.566 --> 00:27:01.666 A:middle
investigations into advanced

00:27:01.666 --> 00:27:03.006 A:middle
techniques such as dual layer

00:27:03.226 --> 00:27:04.066 A:middle
G-buffers, which can

00:27:04.066 --> 00:27:05.776 A:middle
substantially improve post

00:27:05.776 --> 00:27:07.426 A:middle
processing results, or using the

00:27:07.426 --> 00:27:08.696 A:middle
GPU rasterizer to sort of

00:27:08.696 --> 00:27:10.026 A:middle
voxelize triangle meshes.

00:27:10.886 --> 00:27:12.546 A:middle
For both of these onward

00:27:12.546 --> 00:27:13.556 A:middle
accesses to memory has been a

00:27:13.556 --> 00:27:15.156 A:middle
really large barrier to

00:27:15.156 --> 00:27:16.356 A:middle
efficient implementations.

00:27:17.126 --> 00:27:18.806 A:middle
But probably the simplest and

00:27:18.806 --> 00:27:20.396 A:middle
most common application for this

00:27:20.396 --> 00:27:21.666 A:middle
feature is just implementing

00:27:21.666 --> 00:27:22.606 A:middle
custom blend equations.

00:27:23.356 --> 00:27:24.916 A:middle
iOS's hardware could always do

00:27:24.916 --> 00:27:27.176 A:middle
this pretty natively, but this

00:27:27.176 --> 00:27:29.236 A:middle
is not something that desktop

00:27:29.236 --> 00:27:30.896 A:middle
hardware has traditionally been

00:27:30.896 --> 00:27:31.516 A:middle
able to do.

00:27:32.496 --> 00:27:33.736 A:middle
So I'm going to use custom

00:27:33.736 --> 00:27:34.816 A:middle
blending as an example

00:27:34.816 --> 00:27:35.906 A:middle
application to introduce this

00:27:35.906 --> 00:27:36.176 A:middle
feature.

00:27:37.906 --> 00:27:39.916 A:middle
Okay, so pretty typical case of

00:27:39.916 --> 00:27:41.146 A:middle
triangle blending; one triangle

00:27:41.146 --> 00:27:41.666 A:middle
over another.

00:27:42.596 --> 00:27:44.866 A:middle
Pretty much all modern GPU APIs

00:27:44.906 --> 00:27:46.216 A:middle
guarantee that blending happens

00:27:46.216 --> 00:27:47.256 A:middle
in draw call order.

00:27:47.396 --> 00:27:48.686 A:middle
It provides this nice,

00:27:48.756 --> 00:27:50.246 A:middle
convenient illusion of serial

00:27:50.246 --> 00:27:50.776 A:middle
execution.

00:27:51.626 --> 00:27:53.206 A:middle
But of course what's really

00:27:53.206 --> 00:27:54.416 A:middle
going on behind the scenes is

00:27:54.516 --> 00:27:55.846 A:middle
GPU hardware's highly parallel.

00:27:55.846 --> 00:27:56.916 A:middle
It's going to be running

00:27:56.916 --> 00:27:58.086 A:middle
multiple threads concurrently.

00:27:58.666 --> 00:28:00.126 A:middle
And only this fixed-function

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:58.666 --> 00:28:00.126 A:middle
And only this fixed-function

00:28:00.126 --> 00:28:01.616 A:middle
blend step at the end is going

00:28:01.616 --> 00:28:02.876 A:middle
to be delayed until everything

00:28:02.876 --> 00:28:05.596 A:middle
gets put back in order again.

00:28:05.596 --> 00:28:06.716 A:middle
There's this implicit wait that

00:28:06.716 --> 00:28:08.726 A:middle
happens before that blend step.

00:28:10.296 --> 00:28:12.516 A:middle
Things change however if the

00:28:12.516 --> 00:28:13.446 A:middle
ordering -- if we need to put

00:28:13.446 --> 00:28:14.596 A:middle
things in order not at the end

00:28:14.596 --> 00:28:16.146 A:middle
of our fragment shooter, but

00:28:16.246 --> 00:28:17.896 A:middle
right in the middle because in

00:28:17.896 --> 00:28:19.996 A:middle
this case triangle one wants to

00:28:19.996 --> 00:28:21.136 A:middle
write something to memory that

00:28:21.136 --> 00:28:22.426 A:middle
triangle two's threads want to

00:28:22.426 --> 00:28:22.856 A:middle
read from.

00:28:23.076 --> 00:28:24.846 A:middle
If we want triangle two to be

00:28:24.846 --> 00:28:26.066 A:middle
able to build upon and consume

00:28:26.066 --> 00:28:27.856 A:middle
triangle one's data we need to

00:28:27.856 --> 00:28:28.726 A:middle
get that ordering back.

00:28:29.466 --> 00:28:32.196 A:middle
And so that's pretty much what

00:28:32.196 --> 00:28:33.406 A:middle
Raster Order Groups provides.

00:28:34.536 --> 00:28:36.856 A:middle
So I'm going to jump over to a

00:28:37.036 --> 00:28:37.986 A:middle
shader code example.

00:28:38.586 --> 00:28:40.946 A:middle
So if I want to implement custom

00:28:40.946 --> 00:28:42.296 A:middle
blending, an initial attempt

00:28:42.466 --> 00:28:43.896 A:middle
that does not work is going to

00:28:44.076 --> 00:28:45.556 A:middle
be to replace my classic

00:28:45.556 --> 00:28:46.526 A:middle
graphics frame buffer with a

00:28:46.526 --> 00:28:47.826 A:middle
read to write texture and

00:28:47.826 --> 00:28:49.536 A:middle
perform all of my rendering and

00:28:49.536 --> 00:28:50.466 A:middle
blending directly to this

00:28:50.466 --> 00:28:50.786 A:middle
texture.

00:28:51.606 --> 00:28:53.806 A:middle
But of course if the threads

00:28:53.806 --> 00:28:55.056 A:middle
that I'm blending over have yet

00:28:55.056 --> 00:28:56.246 A:middle
to execute, or concurrently

00:28:56.246 --> 00:28:58.896 A:middle
executing, this is -- this whole

00:28:58.996 --> 00:29:00.426 A:middle
remodify/write sequence is going

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:58.996 --> 00:29:00.426 A:middle
remodify/write sequence is going

00:29:00.426 --> 00:29:01.426 A:middle
to create a race condition.

00:29:02.706 --> 00:29:03.806 A:middle
So how do we use Raster Order

00:29:03.806 --> 00:29:04.976 A:middle
Groups to fix this?

00:29:05.136 --> 00:29:07.246 A:middle
It's really, really easy.

00:29:08.456 --> 00:29:09.976 A:middle
All I have to do is add a new

00:29:10.106 --> 00:29:12.826 A:middle
attribute to the memory that has

00:29:12.826 --> 00:29:13.916 A:middle
conflicting accesses.

00:29:14.716 --> 00:29:16.736 A:middle
At this point the compiler and

00:29:16.736 --> 00:29:17.526 A:middle
the hardware are going to

00:29:17.526 --> 00:29:18.706 A:middle
cooperate to be able to

00:29:18.706 --> 00:29:20.446 A:middle
implicitly take the entire range

00:29:20.696 --> 00:29:21.636 A:middle
of [inaudible] shader that

00:29:21.636 --> 00:29:22.826 A:middle
accesses that memory from the

00:29:22.826 --> 00:29:23.996 A:middle
very first to the very last

00:29:23.996 --> 00:29:25.216 A:middle
access and turn it into a

00:29:25.216 --> 00:29:26.196 A:middle
critical section behind the

00:29:26.196 --> 00:29:26.666 A:middle
scenes.

00:29:28.636 --> 00:29:29.656 A:middle
You can also apply this

00:29:29.656 --> 00:29:31.126 A:middle
attribute to normal device

00:29:31.126 --> 00:29:33.686 A:middle
memory pointers, not just

00:29:34.376 --> 00:29:34.706 A:middle
textures.

00:29:34.706 --> 00:29:37.446 A:middle
So with that we get the thread

00:29:37.446 --> 00:29:38.366 A:middle
schedule that we want.

00:29:39.046 --> 00:29:40.236 A:middle
Thread one will proceed and

00:29:40.236 --> 00:29:41.946 A:middle
write to memory and thread two

00:29:41.946 --> 00:29:43.356 A:middle
is going to stop and wait until

00:29:43.356 --> 00:29:45.876 A:middle
thread one's write's complete

00:29:45.876 --> 00:29:47.746 A:middle
giving us basically race free

00:29:47.746 --> 00:29:50.266 A:middle
access to this memory.

00:29:51.746 --> 00:29:52.916 A:middle
Oh, there's one other really

00:29:52.916 --> 00:29:53.936 A:middle
important topic and that's

00:29:53.936 --> 00:29:55.846 A:middle
talking about which threads are

00:29:55.846 --> 00:29:57.096 A:middle
synchronizing with each other.

00:29:57.536 --> 00:29:59.486 A:middle
So of course GPU hardware's

00:29:59.486 --> 00:30:00.316 A:middle
going to be running not just

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:59.486 --> 00:30:00.316 A:middle
going to be running not just

00:30:00.316 --> 00:30:02.126 A:middle
two, but tens of thousands of

00:30:02.126 --> 00:30:04.956 A:middle
threads at the same time and in

00:30:05.066 --> 00:30:06.266 A:middle
fact it's probably executing

00:30:06.266 --> 00:30:07.576 A:middle
every single thread from both of

00:30:07.576 --> 00:30:08.956 A:middle
these triangles simultaneously.

00:30:09.446 --> 00:30:11.876 A:middle
So of all of these thousands --

00:30:11.876 --> 00:30:12.636 A:middle
tens of thousands -- of threads,

00:30:12.636 --> 00:30:13.796 A:middle
which one synchronizes with each

00:30:13.796 --> 00:30:13.996 A:middle
other?

00:30:15.666 --> 00:30:17.626 A:middle
So I've highlighted one pixel

00:30:17.626 --> 00:30:18.816 A:middle
here because that's the answer

00:30:18.816 --> 00:30:19.416 A:middle
to this question.

00:30:20.186 --> 00:30:21.706 A:middle
You -- this feature only

00:30:21.706 --> 00:30:22.676 A:middle
synchronizes against other

00:30:22.676 --> 00:30:23.806 A:middle
threads that your current

00:30:23.806 --> 00:30:25.356 A:middle
fragment shooter thread overlaps

00:30:25.356 --> 00:30:27.346 A:middle
with, those other threads that

00:30:27.426 --> 00:30:28.936 A:middle
are targeting the same frame

00:30:28.936 --> 00:30:30.976 A:middle
buffer xy location, targeting

00:30:30.976 --> 00:30:32.716 A:middle
the same multi-sample location,

00:30:33.026 --> 00:30:34.136 A:middle
targeting the same render target

00:30:34.136 --> 00:30:34.616 A:middle
index.

00:30:36.556 --> 00:30:37.606 A:middle
If I wanted -- and it

00:30:37.606 --> 00:30:38.916 A:middle
specifically does not provide

00:30:38.966 --> 00:30:40.586 A:middle
any guarantees at all against --

00:30:40.586 --> 00:30:41.676 A:middle
that you can safely access

00:30:41.676 --> 00:30:43.206 A:middle
memory that are written by any

00:30:43.206 --> 00:30:44.106 A:middle
neighboring pixels.

00:30:45.196 --> 00:30:46.646 A:middle
If you do need to have these

00:30:46.646 --> 00:30:48.326 A:middle
kind of area -- or region of

00:30:48.326 --> 00:30:49.566 A:middle
influence -- kind of algorithms

00:30:49.926 --> 00:30:50.986 A:middle
then you will need to go back to

00:30:50.986 --> 00:30:52.156 A:middle
using full memory barriers

00:30:52.186 --> 00:30:53.566 A:middle
between draw call -- or full API

00:30:53.566 --> 00:30:54.726 A:middle
barriers between draw calls or

00:30:54.726 --> 00:30:55.496 A:middle
render passes.

00:30:56.206 --> 00:30:57.676 A:middle
But this comes at a much higher

00:30:57.676 --> 00:30:59.486 A:middle
performance cost and it does not

00:30:59.486 --> 00:31:00.706 A:middle
work in the case where you have

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:59.486 --> 00:31:00.706 A:middle
work in the case where you have

00:31:00.706 --> 00:31:02.066 A:middle
triangle overlap within a single

00:31:02.066 --> 00:31:02.516 A:middle
draw call.

00:31:02.816 --> 00:31:05.076 A:middle
But for these common algorithms

00:31:05.116 --> 00:31:06.636 A:middle
that you do have only need

00:31:06.636 --> 00:31:08.036 A:middle
overlap only synchronization,

00:31:08.666 --> 00:31:09.806 A:middle
Raster Order Groups can get the

00:31:09.806 --> 00:31:11.096 A:middle
job done at a substantially

00:31:11.096 --> 00:31:12.786 A:middle
lower performance cost.

00:31:13.576 --> 00:31:15.316 A:middle
So this is a pretty actually

00:31:15.506 --> 00:31:16.546 A:middle
easy one and that's really all

00:31:16.546 --> 00:31:17.226 A:middle
I've got to say about it.

00:31:17.226 --> 00:31:19.376 A:middle
Raster Order Groups lets you

00:31:19.376 --> 00:31:21.076 A:middle
efficiently wait for overlapping

00:31:21.346 --> 00:31:23.876 A:middle
and only overlapping threads to

00:31:23.876 --> 00:31:24.956 A:middle
finish their access to memory,

00:31:25.636 --> 00:31:27.376 A:middle
which enables a collection of GP

00:31:27.376 --> 00:31:28.566 A:middle
algorithms that were previously

00:31:28.566 --> 00:31:29.856 A:middle
just too inefficient to use

00:31:29.856 --> 00:31:31.116 A:middle
practically in GPU hardware.

00:31:33.336 --> 00:31:35.596 A:middle
This middle of shader thread

00:31:35.596 --> 00:31:36.906 A:middle
summarization is a feature of

00:31:36.906 --> 00:31:38.386 A:middle
the latest GPU hardware, so it

00:31:38.386 --> 00:31:39.116 A:middle
is something you do need to

00:31:39.116 --> 00:31:40.256 A:middle
check for at run time.

00:31:40.926 --> 00:31:42.276 A:middle
In particular it's supported on

00:31:42.276 --> 00:31:43.726 A:middle
the newest AMD Vega GPUs

00:31:43.726 --> 00:31:45.086 A:middle
announced this week as well as

00:31:45.086 --> 00:31:46.186 A:middle
the past couple years' worth of

00:31:46.186 --> 00:31:47.036 A:middle
Intel GPUs.

00:31:49.046 --> 00:31:50.026 A:middle
And that brings us on to our

00:31:50.026 --> 00:31:51.116 A:middle
second feature and that is the

00:31:51.116 --> 00:31:52.746 A:middle
new iPad Pro's ProMotion

00:31:52.746 --> 00:31:52.956 A:middle
Display.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:01.076 --> 00:32:02.316 A:middle
So ProMotion, this is a

00:32:02.446 --> 00:32:03.836 A:middle
particularly great feature for

00:32:03.836 --> 00:32:05.016 A:middle
graphics and game developers and

00:32:05.016 --> 00:32:06.066 A:middle
so I really want to show you

00:32:06.066 --> 00:32:07.456 A:middle
what you can do with it.

00:32:07.806 --> 00:32:10.296 A:middle
This is the first of a sequence

00:32:10.296 --> 00:32:11.436 A:middle
of timeline diagrams I'm going

00:32:11.436 --> 00:32:13.896 A:middle
to show you, showing us when the

00:32:13.896 --> 00:32:15.426 A:middle
GPU starts and finishes

00:32:15.426 --> 00:32:16.746 A:middle
producing a frame, and then when

00:32:16.746 --> 00:32:17.896 A:middle
that same frame finally gets

00:32:17.896 --> 00:32:19.086 A:middle
onto the glass for the user to

00:32:19.086 --> 00:32:19.316 A:middle
see.

00:32:20.476 --> 00:32:21.946 A:middle
The first and most obvious thing

00:32:21.946 --> 00:32:23.186 A:middle
that ProMotion does is we can

00:32:23.186 --> 00:32:24.976 A:middle
now render at 120 frames per

00:32:24.976 --> 00:32:25.376 A:middle
second.

00:32:27.146 --> 00:32:28.726 A:middle
This feels absolutely fantastic

00:32:28.726 --> 00:32:29.736 A:middle
for anything that has really

00:32:29.736 --> 00:32:31.436 A:middle
high speed animations, for

00:32:31.436 --> 00:32:32.626 A:middle
anything that's latency critical

00:32:32.626 --> 00:32:33.926 A:middle
such as tracking user touch or

00:32:33.926 --> 00:32:34.586 A:middle
pencil input.

00:32:35.376 --> 00:32:37.706 A:middle
And it does have some catches.

00:32:37.706 --> 00:32:40.176 A:middle
You of course only get half as

00:32:40.176 --> 00:32:41.976 A:middle
much CPU and GPU time available

00:32:41.976 --> 00:32:43.426 A:middle
per frame so you really have to

00:32:43.426 --> 00:32:44.186 A:middle
pay a lot of attention to

00:32:44.186 --> 00:32:46.026 A:middle
optimization and it does

00:32:46.026 --> 00:32:47.106 A:middle
increase overall system power

00:32:47.106 --> 00:32:47.646 A:middle
consumption.

00:32:48.646 --> 00:32:49.376 A:middle
But if you've got the right

00:32:49.376 --> 00:32:51.336 A:middle
content, where this matters, it

00:32:51.336 --> 00:32:52.556 A:middle
gets a really payoff for the

00:32:52.556 --> 00:32:53.406 A:middle
user experience.

00:32:54.836 --> 00:32:56.396 A:middle
But ProMotion goes a lot farther

00:32:56.396 --> 00:32:57.926 A:middle
than 120 frames per second

00:32:57.926 --> 00:32:58.226 A:middle
rendering.

00:32:59.006 --> 00:33:01.466 A:middle
It also provides much more

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:59.006 --> 00:33:01.466 A:middle
It also provides much more

00:33:01.466 --> 00:33:03.326 A:middle
flexibility regarding when to

00:33:03.326 --> 00:33:04.376 A:middle
swap the next image onto the

00:33:04.376 --> 00:33:04.846 A:middle
glass.

00:33:05.556 --> 00:33:07.606 A:middle
We're not limited to just 120 or

00:33:07.606 --> 00:33:09.726 A:middle
30 or 60 frames per second.

00:33:10.316 --> 00:33:12.646 A:middle
ProMotion behaves much more

00:33:12.646 --> 00:33:13.886 A:middle
gracefully as your application's

00:33:13.886 --> 00:33:15.276 A:middle
performance moves up and down

00:33:15.546 --> 00:33:16.586 A:middle
compared to a fixed frame rate

00:33:16.586 --> 00:33:16.996 A:middle
display.

00:33:18.206 --> 00:33:21.016 A:middle
For example, here I have a

00:33:21.056 --> 00:33:22.406 A:middle
timeline diagram of a title

00:33:22.406 --> 00:33:23.756 A:middle
that, you know just -- is just

00:33:23.756 --> 00:33:24.816 A:middle
doing too much GPU work to

00:33:24.816 --> 00:33:26.196 A:middle
target 60 frames per second.

00:33:26.346 --> 00:33:27.056 A:middle
You know they're producing

00:33:27.056 --> 00:33:28.736 A:middle
frames every about 21

00:33:28.736 --> 00:33:30.196 A:middle
milliseconds or about 48 frames

00:33:30.196 --> 00:33:30.686 A:middle
per second.

00:33:31.346 --> 00:33:33.296 A:middle
The GPU is perfectly happy to do

00:33:33.296 --> 00:33:35.366 A:middle
that, but on the display side we

00:33:35.366 --> 00:33:36.906 A:middle
can only refresh once every 16

00:33:36.906 --> 00:33:38.006 A:middle
milliseconds and so we end up

00:33:38.006 --> 00:33:38.806 A:middle
with this beating pattern.

00:33:38.876 --> 00:33:39.966 A:middle
There's this stuttering that the

00:33:39.966 --> 00:33:41.696 A:middle
user feels where some frames are

00:33:41.696 --> 00:33:42.746 A:middle
on the glass a lot longer than

00:33:42.746 --> 00:33:43.186 A:middle
others.

00:33:43.886 --> 00:33:46.656 A:middle
And it's not nice at all.

00:33:47.136 --> 00:33:48.696 A:middle
And so pretty much universally

00:33:48.696 --> 00:33:49.676 A:middle
what applications do in this

00:33:49.676 --> 00:33:50.426 A:middle
case is they all have to

00:33:50.426 --> 00:33:51.806 A:middle
artificially constrain the frame

00:33:51.806 --> 00:33:53.606 A:middle
rate all the way down to 30

00:33:53.606 --> 00:33:56.166 A:middle
frames per second.

00:33:56.166 --> 00:33:57.516 A:middle
They're basically trading away

00:33:57.516 --> 00:33:58.826 A:middle
their peak frame rate in order

00:33:58.826 --> 00:33:59.756 A:middle
to get some level of

00:33:59.756 --> 00:34:00.386 A:middle
consistency.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:59.756 --> 00:34:00.386 A:middle
consistency.

00:34:02.006 --> 00:34:03.966 A:middle
ProMotion does much better here.

00:34:04.446 --> 00:34:05.456 A:middle
So if I just take the same

00:34:05.456 --> 00:34:06.426 A:middle
application, move it to a

00:34:06.426 --> 00:34:08.956 A:middle
ProMotion display, it does this

00:34:08.956 --> 00:34:09.585 A:middle
to our timeline.

00:34:10.656 --> 00:34:11.866 A:middle
We now have a refresh point

00:34:11.866 --> 00:34:13.426 A:middle
every four milliseconds rather

00:34:13.426 --> 00:34:14.176 A:middle
than every 16.

00:34:15.096 --> 00:34:16.485 A:middle
Our timeline gets pulled in,

00:34:16.706 --> 00:34:18.116 A:middle
even with the GPU doing exactly

00:34:18.116 --> 00:34:19.116 A:middle
the same work as before.

00:34:19.735 --> 00:34:21.926 A:middle
The display can now present at

00:34:21.926 --> 00:34:23.456 A:middle
an entirely consistent 48 frames

00:34:23.456 --> 00:34:23.966 A:middle
per second.

00:34:24.815 --> 00:34:26.295 A:middle
The user is now getting both the

00:34:26.295 --> 00:34:27.956 A:middle
best possible frame rate and

00:34:27.956 --> 00:34:29.985 A:middle
perfect consistency from frame

00:34:29.985 --> 00:34:30.386 A:middle
to frame.

00:34:31.016 --> 00:34:31.946 A:middle
This tradeoff that we had to

00:34:31.946 --> 00:34:32.886 A:middle
make is completely gone.

00:34:34.076 --> 00:34:36.926 A:middle
Furthermore -- so a second

00:34:36.926 --> 00:34:38.826 A:middle
example is that this time in

00:34:38.826 --> 00:34:41.126 A:middle
application that wanted to make

00:34:41.126 --> 00:34:42.775 A:middle
60 frames per second, but one

00:34:42.775 --> 00:34:44.496 A:middle
frame just ran a bit long and we

00:34:44.496 --> 00:34:48.126 A:middle
missed our deadline.

00:34:48.126 --> 00:34:49.716 A:middle
On a fixed frame rate display we

00:34:49.716 --> 00:34:50.656 A:middle
end up on the display side with

00:34:50.656 --> 00:34:51.696 A:middle
a pattern that looks very

00:34:51.696 --> 00:34:52.956 A:middle
similar to what we saw before.

00:34:54.436 --> 00:34:55.626 A:middle
ProMotion can fix this too.

00:34:57.406 --> 00:34:58.456 A:middle
So frame one's time on the

00:34:58.456 --> 00:34:59.706 A:middle
glass, rather than it being

00:34:59.706 --> 00:35:01.166 A:middle
extended by 16 milliseconds, is

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:59.706 --> 00:35:01.166 A:middle
extended by 16 milliseconds, is

00:35:01.166 --> 00:35:02.486 A:middle
now only extended by four.

00:35:02.956 --> 00:35:04.356 A:middle
The degree of stutter that the

00:35:04.356 --> 00:35:06.266 A:middle
user experiences is tremendously

00:35:06.266 --> 00:35:08.896 A:middle
reduced and then frame two and

00:35:08.896 --> 00:35:11.166 A:middle
three, their latency gets pulled

00:35:11.166 --> 00:35:12.116 A:middle
right back into where they were

00:35:12.116 --> 00:35:12.626 A:middle
before.

00:35:13.256 --> 00:35:14.566 A:middle
The system recovers right back

00:35:14.566 --> 00:35:15.716 A:middle
onto the timeline right away,

00:35:16.166 --> 00:35:18.966 A:middle
latency is improved, and your

00:35:18.966 --> 00:35:20.276 A:middle
application can proceed on.

00:35:20.336 --> 00:35:21.136 A:middle
We've just gotten right back to

00:35:21.136 --> 00:35:22.586 A:middle
where we wanted to be.

00:35:23.246 --> 00:35:25.956 A:middle
So put it all together, it just

00:35:25.956 --> 00:35:27.646 A:middle
makes animation just feel that

00:35:27.646 --> 00:35:28.966 A:middle
much more robust and solid no

00:35:28.966 --> 00:35:30.616 A:middle
matter what's going on.

00:35:31.726 --> 00:35:33.636 A:middle
So how do you actually go about

00:35:33.636 --> 00:35:34.556 A:middle
taking advantage of this?

00:35:35.586 --> 00:35:38.406 A:middle
For normal UIKit animation, such

00:35:38.406 --> 00:35:39.376 A:middle
as scrolling through lists or

00:35:39.376 --> 00:35:41.336 A:middle
views, iOS will do this entirely

00:35:41.336 --> 00:35:42.356 A:middle
for you out of the box.

00:35:42.846 --> 00:35:44.346 A:middle
It will render it 120 frames per

00:35:44.346 --> 00:35:45.276 A:middle
second when appropriate.

00:35:45.306 --> 00:35:47.436 A:middle
It will use the flexible display

00:35:47.516 --> 00:35:48.296 A:middle
times when appropriate.

00:35:50.036 --> 00:35:51.076 A:middle
Metal applications though tend

00:35:51.076 --> 00:35:52.116 A:middle
to be much more aware of their

00:35:52.116 --> 00:35:53.306 A:middle
timing and so for those we've

00:35:53.306 --> 00:35:54.276 A:middle
made this an opt in feature.

00:35:56.116 --> 00:35:57.716 A:middle
Opting in is done really easily

00:35:57.716 --> 00:35:58.996 A:middle
just by adding a new entry to

00:35:58.996 --> 00:35:59.936 A:middle
your application bundles

00:35:59.936 --> 00:36:00.696 A:middle
info.plist.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:59.936 --> 00:36:00.696 A:middle
info.plist.

00:36:01.476 --> 00:36:03.036 A:middle
Once you do this the timing

00:36:03.036 --> 00:36:04.446 A:middle
behavior of our three Metal

00:36:04.446 --> 00:36:06.026 A:middle
presentation API changes a

00:36:06.026 --> 00:36:06.366 A:middle
little bit.

00:36:06.366 --> 00:36:07.366 A:middle
And so I'm going to walk you

00:36:07.366 --> 00:36:08.676 A:middle
through those three APIs and how

00:36:08.676 --> 00:36:09.286 A:middle
they change now.

00:36:09.976 --> 00:36:11.896 A:middle
So the first of our Metal

00:36:11.896 --> 00:36:13.876 A:middle
presentation APIs is just

00:36:14.296 --> 00:36:15.906 A:middle
present.

00:36:16.726 --> 00:36:18.556 A:middle
It's -- it says present

00:36:18.556 --> 00:36:19.986 A:middle
immediately; schedule my image

00:36:19.986 --> 00:36:20.826 A:middle
to be put on the glass at the

00:36:20.826 --> 00:36:22.496 A:middle
very next available refresh

00:36:22.556 --> 00:36:24.136 A:middle
point after the GPU finishes.

00:36:25.206 --> 00:36:26.436 A:middle
On fixed frame rate hardware

00:36:26.436 --> 00:36:28.396 A:middle
that's 16 milliseconds and on

00:36:28.396 --> 00:36:29.786 A:middle
iPad Pro that's now four

00:36:29.786 --> 00:36:30.456 A:middle
milliseconds.

00:36:30.636 --> 00:36:32.696 A:middle
This is the easiest API to use

00:36:32.696 --> 00:36:33.556 A:middle
because it takes no runs.

00:36:33.556 --> 00:36:34.876 A:middle
So it's the API that most of the

00:36:34.876 --> 00:36:35.806 A:middle
people in this room are already

00:36:35.806 --> 00:36:36.126 A:middle
using.

00:36:37.246 --> 00:36:38.376 A:middle
It's also the API that gives you

00:36:38.376 --> 00:36:39.886 A:middle
the lowest latency access to the

00:36:39.886 --> 00:36:40.286 A:middle
display.

00:36:41.386 --> 00:36:43.066 A:middle
It works identically on both our

00:36:43.066 --> 00:36:44.426 A:middle
fixed frame rate and ProMotion

00:36:44.426 --> 00:36:46.466 A:middle
hardware, but once you opt in it

00:36:46.466 --> 00:36:47.466 A:middle
starts working with much, much

00:36:47.466 --> 00:36:47.976 A:middle
better granularity.

00:36:51.476 --> 00:36:52.936 A:middle
The second of our Metal

00:36:52.936 --> 00:36:54.826 A:middle
presentation APIs is present

00:36:54.826 --> 00:36:55.866 A:middle
with minimum duration.

00:36:56.666 --> 00:36:59.066 A:middle
So this one says; whenever this

00:36:59.066 --> 00:37:00.596 A:middle
image lands on the glass, keep

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:59.066 --> 00:37:00.596 A:middle
image lands on the glass, keep

00:37:00.596 --> 00:37:01.666 A:middle
it there for a certain fixed

00:37:01.666 --> 00:37:02.306 A:middle
amount of time.

00:37:02.876 --> 00:37:03.776 A:middle
So if my image lands on the

00:37:03.776 --> 00:37:04.796 A:middle
glass here, it's going to stay

00:37:04.796 --> 00:37:05.956 A:middle
for 33 milliseconds.

00:37:05.956 --> 00:37:08.006 A:middle
And if my start time shifts so

00:37:08.006 --> 00:37:08.726 A:middle
does the end time.

00:37:09.406 --> 00:37:10.946 A:middle
This is the API you'd use if you

00:37:10.946 --> 00:37:12.216 A:middle
want perfect consistency in

00:37:12.216 --> 00:37:13.626 A:middle
frame rate from frame to frame.

00:37:14.246 --> 00:37:15.976 A:middle
This is particularly useful in

00:37:15.976 --> 00:37:17.446 A:middle
30 frames per seconds -- on 60

00:37:17.686 --> 00:37:19.236 A:middle
rate per seconds displays,

00:37:19.236 --> 00:37:20.156 A:middle
although it's also sometimes

00:37:20.156 --> 00:37:21.276 A:middle
useful on ProMotion as well.

00:37:22.246 --> 00:37:24.536 A:middle
But our third presentation

00:37:24.536 --> 00:37:25.746 A:middle
varying is the most interesting

00:37:25.746 --> 00:37:26.216 A:middle
by far.

00:37:26.406 --> 00:37:28.246 A:middle
It's present at a specific time

00:37:28.566 --> 00:37:30.316 A:middle
and it does exactly what it

00:37:30.316 --> 00:37:30.826 A:middle
sounds like.

00:37:31.566 --> 00:37:32.936 A:middle
If the GPU's done well before

00:37:32.936 --> 00:37:34.256 A:middle
the designated time, the display

00:37:34.256 --> 00:37:34.666 A:middle
will wait.

00:37:35.426 --> 00:37:36.386 A:middle
If the GPU runs over your

00:37:36.386 --> 00:37:37.796 A:middle
deadline the display will pick

00:37:37.796 --> 00:37:39.436 A:middle
it up at the very next available

00:37:39.436 --> 00:37:40.366 A:middle
point afterwards.

00:37:41.516 --> 00:37:44.086 A:middle
This is the key API to use if

00:37:44.086 --> 00:37:45.206 A:middle
you want to build fully custom

00:37:45.206 --> 00:37:46.426 A:middle
animation and timing loops.

00:37:47.116 --> 00:37:48.866 A:middle
This API to present and time,

00:37:48.946 --> 00:37:50.486 A:middle
combined with ProMotion display

00:37:50.926 --> 00:37:52.116 A:middle
basically lets you leave behind

00:37:52.116 --> 00:37:53.276 A:middle
the concept of a fixed frame

00:37:53.276 --> 00:37:54.526 A:middle
rate entirely and render your

00:37:54.526 --> 00:37:56.036 A:middle
content exactly for the time the

00:37:56.036 --> 00:37:57.026 A:middle
user is going to see it.

00:37:57.836 --> 00:37:59.126 A:middle
If you want to keep your Metal

00:37:59.126 --> 00:38:00.346 A:middle
view perfectly in synch with

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:59.126 --> 00:38:00.346 A:middle
view perfectly in synch with

00:38:00.346 --> 00:38:01.246 A:middle
something else happening on the

00:38:01.246 --> 00:38:03.206 A:middle
system, such as audio, or if you

00:38:03.206 --> 00:38:04.066 A:middle
want to basically provide the

00:38:04.066 --> 00:38:05.296 A:middle
appearance of zero latency at

00:38:05.296 --> 00:38:06.436 A:middle
all and be able to forward

00:38:06.436 --> 00:38:07.606 A:middle
project your animation for

00:38:07.606 --> 00:38:09.006 A:middle
exactly when the user's going to

00:38:09.006 --> 00:38:10.866 A:middle
see your content this is what

00:38:10.866 --> 00:38:11.676 A:middle
lets you do that.

00:38:13.096 --> 00:38:13.946 A:middle
Now of course the trick is

00:38:13.946 --> 00:38:15.156 A:middle
implementing that project next

00:38:15.156 --> 00:38:15.726 A:middle
display time.

00:38:15.726 --> 00:38:16.426 A:middle
That's your function.

00:38:17.456 --> 00:38:18.596 A:middle
To make that work you do need

00:38:18.596 --> 00:38:19.816 A:middle
some feedback from the system to

00:38:19.816 --> 00:38:20.976 A:middle
help you determine what your

00:38:20.976 --> 00:38:21.996 A:middle
actual performance is.

00:38:22.026 --> 00:38:23.186 A:middle
And so we've added that as well.

00:38:24.226 --> 00:38:26.796 A:middle
So a Metal drawable object is a

00:38:26.796 --> 00:38:27.986 A:middle
transient object that tracks the

00:38:27.986 --> 00:38:29.326 A:middle
lifetime of one image you've

00:38:29.326 --> 00:38:30.576 A:middle
rendered all the way through the

00:38:30.576 --> 00:38:31.256 A:middle
display system.

00:38:31.566 --> 00:38:34.736 A:middle
It can now be queried for the

00:38:34.736 --> 00:38:36.256 A:middle
specific time that frame lands

00:38:36.256 --> 00:38:37.446 A:middle
on the glass and you can also

00:38:37.446 --> 00:38:38.176 A:middle
get a call back when that

00:38:38.176 --> 00:38:38.706 A:middle
happens.

00:38:39.736 --> 00:38:41.296 A:middle
So now you can know when your

00:38:41.296 --> 00:38:42.536 A:middle
image is landing on the glass,

00:38:42.906 --> 00:38:44.486 A:middle
when they're being removed, and

00:38:44.486 --> 00:38:45.526 A:middle
you have the key signal to know

00:38:45.526 --> 00:38:47.186 A:middle
when you are or are not making

00:38:47.186 --> 00:38:48.236 A:middle
the designated timing that you

00:38:48.236 --> 00:38:49.716 A:middle
intended and are giving you the

00:38:49.716 --> 00:38:50.976 A:middle
signal to adjust for future

00:38:50.976 --> 00:38:51.526 A:middle
frames.

00:38:54.006 --> 00:38:55.976 A:middle
So that's the story of ProMotion

00:38:55.976 --> 00:38:57.106 A:middle
and what you need to do to make

00:38:57.106 --> 00:38:58.126 A:middle
use of it on the future -- on

00:38:58.126 --> 00:38:59.156 A:middle
these new iPad Pros.

00:38:59.766 --> 00:39:01.396 A:middle
It's incredibly easy to get more

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:59.766 --> 00:39:01.396 A:middle
It's incredibly easy to get more

00:39:01.396 --> 00:39:02.536 A:middle
consistent and higher frame

00:39:02.536 --> 00:39:05.086 A:middle
rates with almost no code

00:39:05.086 --> 00:39:06.326 A:middle
changing at all in most

00:39:06.326 --> 00:39:07.066 A:middle
applications.

00:39:08.496 --> 00:39:10.136 A:middle
From there it gives you a menu

00:39:10.136 --> 00:39:11.436 A:middle
of options to decide what

00:39:11.436 --> 00:39:12.586 A:middle
display time model is going to

00:39:12.586 --> 00:39:13.736 A:middle
best benefit your particular

00:39:13.736 --> 00:39:13.956 A:middle
app.

00:39:14.806 --> 00:39:16.186 A:middle
A really, really fast paced

00:39:16.256 --> 00:39:18.046 A:middle
Twitch arcade game or something

00:39:18.046 --> 00:39:19.816 A:middle
tracking touch or pencil input

00:39:19.816 --> 00:39:21.116 A:middle
probably wants to go for 120

00:39:21.116 --> 00:39:21.866 A:middle
frames per second.

00:39:22.476 --> 00:39:24.206 A:middle
A really high end rendering

00:39:24.206 --> 00:39:25.596 A:middle
title might want to stick with

00:39:25.656 --> 00:39:26.986 A:middle
30 or 60 frames per second or

00:39:26.986 --> 00:39:28.006 A:middle
somewhere in between and just

00:39:28.006 --> 00:39:30.286 A:middle
enjoy the consistency benefits.

00:39:30.966 --> 00:39:32.086 A:middle
And applications that want to

00:39:32.086 --> 00:39:32.996 A:middle
really take control of their

00:39:32.996 --> 00:39:34.336 A:middle
timing loop have entirely new

00:39:34.336 --> 00:39:35.376 A:middle
capabilities here as well.

00:39:36.136 --> 00:39:37.786 A:middle
But regardless of what your app

00:39:37.786 --> 00:39:39.796 A:middle
actually is, ProMotion gives you

00:39:39.796 --> 00:39:41.016 A:middle
this powerful new tool to

00:39:41.016 --> 00:39:42.286 A:middle
support its specific animation

00:39:42.286 --> 00:39:42.556 A:middle
needs.

00:39:42.556 --> 00:39:45.136 A:middle
So that's ProMotion.

00:39:45.846 --> 00:39:48.676 A:middle
So moving on, I have a different

00:39:48.766 --> 00:39:50.176 A:middle
display topic to talk about and

00:39:50.176 --> 00:39:51.106 A:middle
that is a feature we're calling

00:39:51.106 --> 00:39:52.146 A:middle
Direct 2 Display.

00:39:54.076 --> 00:39:56.036 A:middle
So the story of what happens

00:39:56.036 --> 00:39:57.866 A:middle
after your GPU finishes

00:39:57.866 --> 00:39:59.136 A:middle
rendering your content and the

00:39:59.136 --> 00:40:00.256 A:middle
display is actually a little bit

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:59.136 --> 00:40:00.256 A:middle
display is actually a little bit

00:40:00.256 --> 00:40:00.896 A:middle
more complicated.

00:40:00.966 --> 00:40:02.716 A:middle
And then your image can take two

00:40:02.716 --> 00:40:04.666 A:middle
paths to the display; GPU

00:40:04.666 --> 00:40:06.856 A:middle
composition and direct to

00:40:07.956 --> 00:40:08.146 A:middle
display.

00:40:08.266 --> 00:40:10.086 A:middle
The first of those is a -- your

00:40:10.086 --> 00:40:11.776 A:middle
typical user interface scenario

00:40:12.366 --> 00:40:13.306 A:middle
where I've got a collection of

00:40:13.306 --> 00:40:14.916 A:middle
views or layers or windows and

00:40:14.916 --> 00:40:17.256 A:middle
the like and at this point the

00:40:17.256 --> 00:40:18.206 A:middle
system is going to take all of

00:40:18.206 --> 00:40:18.966 A:middle
these and composite them

00:40:18.966 --> 00:40:19.326 A:middle
together.

00:40:19.466 --> 00:40:20.596 A:middle
It's going to scale any content

00:40:20.596 --> 00:40:21.236 A:middle
to fit the display.

00:40:21.236 --> 00:40:21.736 A:middle
It's going to perform

00:40:21.736 --> 00:40:22.626 A:middle
color/space conversion.

00:40:22.626 --> 00:40:23.576 A:middle
It's going to perform -- apply

00:40:23.576 --> 00:40:24.606 A:middle
any core image filters or

00:40:24.606 --> 00:40:25.886 A:middle
blending and it's going to

00:40:25.886 --> 00:40:27.346 A:middle
produce the one, final combined

00:40:27.346 --> 00:40:28.466 A:middle
image that the user sees.

00:40:30.606 --> 00:40:32.266 A:middle
This is really, really critical

00:40:32.266 --> 00:40:33.496 A:middle
abstraction for full-featured

00:40:33.496 --> 00:40:34.406 A:middle
user interfaces.

00:40:35.896 --> 00:40:37.846 A:middle
But it's also all done on the

00:40:37.846 --> 00:40:39.006 A:middle
GPU and it takes some time and

00:40:39.006 --> 00:40:39.536 A:middle
memory there.

00:40:40.266 --> 00:40:41.576 A:middle
And if we're basically building,

00:40:41.576 --> 00:40:42.476 A:middle
you know a full-screen

00:40:42.476 --> 00:40:43.886 A:middle
application, you know it's a

00:40:43.886 --> 00:40:44.956 A:middle
little bit overkill for that.

00:40:45.426 --> 00:40:46.136 A:middle
And so that's where direct

00:40:46.136 --> 00:40:47.936 A:middle
display mode comes in.

00:40:48.086 --> 00:40:49.066 A:middle
If none of these operations are

00:40:49.066 --> 00:40:51.326 A:middle
actually required, we can point

00:40:51.326 --> 00:40:52.766 A:middle
the display hardware directly at

00:40:52.806 --> 00:40:54.046 A:middle
the memory you just rendered to

00:40:54.416 --> 00:40:55.686 A:middle
and so without any middleman at

00:40:55.686 --> 00:40:55.816 A:middle
all.

00:40:56.716 --> 00:40:58.856 A:middle
So how do you enable this?

00:40:59.236 --> 00:41:01.026 A:middle
It turns out there is no single

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:59.236 --> 00:41:01.026 A:middle
It turns out there is no single

00:41:01.026 --> 00:41:02.546 A:middle
turn it on API for direct to

00:41:02.546 --> 00:41:02.966 A:middle
display.

00:41:03.736 --> 00:41:05.396 A:middle
This mode is really an omission

00:41:05.396 --> 00:41:06.626 A:middle
of anything that requires the

00:41:06.626 --> 00:41:07.986 A:middle
GPU compositer to intervene.

00:41:08.656 --> 00:41:10.216 A:middle
When the compositer takes a look

00:41:10.216 --> 00:41:11.426 A:middle
at the set-up of your scene and

00:41:11.426 --> 00:41:12.856 A:middle
says there's nothing it needs to

00:41:12.856 --> 00:41:14.736 A:middle
do here it will just step out of

00:41:15.406 --> 00:41:16.296 A:middle
the way.

00:41:16.296 --> 00:41:18.006 A:middle
So how can you set up your scene

00:41:18.006 --> 00:41:20.556 A:middle
to get the compositer to step

00:41:20.556 --> 00:41:22.396 A:middle
out of the way?

00:41:22.476 --> 00:41:23.526 A:middle
So this is pretty

00:41:23.526 --> 00:41:24.746 A:middle
straightforward, an intuitive

00:41:24.796 --> 00:41:25.996 A:middle
feel of, does my content need

00:41:25.996 --> 00:41:26.936 A:middle
any kind of nontrurial

00:41:26.936 --> 00:41:27.676 A:middle
[phonetic] processing is a

00:41:27.676 --> 00:41:29.166 A:middle
pretty good intuitive start.

00:41:29.896 --> 00:41:30.976 A:middle
But more specifically you do

00:41:30.976 --> 00:41:31.986 A:middle
want your layer to be opaque.

00:41:32.556 --> 00:41:33.586 A:middle
I don't want to be blending over

00:41:33.586 --> 00:41:33.936 A:middle
anything.

00:41:34.246 --> 00:41:36.446 A:middle
We don't want to apply anything

00:41:36.446 --> 00:41:37.546 A:middle
that requires that core

00:41:37.546 --> 00:41:38.496 A:middle
animation or the window server

00:41:38.766 --> 00:41:39.776 A:middle
modify our pixels.

00:41:39.776 --> 00:41:40.676 A:middle
We don't want to put on rounded

00:41:40.676 --> 00:41:42.236 A:middle
corners in our view or masking

00:41:42.236 --> 00:41:44.206 A:middle
or filters or the like.

00:41:45.496 --> 00:41:46.726 A:middle
We do want to be full-screen.

00:41:47.076 --> 00:41:49.326 A:middle
If your content does not

00:41:49.326 --> 00:41:51.086 A:middle
actually match the aspect ratio

00:41:51.086 --> 00:41:52.266 A:middle
of the display it is okay to put

00:41:52.266 --> 00:41:53.726 A:middle
a full-screen, opaque, black

00:41:53.726 --> 00:41:55.166 A:middle
background layer to sort of give

00:41:55.166 --> 00:41:56.226 A:middle
a black bar kind of effect.

00:41:56.226 --> 00:41:57.046 A:middle
But in the end we want to

00:41:57.046 --> 00:41:58.346 A:middle
basically obscure everything.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:01.286 --> 00:42:02.486 A:middle
We do want to pick render

00:42:02.486 --> 00:42:03.466 A:middle
resolutions that match the

00:42:03.466 --> 00:42:04.136 A:middle
native panel.

00:42:05.016 --> 00:42:06.246 A:middle
So this is actually a little bit

00:42:06.246 --> 00:42:07.446 A:middle
tricky because all of our --

00:42:07.446 --> 00:42:08.896 A:middle
both on macOS and iOS we ship

00:42:08.896 --> 00:42:10.396 A:middle
hardware that has a virtual

00:42:10.396 --> 00:42:12.336 A:middle
desktop modes or resolution

00:42:12.336 --> 00:42:13.526 A:middle
modes that are larger than the

00:42:13.526 --> 00:42:14.496 A:middle
actual physical panel.

00:42:14.596 --> 00:42:16.036 A:middle
And the last thing we want to do

00:42:16.036 --> 00:42:17.216 A:middle
is spend time rendering too many

00:42:17.216 --> 00:42:18.446 A:middle
pixels only to have to spend

00:42:18.446 --> 00:42:19.586 A:middle
time on the GPU to scale it all

00:42:19.586 --> 00:42:19.976 A:middle
back down again.

00:42:24.296 --> 00:42:25.676 A:middle
And finally, you want to pick a

00:42:25.676 --> 00:42:26.806 A:middle
color, space, and pixel format

00:42:26.806 --> 00:42:27.876 A:middle
that the display hardware is

00:42:27.876 --> 00:42:29.016 A:middle
happy to read from directly.

00:42:29.896 --> 00:42:30.956 A:middle
And so this one, there's any

00:42:30.956 --> 00:42:32.046 A:middle
infinite number of combinations

00:42:32.046 --> 00:42:33.816 A:middle
here so I want to help out by

00:42:33.816 --> 00:42:34.486 A:middle
giving you a little bit of a

00:42:34.486 --> 00:42:35.816 A:middle
white list of some particularly

00:42:35.816 --> 00:42:36.746 A:middle
common and efficient

00:42:36.746 --> 00:42:37.416 A:middle
combinations.

00:42:39.766 --> 00:42:41.426 A:middle
So right on the top is our good

00:42:41.426 --> 00:42:44.406 A:middle
old friend; SRGB8888.

00:42:44.406 --> 00:42:45.326 A:middle
This is pretty much the

00:42:45.326 --> 00:42:46.816 A:middle
universal pixel format that most

00:42:46.816 --> 00:42:48.636 A:middle
applications use and all

00:42:48.636 --> 00:42:50.446 A:middle
hardware is happy to read.

00:42:50.446 --> 00:42:51.606 A:middle
And so for most people that's

00:42:51.606 --> 00:42:52.026 A:middle
all they need.

00:42:53.496 --> 00:42:55.706 A:middle
But we've been shipping wide

00:42:55.706 --> 00:42:57.926 A:middle
color gamut P3 displays on both

00:42:57.926 --> 00:43:00.686 A:middle
our macOS and iOS hardware and

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:57.926 --> 00:43:00.686 A:middle
our macOS and iOS hardware and

00:43:00.936 --> 00:43:02.076 A:middle
if your application does want to

00:43:02.076 --> 00:43:03.596 A:middle
start making use of this ability

00:43:03.596 --> 00:43:04.756 A:middle
to represent more colors, you

00:43:04.756 --> 00:43:05.836 A:middle
need to pay a bit more

00:43:05.836 --> 00:43:06.226 A:middle
attention.

00:43:06.226 --> 00:43:09.496 A:middle
In both the -- the concepts are

00:43:09.496 --> 00:43:10.916 A:middle
the same between iOS and macOS,

00:43:10.916 --> 00:43:11.826 A:middle
although the details differ a

00:43:11.826 --> 00:43:13.146 A:middle
little bit.

00:43:13.146 --> 00:43:14.516 A:middle
In both cases we do want to

00:43:14.516 --> 00:43:15.676 A:middle
render to attend the pixel

00:43:17.096 --> 00:43:19.936 A:middle
format, but note that if you

00:43:19.936 --> 00:43:21.396 A:middle
render P3 content onto a P3

00:43:21.396 --> 00:43:23.116 A:middle
display that's fine, but if you

00:43:23.116 --> 00:43:25.516 A:middle
render P3 content onto an SRGB

00:43:25.516 --> 00:43:27.996 A:middle
display the system -- the GP

00:43:27.996 --> 00:43:29.096 A:middle
compositer might have to get

00:43:29.096 --> 00:43:30.156 A:middle
involved to crush the color

00:43:30.156 --> 00:43:31.256 A:middle
space back down to fit the

00:43:31.256 --> 00:43:31.646 A:middle
display.

00:43:32.536 --> 00:43:34.036 A:middle
And so this is -- P3 is not

00:43:34.036 --> 00:43:34.646 A:middle
something you want to do

00:43:34.646 --> 00:43:35.826 A:middle
universally, all the time.

00:43:35.936 --> 00:43:37.006 A:middle
you do want to take a look at

00:43:37.056 --> 00:43:39.286 A:middle
the current display and make

00:43:39.286 --> 00:43:40.446 A:middle
this a conditional thing.

00:43:40.816 --> 00:43:43.186 A:middle
So finally, for completeness I'm

00:43:43.186 --> 00:43:44.556 A:middle
also going to list RGBA float

00:43:44.556 --> 00:43:45.696 A:middle
16, which is sort of the

00:43:45.696 --> 00:43:47.946 A:middle
universal, wide gamut, high

00:43:47.946 --> 00:43:49.236 A:middle
dynamic range pixel format.

00:43:49.786 --> 00:43:51.916 A:middle
Although, in -- I do -- it's

00:43:51.916 --> 00:43:53.096 A:middle
also necessary for MacOS's

00:43:53.096 --> 00:43:54.286 A:middle
extended data range feature.

00:43:55.026 --> 00:43:55.906 A:middle
Although it is worth noting that

00:43:55.906 --> 00:43:57.306 A:middle
it does require GPU compositing

00:43:57.306 --> 00:43:57.976 A:middle
in all cases.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:01.486 --> 00:44:02.396 A:middle
So I mentioned, you do want to

00:44:02.396 --> 00:44:03.606 A:middle
be a little bit conditional if

00:44:03.606 --> 00:44:04.536 A:middle
you write an application that's

00:44:04.536 --> 00:44:05.416 A:middle
wide color aware.

00:44:06.206 --> 00:44:07.576 A:middle
Fortunately, both UIKit and

00:44:07.616 --> 00:44:08.606 A:middle
AppKit provide really convenient

00:44:08.606 --> 00:44:08.976 A:middle
APIs to check that.

00:44:13.086 --> 00:44:14.616 A:middle
So the last step is, how do you

00:44:14.616 --> 00:44:15.886 A:middle
know if you're actually on the

00:44:15.886 --> 00:44:17.476 A:middle
directed display path?

00:44:17.476 --> 00:44:18.506 A:middle
So this is a screen shot of our

00:44:18.506 --> 00:44:19.796 A:middle
Metal system trace tool and

00:44:19.796 --> 00:44:20.396 A:middle
instruments.

00:44:20.646 --> 00:44:23.186 A:middle
And Metal system trace is pretty

00:44:23.186 --> 00:44:24.836 A:middle
much a developer tool that will

00:44:24.836 --> 00:44:26.486 A:middle
give you a live timeline of the

00:44:26.486 --> 00:44:27.706 A:middle
CPU and the GPU in the display.

00:44:28.046 --> 00:44:29.936 A:middle
Pretty much a real-world version

00:44:29.936 --> 00:44:30.826 A:middle
of the diagrams I've been

00:44:30.826 --> 00:44:31.466 A:middle
showing you in this

00:44:31.466 --> 00:44:32.066 A:middle
presentation.

00:44:33.226 --> 00:44:35.046 A:middle
So in this case, I want to

00:44:35.046 --> 00:44:36.416 A:middle
highlight my three frames that

00:44:36.416 --> 00:44:36.846 A:middle
I've rendered.

00:44:37.376 --> 00:44:38.936 A:middle
The color-time intervals are my

00:44:38.936 --> 00:44:39.946 A:middle
own application's rendering.

00:44:41.126 --> 00:44:42.556 A:middle
And the gray time intervals are

00:44:42.556 --> 00:44:44.276 A:middle
some other processes in the GPU.

00:44:45.546 --> 00:44:46.636 A:middle
I can get more details down at

00:44:46.636 --> 00:44:47.506 A:middle
the bottom of the window or I

00:44:47.506 --> 00:44:48.136 A:middle
can see it's coming from

00:44:48.136 --> 00:44:50.666 A:middle
backboard D, our iOS composition

00:44:50.666 --> 00:44:51.236 A:middle
process.

00:44:51.426 --> 00:44:52.436 A:middle
So this is the case where my

00:44:52.436 --> 00:44:53.506 A:middle
application is going down the

00:44:53.506 --> 00:44:55.766 A:middle
GPU compositing path.

00:44:55.766 --> 00:44:56.726 A:middle
Going back and revisiting some

00:44:56.726 --> 00:44:58.996 A:middle
of our best practices can remove

00:44:58.996 --> 00:45:00.316 A:middle
that from the picture and now I

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:58.996 --> 00:45:00.316 A:middle
that from the picture and now I

00:45:00.316 --> 00:45:01.946 A:middle
can rerun my Metal system trace

00:45:02.386 --> 00:45:03.806 A:middle
and see that I have a timeline

00:45:03.806 --> 00:45:05.456 A:middle
where, you know I've got the GPU

00:45:05.546 --> 00:45:06.446 A:middle
completely and entirely to

00:45:06.446 --> 00:45:06.936 A:middle
myself.

00:45:10.156 --> 00:45:11.846 A:middle
So that's it for direct to

00:45:11.976 --> 00:45:12.586 A:middle
display.

00:45:12.586 --> 00:45:13.916 A:middle
Our system compositors can make

00:45:13.916 --> 00:45:15.206 A:middle
a lot of magic happen behind the

00:45:15.206 --> 00:45:16.576 A:middle
scenes to make full-featured

00:45:16.576 --> 00:45:18.446 A:middle
user interfaces possible, but

00:45:18.446 --> 00:45:19.536 A:middle
that can come at a performance

00:45:19.536 --> 00:45:20.806 A:middle
cost because they use the GPU to

00:45:20.806 --> 00:45:21.256 A:middle
do it.

00:45:22.216 --> 00:45:23.286 A:middle
By being a little bit aware of

00:45:23.286 --> 00:45:23.866 A:middle
what you're asking the

00:45:23.866 --> 00:45:25.366 A:middle
compositer to do, or more

00:45:25.366 --> 00:45:26.726 A:middle
importantly by not asking what

00:45:26.726 --> 00:45:28.016 A:middle
you're not asking the compositer

00:45:28.016 --> 00:45:29.876 A:middle
to do, it can get out of the way

00:45:29.876 --> 00:45:31.646 A:middle
without using the GPU, returning

00:45:31.646 --> 00:45:32.586 A:middle
some of that time to you.

00:45:33.326 --> 00:45:35.356 A:middle
Direct to display is supported

00:45:35.356 --> 00:45:36.876 A:middle
on iOS and Tos and always has

00:45:36.876 --> 00:45:38.886 A:middle
been and its support is new to

00:45:38.886 --> 00:45:40.476 A:middle
macOS High Sierra for Metal

00:45:40.476 --> 00:45:40.966 A:middle
applications.

00:45:45.196 --> 00:45:46.366 A:middle
So with that I want to touch on

00:45:46.366 --> 00:45:47.956 A:middle
our last topic of the day and

00:45:47.956 --> 00:45:50.396 A:middle
that's everything else.

00:45:50.446 --> 00:45:51.546 A:middle
There's a lot more that we've

00:45:51.546 --> 00:45:52.656 A:middle
added to the core frameworks and

00:45:52.656 --> 00:45:53.846 A:middle
sheeting language for Metal 2.

00:45:53.906 --> 00:45:55.136 A:middle
And so I'm not going to dive

00:45:55.136 --> 00:45:56.056 A:middle
deep into any of these things,

00:45:56.056 --> 00:45:56.716 A:middle
but I do want to give you a

00:45:56.716 --> 00:45:57.006 A:middle
survey.

00:45:57.006 --> 00:46:00.076 A:middle
So right off the bat we've added

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:57.006 --> 00:46:00.076 A:middle
So right off the bat we've added

00:46:00.366 --> 00:46:01.766 A:middle
some new APIs to be able to

00:46:01.766 --> 00:46:03.746 A:middle
query how much GPU memory's

00:46:03.746 --> 00:46:05.146 A:middle
being allocated for each buffer,

00:46:05.146 --> 00:46:06.276 A:middle
for each texture, for each Heap.

00:46:06.566 --> 00:46:08.816 A:middle
This actually takes into account

00:46:08.816 --> 00:46:09.406 A:middle
things that just generally

00:46:09.406 --> 00:46:10.496 A:middle
happen behind the scenes, like

00:46:10.496 --> 00:46:12.326 A:middle
alignment and various padding.

00:46:12.986 --> 00:46:13.826 A:middle
So this can give you a more

00:46:13.826 --> 00:46:15.186 A:middle
accurate view of how much GPU

00:46:15.186 --> 00:46:16.416 A:middle
memory you're actually using.

00:46:16.416 --> 00:46:19.296 A:middle
We also have a roll-up query on

00:46:19.296 --> 00:46:21.836 A:middle
the Metal device, which is the

00:46:21.836 --> 00:46:23.596 A:middle
entire GPU memory usage for your

00:46:23.596 --> 00:46:24.606 A:middle
entire process.

00:46:24.936 --> 00:46:26.546 A:middle
And this is particularly notable

00:46:26.546 --> 00:46:28.436 A:middle
because that also counts all of

00:46:28.436 --> 00:46:29.446 A:middle
the memory that the driver needs

00:46:29.446 --> 00:46:30.786 A:middle
to allocate that's not otherwise

00:46:30.786 --> 00:46:32.986 A:middle
visible to you; things like

00:46:32.986 --> 00:46:34.506 A:middle
memory to put shader code in or

00:46:34.506 --> 00:46:35.516 A:middle
command buffers or anything

00:46:35.516 --> 00:46:35.906 A:middle
else.

00:46:36.396 --> 00:46:37.346 A:middle
So this can give you where

00:46:37.346 --> 00:46:38.326 A:middle
you're at relative -- you know

00:46:38.376 --> 00:46:39.406 A:middle
everything all in compared to

00:46:39.406 --> 00:46:39.976 A:middle
your memory usage target.

00:46:43.566 --> 00:46:44.496 A:middle
We have a couple compute

00:46:44.496 --> 00:46:45.416 A:middle
oriented additions.

00:46:45.866 --> 00:46:47.076 A:middle
The first of those is that we've

00:46:47.076 --> 00:46:48.106 A:middle
added a set of shading language

00:46:48.106 --> 00:46:49.466 A:middle
functions to help -- to allow

00:46:49.466 --> 00:46:50.656 A:middle
you to transfer data directly

00:46:50.656 --> 00:46:51.806 A:middle
between threads in a SIMD group.

00:46:52.026 --> 00:46:54.126 A:middle
If you're not familiar; GPU

00:46:54.126 --> 00:46:55.356 A:middle
hardware typically gains an

00:46:55.576 --> 00:46:57.436 A:middle
individual vertex fragment and

00:46:57.436 --> 00:46:59.426 A:middle
compute shader thread into SIMD

00:46:59.426 --> 00:47:00.586 A:middle
groups and executes them

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:59.426 --> 00:47:00.586 A:middle
groups and executes them

00:47:00.586 --> 00:47:01.816 A:middle
together for greater efficiency.

00:47:02.366 --> 00:47:04.096 A:middle
This are also called wayfrencer

00:47:04.096 --> 00:47:04.576 A:middle
[phonetic] warps.

00:47:05.596 --> 00:47:07.216 A:middle
Within a group these threads do

00:47:07.216 --> 00:47:08.336 A:middle
have some ability to directly

00:47:08.336 --> 00:47:09.586 A:middle
communicate without having to

00:47:09.586 --> 00:47:10.626 A:middle
load and store through memory.

00:47:11.236 --> 00:47:12.956 A:middle
They can read values directly

00:47:12.956 --> 00:47:14.046 A:middle
out of one thread's register and

00:47:14.046 --> 00:47:14.926 A:middle
write them to another thread's

00:47:14.926 --> 00:47:15.496 A:middle
register.

00:47:15.626 --> 00:47:16.346 A:middle
And that's what these new

00:47:16.346 --> 00:47:17.336 A:middle
standard library functions

00:47:17.336 --> 00:47:17.636 A:middle
allow.

00:47:18.626 --> 00:47:21.346 A:middle
So in this case broadcast means

00:47:21.346 --> 00:47:22.576 A:middle
I can read a data directly --

00:47:22.686 --> 00:47:24.056 A:middle
read a field directly out of

00:47:24.056 --> 00:47:25.356 A:middle
thread zero's registers and

00:47:25.356 --> 00:47:26.236 A:middle
write it directly into the

00:47:26.236 --> 00:47:27.696 A:middle
registers of 16 other threads

00:47:27.696 --> 00:47:28.626 A:middle
that happen to be part of this

00:47:28.626 --> 00:47:28.856 A:middle
group.

00:47:33.046 --> 00:47:34.436 A:middle
Our second compute addition is

00:47:34.436 --> 00:47:35.606 A:middle
to give you more flexibility in

00:47:35.606 --> 00:47:36.906 A:middle
how big your thread groups are.

00:47:37.786 --> 00:47:39.396 A:middle
So for example if I have a pixel

00:47:39.396 --> 00:47:40.376 A:middle
bird here that I want to run

00:47:40.376 --> 00:47:41.746 A:middle
some pretty classic image

00:47:41.746 --> 00:47:44.696 A:middle
processing kernel over, but then

00:47:44.696 --> 00:47:45.766 A:middle
I've written my compute kernel

00:47:45.766 --> 00:47:47.486 A:middle
such that I'm using four by four

00:47:47.486 --> 00:47:48.336 A:middle
thread groups everywhere.

00:47:49.736 --> 00:47:50.766 A:middle
Well, this leads to some

00:47:50.766 --> 00:47:52.076 A:middle
problems because I've got -- if

00:47:52.076 --> 00:47:53.546 A:middle
my image is not a nice multiple

00:47:53.546 --> 00:47:54.886 A:middle
of my thread group size I've got

00:47:54.886 --> 00:47:55.896 A:middle
a bunch of stray threads on the

00:47:55.896 --> 00:47:56.226 A:middle
side.

00:47:56.886 --> 00:47:59.596 A:middle
I mean this means that I've got

00:47:59.596 --> 00:48:01.556 A:middle
to dive into those and say when

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:59.596 --> 00:48:01.556 A:middle
to dive into those and say when

00:48:01.556 --> 00:48:02.376 A:middle
I actually write my code.

00:48:02.376 --> 00:48:03.296 A:middle
I have to be defensive.

00:48:03.296 --> 00:48:04.156 A:middle
Am I out of bounds?

00:48:04.156 --> 00:48:04.986 A:middle
I have to handle it in some

00:48:04.986 --> 00:48:05.566 A:middle
special way.

00:48:05.566 --> 00:48:06.976 A:middle
It's doable but annoying.

00:48:07.806 --> 00:48:08.746 A:middle
It also means that we're just

00:48:08.746 --> 00:48:09.966 A:middle
wasting GPU cycles.

00:48:11.096 --> 00:48:12.726 A:middle
So non-uniform thread group

00:48:12.726 --> 00:48:14.366 A:middle
sizes, unless you declare what

00:48:14.366 --> 00:48:15.306 A:middle
dimensions you want to run your

00:48:15.306 --> 00:48:16.726 A:middle
kernel over, without being

00:48:16.726 --> 00:48:17.956 A:middle
multiple thread group sizes.

00:48:18.556 --> 00:48:19.986 A:middle
So the hard working, smaller

00:48:19.986 --> 00:48:21.596 A:middle
thread groups along the edges of

00:48:21.596 --> 00:48:23.366 A:middle
my grid, in order to say -- in

00:48:23.366 --> 00:48:24.296 A:middle
order to just shave off that

00:48:24.296 --> 00:48:25.836 A:middle
unnecessary work it both

00:48:25.936 --> 00:48:28.286 A:middle
improves GPU performance and

00:48:28.286 --> 00:48:29.586 A:middle
just makes your kernels easier

00:48:29.586 --> 00:48:29.856 A:middle
to write.

00:48:34.066 --> 00:48:35.046 A:middle
We've added support for a view

00:48:35.046 --> 00:48:35.716 A:middle
port arrays.

00:48:35.956 --> 00:48:37.576 A:middle
You can now configure up to 16

00:48:37.576 --> 00:48:39.226 A:middle
simultaneous view ports and your

00:48:39.226 --> 00:48:40.966 A:middle
vertex shader can select, per

00:48:40.966 --> 00:48:42.596 A:middle
triangle, which view port that

00:48:42.596 --> 00:48:43.746 A:middle
triangle gets presented into.

00:48:44.446 --> 00:48:45.426 A:middle
I'm not going to go further into

00:48:45.426 --> 00:48:46.086 A:middle
this because it will be

00:48:46.086 --> 00:48:47.856 A:middle
discussed in detail tomorrow in

00:48:47.856 --> 00:48:49.006 A:middle
the VR with Metal 2 session.

00:48:49.376 --> 00:48:50.746 A:middle
It is particularly valuable for

00:48:50.746 --> 00:48:51.446 A:middle
efficiently rendering to the

00:48:51.446 --> 00:48:51.976 A:middle
left and right eyes.

00:48:56.496 --> 00:48:57.306 A:middle
We've added the ability to

00:48:57.306 --> 00:48:58.946 A:middle
choose where each pixel your

00:48:58.946 --> 00:48:59.906 A:middle
multi-sample locations are

00:48:59.906 --> 00:49:00.426 A:middle
supported.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:59.906 --> 00:49:00.426 A:middle
supported.

00:49:01.026 --> 00:49:02.606 A:middle
This lets you do a few

00:49:02.606 --> 00:49:04.186 A:middle
interesting things including

00:49:04.186 --> 00:49:05.196 A:middle
maybe toggling your sample

00:49:05.196 --> 00:49:07.086 A:middle
positions every other frame and

00:49:07.086 --> 00:49:07.796 A:middle
giving you some new -- you know

00:49:07.796 --> 00:49:08.856 A:middle
valuable input into some

00:49:08.856 --> 00:49:09.696 A:middle
temporal anti-aliasing

00:49:09.696 --> 00:49:09.976 A:middle
algorithms.

00:49:15.546 --> 00:49:17.036 A:middle
In the vein of trying to keep --

00:49:17.096 --> 00:49:18.556 A:middle
of working to bring our

00:49:18.556 --> 00:49:19.586 A:middle
platforms up to date to have

00:49:19.636 --> 00:49:20.646 A:middle
them have the same feature set

00:49:20.646 --> 00:49:21.686 A:middle
wherever possible, we've brought

00:49:21.686 --> 00:49:23.186 A:middle
resource Heaps, shipped last

00:49:23.186 --> 00:49:25.416 A:middle
year in iOS 10 to macOS High

00:49:25.416 --> 00:49:26.196 A:middle
Sierra this year.

00:49:26.466 --> 00:49:28.646 A:middle
So I'm going to actually do a

00:49:28.646 --> 00:49:29.756 A:middle
little bit of a refresher on

00:49:29.756 --> 00:49:32.026 A:middle
this because good use of your

00:49:32.026 --> 00:49:33.716 A:middle
Heaps is really important to

00:49:33.716 --> 00:49:34.646 A:middle
getting the most out of argument

00:49:34.646 --> 00:49:35.066 A:middle
buffers.

00:49:36.436 --> 00:49:37.816 A:middle
So Heaps are of course where I

00:49:37.816 --> 00:49:38.716 A:middle
can allocate a big slab of

00:49:38.716 --> 00:49:40.616 A:middle
memory up front rather than

00:49:40.616 --> 00:49:42.246 A:middle
going to the kernel to -- I want

00:49:42.346 --> 00:49:43.756 A:middle
memory for texture a, and I want

00:49:43.756 --> 00:49:44.876 A:middle
memory for texture b and so

00:49:44.876 --> 00:49:45.246 A:middle
forth.

00:49:45.656 --> 00:49:46.716 A:middle
I can go to the kernel and get

00:49:46.716 --> 00:49:48.866 A:middle
memory right up front and of

00:49:48.866 --> 00:49:50.196 A:middle
course put textures -- you know

00:49:50.226 --> 00:49:51.386 A:middle
add and remove textures and

00:49:51.386 --> 00:49:52.736 A:middle
buffers to -- without having to

00:49:52.806 --> 00:49:55.226 A:middle
go back to the system.

00:49:55.296 --> 00:49:56.586 A:middle
This has a few advantages.

00:49:56.776 --> 00:49:58.036 A:middle
It means that I can bind

00:49:58.036 --> 00:49:58.946 A:middle
everything in that Heap much

00:49:58.946 --> 00:49:59.556 A:middle
more efficiently.

00:49:59.736 --> 00:50:00.496 A:middle
There's much less software

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:49:59.736 --> 00:50:00.496 A:middle
There's much less software

00:50:00.496 --> 00:50:00.856 A:middle
overhead.

00:50:01.616 --> 00:50:02.766 A:middle
It means that we can oftentimes

00:50:02.766 --> 00:50:03.716 A:middle
pack that memory a little bit

00:50:03.756 --> 00:50:04.306 A:middle
closer together.

00:50:04.306 --> 00:50:05.376 A:middle
We can save some padding and

00:50:05.376 --> 00:50:06.906 A:middle
alignment, save you a little bit

00:50:07.396 --> 00:50:08.546 A:middle
of memory.

00:50:08.686 --> 00:50:09.946 A:middle
It means when we delete memory

00:50:10.256 --> 00:50:11.646 A:middle
we don't give memory back to the

00:50:11.646 --> 00:50:12.056 A:middle
system.

00:50:12.356 --> 00:50:13.116 A:middle
That could be good or bad.

00:50:13.826 --> 00:50:15.496 A:middle
It means when we allocate new

00:50:15.496 --> 00:50:16.356 A:middle
memory -- when we allocate a new

00:50:16.356 --> 00:50:17.486 A:middle
texture it means we don't have

00:50:17.486 --> 00:50:18.526 A:middle
to go back to the system and get

00:50:18.526 --> 00:50:18.976 A:middle
new memory.

00:50:22.306 --> 00:50:23.226 A:middle
It also means that you can

00:50:23.226 --> 00:50:24.746 A:middle
choose to alias these textures

00:50:24.746 --> 00:50:25.296 A:middle
with each other.

00:50:26.086 --> 00:50:27.436 A:middle
If I have -- you typically

00:50:27.436 --> 00:50:29.286 A:middle
render targets or intermediate

00:50:29.286 --> 00:50:30.956 A:middle
render targets between different

00:50:30.956 --> 00:50:32.486 A:middle
passes in my render graph.

00:50:32.906 --> 00:50:34.006 A:middle
It means that if I have two

00:50:34.006 --> 00:50:34.716 A:middle
different intermediates that

00:50:34.716 --> 00:50:36.456 A:middle
just don't have to exist at the

00:50:36.456 --> 00:50:37.796 A:middle
same point in time I can alias

00:50:37.796 --> 00:50:38.756 A:middle
them over each other and I can

00:50:38.756 --> 00:50:43.236 A:middle
save tons of memory like this.

00:50:43.926 --> 00:50:45.906 A:middle
So that's it for a quick survey

00:50:46.686 --> 00:50:47.736 A:middle
of Heaps.

00:50:47.816 --> 00:50:50.026 A:middle
We've added linear textures from

00:50:50.206 --> 00:50:51.886 A:middle
iOS to macOS.

00:50:52.126 --> 00:50:53.196 A:middle
Linear textures allows you to

00:50:53.196 --> 00:50:54.976 A:middle
create a texture directly from a

00:50:54.976 --> 00:50:56.566 A:middle
Metal buffer without any copies

00:50:56.616 --> 00:50:57.046 A:middle
at all.

00:50:59.136 --> 00:51:00.106 A:middle
We've extended our function

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:59.136 --> 00:51:00.106 A:middle
We've extended our function

00:51:00.106 --> 00:51:01.556 A:middle
constant feature a little bit.

00:51:01.556 --> 00:51:02.586 A:middle
A quick refresher, function

00:51:02.586 --> 00:51:03.486 A:middle
constants allow you to

00:51:03.486 --> 00:51:04.716 A:middle
specialize by codes.

00:51:04.936 --> 00:51:05.756 A:middle
When you've done all your front

00:51:05.756 --> 00:51:07.296 A:middle
end compilation offline you can

00:51:07.296 --> 00:51:08.466 A:middle
then tweak and customize your

00:51:08.466 --> 00:51:09.716 A:middle
uber shader bi-code a little bit

00:51:09.936 --> 00:51:11.126 A:middle
before actual generating final

00:51:11.126 --> 00:51:11.686 A:middle
machine code.

00:51:12.546 --> 00:51:13.876 A:middle
If you have a classic uber

00:51:13.876 --> 00:51:14.986 A:middle
shader this can save you the

00:51:14.986 --> 00:51:16.036 A:middle
cost of having to re-run the

00:51:16.036 --> 00:51:17.666 A:middle
compiler front end for every

00:51:17.666 --> 00:51:18.556 A:middle
single permutation.

00:51:19.636 --> 00:51:20.846 A:middle
So we've made this a bit more

00:51:20.846 --> 00:51:22.376 A:middle
flexible and added a few more

00:51:22.376 --> 00:51:24.966 A:middle
cases where you can use these

00:51:25.076 --> 00:51:26.116 A:middle
specialized arguments.

00:51:27.876 --> 00:51:28.926 A:middle
We've added some extra vertex

00:51:28.926 --> 00:51:29.616 A:middle
array formats.

00:51:29.656 --> 00:51:31.026 A:middle
We had some missing one and two

00:51:31.026 --> 00:51:32.226 A:middle
component vertex formats.

00:51:32.596 --> 00:51:34.176 A:middle
And we've also added BGRA vertex

00:51:34.176 --> 00:51:34.746 A:middle
formats.

00:51:37.406 --> 00:51:38.446 A:middle
We've brought iOS surface

00:51:38.446 --> 00:51:40.146 A:middle
texture support from macOS to

00:51:40.256 --> 00:51:40.676 A:middle
iOS.

00:51:40.676 --> 00:51:42.546 A:middle
And we've also brought dual

00:51:42.546 --> 00:51:43.986 A:middle
sourced blending to iOS as well,

00:51:44.276 --> 00:51:46.496 A:middle
also particularly useful in some

00:51:46.496 --> 00:51:47.756 A:middle
deferred shading scenarios.

00:51:48.256 --> 00:51:52.586 A:middle
So that's -- brings us to the

00:51:52.586 --> 00:51:55.886 A:middle
end of introducing Metal 2.

00:51:55.886 --> 00:51:57.416 A:middle
My colleague, Michal, started

00:51:57.416 --> 00:51:58.806 A:middle
with giving you a little bit of

00:51:58.806 --> 00:52:00.096 A:middle
an overview of the overall scope

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:51:58.806 --> 00:52:00.096 A:middle
an overview of the overall scope

00:52:00.096 --> 00:52:00.636 A:middle
of Metal 2.

00:52:00.956 --> 00:52:03.496 A:middle
From VR to external GPUs, to

00:52:03.886 --> 00:52:05.036 A:middle
machine learning, and to new

00:52:05.036 --> 00:52:06.716 A:middle
developer tools and performance

00:52:07.126 --> 00:52:07.866 A:middle
analysis.

00:52:07.866 --> 00:52:08.816 A:middle
Of that, the pieces that we

00:52:08.816 --> 00:52:10.766 A:middle
really covered today are our

00:52:10.766 --> 00:52:12.286 A:middle
next big push toward reducing

00:52:12.406 --> 00:52:13.756 A:middle
CPU overhead using argument

00:52:13.756 --> 00:52:14.216 A:middle
buffers.

00:52:14.836 --> 00:52:16.326 A:middle
Argument buffers also unlock the

00:52:16.326 --> 00:52:17.686 A:middle
ability for the GPU to start

00:52:17.746 --> 00:52:18.786 A:middle
taking a little bit of its own

00:52:18.786 --> 00:52:19.696 A:middle
destiny when it comes to

00:52:19.696 --> 00:52:20.956 A:middle
configuring shader arguments,

00:52:20.956 --> 00:52:22.356 A:middle
which is one less reason to take

00:52:22.356 --> 00:52:24.506 A:middle
back to the CPU.

00:52:25.416 --> 00:52:27.146 A:middle
Raster Order Groups let us start

00:52:27.146 --> 00:52:28.496 A:middle
using the rasterizer for things

00:52:28.496 --> 00:52:30.016 A:middle
beyond basic in order blending.

00:52:31.186 --> 00:52:32.306 A:middle
We can now start taking

00:52:32.306 --> 00:52:33.896 A:middle
advantage of the latest hardware

00:52:33.896 --> 00:52:36.386 A:middle
capabilities to do, you know,

00:52:36.386 --> 00:52:38.226 A:middle
vox slice triangle meshes or set

00:52:38.426 --> 00:52:40.146 A:middle
transparency blending either in

00:52:40.146 --> 00:52:41.056 A:middle
order or independent.

00:52:41.126 --> 00:52:42.046 A:middle
They're both -- it makes them

00:52:42.046 --> 00:52:42.646 A:middle
both possible.

00:52:43.836 --> 00:52:46.496 A:middle
For the new iPad Pros, ProMotion

00:52:46.496 --> 00:52:47.556 A:middle
gives you very fine grained

00:52:47.556 --> 00:52:48.956 A:middle
control over exactly how your

00:52:48.956 --> 00:52:50.056 A:middle
animations are presented to the

00:52:50.056 --> 00:52:51.716 A:middle
user, giving you the ability to

00:52:51.716 --> 00:52:53.486 A:middle
get both peak frame rates and

00:52:53.486 --> 00:52:54.566 A:middle
the lowest possible latency.

00:52:54.966 --> 00:52:57.566 A:middle
Direct to display provides you a

00:52:57.566 --> 00:52:58.946 A:middle
path to reclaim a little bit of

00:52:58.946 --> 00:53:00.266 A:middle
GPU performance from the system

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:52:58.946 --> 00:53:00.266 A:middle
GPU performance from the system

00:53:00.366 --> 00:53:01.536 A:middle
by being aware of what our

00:53:01.536 --> 00:53:02.976 A:middle
compositors do on your behalf.

00:53:06.156 --> 00:53:07.366 A:middle
So you'll be able to find the

00:53:07.366 --> 00:53:08.256 A:middle
video and the slides for this

00:53:08.256 --> 00:53:11.046 A:middle
session on the WWDC2017 website.

00:53:11.696 --> 00:53:14.926 A:middle
We have three other sessions on

00:53:14.926 --> 00:53:15.826 A:middle
Metal 2 this year.

00:53:16.426 --> 00:53:18.366 A:middle
In particular, tomorrow

00:53:18.366 --> 00:53:19.276 A:middle
afternoon we're going to have a

00:53:19.276 --> 00:53:20.446 A:middle
session dedicated to VR and

00:53:20.446 --> 00:53:20.966 A:middle
Metal 2.

00:53:21.136 --> 00:53:22.716 A:middle
This is going to go deep into

00:53:22.716 --> 00:53:24.536 A:middle
what your application needs to

00:53:24.536 --> 00:53:26.286 A:middle
do and a conceptual overview of

00:53:26.286 --> 00:53:28.256 A:middle
how to do VR rendering, dive

00:53:28.256 --> 00:53:29.886 A:middle
into specifically how to do VR

00:53:29.886 --> 00:53:31.936 A:middle
with the combination of Metal 2

00:53:31.936 --> 00:53:33.756 A:middle
and the Steam VR toolkit.

00:53:33.756 --> 00:53:35.916 A:middle
It's also going to go into using

00:53:35.916 --> 00:53:37.156 A:middle
Metal with external GPU

00:53:37.156 --> 00:53:37.576 A:middle
hardware.

00:53:39.496 --> 00:53:40.806 A:middle
On Thursday we have a

00:53:40.946 --> 00:53:42.116 A:middle
doubleheader starting with Metal

00:53:42.116 --> 00:53:43.506 A:middle
2 optimization and debugging.

00:53:44.216 --> 00:53:45.536 A:middle
This is going to go into what's

00:53:45.536 --> 00:53:46.556 A:middle
new in our developer and

00:53:46.556 --> 00:53:47.936 A:middle
performance tools and all the

00:53:47.936 --> 00:53:49.166 A:middle
new workflows that enables to

00:53:49.166 --> 00:53:49.916 A:middle
help you build the best

00:53:49.916 --> 00:53:50.906 A:middle
applications possible.

00:53:51.116 --> 00:53:52.646 A:middle
And it's going to be followed up

00:53:52.646 --> 00:53:54.166 A:middle
right after that with using

00:53:54.166 --> 00:53:55.106 A:middle
Metal 2 for compute.

00:53:55.946 --> 00:53:56.946 A:middle
And that's going to really have

00:53:56.946 --> 00:53:58.726 A:middle
a big focus this year on using

00:53:58.726 --> 00:54:00.036 A:middle
the GPU for machine learning

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:53:58.726 --> 00:54:00.036 A:middle
the GPU for machine learning

00:54:00.036 --> 00:54:00.746 A:middle
applications.

00:54:00.746 --> 00:54:01.776 A:middle
We've added a whole lot this

00:54:01.776 --> 00:54:03.636 A:middle
year and we want to show you

00:54:03.636 --> 00:54:05.576 A:middle
everything we've done.

00:54:07.036 --> 00:54:08.226 A:middle
I want to point you to a couple

00:54:08.226 --> 00:54:10.036 A:middle
of last year's WWDC sessions.

00:54:11.116 --> 00:54:12.456 A:middle
The first, What's New in Metal

00:54:12.456 --> 00:54:14.026 A:middle
Part One is where we did a deep

00:54:14.026 --> 00:54:15.616 A:middle
dive on resource Heaps.

00:54:16.026 --> 00:54:16.976 A:middle
And instead if you're looking to

00:54:16.976 --> 00:54:17.856 A:middle
get the best performance out of

00:54:17.856 --> 00:54:19.666 A:middle
argument buffers, argument

00:54:19.666 --> 00:54:20.766 A:middle
buffers and Heaps were built to

00:54:20.766 --> 00:54:22.546 A:middle
go together and so I highly

00:54:22.546 --> 00:54:23.666 A:middle
encourage you to go check out

00:54:23.666 --> 00:54:26.156 A:middle
the video and really -- and, you

00:54:26.266 --> 00:54:28.256 A:middle
know basically plan your

00:54:28.256 --> 00:54:29.156 A:middle
application around both of those

00:54:29.156 --> 00:54:29.516 A:middle
together.

00:54:29.586 --> 00:54:31.066 A:middle
They cover that in a lot more

00:54:31.066 --> 00:54:32.366 A:middle
detail than we did here today.

00:54:33.886 --> 00:54:35.846 A:middle
Second, if the conversation

00:54:35.846 --> 00:54:37.906 A:middle
about direct to display and wide

00:54:37.906 --> 00:54:39.266 A:middle
gamut and wide color interested

00:54:39.266 --> 00:54:40.826 A:middle
you we have a whole session that

00:54:40.826 --> 00:54:41.746 A:middle
really goes deep into the

00:54:41.746 --> 00:54:42.896 A:middle
concepts and the specifics

00:54:42.896 --> 00:54:43.896 A:middle
behind that, we also talked

00:54:43.896 --> 00:54:44.486 A:middle
about last year.

00:54:45.516 --> 00:54:47.476 A:middle
With that I think we'll wrap it

00:54:47.476 --> 00:54:47.596 A:middle
up.

00:54:47.596 --> 00:54:48.686 A:middle
I thank you for all attending

00:54:48.686 --> 00:54:49.396 A:middle
and I hope you enjoy the

00:54:49.396 --> 00:54:50.066 A:middle
remainder of your week.

00:54:50.066 --> 00:54:50.976 A:middle
So thank you.

00:54:51.516 --> 00:54:55.500 A:middle
[ Applause ]

