1
00:00:19,733 --> 00:00:21,300
你好 我的名字是Tanya


2
00:00:21,367 --> 00:00:23,800
欢迎参加第二部分


3
00:00:23,867 --> 00:00:25,867
关于开发CarPlay系统


4
00:00:26,267 --> 00:00:28,867
第一部分的视频已经准备好了


5
00:00:28,933 --> 00:00:31,867
所以如果你还没有看过它
你一定要去看看


6
00:00:32,500 --> 00:00:34,600
在这一部分
我们会覆盖更多细节


7
00:00:34,667 --> 00:00:36,367
在CarPlay是如何集成


8
00:00:36,433 --> 00:00:39,367
到一个典型的汽车
信息娱乐系统里的


9
00:00:40,367 --> 00:00:42,433
我们从一个系统的概览开始


10
00:00:42,800 --> 00:00:45,600
然后谈论音量和资源管理


11
00:00:45,933 --> 00:00:48,833
最后以讨论应用状态管理结尾


12
00:00:50,267 --> 00:00:53,133
现在让我们进入系统概览


13
00:00:54,833 --> 00:00:56,867 line:1
如果你观看了第一个视频


14
00:00:56,933 --> 00:01:01,200 line:1
你会记得要实现一个CarPlay
接收器所需的软件组成部分


15
00:01:01,833 --> 00:01:05,667 line:1
总之你需要和主机之间
有一个基于IP的连接


16
00:01:05,733 --> 00:01:08,733 line:1
不管是USB或者Wi-Fi


17
00:01:09,267 --> 00:01:11,333 line:1
IP是为了交换数据


18
00:01:11,900 --> 00:01:14,400 line:1
CarPlay通讯插件的一个实例


19
00:01:14,467 --> 00:01:17,167 line:1
实现控制协议


20
00:01:17,233 --> 00:01:20,633 line:1
音频框架用来播放和录制声音


21
00:01:20,700 --> 00:01:23,167 line:1
视频框架用来渲染视频流


22
00:01:24,400 --> 00:01:28,500 line:1
然而这些组件只是一个子系统


23
00:01:28,567 --> 00:01:30,567 line:1
在一个典型的车载主机中


24
00:01:31,467 --> 00:01:34,267 line:1
除了CarPlay的功能


25
00:01:34,333 --> 00:01:39,000 line:1
主机还有自己的原生界面
音频资源和逻辑


26
00:01:39,800 --> 00:01:43,200 line:1
两者一起构成完整的主机


27
00:01:44,467 --> 00:01:45,500 line:1
然后你添加


28
00:01:45,567 --> 00:01:48,167 line:1
车里所有的硬件资源


29
00:01:48,233 --> 00:01:54,333 line:1
麦克风 音响 显示屏 传感器
用户输入设备


30
00:01:54,400 --> 00:01:56,567 line:1
然后你就有了完整的系统


31
00:01:58,100 --> 00:02:00,600
好的 这样我们就有了整个系统


32
00:02:01,067 --> 00:02:02,367
现在的问题是


33
00:02:02,433 --> 00:02:06,867
怎样让那些看起来互相竞争的子系统
互相协同工作？


34
00:02:08,199 --> 00:02:09,333
让我们来理解这个问题


35
00:02:10,100 --> 00:02:13,800
首先让我们来看看
传感器的数据是怎样被交换的


36
00:02:13,867 --> 00:02:16,533
我们会用位置数据举例


37
00:02:17,133 --> 00:02:20,867
位置信息包括GPS接收器获得的
数据


38
00:02:20,933 --> 00:02:23,900
或者传感器数据比如轮胎速度


39
00:02:24,767 --> 00:02:27,733
数据通过iAP2传输给设备


40
00:02:27,800 --> 00:02:29,433
并且要一直可用


41
00:02:29,500 --> 00:02:32,100
并且在手机需要时会被查询


42
00:02:33,533 --> 00:02:36,900
接下来让我们来看看仪表组


43
00:02:36,967 --> 00:02:38,233
也就是抬头显示


44
00:02:39,100 --> 00:02:40,867
这个辅助显示


45
00:02:40,933 --> 00:02:43,967
被用来显示设备提供的元数据


46
00:02:44,467 --> 00:02:48,767
这些元数据可能包含
当前播放的音轨


47
00:02:49,100 --> 00:02:52,900
正在进行的通话
或者从iOS 10开始


48
00:02:52,967 --> 00:02:54,733
路线规划导航


49
00:02:55,233 --> 00:02:59,033
数据还是通过IP协议发起


50
00:02:59,100 --> 00:03:00,900
以及根据需要交换


51
00:03:02,533 --> 00:03:05,867
现在让我们来看看
主显示发生了什么


52
00:03:06,400 --> 00:03:10,000
当然要控制
在显示屏上显示的内容


53
00:03:10,333 --> 00:03:13,133
用户必须
用一个触摸屏


54
00:03:13,200 --> 00:03:15,100
一个应用控制器
或者两者都用


55
00:03:15,600 --> 00:03:17,567
所以我们可以认为


56
00:03:17,633 --> 00:03:21,733
显示器和用户输入设备都是存在的


57
00:03:22,933 --> 00:03:25,200
当CarPlay UI活动时


58
00:03:25,267 --> 00:03:29,100
设备在主显示屏上渲染视频流


59
00:03:29,167 --> 00:03:33,233
屏幕和用户输入都被设备使用


60
00:03:34,367 --> 00:03:39,400
但是如果原生用户界面显示在
屏幕上


61
00:03:39,467 --> 00:03:42,233
那么显示屏和用户输入都


62
00:03:42,300 --> 00:03:44,300
被转到原生子系统


63
00:03:45,967 --> 00:03:49,767
然而方向盘上额外的用户控制器


64
00:03:49,833 --> 00:03:53,367
比如语音识别按钮
下/上一个单轨


65
00:03:53,433 --> 00:03:54,900
可能与CarPlay相连


66
00:03:54,967 --> 00:03:57,900
即使屏幕上显示的是原生UI


67
00:03:59,500 --> 00:04:02,933
这样总是可以打开Siri


68
00:04:03,000 --> 00:04:05,067
或者播放下一个单轨


69
00:04:07,333 --> 00:04:11,367
我们已经看过用户界面集成


70
00:04:11,433 --> 00:04:12,900
让我们来谈谈音频


71
00:04:16,867 --> 00:04:21,933
车载音频可以被粗分成3类


72
00:04:22,000 --> 00:04:26,233
第1类提供对音响和麦克风的使用


73
00:04:26,300 --> 00:04:29,367
这被用来通话和进行语音识别


74
00:04:30,533 --> 00:04:32,900
然后我们有音频播放


75
00:04:32,967 --> 00:04:36,833
对任何媒体内容
比如收音机 音乐


76
00:04:38,033 --> 00:04:40,767
最后我们有警告类别


77
00:04:40,833 --> 00:04:43,033
被用作导航提示


78
00:04:43,100 --> 00:04:45,833
或者其他更高优先级的警告


79
00:04:46,833 --> 00:04:48,833
在原生子系统中


80
00:04:48,900 --> 00:04:52,600
这三种类别会被重新发现


81
00:04:53,700 --> 00:04:57,000
在CarPlay中
我们有一个主音频通道


82
00:04:57,067 --> 00:04:59,567
它包括通话 语音识别


83
00:04:59,633 --> 00:05:01,300
和音频播放


84
00:05:02,767 --> 00:05:06,100
还有另一个音频通道被保留


85
00:05:06,167 --> 00:05:09,167
给高优先级提示和声音


86
00:05:09,233 --> 00:05:13,033
比如导航提示或者新消息通知


87
00:05:15,633 --> 00:05:17,167
那么媒体通道


88
00:05:17,500 --> 00:05:20,533
可以播放来自手机的音乐


89
00:05:21,433 --> 00:05:25,767
或者播放来自原生音频资源
的媒体


90
00:05:27,033 --> 00:05:30,367
现在我们看过了媒体播放


91
00:05:30,767 --> 00:05:32,367
我们来看看发生了什么


92
00:05:32,433 --> 00:05:34,533
当CarPlay接到电话时


93
00:05:35,900 --> 00:05:40,033
通话需要音频通道提供


94
00:05:40,100 --> 00:05:42,633
麦克风和音响


95
00:05:43,200 --> 00:05:47,600
所以媒体播放被中断
并且通道被切换了


96
00:05:52,933 --> 00:05:55,167
音频被切换到一个通道


97
00:05:55,233 --> 00:05:59,033
这个通道提供对麦克风和音响
的访问


98
00:06:00,567 --> 00:06:03,533
除了切换到音频通道


99
00:06:03,600 --> 00:06:07,567
屏幕被切换到CarPlay来显示
通话UI


100
00:06:08,767 --> 00:06:12,033
仪表组上的元数据信息


101
00:06:12,100 --> 00:06:13,500
也会更新


102
00:06:15,467 --> 00:06:16,567
当然


103
00:06:16,633 --> 00:06:21,233
如果原生系统也支持通话


104
00:06:21,300 --> 00:06:25,533
那么通话会使用原生系统
来播放和显示


105
00:06:26,500 --> 00:06:28,733
但是在原生系统中通话时


106
00:06:28,800 --> 00:06:32,200
用户可以用Apple Maps导航


107
00:06:33,900 --> 00:06:36,633
所以每当接近转弯时


108
00:06:36,700 --> 00:06:38,767
Apple Maps会播放一个声音


109
00:06:38,833 --> 00:06:41,467
通过公告通道来通知用户


110
00:06:42,333 --> 00:06:46,033
通话继续被转到汽车的音响上


111
00:06:46,433 --> 00:06:50,767
但是路线规划导航通知也被显示


112
00:06:50,833 --> 00:06:53,133
它们和通话音混合在一起


113
00:06:53,967 --> 00:06:56,000
当然在这种情况下


114
00:06:56,433 --> 00:07:00,500
我们不希望用户
听到手机的导航提示


115
00:07:00,700 --> 00:07:04,767
只是一个警告音提醒前方有转弯


116
00:07:06,900 --> 00:07:09,633
如果用户希望看到
下一个转弯在哪


117
00:07:09,700 --> 00:07:12,333
主显示可以显示Apple Maps


118
00:07:13,733 --> 00:07:16,600
最后当通话结束后


119
00:07:18,167 --> 00:07:21,600
音乐继续通过原生子系统播放


120
00:07:22,300 --> 00:07:26,167
就像用户在通话前正在听的一样


121
00:07:27,000 --> 00:07:29,467
现在导航公告


122
00:07:29,533 --> 00:07:35,200
将包括所有的导航语音
因为用户不再进行通话


123
00:07:36,367 --> 00:07:37,200
好的


124
00:07:37,833 --> 00:07:42,833
如你所见 集成CarPlay是一个
很复杂的任务


125
00:07:42,900 --> 00:07:46,300
特别是在共享硬件资源方面


126
00:07:46,933 --> 00:07:49,733
但是在我们进行这些细节前


127
00:07:49,800 --> 00:07:51,600
让我们看看音量控制


128
00:07:53,933 --> 00:07:55,167
音量管理


129
00:07:56,233 --> 00:07:57,533
你们可能知道


130
00:07:58,000 --> 00:08:02,067
一个普通的车载主机显示
音量指示


131
00:08:02,133 --> 00:08:04,900
当用户操作音量旋钮时


132
00:08:04,967 --> 00:08:06,133
然后那个音量旋钮


133
00:08:06,200 --> 00:08:09,367
控制当前播放的音频的音量


134
00:08:11,400 --> 00:08:14,533
CarPlay音频也有相同原理


135
00:08:15,000 --> 00:08:17,633
但是有一个不同的音量设置


136
00:08:17,700 --> 00:08:20,600
对每一个主要的CarPlay应用


137
00:08:21,300 --> 00:08:22,533
让我们看看它们


138
00:08:24,000 --> 00:08:25,467
当播放Siri时


139
00:08:25,700 --> 00:08:29,367
音量旋钮只对语音互动设置音量


140
00:08:30,333 --> 00:08:34,167
当有来电时
来电铃声的音量被控制


141
00:08:35,732 --> 00:08:40,533
当用户在通话中时
通话音量被控制


142
00:08:42,033 --> 00:08:46,667
如果靠近下一个转弯
导航提示被播放


143
00:08:47,000 --> 00:08:49,900
那么用户可以改变导航音量


144
00:08:50,600 --> 00:08:53,833
请记住媒体可以在后台播放


145
00:08:54,000 --> 00:08:57,100
但是它的音量会在有那些提示时
自动降低


146
00:08:57,167 --> 00:08:58,767
而且不能被改变


147
00:09:00,233 --> 00:09:03,967
一旦提示音结束并且音乐音量
恢复正常


148
00:09:04,067 --> 00:09:06,933
这个旋钮就会控制媒体音量


149
00:09:08,267 --> 00:09:11,667
好的现在让我们来看看资源管理


150
00:09:13,733 --> 00:09:17,600
我们来看看哪些资源被管理


151
00:09:17,767 --> 00:09:19,700
谈论他们怎样被管理


152
00:09:19,767 --> 00:09:22,267
并讨论一些典型的例子


153
00:09:24,233 --> 00:09:27,233
我们看到有很多硬件资源


154
00:09:27,633 --> 00:09:31,200
但是让我们理解它们中的哪些
被管理了


155
00:09:32,600 --> 00:09:33,633
只有2个


156
00:09:34,300 --> 00:09:37,700
mainScreen是汽车的主显示


157
00:09:38,200 --> 00:09:39,500
以及mainAudio


158
00:09:39,567 --> 00:09:43,000
因为这个资源提供对车载音频
系统的访问


159
00:09:45,033 --> 00:09:48,467
这些资源可以被占有或借用


160
00:09:49,367 --> 00:09:50,800
当你占有一个资源时


161
00:09:50,867 --> 00:09:53,867
它在无限的时间内属于你


162
00:09:53,933 --> 00:09:55,400
它基本上就是你的


163
00:09:56,167 --> 00:09:59,467
当你借用一个资源
你可以使用它一段时间


164
00:09:59,800 --> 00:10:02,500
但是使用完后你要还回去


165
00:10:04,267 --> 00:10:10,367
我们让原生用户界面
永久占有显示


166
00:10:10,833 --> 00:10:13,400
用户可以使用原生导航


167
00:10:13,467 --> 00:10:15,333
或者听收音机


168
00:10:15,400 --> 00:10:17,633
或者修改一些汽车设置


169
00:10:19,033 --> 00:10:21,867
怎样永久切换到原生UI？


170
00:10:22,833 --> 00:10:27,433
原生UI可以在用户按硬件按钮时
占有屏幕


171
00:10:27,500 --> 00:10:29,333
或者切换到原生UI


172
00:10:29,400 --> 00:10:32,567
在CarPlay UI里的入口


173
00:10:33,267 --> 00:10:38,633
或者用原生语音识别来启动
一个原生应用


174
00:10:40,767 --> 00:10:42,733
现在假设用户选择


175
00:10:42,800 --> 00:10:45,367
主菜单里的
Apple CarPlay图标


176
00:10:48,400 --> 00:10:49,600
这种情况下


177
00:10:49,667 --> 00:10:53,967
CarPlay接管屏幕
因为用户明确的要求这样


178
00:10:55,300 --> 00:10:58,700
是什么导致的这个永久切换？


179
00:10:59,300 --> 00:11:01,233
任何和CarPlay有关的硬件按钮


180
00:11:01,967 --> 00:11:03,500
或者如我们所见


181
00:11:03,567 --> 00:11:06,500
原生UI中的任何CarPlay按钮


182
00:11:07,267 --> 00:11:11,500
或者通过Siri
例如通过说打开地图


183
00:11:14,000 --> 00:11:18,033
现在有其他应用需要借用资源


184
00:11:18,433 --> 00:11:22,133
请记住它们只需要使用一会
然后会还回来


185
00:11:23,200 --> 00:11:25,367
我们在谈论哪些应用？


186
00:11:26,367 --> 00:11:29,067
通话 话音互动


187
00:11:29,533 --> 00:11:32,033
通知 警告


188
00:11:34,067 --> 00:11:35,433
让我们来看一个例子


189
00:11:36,200 --> 00:11:39,333
原生UI占用主屏幕资源


190
00:11:39,400 --> 00:11:41,567
并且永久在屏幕上显示


191
00:11:43,933 --> 00:11:46,033
现在用户在CarPlay里接到电话


192
00:11:46,567 --> 00:11:48,900
CarPlay UI借用屏幕


193
00:11:48,967 --> 00:11:52,067
并显示通话时间


194
00:11:52,900 --> 00:11:54,600
一旦通话结束


195
00:11:55,567 --> 00:11:57,700
我们回到原生UI


196
00:11:58,367 --> 00:12:01,500
并保持这样直到有其他用户活动


197
00:12:04,967 --> 00:12:07,533
接下来让我们看看主音频资源


198
00:12:08,300 --> 00:12:11,133
主音频可以被分为四个主要类型


199
00:12:11,433 --> 00:12:14,667
每个类型被不同
CarPlay应用使用


200
00:12:14,933 --> 00:12:18,267
因为它提供
对不同硬件资源的访问


201
00:12:19,733 --> 00:12:26,000
媒体仅有音频输出
被用来播放所有媒体


202
00:12:26,633 --> 00:12:30,133
警告仅有输出


203
00:12:30,200 --> 00:12:32,833
被用来播放铃声和定时器警告


204
00:12:34,200 --> 00:12:37,067
Siri使用语音识别


205
00:12:37,133 --> 00:12:39,267
因为它加入了对麦克风的使用


206
00:12:40,700 --> 00:12:44,100
对用来通话的电话类型同样如此


207
00:12:45,433 --> 00:12:49,933
对用作未定义音频的默认类型
也是如此


208
00:12:52,400 --> 00:12:57,300
但是不要忘记第二个音频通道
它用作导航公告


209
00:12:58,267 --> 00:13:02,767
alternateAudio没有被管理
它基本上总是可用


210
00:13:02,833 --> 00:13:05,133
所以不需要占用或借用它


211
00:13:05,867 --> 00:13:07,800
在mainAudio通道里


212
00:13:07,867 --> 00:13:11,833
alternateAudio与所有的音频类型都
是混合在一起的


213
00:13:11,900 --> 00:13:13,533
它总是可以被访问


214
00:13:15,100 --> 00:13:16,067
就这些了


215
00:13:16,133 --> 00:13:19,800
我要交给Tom来谈谈资源管理


216
00:13:22,867 --> 00:13:23,700 line:1
谢谢Tanya


217
00:13:23,867 --> 00:13:26,867 line:1
大家好 我是Tom
我也在CarPlay组里工作


218
00:13:27,533 --> 00:13:30,433 line:1
我们已经知道了哪些资源被管理


219
00:13:30,500 --> 00:13:33,200 line:1
而且你知道可以占有或借用资源


220
00:13:33,267 --> 00:13:35,433 line:1
让我们谈谈怎样管理它们


221
00:13:37,633 --> 00:13:42,533
要在两个子系统中分配资源
我们需要仲裁者


222
00:13:42,600 --> 00:13:45,567
我们把这个仲裁者叫做
资源管理器


223
00:13:49,467 --> 00:13:51,267
资源管理器是干什么的？


224
00:13:51,900 --> 00:13:53,467
它主要有三个任务


225
00:13:53,733 --> 00:13:56,533
首先它知道整个系统的当前状态


226
00:13:57,433 --> 00:14:01,100
其次它根据
一些严格的规则来决定


227
00:14:01,167 --> 00:14:03,100
哪个系统获得资源


228
00:14:03,600 --> 00:14:06,700
第三根据当前状态和一系列规则


229
00:14:07,233 --> 00:14:09,933
它把资源分配给一方或另一方


230
00:14:10,300 --> 00:14:12,333
让我们看看实际中 它是如何工作的


231
00:14:14,833 --> 00:14:19,100
假设原生UI和CarPlay
都需要在屏幕上显示一些信息


232
00:14:20,133 --> 00:14:23,300
它们都发出申请要求获得
屏幕的所有权


233
00:14:25,400 --> 00:14:28,000
那么资源管理器查看内部状态


234
00:14:28,067 --> 00:14:31,300
并决定它们中的哪个应该获得屏幕


235
00:14:33,533 --> 00:14:35,967
我们假设在这个情况下
原生UI的请求


236
00:14:36,033 --> 00:14:38,667
有更高优先级
那么屏幕被分配给它


237
00:14:39,167 --> 00:14:41,200
资源管理器发送通知


238
00:14:41,267 --> 00:14:43,467
屏幕现在可以被原生UI使用


239
00:14:44,967 --> 00:14:48,533
只有原生UI可以在屏幕上显示内容


240
00:14:49,333 --> 00:14:51,333
必须要注意到状态并没有改变


241
00:14:51,400 --> 00:14:53,667
直到资源管理器发送更新


242
00:14:56,333 --> 00:14:58,333
那么资源管理器是在哪运行？


243
00:14:58,933 --> 00:15:01,600
它是原生系统
还是CarPlay的一部分？


244
00:15:02,367 --> 00:15:05,800
当我们设计CarPlay时
我们问了自己同样的问题


245
00:15:06,267 --> 00:15:10,400
我们考虑了交换资源的详细信息
的复杂性


246
00:15:10,467 --> 00:15:11,733
我们考虑了未来


247
00:15:11,967 --> 00:15:14,300
如果那些规则要调整该怎么办？


248
00:15:14,967 --> 00:15:17,400
如果CarPlay上出现新应用
该怎么办？


249
00:15:17,467 --> 00:15:20,000
如果车上没有已有的设计需要
处理该怎么办？


250
00:15:20,633 --> 00:15:23,267
哪种方案带来最大的灵活性


251
00:15:23,333 --> 00:15:24,567
在接下来的五年？


252
00:15:24,967 --> 00:15:26,600
所以我们决定实现一个系统


253
00:15:26,667 --> 00:15:30,467
在原生系统中的复杂度更低
更易于升级


254
00:15:30,533 --> 00:15:33,233
当消费者拥有车辆一段时间后


255
00:15:33,600 --> 00:15:37,233
所以资源管理器在iOS里实现


256
00:15:40,067 --> 00:15:41,867
因为资源管理器是


257
00:15:42,300 --> 00:15:45,100
与原生系统互动的组件


258
00:15:45,167 --> 00:15:47,167
我们让iPhone作为控制器


259
00:15:47,500 --> 00:15:49,200
让主机作为附件


260
00:15:49,700 --> 00:15:50,567
但不要忘了


261
00:15:51,367 --> 00:15:54,100
所有iPhone应用请求同样的资源


262
00:15:54,167 --> 00:15:56,333
用和原生UI同样的方式


263
00:15:59,533 --> 00:16:00,367
接下来


264
00:16:00,633 --> 00:16:03,800
你可以用什么命令和资源管理器
互动？


265
00:16:05,000 --> 00:16:05,833
很简单


266
00:16:06,167 --> 00:16:07,633
你只需要两个命令


267
00:16:08,167 --> 00:16:11,233
changeModes命令
用来请求或释放资源


268
00:16:11,300 --> 00:16:14,600
modesChanged命令
用来描述当前状态


269
00:16:16,233 --> 00:16:18,867
changeModes
是主机发出的通知


270
00:16:20,400 --> 00:16:23,800
在这个情况下主机是附件
向作为控制器的资源管理器


271
00:16:29,200 --> 00:16:31,100
changeModes命令表明


272
00:16:31,167 --> 00:16:33,567
附件想对资源做什么


273
00:16:33,800 --> 00:16:35,367
它声明它为什么需要这个资源


274
00:16:36,033 --> 00:16:39,633
以及谁可以占有或借用这个资源
当它被传递后


275
00:16:41,667 --> 00:16:45,700
modesChanged
是控制器传递回主机的通知


276
00:16:48,233 --> 00:16:50,333
modesChanged
提供当前状态


277
00:16:50,400 --> 00:16:53,500
它描述谁拥有这个系统资源


278
00:16:53,900 --> 00:16:56,800
它发送这些信息
所以附件知道一个资源是否被传递


279
00:16:56,867 --> 00:16:58,133
所有者是否更换了


280
00:17:00,733 --> 00:17:03,633
我们来谈谈资源管理器如何工作
的更多细节


281
00:17:04,700 --> 00:17:09,233
我们从一个简单活动开始
切换iOS音频到收音机


282
00:17:09,800 --> 00:17:12,133
然后我们会谈论原生语音识别


283
00:17:12,933 --> 00:17:14,599
再接下来是怎样处理倒车雷达


284
00:17:14,666 --> 00:17:17,500
这个情况下你不想iPhone应用
来打扰你


285
00:17:17,900 --> 00:17:21,633
最后我们会看一个Siri触发
音乐播放的例子


286
00:17:23,099 --> 00:17:24,733
让我们来看播放收音机音频


287
00:17:25,633 --> 00:17:28,600
假设iPhone正在
通过车载音响播放音乐


288
00:17:29,600 --> 00:17:32,367
然后用户在原生系统中想听收音机


289
00:17:32,433 --> 00:17:33,700
这是收音机按钮


290
00:17:37,933 --> 00:17:41,433
主机发送changeModes
请求获得音响的所有权


291
00:17:42,200 --> 00:17:43,467
而且它获得这个所有权


292
00:17:43,533 --> 00:17:47,500
因为用户可能会继续听很长时间
的收音机


293
00:17:48,733 --> 00:17:50,733
控制器把音频交给主机


294
00:17:50,800 --> 00:17:52,900
且发送modesChanged通知


295
00:17:54,000 --> 00:17:57,367
主机就是音频资源的新的所有者


296
00:18:01,033 --> 00:18:03,100
它可以开始播放收音机


297
00:18:03,700 --> 00:18:06,867
mainAudio资源在这时被永久
赋予主机


298
00:18:09,467 --> 00:18:11,367
总之这个例子向我们展示了


299
00:18:11,833 --> 00:18:13,267
什么时候要求一个资源


300
00:18:13,333 --> 00:18:15,400
以及原生系统不应该使用该资源


301
00:18:15,467 --> 00:18:17,933
在它拥有这个资源前


302
00:18:20,000 --> 00:18:24,167
让我们看下一个例子
使用原生语音识别


303
00:18:25,167 --> 00:18:27,500
在我们的上个例子里
收音机仍然在播放


304
00:18:28,567 --> 00:18:32,000
让我们看看用户启动原生语音识别
时会发生什么


305
00:18:34,700 --> 00:18:38,100
这个单元请求暂时拥有显示和音频


306
00:18:38,467 --> 00:18:42,400
所以transferType
应该设置成借用音频和屏幕


307
00:18:44,200 --> 00:18:47,833
mainScreen和mainAudio
传递给附件


308
00:18:51,167 --> 00:18:53,467
然后原生语音识别开始


309
00:18:55,500 --> 00:18:57,000
一旦语音对话结束


310
00:18:57,067 --> 00:19:00,700
主机把借用的资源交还
通过发送unborrow命令


311
00:19:03,433 --> 00:19:05,700
因为单元在之前正在播放收音机


312
00:19:05,900 --> 00:19:08,400
资源被重新赋予给主机


313
00:19:10,167 --> 00:19:11,633
收音机可以继续


314
00:19:12,867 --> 00:19:14,100
现在你可能想知道


315
00:19:14,267 --> 00:19:17,900
为什么附件已经拥有资源
还要借用资源？


316
00:19:17,967 --> 00:19:19,400
这是一个很好的问题


317
00:19:20,067 --> 00:19:22,367
当资源管理器评估请求时


318
00:19:22,433 --> 00:19:26,467
要变更一个资源的所有权
控制器要知道系统的当前状态


319
00:19:26,533 --> 00:19:29,233
资源管理器需要知道你为什么在
使用这些资源


320
00:19:29,300 --> 00:19:30,933
这样它才能进行正确判断


321
00:19:31,000 --> 00:19:33,233
如果其它部分晚些时候需要资源


322
00:19:35,067 --> 00:19:36,700
我们来看下一个例子


323
00:19:37,400 --> 00:19:38,733
显示倒车雷达


324
00:19:40,700 --> 00:19:42,233
若CarPlay正播放音频


325
00:19:42,300 --> 00:19:44,333
屏幕上正显示原生UI


326
00:19:45,267 --> 00:19:48,733
当用户挂倒车档
倒车雷达借用屏幕


327
00:19:49,533 --> 00:19:52,367
然而请注意它也告诉资源管理器


328
00:19:52,433 --> 00:19:54,467
屏幕不可被再次借用


329
00:19:59,633 --> 00:20:02,800
资源管理器把屏幕分配给原生UI


330
00:20:02,867 --> 00:20:04,633
并且注意到这个限制


331
00:20:06,133 --> 00:20:08,100
现在显示倒车雷达


332
00:20:08,667 --> 00:20:10,433
CarPlay音频继续播放


333
00:20:11,100 --> 00:20:12,833
但是现在用户接到来电


334
00:20:15,633 --> 00:20:17,800
iPhone不能在屏幕上
显示任何内容


335
00:20:17,867 --> 00:20:20,067
因为主机限制了对屏幕的访问


336
00:20:20,133 --> 00:20:22,100
但是铃声能过音响播放


337
00:20:23,700 --> 00:20:24,800
这是怎么发生的？


338
00:20:25,867 --> 00:20:28,367
changeModes命令中
这个单元告诉资源管理器


339
00:20:28,433 --> 00:20:31,067
它拥有的资源使用哪些规则


340
00:20:31,133 --> 00:20:33,000
通过在任何时间设置
borrowConstraint


341
00:20:33,067 --> 00:20:36,300
这个单元允许应用借用资源


342
00:20:36,533 --> 00:20:40,767
通过把它设置成user-initiated
只有用户发起的事件可以借用


343
00:20:41,500 --> 00:20:44,233
永远没有应用可以使用这些资源


344
00:20:44,733 --> 00:20:45,767
在这个例子中


345
00:20:48,133 --> 00:20:51,133
如你所见这个限制对系统的行为
有个很大的影响


346
00:20:51,200 --> 00:20:53,233
所以它们必须被正确使用


347
00:20:53,900 --> 00:20:57,700
只有需要用户立即注意时
才限制访问


348
00:20:58,167 --> 00:21:01,533
有CarPlay连接时
不要限制永久所有权


349
00:21:03,367 --> 00:21:04,933
这就是使用倒车雷达


350
00:21:06,300 --> 00:21:09,500
最后一个例子
当Siri播放音乐时发生了什么


351
00:21:10,767 --> 00:21:12,700
我们又一次从播放收音机开始


352
00:21:13,900 --> 00:21:15,300
用户启动Siri


353
00:21:17,833 --> 00:21:19,067
Siri在手机上运行


354
00:21:19,133 --> 00:21:21,567
资源管理器告诉原生系统


355
00:21:21,633 --> 00:21:23,967
资源被分配给Siri


356
00:21:25,567 --> 00:21:29,467
Siri出现然后用户说
“Siri播放音乐”


357
00:21:32,167 --> 00:21:34,267
Siri交还显示和音频资源


358
00:21:34,333 --> 00:21:37,267
但是现在音乐应用需要音频资源
播放音乐


359
00:21:37,500 --> 00:21:39,667
所以资源管理器通知主机


360
00:21:39,733 --> 00:21:41,567
手机拥有mainAudio


361
00:21:41,633 --> 00:21:43,633
但是屏幕还给附件


362
00:21:44,400 --> 00:21:47,067
主机不再继续播放收音机


363
00:21:49,433 --> 00:21:52,067
所以在车里能听到iPhone音频


364
00:21:53,900 --> 00:21:55,000
我们从中看到什么？


365
00:21:55,400 --> 00:21:57,000
在两种场合
资源管理器


366
00:21:57,067 --> 00:21:59,733
在没向主机发送请求的情况下
改变了状态


367
00:21:59,800 --> 00:22:01,200
这是完全可以的


368
00:22:02,033 --> 00:22:05,733
因为手机上的应用也会请求资源


369
00:22:05,800 --> 00:22:08,267
如果它们得到资源
单元收到了通知


370
00:22:08,967 --> 00:22:10,133
怎么处理这种情况


371
00:22:10,867 --> 00:22:14,233
在每个modesChanged之后
你要检查你是否是所有者


372
00:22:14,533 --> 00:22:16,667
如果你是继续你的活动


373
00:22:16,767 --> 00:22:19,367
否则你需要得到CarPlay来处理


374
00:22:20,000 --> 00:22:21,533
第二 不要忽略


375
00:22:21,600 --> 00:22:24,933
手机发起的把资源切换给手机


376
00:22:27,033 --> 00:22:30,800
至此我们已经看过了资源交换
的例子


377
00:22:30,867 --> 00:22:32,667
但是还有一种情况两边


378
00:22:32,733 --> 00:22:34,667
都想完成同样的任务


379
00:22:34,733 --> 00:22:37,000
让我们看看应用是怎么被管理的


380
00:22:38,767 --> 00:22:42,533
我们要管理原生和CarPlay应用
它们有相似的特点


381
00:22:42,600 --> 00:22:44,233
但是关于那些应用呢？


382
00:22:44,800 --> 00:22:49,333
他们导航 通话 语音识别


383
00:22:51,333 --> 00:22:54,567
我们通过appState来实现
什么是appState？


384
00:22:54,967 --> 00:22:57,467
我们用不同的appState记录
谁现在参与了


385
00:22:57,533 --> 00:23:00,033
共享的应用
这些应用只能活动


386
00:23:00,100 --> 00:23:03,000
在附件上或者控制器上
在任一个时刻


387
00:23:03,833 --> 00:23:06,467
所以这三个不同的appState
是TurnByTurn


388
00:23:06,533 --> 00:23:08,533
PhoneCall和Speech


389
00:23:10,533 --> 00:23:11,467
让我们来看看


390
00:23:12,067 --> 00:23:15,100
导航appState是怎么被管理


391
00:23:16,900 --> 00:23:19,300
当导航在附件上启动时


392
00:23:19,367 --> 00:23:21,167
它用一changeModes命令


393
00:23:21,233 --> 00:23:23,933
来更新要激活的
TurnByTurn appState


394
00:23:27,567 --> 00:23:30,633
在这个例子中
是最后的会获胜的情况


395
00:23:31,033 --> 00:23:33,867
控制器把TurnByTurn
appState交附件


396
00:23:33,933 --> 00:23:36,667
返回一个modesChanged
命令 显示附件


397
00:23:36,733 --> 00:23:38,933
是当前运行的导航


398
00:23:40,667 --> 00:23:44,867
现在让我们来看看用户用Apple Maps
设置一个新目的地时会发生什么


399
00:23:44,933 --> 00:23:47,100
当原生系统已经在导航时


400
00:23:47,567 --> 00:23:50,933
用户说 “Siri带我去最近
的咖啡店”


401
00:23:51,867 --> 00:23:54,800
现在iPhone开始了导航


402
00:23:54,867 --> 00:23:57,533
控制器更新TurnByTurn appState


403
00:23:59,733 --> 00:24:04,033
这是对附件的指令
要停止它自己的导航


404
00:24:05,767 --> 00:24:10,233
现在iPhone开始导航
控制器更新TurnByTurn appState


405
00:24:10,300 --> 00:24:14,100
这是对附件的指令
要停止它自己的导航


406
00:24:16,033 --> 00:24:18,500
现在Apple Maps的导航


407
00:24:18,567 --> 00:24:22,033
显示在了屏幕上
并且公告通过音频播放


408
00:24:22,100 --> 00:24:25,133
并且和原生导航系统不会冲突


409
00:24:27,667 --> 00:24:29,733
所以现在Apple Maps的导航


410
00:24:29,800 --> 00:24:31,967
显示在了屏幕上
并且公告通过音频播放


411
00:24:32,033 --> 00:24:34,733
并且和原生导航系统不会冲突


412
00:24:36,300 --> 00:24:37,667
关于导航就这么多了


413
00:24:38,167 --> 00:24:39,633
接下来让我们看看通话


414
00:24:41,233 --> 00:24:44,800
如果主机支持通过Bluetooth
来使用第二个电话


415
00:24:44,867 --> 00:24:46,400
并且有一个正在进行的通话


416
00:24:46,867 --> 00:24:48,833
这个通话独占mainAudio


417
00:24:49,233 --> 00:24:51,200
通话不能被打断


418
00:24:51,467 --> 00:24:54,733
那用户在CarPlay设备上收到
来电会发生什么？


419
00:24:55,933 --> 00:24:58,700
CarPlay只能在这台设备上响铃


420
00:24:58,767 --> 00:25:01,100
因为不能打断正在进行的通话


421
00:25:01,567 --> 00:25:03,833
被PhoneCall appState管理


422
00:25:05,200 --> 00:25:07,300
最后来看看语音互动


423
00:25:08,033 --> 00:25:10,300
如果主机有原生的语音识别


424
00:25:10,367 --> 00:25:12,800
当它运行时借用了资源


425
00:25:12,867 --> 00:25:16,800
并独占音响 麦克风和屏幕资源


426
00:25:17,467 --> 00:25:20,833
但是它能在任何时候被用户
发起的事件打断


427
00:25:21,733 --> 00:25:24,467
所以用户启动Siri


428
00:25:25,900 --> 00:25:29,733
原生语音识别结束
Siri继续出现在车载显示上


429
00:25:30,233 --> 00:25:32,567
Speech appState
被用来实现这个


430
00:25:35,600 --> 00:25:36,433
总之


431
00:25:36,933 --> 00:25:39,633
CarPlay和你的原生系统依赖
相同的资源


432
00:25:39,700 --> 00:25:42,700
被设计成和原生用户体验共存


433
00:25:43,333 --> 00:25:45,067
为了优秀的CarPlay体验


434
00:25:45,133 --> 00:25:47,133
考虑每一种使用情况的资源处理


435
00:25:47,200 --> 00:25:49,767
遵守CarPlay设计建议


436
00:25:50,500 --> 00:25:53,833
CarPlay的详述可以通过
MFi Program获得


437
00:25:55,067 --> 00:25:57,633
若你还没有观看开发CarPlay
系统的第一部分


438
00:25:57,700 --> 00:25:59,333
我鼓励你去看一下


439
00:25:59,767 --> 00:26:01,333
关于这次讨论的更多信息


440
00:26:01,733 --> 00:26:03,633
请访问屏幕上的网址

