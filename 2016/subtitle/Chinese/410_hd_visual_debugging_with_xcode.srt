1
00:00:19,887 --> 00:00:24,591
<c.magenta>Xcode下可视化调试工具</c>


2
00:00:29,796 --> 00:00:30,864
<c.magenta>大家下午好</c>


3
00:00:31,632 --> 00:00:34,201
<c.magenta>欢迎来到</c>
<c.magenta>“Xcode下可视化调试工具”演讲</c>


4
00:00:35,169 --> 00:00:38,172
<c.magenta>我是Chris</c>
<c.magenta>在Xcode调试工具UI小组工作</c>


5
00:00:39,373 --> 00:00:43,210
<c.magenta>众所周知 调试工具存在已久</c>


6
00:00:44,611 --> 00:00:46,180
<c.magenta>就在不久以前</c>


7
00:00:46,246 --> 00:00:48,715
<c.magenta>调试工具看上去还是这个样子</c>


8
00:00:51,418 --> 00:00:53,820
<c.magenta>此后不久 UI进行了改进</c>


9
00:00:53,887 --> 00:00:56,757
<c.magenta>调试工具开始看上去像这个样子</c>


10
00:00:59,259 --> 00:01:00,661
<c.magenta>但是快进到今天</c>


11
00:01:00,727 --> 00:01:03,530
<c.magenta>调试工具变得更加强大</c>


12
00:01:03,597 --> 00:01:06,066
<c.magenta>同时也更容易操作</c>


13
00:01:06,567 --> 00:01:09,736
<c.magenta>其中大部分要归功于它变得更为可视化</c>


14
00:01:09,803 --> 00:01:12,940
<c.magenta>这帮助我们更为快速</c>
<c.magenta>更为直观地解决问题</c>


15
00:01:13,874 --> 00:01:16,076
<c.magenta>今天 我将和同事们一起讲解</c>


16
00:01:16,143 --> 00:01:18,979
<c.magenta>Xcode中最新的可视化调试工具</c>


17
00:01:22,583 --> 00:01:24,284
<c.magenta>首先 快速概述一下讲座的内容</c>


18
00:01:25,219 --> 00:01:27,621
<c.magenta>我们将会讲解Xcode的新功能</c>


19
00:01:27,688 --> 00:01:31,625
<c.magenta>能报告工具发现的运行时问题</c>


20
00:01:32,626 --> 00:01:35,229
<c.magenta>我们还将讲解最新的增强功能</c>


21
00:01:35,295 --> 00:01:37,197
<c.magenta>对Xcode的视图调试工具所作的</c>


22
00:01:37,264 --> 00:01:40,601
<c.magenta>以及如何把自动布局调试</c>
<c.magenta>变得前所未有地简单</c>


23
00:01:41,735 --> 00:01:44,838
<c.magenta>我们还将讲解一个新功能</c>
<c.magenta>可以可视化调试</c>


24
00:01:44,905 --> 00:01:47,674
<c.magenta>就是状态机 以及做出的增强</c>


25
00:01:47,741 --> 00:01:51,812
<c.magenta>在FPS性能测量方面</c>
<c.magenta>从而更好帮助调试SpriteKit</c>


26
00:01:51,879 --> 00:01:53,514
<c.magenta>以及SceneKit帧率问题</c>


27
00:01:54,548 --> 00:01:58,151
<c.magenta>最后 将讲解Xcode的一个新功能</c>


28
00:01:58,218 --> 00:01:59,820
<c.magenta>可视化内存图形调试工具</c>


29
00:02:03,857 --> 00:02:05,926
<c.magenta>首先来看问题</c>


30
00:02:08,862 --> 00:02:12,332
<c.magenta>我们都知道 编译时发生的问题</c>
<c.magenta>比如编译器警告 错误</c>


31
00:02:12,399 --> 00:02:15,469
<c.magenta>和静态分析问题 都已经得到了</c>


32
00:02:15,536 --> 00:02:20,307
<c.magenta>Xcode用户界面充分支持</c>
<c.magenta>和测试时发现的问题相同</c>


33
00:02:21,408 --> 00:02:24,077
<c.magenta>然而 不能同理可证</c>


34
00:02:24,144 --> 00:02:27,681
<c.magenta>调试和分析工具的扩展组件</c>
<c.magenta>发现的运行时问题</c>


35
00:02:28,348 --> 00:02:32,452
<c.magenta>这些工具都已经被遗忘</c>


36
00:02:32,519 --> 00:02:36,757
<c.magenta>最多会被用来在控制台上记录输出结果</c>


37
00:02:37,124 --> 00:02:38,292
<c.magenta>不是最好的体验</c>


38
00:02:38,792 --> 00:02:40,561
<c.magenta>我们认为可以做得更好</c>


39
00:02:42,396 --> 00:02:45,199 line:1
<c.magenta>在Xcode 8</c>
<c.magenta>我们引进了运行时问题</c>


40
00:02:52,239 --> 00:02:55,943
<c.magenta>运行时问题</c>
<c.magenta>把工具在运行时发现的问题上升</c>


41
00:02:56,543 --> 00:03:00,514
<c.magenta>和UI里传统编译时问题同等地位</c>


42
00:03:02,950 --> 00:03:05,619
<c.magenta>活动查看器会如此显示</c>


43
00:03:05,686 --> 00:03:09,523
<c.magenta>当发现任何运行时问题时</c>
<c.magenta>并报告问题数量</c>


44
00:03:12,025 --> 00:03:15,095
<c.magenta>我们增强了问题浏览器</c>
<c.magenta>包含新的运行时范围</c>


45
00:03:15,362 --> 00:03:17,664
<c.magenta>这区分了运行时问题</c>


46
00:03:17,731 --> 00:03:19,499
<c.magenta>和传统的编译时问题</c>


47
00:03:19,566 --> 00:03:22,636
<c.magenta>比如编译器警告 错误和静态分析问题</c>


48
00:03:26,440 --> 00:03:29,810
<c.magenta>在运行时 会看到什么样的问题呢？</c>


49
00:03:30,477 --> 00:03:33,013
<c.magenta>在Xcode 8 我们处理三个范围</c>


50
00:03:33,580 --> 00:03:36,316
<c.magenta>首先 线程问题</c>


51
00:03:37,017 --> 00:03:38,886
<c.magenta>我们全新的</c>
<c.magenta>"Thread Sanitizer线程检查工具"</c>


52
00:03:38,952 --> 00:03:43,390
<c.magenta>可检测线程问题在应用中 在运行时</c>


53
00:03:45,692 --> 00:03:46,894
<c.magenta>UI布局问题</c>


54
00:03:46,994 --> 00:03:49,396
<c.magenta>我们扩展了Xcode的视图调试工具</c>


55
00:03:49,463 --> 00:03:52,165
<c.magenta>来自动检测模糊的布局问题</c>


56
00:03:52,232 --> 00:03:53,534
<c.magenta>在应用中 在运行时</c>


57
00:03:55,903 --> 00:03:56,837
<c.magenta>以及 内存问题</c>


58
00:03:57,237 --> 00:03:59,139
<c.magenta>全新的内存图形调试工具</c>


59
00:03:59,206 --> 00:04:01,241
<c.magenta>一会儿我们会详细解释</c>


60
00:04:01,308 --> 00:04:03,977
<c.magenta>它可以自动检测内存泄漏</c>


61
00:04:04,044 --> 00:04:05,612
<c.magenta>在应用中 在运行时</c>


62
00:04:09,783 --> 00:04:11,118
<c.magenta>所以 如你在周一所听到的</c>


63
00:04:11,185 --> 00:04:13,287
<c.magenta>Xcode最新的运行时的检查工具</c>


64
00:04:13,353 --> 00:04:14,821
<c.magenta>就是"Thread Sanitizer线程检查工具"</c>


65
00:04:15,422 --> 00:04:19,892
<c.magenta>"Thread Sanitizer线程检查工具"</c>
<c.magenta>帮助我们检测和更好地理解线程问题</c>


66
00:04:19,959 --> 00:04:21,962
<c.magenta>在应用中 在运行时</c>


67
00:04:22,629 --> 00:04:25,032
<c.magenta>它可以检测到的问题有 数据竞争</c>


68
00:04:25,098 --> 00:04:28,368
<c.magenta>使用为初始化的互斥锁</c>
<c.magenta>来自错误线程的解锁</c>


69
00:04:28,836 --> 00:04:31,471
<c.magenta>线程泄漏及信号处理器的不安全调用等</c>


70
00:04:32,172 --> 00:04:36,176
<c.magenta>发现以上任何一种问题</c>
<c.magenta>都会被报告为运行时问题</c>


71
00:04:37,244 --> 00:04:40,180
<c.magenta>"Thread Sanitizer线程检查工具"</c>
<c.magenta>是一个强大的全新的运行时分析工具</c>


72
00:04:40,247 --> 00:04:43,083
<c.magenta>为了更充分地理解它可以观看</c>
<c.magenta>关于"Thread Sanitizer线程检查工具"</c>


73
00:04:43,150 --> 00:04:44,551
<c.magenta>以及静态分析演讲</c>


74
00:04:50,591 --> 00:04:52,559
<c.magenta>视图调试是一个非常优秀的范例</c>


75
00:04:52,626 --> 00:04:55,495
<c.magenta>在Xcode的调试工具中</c>
<c.magenta>变得越来越可视化</c>


76
00:04:56,063 --> 00:05:00,901
<c.magenta>仅仅在过去几年 关于UI调试问题</c>


77
00:05:00,968 --> 00:05:04,071
<c.magenta>我们从必须要读取调试输出</c>


78
00:05:04,137 --> 00:05:07,407
<c.magenta>到一个像这样的工具台 变成这样</c>


79
00:05:08,008 --> 00:05:11,245
<c.magenta>Xcode的可视化视图调试工具</c>
<c.magenta>有非常好的用户体验</c>


80
00:05:11,445 --> 00:05:14,414
<c.magenta>对于调试和理解可视化UI问题</c>


81
00:05:15,449 --> 00:05:16,783
<c.magenta>如果你还从未使用过</c>


82
00:05:17,484 --> 00:05:19,319
<c.magenta>当应用在运行Xcode时</c>


83
00:05:20,053 --> 00:05:24,291
<c.magenta>只需点击调试工具条下方的</c>
<c.magenta>“调试视图层次结构”按钮</c>


84
00:05:25,526 --> 00:05:27,594
<c.magenta>Xcode将会快照你的应用</c>


85
00:05:28,529 --> 00:05:29,930
<c.magenta>快照你的视图层次结构</c>


86
00:05:29,997 --> 00:05:32,766
<c.magenta>把它在一可互动的3D场景里分解出来</c>


87
00:05:33,600 --> 00:05:38,071
<c.magenta>在那里</c>
<c.magenta>你可以在3D画布里检查视图层次结构</c>


88
00:05:38,672 --> 00:05:40,541
<c.magenta>还可以在分级视图里</c>


89
00:05:40,774 --> 00:05:44,545
<c.magenta>你可以检查所有视图和限制的属性</c>


90
00:05:44,611 --> 00:05:45,846
<c.magenta>利用检查器</c>


91
00:05:48,916 --> 00:05:52,386
<c.magenta>在Xcode 8</c>
<c.magenta>我们让视图调试——</c>


92
00:05:53,554 --> 00:05:54,988
<c.magenta>你猜？比过去任何时候都更好</c>


93
00:06:02,963 --> 00:06:05,365
<c.magenta>快照现在比过去快了近70％</c>


94
00:06:05,432 --> 00:06:07,201
<c.magenta>所以你可以从运行应用</c>


95
00:06:07,267 --> 00:06:09,570
<c.magenta>切换到调试UI问题 前所未有的快</c>


96
00:06:15,542 --> 00:06:17,110
<c.magenta>渲染复杂布局</c>


97
00:06:17,177 --> 00:06:20,581
<c.magenta>和转换视图在Xcode 8里更准确</c>


98
00:06:20,681 --> 00:06:24,184
<c.magenta>谈到准确</c>
<c.magenta>Xcode现可渲染模糊视图</c>


99
00:06:24,251 --> 00:06:26,987
<c.magenta>比如画布上带高保真视觉效果的视图</c>


100
00:06:27,621 --> 00:06:30,357
<c.magenta>因此在Xcode的</c>
<c.magenta>视图调试工具所见到的</c>


101
00:06:30,424 --> 00:06:32,459
<c.magenta>更为准确地反应了在设备上所见到的</c>


102
00:06:33,026 --> 00:06:35,429
<c.magenta>在beta 2</c>
<c.magenta>将会看到改进的模糊渲染</c>


103
00:06:36,930 --> 00:06:39,132
<c.magenta>我们添加了便利性 比如可以直接跳转</c>


104
00:06:39,199 --> 00:06:41,101
<c.magenta>从视图类到源代码</c>


105
00:06:41,168 --> 00:06:43,904
<c.magenta>只需在对象检查器上点击跳转按钮</c>


106
00:06:45,706 --> 00:06:48,442
<c.magenta>浏览过滤也变得更为强大了</c>


107
00:06:48,842 --> 00:06:53,514
<c.magenta>可以通过任何标签上的文本</c>
<c.magenta>或按钮标题上的文本进行过滤</c>


108
00:06:54,448 --> 00:06:58,719
<c.magenta>或者你可以通过类名进行过滤</c>
<c.magenta>也包括超类名</c>


109
00:06:58,852 --> 00:07:02,656
<c.magenta>比如 如果通过UI标签进行过滤</c>
<c.magenta>将会返回</c>


110
00:07:02,723 --> 00:07:05,559
<c.magenta>所有视图层次结构中</c>
<c.magenta>该UI标签的所有子类</c>


111
00:07:06,193 --> 00:07:07,895
<c.magenta>甚至可以通过内存地址进行过滤</c>


112
00:07:08,061 --> 00:07:10,230
<c.magenta>这样可以迅速找到特定的视图</c>


113
00:07:10,297 --> 00:07:11,999
<c.magenta>只需知道其内存地址</c>


114
00:07:17,171 --> 00:07:20,240
<c.magenta>自动布局调试也进步显著</c>


115
00:07:20,741 --> 00:07:24,378
<c.magenta>检查器可以显示更多</c>
<c.magenta>和自动布局相关的属性</c>


116
00:07:25,045 --> 00:07:27,915
<c.magenta>限制在画布上表现得更好</c>


117
00:07:28,582 --> 00:07:30,484
<c.magenta>我们用标记渲染限制</c>


118
00:07:30,551 --> 00:07:33,654
<c.magenta>来代表不平等或长宽比关系</c>


119
00:07:33,987 --> 00:07:37,057
<c.magenta>我们还用虚线渲染非必须限制</c>


120
00:07:37,124 --> 00:07:39,393
<c.magenta>所以你可以很容易分辨</c>


121
00:07:39,459 --> 00:07:41,562
<c.magenta>画布上的必须限制和非必须限制</c>


122
00:07:42,696 --> 00:07:45,399
<c.magenta>但是我最欣赏的自动布局调试的新功能</c>


123
00:07:45,465 --> 00:07:47,601
<c.magenta>是它结合了运行时问题</c>


124
00:07:49,436 --> 00:07:52,773
<c.magenta>Xcode现可自动检测模糊布局问题</c>


125
00:07:52,840 --> 00:07:55,142
<c.magenta>在视图层次结构里 在运行时</c>


126
00:08:01,648 --> 00:08:02,816
<c.magenta>它是怎么运作的？</c>


127
00:08:03,150 --> 00:08:04,885
<c.magenta>当快照视图层次结构时</c>


128
00:08:04,952 --> 00:08:09,223
<c.magenta>Xcode将会检查每一个视图</c>
<c.magenta>并将准确决定</c>


129
00:08:09,289 --> 00:08:11,758
<c.magenta>其中任何一个视图是否存在模糊布局</c>


130
00:08:11,825 --> 00:08:13,760
<c.magenta>以及模糊原因</c>


131
00:08:14,595 --> 00:08:20,434
<c.magenta>如果检测到任何布局问题</c>
<c.magenta>将会作为运行时问题报告</c>


132
00:08:21,134 --> 00:08:23,270
<c.magenta>所以可以看见它们显示在活动查看器里</c>


133
00:08:23,604 --> 00:08:26,507
<c.magenta>还可以看见它们在运行时</c>
<c.magenta>被列在问题浏览器里</c>


134
00:08:28,075 --> 00:08:31,645
<c.magenta>此外 视图层次结构一览将会标记</c>


135
00:08:31,712 --> 00:08:34,847
<c.magenta>任何有布局问题的视图</c>
<c.magenta>因此可以轻易找到它们</c>


136
00:08:34,914 --> 00:08:37,150
<c.magenta>在整个布局层次结构下</c>


137
00:08:39,318 --> 00:08:42,956
<c.magenta>对于一个选中的视图</c>
<c.magenta>尺寸检查器将会包含</c>


138
00:08:43,023 --> 00:08:46,326
<c.magenta>任何布局问题的细节 以及所有</c>


139
00:08:46,393 --> 00:08:48,529
<c.magenta>参与该视图布局的限制</c>


140
00:08:49,830 --> 00:08:51,999
<c.magenta>我们对Xcode新功能感到十分激动</c>


141
00:08:52,065 --> 00:08:54,902
<c.magenta>它可以在运行时自动检测模糊布局问题</c>


142
00:08:55,202 --> 00:08:56,603
<c.magenta>我想为你们做一个演示</c>


143
00:08:59,273 --> 00:09:02,442
<c.magenta>我有一个iPhone连在Mac上</c>


144
00:09:02,743 --> 00:09:05,946
<c.magenta>Xcode已经启动</c>
<c.magenta>正运行一个叫DemoBots的项目</c>


145
00:09:06,013 --> 00:09:10,484
<c.magenta>这是我们今年更新Swift 3中的</c>
<c.magenta>示例代码项目之一</c>


146
00:09:11,385 --> 00:09:13,287
<c.magenta>在右边 我正使用</c>
<c.magenta>QuickTime Player</c>


147
00:09:13,353 --> 00:09:16,290
<c.magenta>把手机屏幕映射在桌面上</c>
<c.magenta>大家才都可以看见</c>


148
00:09:17,024 --> 00:09:20,027
<c.magenta>我们的团队的任务是</c>
<c.magenta>把一个游戏指导说明书</c>


149
00:09:20,093 --> 00:09:22,629
<c.magenta>添加到DemoBots</c>
<c.magenta>所以做了一个“如何开始游戏”界面</c>


150
00:09:23,197 --> 00:09:26,300
<c.magenta>然而 在演讲前我们发现了一些问题</c>


151
00:09:26,400 --> 00:09:28,869
<c.magenta>现在是调试这些问题的好机会</c>


152
00:09:29,603 --> 00:09:30,637
<c.magenta>点击“如何开始游戏”</c>


153
00:09:30,971 --> 00:09:32,406
<c.magenta>这就是“如何开始游戏”界面</c>


154
00:09:32,806 --> 00:09:33,740
<c.magenta>不怎么样是吧？</c>


155
00:09:34,374 --> 00:09:36,577
<c.magenta>显然 存在一些问题 来看一下</c>


156
00:09:36,643 --> 00:09:39,146
<c.magenta>可以看到DemoBots图标在后面</c>


157
00:09:39,213 --> 00:09:41,615
<c.magenta>上方有一些错位的文本</c>


158
00:09:41,982 --> 00:09:44,284
<c.magenta>我们需要来调试 从哪儿开始？</c>


159
00:09:45,118 --> 00:09:46,420
<c.magenta>给你们一点提示</c>


160
00:09:46,920 --> 00:09:50,023
<c.magenta>DemoBots是一款用</c>
<c.magenta>SpriteKit编写的街机小游戏</c>


161
00:09:50,090 --> 00:09:53,093
<c.magenta>但该屏幕是</c>
<c.magenta>用UIKit和自动布局产生的</c>


162
00:09:53,660 --> 00:09:55,929
<c.magenta>所以最好的开始的地方是在</c>


163
00:09:55,996 --> 00:09:59,867
<c.magenta>在视图层次和布局结构上</c>


164
00:09:59,933 --> 00:10:01,034
<c.magenta>我们一起来操作</c>


165
00:10:01,835 --> 00:10:03,136
<c.magenta>回到Xcode</c>


166
00:10:04,571 --> 00:10:05,539
<c.magenta>最底部</c>


167
00:10:06,206 --> 00:10:08,342
<c.magenta>找到“调试视图层次”按钮</c>


168
00:10:09,610 --> 00:10:10,711
<c.magenta>点击</c>


169
00:10:10,777 --> 00:10:14,047
<c.magenta>它将暂停应用 快照整个视图结构</c>


170
00:10:14,948 --> 00:10:15,816
<c.magenta>在编辑器里</c>


171
00:10:16,350 --> 00:10:19,853
<c.magenta>我们返回了刚才屏幕上所见的准确表达</c>


172
00:10:20,721 --> 00:10:22,956
<c.magenta>为了查看内部结构</c>


173
00:10:23,023 --> 00:10:24,892
<c.magenta>我们只需把它拖进画布</c>


174
00:10:24,958 --> 00:10:28,495
<c.magenta>把完整的视图结构开拓成3D视图</c>


175
00:10:33,867 --> 00:10:37,204
<c.magenta>在这里 可看到构成该屏幕的所有视图</c>


176
00:10:37,271 --> 00:10:38,539
<c.magenta>后面的视窗</c>


177
00:10:38,672 --> 00:10:40,707
<c.magenta>容器视图 视觉效果视图</c>


178
00:10:40,774 --> 00:10:43,644
<c.magenta>及构成“如何开始游戏”说明书的视图</c>


179
00:10:43,944 --> 00:10:45,112
<c.magenta>放大看一下</c>


180
00:10:45,579 --> 00:10:47,481
<c.magenta>我们看到DemoBots图标在后面</c>


181
00:10:47,548 --> 00:10:49,383
<c.magenta>还有很多标签和图像</c>


182
00:10:49,716 --> 00:10:53,086
<c.magenta>我们迅速可以了解 通过旋转</c>


183
00:10:53,153 --> 00:10:55,055
<c.magenta>找出屏幕上的一团乱的原因</c>


184
00:10:55,322 --> 00:10:57,925
<c.magenta>所有这些视图都彼此叠加</c>


185
00:10:58,225 --> 00:10:59,526
<c.magenta>所以我们的布局有问题</c>


186
00:11:00,127 --> 00:11:02,629
<c.magenta>传统的工作流程是</c>


187
00:11:02,696 --> 00:11:04,565
<c.magenta>检测每一个视图及其限制</c>


188
00:11:04,631 --> 00:11:07,034
<c.magenta>然后试着确定产生布局问题的原因</c>


189
00:11:07,367 --> 00:11:10,304
<c.magenta>但在Xcode 8</c>
<c.magenta>我们有一些额外的可用信息</c>


190
00:11:10,871 --> 00:11:13,874
<c.magenta>注意上方的活动查看器Xcode报告</c>


191
00:11:13,941 --> 00:11:15,676
<c.magenta>我们有运行时问题</c>


192
00:11:16,577 --> 00:11:18,545
<c.magenta>可以点击它</c>


193
00:11:18,779 --> 00:11:21,481
<c.magenta>将会打开问题浏览器</c>


194
00:11:21,982 --> 00:11:24,952
<c.magenta>但你可能也注意到了左边这里</c>


195
00:11:25,018 --> 00:11:26,553
<c.magenta>在调试浏览器里</c>


196
00:11:27,487 --> 00:11:29,423
<c.magenta>Xcode标记出一些视图</c>


197
00:11:29,690 --> 00:11:31,859
<c.magenta>它告诉我们 这些视图有布局问题</c>


198
00:11:31,925 --> 00:11:33,227
<c.magenta>直接来看这里</c>


199
00:11:34,228 --> 00:11:35,662
<c.magenta>如果选中第一个视图</c>


200
00:11:36,263 --> 00:11:38,365
<c.magenta>画布中高亮显示</c>


201
00:11:38,665 --> 00:11:41,735
<c.magenta>然后打开该视图的尺寸检查器</c>
<c.magenta>右边这里</c>


202
00:11:42,970 --> 00:11:46,139
<c.magenta>在这里 我们可以在限制中</c>
<c.magenta>找出布局问题的原因</c>


203
00:11:46,507 --> 00:11:49,343
<c.magenta>该视图有一个模糊垂直位置</c>


204
00:11:50,077 --> 00:11:52,579
<c.magenta>也就是说自动布局没有足够的信息</c>


205
00:11:52,646 --> 00:11:56,083
<c.magenta>在垂直维度明确定位该视图</c>


206
00:11:56,984 --> 00:11:58,685
<c.magenta>很典型 限制缺失</c>


207
00:12:00,354 --> 00:12:01,722
<c.magenta>来看下一个视图</c>


208
00:12:02,256 --> 00:12:04,658
<c.magenta>有着一样的问题 垂直位置模糊</c>


209
00:12:05,292 --> 00:12:06,827
<c.magenta>下一个视图也是</c>


210
00:12:06,894 --> 00:12:08,095
<c.magenta>若我随机点击一些别的</c>


211
00:12:08,161 --> 00:12:09,796
<c.magenta>似乎它们都有同样的问题</c>


212
00:12:10,264 --> 00:12:13,467
<c.magenta>我很好奇 这个列表的第一个子视图</c>


213
00:12:13,934 --> 00:12:15,135
<c.magenta>并没被标记显示有问题</c>


214
00:12:15,202 --> 00:12:17,304
<c.magenta>可能是查看布局代码时的一个线索</c>


215
00:12:17,905 --> 00:12:18,972
<c.magenta>现在我们来看一下</c>


216
00:12:19,239 --> 00:12:20,674
<c.magenta>如果选中父视图</c>


217
00:12:21,241 --> 00:12:23,710
<c.magenta>类名是</c>
<c.magenta>InstructionsLayoutView</c>


218
00:12:23,777 --> 00:12:26,713
<c.magenta>这就是负责显示</c>
<c.magenta>“如何开始游戏”屏幕的视图</c>


219
00:12:27,581 --> 00:12:29,383
<c.magenta>来看看它的源代码</c>


220
00:12:29,917 --> 00:12:32,686
<c.magenta>一种简单的方法就是选中视图</c>


221
00:12:32,753 --> 00:12:34,021
<c.magenta>右边这里</c>


222
00:12:34,087 --> 00:12:36,290
<c.magenta>可以找到 对象检查器</c>


223
00:12:36,657 --> 00:12:39,927
<c.magenta>该按钮可以直接跳转到视图源代码</c>


224
00:12:40,627 --> 00:12:41,728
<c.magenta>如此操作</c>


225
00:12:41,795 --> 00:12:43,797
<c.magenta>关上检查器 多留出一点空间</c>


226
00:12:44,031 --> 00:12:46,667
<c.magenta>我们来看看</c>
<c.magenta>InstructionsLayoutView的源代码</c>


227
00:12:48,202 --> 00:12:50,838
<c.magenta>首先开始循环</c>


228
00:12:50,904 --> 00:12:53,140
<c.magenta>说明书的每一个部分 都是模块对象</c>


229
00:12:53,207 --> 00:12:57,678
<c.magenta>描述了页眉部分 段落部分 和图片</c>


230
00:12:58,212 --> 00:13:00,914
<c.magenta>代码把它们从上到下显示</c>


231
00:13:01,582 --> 00:13:04,785
<c.magenta>对于每一个部分 修复视图</c>
<c.magenta>把它添加到视图层次结构</c>


232
00:13:05,152 --> 00:13:07,354
<c.magenta>然后是水平布局的源代码</c>


233
00:13:07,487 --> 00:13:09,323
<c.magenta>但在水平布局中没有发现任何问题</c>


234
00:13:09,389 --> 00:13:11,525
<c.magenta>所以略过此处 到垂直布局</c>


235
00:13:12,526 --> 00:13:14,228
<c.magenta>这里 有两条通路</c>


236
00:13:14,595 --> 00:13:17,130
<c.magenta>第一条是 对于第一个子视图</c>


237
00:13:17,197 --> 00:13:18,198
<c.magenta>把它限制到容器顶端</c>


238
00:13:18,866 --> 00:13:22,569
<c.magenta>我们已经注意到 第一个子视图</c>


239
00:13:22,636 --> 00:13:23,871
<c.magenta>并未报告含有任何问题</c>


240
00:13:24,071 --> 00:13:26,406
<c.magenta>所以 该限制我们认为是设置正确的</c>


241
00:13:26,473 --> 00:13:28,642
<c.magenta>来看看条件的另一面</c>


242
00:13:29,510 --> 00:13:32,713
<c.magenta>这里 查找可选的</c>
<c.magenta>previousPartView</c>


243
00:13:32,779 --> 00:13:36,016
<c.magenta>如果找到了</c>
<c.magenta>就把它指定给上面的局部变量</c>


244
00:13:36,383 --> 00:13:39,620
<c.magenta>然后可把每个视图限制到它上面的视图</c>


245
00:13:40,020 --> 00:13:41,855
<c.magenta>看上去这就是缺失的限制</c>


246
00:13:42,389 --> 00:13:46,760
<c.magenta>让我们来看看为什么该条件不为真</c>


247
00:13:47,461 --> 00:13:50,864
<c.magenta>选中previousPartView</c>
<c.magenta>我们从它开始</c>


248
00:13:50,931 --> 00:13:55,335
<c.magenta>我将使用Command-A选中</c>
<c.magenta>Command-F跳出搜索栏</c>


249
00:13:56,069 --> 00:13:57,771
<c.magenta>检查该变量的实例</c>


250
00:13:58,272 --> 00:13:59,907
<c.magenta>可以看到其在顶端被定义</c>


251
00:14:00,107 --> 00:14:02,409
<c.magenta>它被指定为nil 在for循环之前</c>


252
00:14:02,843 --> 00:14:04,211
<c.magenta>在下方这里也检查</c>


253
00:14:04,645 --> 00:14:06,747
<c.magenta>在外循环外又检查一次</c>


254
00:14:06,813 --> 00:14:08,615
<c.magenta>来处理底部限制</c>


255
00:14:08,682 --> 00:14:10,717
<c.magenta>但看上去我们从未指定给它</c>


256
00:14:10,918 --> 00:14:12,219
<c.magenta>快速修复一下</c>


257
00:14:13,053 --> 00:14:15,422
<c.magenta>在循环结尾 我们可把</c>
<c.magenta>previousPartView</c>


258
00:14:16,023 --> 00:14:17,257
<c.magenta>设定给当前的partView</c>


259
00:14:17,624 --> 00:14:21,028
<c.magenta>然后在每一个循环中</c>
<c.magenta>前一个视图都可用</c>


260
00:14:21,094 --> 00:14:23,497
<c.magenta>都将指定给上面的视图</c>


261
00:14:23,564 --> 00:14:26,567
<c.magenta>我们将从视图到其上面的视图</c>
<c.magenta>之间建立一个限制</c>


262
00:14:27,234 --> 00:14:29,169
<c.magenta>停止 重新运行 看看结果</c>


263
00:14:29,903 --> 00:14:31,305
<c.magenta>我把QuickTime移到前面</c>


264
00:14:32,105 --> 00:14:34,241
<c.magenta>请注意Xcode能给提供多少信息</c>


265
00:14:34,308 --> 00:14:36,510
<c.magenta>甚至在看到代码之前</c>


266
00:14:36,977 --> 00:14:39,279
<c.magenta>{\an2用视图调试器查看结构内部</c>


267
00:14:39,346 --> 00:14:40,881
<c.magenta>看看有什么问题</c>


268
00:14:41,181 --> 00:14:43,350
<c.magenta>更重要的 Xcode会主动告诉我们</c>


269
00:14:43,417 --> 00:14:46,486
<c.magenta>应用里的某些布局问题</c>


270
00:14:46,787 --> 00:14:50,190
<c.magenta>哪个视图有问题 尤其是什么样的问题</c>


271
00:14:50,457 --> 00:14:53,093
<c.magenta>这在我们查看代码之前就有了很多信息</c>


272
00:14:53,160 --> 00:14:56,463
<c.magenta>因此我们可以迅速锁定</c>
<c.magenta>需要查看的代码部分</c>


273
00:14:57,698 --> 00:15:00,033
<c.magenta>现在应用正在运行</c>
<c.magenta>点击“如何开始游戏”</c>


274
00:15:01,034 --> 00:15:02,236
<c.magenta>看上去好多了</c>


275
00:15:02,302 --> 00:15:03,971
<c.magenta>我们有了一个美观的说明页面</c>


276
00:15:11,211 --> 00:15:16,083
<c.magenta>现在Xcode可以报告运行时错误</c>


277
00:15:16,149 --> 00:15:19,253
<c.magenta>采用和检测编译时问题时一样的UI</c>


278
00:15:20,587 --> 00:15:23,423
<c.magenta>今年 Xcode的视图调试器</c>
<c.magenta>也有了显著的改进</c>


279
00:15:23,790 --> 00:15:27,494
<c.magenta>包括更为迅速的快照和更为准确的渲染</c>


280
00:15:27,561 --> 00:15:30,297
<c.magenta>在复杂布局和模糊视图方面</c>


281
00:15:31,598 --> 00:15:34,401
<c.magenta>在自动调试方面也有了显著的改进</c>


282
00:15:34,468 --> 00:15:36,370
<c.magenta>尤其是 Xcode现在可以</c>


283
00:15:36,436 --> 00:15:40,040
<c.magenta>在运行时自动检测模糊布局问题</c>


284
00:15:40,674 --> 00:15:43,043
<c.magenta>Xcode的视图调试器支持各种UI</c>


285
00:15:43,110 --> 00:15:45,679
<c.magenta>在Mac OS iOS和tvOS上</c>


286
00:15:46,146 --> 00:15:47,247
<c.magenta>在你的项目中试一下</c>


287
00:15:47,314 --> 00:15:50,918
<c.magenta>我们很乐意得到反馈</c>
<c.magenta>关于它如何在调试流程中给你带来帮助</c>


288
00:15:53,120 --> 00:15:54,855
<c.magenta>下面 我想把讲台让给Tyler</c>


289
00:15:54,922 --> 00:15:58,659
<c.magenta>他将为我们讲解</c>
<c.magenta>调试状态机和帧速率问题</c>


290
00:15:58,926 --> 00:15:59,760
<c.magenta>谢谢大家</c>


291
00:16:04,865 --> 00:16:05,799
<c.magenta>谢谢Chris</c>


292
00:16:06,500 --> 00:16:09,336
<c.magenta>今天 我将为大家演示</c>
<c.magenta>一种增强调试体验的新方法</c>


293
00:16:09,403 --> 00:16:10,771
<c.magenta>利用状态机快速查看</c>


294
00:16:10,838 --> 00:16:14,274
<c.magenta>及Xcode 8中FPS性能检测的</c>
<c.magenta>内部机理</c>


295
00:16:15,909 --> 00:16:17,444
<c.magenta>今天有很多有用的快速查看</c>


296
00:16:17,511 --> 00:16:19,580
<c.magenta>已经在Xcode 7里可用</c>


297
00:16:19,847 --> 00:16:23,183
<c.magenta>这些为你提供了</c>
<c.magenta>实时查看各种对象的可能</c>


298
00:16:23,250 --> 00:16:24,318
<c.magenta>在调试过程中</c>


299
00:16:24,718 --> 00:16:27,020
<c.magenta>你甚至可以自定义快速查看</c>


300
00:16:27,087 --> 00:16:28,889
<c.magenta>来检查应用内部对象</c>


301
00:16:29,656 --> 00:16:30,991
<c.magenta>现在在Xcode 8</c>


302
00:16:31,058 --> 00:16:34,294
<c.magenta>我们扩展了内置的快速查看</c>
<c.magenta>包含了状态机</c>


303
00:16:35,195 --> 00:16:37,397
<c.magenta>首先我们来看状态机到底是什么</c>


304
00:16:37,464 --> 00:16:39,066
<c.magenta>以及如何在应用内部使用</c>


305
00:16:41,168 --> 00:16:43,737
<c.magenta>你们当中一定有很多人已对</c>
<c.magenta>GKStateMachine很熟悉</c>


306
00:16:43,804 --> 00:16:46,139
<c.magenta>去年它是</c>
<c.magenta>GameplayKit的一部分</c>


307
00:16:46,206 --> 00:16:49,376
<c.magenta>可用于</c>
<c.magenta>Mac OS iOS和tvOS</c>


308
00:16:50,277 --> 00:16:53,146
<c.magenta>状态机允许你更为简单地定义复杂行为</c>


309
00:16:53,213 --> 00:16:55,382
<c.magenta>通过把它构建成为一个有向图</c>


310
00:16:55,816 --> 00:16:57,017
<c.magenta>在状态机内</c>


311
00:16:57,084 --> 00:16:59,486
<c.magenta>你为每一个状态提供一个离散行为</c>


312
00:17:00,220 --> 00:17:02,723
<c.magenta>可以像播放一个动画这么简单</c>


313
00:17:02,789 --> 00:17:05,459
<c.magenta>或者更复杂的 比如一个AI</c>


314
00:17:06,460 --> 00:17:08,929
<c.magenta>然后对每一个状态定义条件</c>


315
00:17:08,996 --> 00:17:12,266
<c.magenta>状态机可以据此</c>
<c.magenta>从一个状态转换到另一个状态</c>


316
00:17:13,834 --> 00:17:17,637
<c.magenta>组装完成后</c>
<c.magenta>状态机可以产生极其复杂的行为</c>


317
00:17:17,704 --> 00:17:21,308
<c.magenta>然而 在代码里它们也会变得很难辨识</c>


318
00:17:21,375 --> 00:17:22,943
<c.magenta>由于它们复杂度的增加</c>


319
00:17:23,377 --> 00:17:26,914
<c.magenta>简单的状态机可以迅速进化得更为详细</c>


320
00:17:28,615 --> 00:17:31,118
<c.magenta>在Xcode 7.3</c>
<c.magenta>对调试状态机的支持</c>


321
00:17:31,185 --> 00:17:34,087
<c.magenta>只局限在当前状态和它的转换</c>


322
00:17:34,454 --> 00:17:36,156
<c.magenta>而现在在Xcode 8</c>


323
00:17:36,223 --> 00:17:38,725
<c.magenta>我们可以可视化完整的状态机</c>


324
00:17:38,792 --> 00:17:40,594
<c.magenta>因此可以一目了然当前状态</c>


325
00:17:41,728 --> 00:17:43,764
<c.magenta>这非常有用 不论你正在</c>


326
00:17:43,830 --> 00:17:46,767
<c.magenta>操作简单的状态机 还是你在操作</c>


327
00:17:46,834 --> 00:17:49,469
<c.magenta>更为复杂的状态机</c>


328
00:17:50,003 --> 00:17:53,207
<c.magenta>利用快速查看</c>
<c.magenta>你可以迅速调试潜在问题</c>


329
00:17:53,273 --> 00:17:56,343
<c.magenta>并且准确评估状态机的当前情况</c>


330
00:17:59,246 --> 00:18:01,582
<c.magenta>现在我们把焦点转到性能</c>


331
00:18:02,282 --> 00:18:04,751
<c.magenta>任何时候新建任何形式的</c>
<c.magenta>游戏或视觉应用</c>


332
00:18:04,885 --> 00:18:06,620
<c.magenta>保证良好性能都是关键</c>


333
00:18:06,987 --> 00:18:09,690
<c.magenta>在Xcode 8</c>
<c.magenta>我们扩大了FPS性能测量</c>


334
00:18:09,756 --> 00:18:10,824
<c.magenta>在这方面进行帮助</c>


335
00:18:12,526 --> 00:18:14,027
<c.magenta>你们当中很多人应该已很熟悉</c>


336
00:18:14,094 --> 00:18:16,530
<c.magenta>Xcode 7的FPS性能测量</c>


337
00:18:16,830 --> 00:18:18,632
<c.magenta>在报告一开始</c>


338
00:18:18,699 --> 00:18:20,667
<c.magenta>可以看到实时状态的数据</c>


339
00:18:21,535 --> 00:18:22,703
<c.magenta>这包括了帧速率</c>


340
00:18:22,769 --> 00:18:25,172
<c.magenta>即当前每秒被渲染的帧数</c>


341
00:18:26,006 --> 00:18:27,541
<c.magenta>以及GPU利用率</c>


342
00:18:27,608 --> 00:18:30,143
<c.magenta>可以看到哪部分的GPU利用率最高</c>


343
00:18:30,611 --> 00:18:33,580
<c.magenta>以及CPU和GPU的帧时间</c>


344
00:18:34,147 --> 00:18:37,818
<c.magenta>可以帮助表明</c>
<c.magenta>是CPU绑定还是GPU绑定</c>


345
00:18:39,953 --> 00:18:41,922
<c.magenta>现在 除了实时数据</c>


346
00:18:41,989 --> 00:18:44,791
<c.magenta>Xcode 8还提供了时间线历史</c>


347
00:18:44,858 --> 00:18:47,261
<c.magenta>SpriteKit和</c>
<c.magenta>SceneKit帧时间</c>


348
00:18:47,327 --> 00:18:49,129
<c.magenta>为CPU和GPU两者</c>


349
00:18:49,563 --> 00:18:51,665
<c.magenta>在iOS和watchOS都可用</c>


350
00:18:52,165 --> 00:18:55,135
<c.magenta>这里很棒的一点是</c>
<c.magenta>我们分解了CPU的帧时间</c>


351
00:18:55,202 --> 00:18:56,904
<c.magenta>以及CPU的各个部分</c>


352
00:18:56,970 --> 00:18:58,572
<c.magenta>所以可很清楚地看到有多少时间</c>


353
00:18:58,639 --> 00:19:01,141
<c.magenta>用于渲染 或运行更新循环</c>


354
00:19:01,208 --> 00:19:04,611
<c.magenta>评估行动和物理</c>
<c.magenta>甚至多少时间是空闲的</c>


355
00:19:06,046 --> 00:19:07,548
<c.magenta>当应用暂停时</c>


356
00:19:07,614 --> 00:19:10,284
<c.magenta>可以滚动查看所有性能历史</c>


357
00:19:10,350 --> 00:19:12,953
<c.magenta>就可看到它随着应用的运行如何变化</c>


358
00:19:13,854 --> 00:19:16,123
<c.magenta>如果有某一个特别感兴趣的地方</c>


359
00:19:16,190 --> 00:19:19,293
<c.magenta>你可以深入检查更多的细节</c>


360
00:19:19,660 --> 00:19:21,495
<c.magenta>查看确切时间点</c>


361
00:19:23,864 --> 00:19:26,300
<c.magenta>来看一下如何在应用里应用</c>


362
00:19:43,116 --> 00:19:45,853
<c.magenta>我们找到了布局问题</c>


363
00:19:45,953 --> 00:19:48,989
<c.magenta>在“如何开始游戏”菜单</c>
<c.magenta>点进游戏本身</c>


364
00:19:51,058 --> 00:19:54,294
<c.magenta>这个游戏的目标是</c>
<c.magenta>把所有的损坏的机器人</c>


365
00:19:54,361 --> 00:19:56,463
<c.magenta>变成好的机器人</c>


366
00:19:57,064 --> 00:19:59,466
<c.magenta>要达成目标 我有一道光束 射向它们</c>


367
00:19:59,533 --> 00:20:01,768
<c.magenta>就可以把它们重置为好机器人</c>


368
00:20:02,202 --> 00:20:05,339
<c.magenta>我们看到这里有一个坏机器人在追我</c>


369
00:20:05,405 --> 00:20:07,374
<c.magenta>我用光束射向它</c>


370
00:20:11,578 --> 00:20:14,715
<c.magenta>可看到它变成好机器人了 显示为绿色</c>


371
00:20:15,415 --> 00:20:18,218
<c.magenta>但是我看到还有光束</c>


372
00:20:18,285 --> 00:20:20,654
<c.magenta>显示在机器人上面 不该有这样的情况</c>


373
00:20:21,388 --> 00:20:24,892
<c.magenta>既然我们用状态机来管理光束行为</c>


374
00:20:25,225 --> 00:20:26,627
<c.magenta>这是一个很好的对象</c>


375
00:20:26,693 --> 00:20:29,796
<c.magenta>来使用状态机快速查看这里是怎么回事</c>


376
00:20:31,365 --> 00:20:35,169
<c.magenta>我将会暂停应用</c>
<c.magenta>浏览BeamComponent</c>


377
00:20:36,203 --> 00:20:39,473
<c.magenta>我们用BeamComponent</c>
<c.magenta>来新建和更新</c>


378
00:20:39,540 --> 00:20:41,608
<c.magenta>管理光束行为的状态机</c>


379
00:20:41,975 --> 00:20:44,178
<c.magenta>在更新循环里添加一个断点</c>


380
00:20:44,244 --> 00:20:47,080
<c.magenta>继续游戏 马上进入断点</c>


381
00:20:48,081 --> 00:20:50,450
<c.magenta>因为应用已经暂停 可以进入调试区</c>


382
00:20:50,517 --> 00:20:52,553
<c.magenta>找到状态机的实例</c>


383
00:20:52,953 --> 00:20:54,087
<c.magenta>快速查看它</c>


384
00:20:55,088 --> 00:20:57,424
<c.magenta>在这里 我们看到整个状态机</c>


385
00:20:58,058 --> 00:21:01,895
<c.magenta>蓝色是当前所处状态</c>
<c.magenta>即BeamFiringState</c>


386
00:21:01,962 --> 00:21:04,264
<c.magenta>灰色是所有</c>


387
00:21:04,331 --> 00:21:05,866
<c.magenta>组成状态机的其余状态</c>


388
00:21:06,767 --> 00:21:09,403
<c.magenta>我们还可以看到每个状态之间的转换</c>


389
00:21:09,570 --> 00:21:12,773
<c.magenta>我立即注意到的是有很多转换条件</c>


390
00:21:12,840 --> 00:21:16,143
<c.magenta>指向BeamFiringState</c>
<c.magenta>但没有转换指出去</c>


391
00:21:16,810 --> 00:21:18,745
<c.magenta>也就是说 一旦进入到开火模式</c>


392
00:21:18,812 --> 00:21:20,080
<c.magenta>就没办法离开</c>


393
00:21:20,681 --> 00:21:22,716
<c.magenta>来检查</c>
<c.magenta>BeamFiringState</c>


394
00:21:22,783 --> 00:21:24,051
<c.magenta>看到底是怎么回事</c>


395
00:21:24,918 --> 00:21:27,754
<c.magenta>删除断点 关闭调试区</c>


396
00:21:27,821 --> 00:21:29,423
<c.magenta>切换到</c>
<c.magenta>BeamFiringState</c>


397
00:21:31,491 --> 00:21:33,126
<c.magenta>现在来看更新循环</c>


398
00:21:33,193 --> 00:21:36,096
<c.magenta>这里可以看到有一些转换逻辑</c>


399
00:21:36,163 --> 00:21:38,599
<c.magenta>既指向CoolingState</c>
<c.magenta>又指向IdleState</c>


400
00:21:39,466 --> 00:21:40,667
<c.magenta>但在下面的方法里</c>


401
00:21:40,734 --> 00:21:44,304
<c.magenta>检查我们要转换的状态是否有效</c>


402
00:21:44,371 --> 00:21:45,806
<c.magenta>总是返回假</c>


403
00:21:45,873 --> 00:21:47,908
<c.magenta>这是不正确的 因为我们想要转换到</c>


404
00:21:47,975 --> 00:21:49,176
<c.magenta>冷却状态或者空闲状态</c>


405
00:21:50,177 --> 00:21:51,712
<c.magenta>现在修复该问题</c>


406
00:21:51,778 --> 00:21:53,714
<c.magenta>通过检查想要转换到的状态</c>


407
00:21:53,780 --> 00:21:55,415
<c.magenta>是否是两个有效的状态之一</c>


408
00:21:55,816 --> 00:21:57,217
<c.magenta>回到游戏当中</c>


409
00:21:57,284 --> 00:21:59,553
<c.magenta>检查这是否是我们看到的问题</c>


410
00:22:00,754 --> 00:22:04,625
<c.magenta>当我们转换到FiringState</c>
<c.magenta>满足条件退出时</c>


411
00:22:04,691 --> 00:22:07,828
<c.magenta>我们应该可转换回IdleState</c>


412
00:22:09,830 --> 00:22:10,931
<c.magenta>进入游戏</c>


413
00:22:10,998 --> 00:22:14,301
<c.magenta>向坏机器人开火</c>


414
00:22:14,368 --> 00:22:15,736
<c.magenta>把它变为好机器人</c>


415
00:22:16,036 --> 00:22:20,073
<c.magenta>可以看到光束已经不在游戏者头上了</c>


416
00:22:20,140 --> 00:22:21,775
<c.magenta>看来问题已经解决了</c>


417
00:22:23,076 --> 00:22:25,679
<c.magenta>我们还发现了游戏存在性能问题</c>


418
00:22:26,013 --> 00:22:28,682
<c.magenta>底部有很多地面机器人</c>


419
00:22:28,749 --> 00:22:31,018
<c.magenta>我发现如果游戏者被机器人袭击</c>


420
00:22:31,084 --> 00:22:33,020
<c.magenta>性能会急剧下降</c>


421
00:22:33,987 --> 00:22:35,756
<c.magenta>我将切换到FPS性能测量</c>


422
00:22:35,822 --> 00:22:39,059
<c.magenta>这样就可以在运行时实时看到性能数据</c>


423
00:22:39,693 --> 00:22:42,963
<c.magenta>可以看到在这里 显示的是目标帧时间</c>


424
00:22:43,263 --> 00:22:45,966
<c.magenta>本例中 是16.6毫秒</c>


425
00:22:46,133 --> 00:22:49,303
<c.magenta>也就是保持每秒60帧的帧速率</c>


426
00:22:50,838 --> 00:22:53,674
<c.magenta>可以看到一部分时间被用在渲染的时间</c>


427
00:22:53,740 --> 00:22:55,442
<c.magenta>以及用在运行客户更新的时间</c>


428
00:22:55,776 --> 00:22:58,512
<c.magenta>还有CPU空闲时间的回旋余地</c>


429
00:22:59,947 --> 00:23:02,115
<c.magenta>回到游戏 移到右边</c>


430
00:23:02,182 --> 00:23:04,852
<c.magenta>有一个敌人机器人 我会让它袭击我</c>


431
00:23:04,918 --> 00:23:07,221
<c.magenta>试着重现性能问题</c>


432
00:23:08,088 --> 00:23:09,857
<c.magenta>现在切换回性能测量</c>


433
00:23:09,923 --> 00:23:11,725
<c.magenta>看看更新循环里是怎么回事</c>


434
00:23:12,326 --> 00:23:15,395
<c.magenta>我发现很长一段时间被用于评估操作上</c>


435
00:23:15,462 --> 00:23:18,131
<c.magenta>事实上 现在帧速率大幅下降</c>


436
00:23:18,899 --> 00:23:20,367
<c.magenta>暂停应用</c>


437
00:23:20,434 --> 00:23:22,703
<c.magenta>来看看其中的问题所在</c>


438
00:23:23,837 --> 00:23:26,306
<c.magenta>既然已经暂停 我可以及时滚动</c>


439
00:23:26,373 --> 00:23:27,808
<c.magenta>回到帧分解</c>


440
00:23:27,875 --> 00:23:30,244
<c.magenta>看看应用里之前的帧时间</c>


441
00:23:30,711 --> 00:23:33,313
<c.magenta>可以看到在主菜单</c>


442
00:23:33,380 --> 00:23:35,115
<c.magenta>只有小部分时间用于渲染</c>


443
00:23:35,182 --> 00:23:36,583
<c.magenta>大部分时间都在空闲</c>


444
00:23:36,950 --> 00:23:39,219
<c.magenta>游戏中的分解部分也是如此</c>


445
00:23:39,586 --> 00:23:41,655
<c.magenta>我们已经找出了性能问题</c>


446
00:23:41,722 --> 00:23:44,424
<c.magenta>可以点击 然后按住来查看细节</c>


447
00:23:44,491 --> 00:23:46,727
<c.magenta>对于我们发现的性能问题</c>


448
00:23:47,227 --> 00:23:51,665
<c.magenta>在这里 我看到帧时间是36.2毫秒</c>


449
00:23:51,732 --> 00:23:54,902
<c.magenta>71%都用于评估操作</c>


450
00:23:55,802 --> 00:23:59,039
<c.magenta>也就是说在游戏中</c>
<c.magenta>可能存在一个或两个问题</c>


451
00:23:59,473 --> 00:24:01,241
<c.magenta>我们可能在场景中有一个操作</c>


452
00:24:01,308 --> 00:24:04,444
<c.magenta>占用了非常长的时间来评估</c>


453
00:24:04,845 --> 00:24:08,215
<c.magenta>或者 可能会有很多操作</c>
<c.magenta>造成更新循环产生瓶颈</c>


454
00:24:08,916 --> 00:24:12,386
<c.magenta>现在已经知道更新循环里哪里有问题</c>


455
00:24:16,056 --> 00:24:18,225
<c.magenta>我们知道该如何利用状态机快速查看</c>


456
00:24:18,292 --> 00:24:20,627
<c.magenta>来调试游戏中碰到的问题</c>


457
00:24:20,994 --> 00:24:23,130
<c.magenta>以及FPS性能测量如何显示</c>


458
00:24:23,197 --> 00:24:25,866
<c.magenta>更新循环的具体哪里出了问题</c>


459
00:24:26,800 --> 00:24:28,602
<c.magenta>现邀请Daniel Delwood</c>


460
00:24:28,669 --> 00:24:30,838
<c.magenta>上台为大家讲解全新的内存图形调试器</c>


461
00:24:30,904 --> 00:24:32,439
<c.magenta>我们用来确定</c>


462
00:24:32,506 --> 00:24:35,642
<c.magenta>操作问题从哪里产生</c>
<c.magenta>然后可以对其进行修复</c>


463
00:24:43,350 --> 00:24:44,284
<c.magenta>谢谢你 Tyler</c>


464
00:24:44,985 --> 00:24:46,086
<c.magenta>我很激动能够为大家讲解</c>


465
00:24:46,153 --> 00:24:48,722
<c.magenta>Xcode 8里</c>
<c.magenta>全新的内存图形调试器</c>


466
00:24:48,789 --> 00:24:51,391
<c.magenta>我很喜欢视图调试器</c>


467
00:24:51,625 --> 00:24:53,961
<c.magenta>它是可以更好理解应用的工具</c>


468
00:24:54,127 --> 00:24:57,464
<c.magenta>如同视图调试器了解视图层次结构</c>


469
00:24:57,531 --> 00:25:00,367
<c.magenta>内存图形调试器可以帮助了解内存</c>


470
00:25:00,434 --> 00:25:02,069
<c.magenta>以及内存之间如何互相引用</c>


471
00:25:02,469 --> 00:25:06,073
<c.magenta>它想回答的一个核心问题是</c>


472
00:25:06,340 --> 00:25:09,076
<c.magenta>为什么某些对象还存在于堆里？</c>


473
00:25:10,010 --> 00:25:12,179
<c.magenta>对象互相引用</c>


474
00:25:12,246 --> 00:25:16,583
<c.magenta>你知道 现在引用</c>


475
00:25:16,650 --> 00:25:19,920
<c.magenta>和注释已经成为</c>
<c.magenta>自动引用指南世界的重要问题</c>


476
00:25:20,721 --> 00:25:24,791
<c.magenta>我们该如何解决存在</c>


477
00:25:24,858 --> 00:25:27,528
<c.magenta>不需要的对象 泄漏的对象</c>
<c.magenta>或遗弃的对象的问题</c>


478
00:25:28,195 --> 00:25:31,398
<c.magenta>有一些命令行工具 比如Heap</c>


479
00:25:32,065 --> 00:25:35,135
<c.magenta>Heap将快照你的进程</c>


480
00:25:35,202 --> 00:25:37,804
<c.magenta>遍历检查 找出不同类型的摘要</c>


481
00:25:37,871 --> 00:25:41,108
<c.magenta>以及进程中对象数量</c>


482
00:25:41,175 --> 00:25:45,579
<c.magenta>你甚至可以使用“地址”标记</c>
<c.magenta>来寻找特定类型的对象</c>


483
00:25:45,646 --> 00:25:47,748
<c.magenta>获取实例列表</c>


484
00:25:48,315 --> 00:25:50,684
<c.magenta>一旦对某个实例感兴趣</c>


485
00:25:51,185 --> 00:25:54,188
<c.magenta>可以用leaks中</c>
<c.magenta>寻找关于连接问题的信息</c>


486
00:25:54,254 --> 00:25:56,423
<c.magenta>是否未被引用？是否存在泄漏？</c>


487
00:25:56,790 --> 00:25:59,860
<c.magenta>是不是从全局位置有一条通路</c>


488
00:25:59,927 --> 00:26:03,830
<c.magenta>在应用中一直指向该对象？</c>


489
00:26:05,065 --> 00:26:08,802
<c.magenta>在任何此类调查时</c>
<c.magenta>你都可能需要进一步的细节</c>


490
00:26:08,869 --> 00:26:10,504
<c.magenta>比如栈分配追踪</c>


491
00:26:10,804 --> 00:26:12,372
<c.magenta>可以用</c>
<c.magenta>malloc_history获得</c>


492
00:26:12,906 --> 00:26:15,442
<c.magenta>而这些都不是可视化体验</c>


493
00:26:15,509 --> 00:26:18,579
<c.magenta>这就是我们为何要把这三个工具集成到</c>


494
00:26:18,645 --> 00:26:20,280
<c.magenta>内存图形调试器的IDE</c>


495
00:26:20,681 --> 00:26:24,218
<c.magenta>快速浏览一下它的构成</c>


496
00:26:24,484 --> 00:26:27,921
<c.magenta>左边 浏览器中显示堆类型信息</c>


497
00:26:27,988 --> 00:26:29,256
<c.magenta>用来开始分析</c>


498
00:26:29,957 --> 00:26:31,792
<c.magenta>中间的编辑器</c>


499
00:26:31,859 --> 00:26:33,894
<c.magenta>显示连接问题</c>


500
00:26:34,328 --> 00:26:37,564
<c.magenta>右边 我们用来显示</c>


501
00:26:37,631 --> 00:26:40,501
<c.magenta>通过检查器显示栈分配追踪</c>


502
00:26:40,868 --> 00:26:43,403
<c.magenta>讲完以上 回到演示例子</c>


503
00:26:44,104 --> 00:26:46,507
<c.magenta>从Tyler讲到的地方开始</c>
<c.magenta>看看我们是否</c>


504
00:26:46,573 --> 00:26:48,575
<c.magenta>能看到他所看到的操作问题</c>


505
00:26:48,842 --> 00:26:49,710
<c.magenta>好</c>


506
00:26:50,010 --> 00:26:54,748
<c.magenta>现在我们在FPS性能测量</c>


507
00:26:54,815 --> 00:26:59,520
<c.magenta>看到那些应用里可能出错的动作</c>


508
00:26:59,953 --> 00:27:01,655
<c.magenta>我们可以直接查看</c>


509
00:27:01,722 --> 00:27:04,858
<c.magenta>通过选择内存图形调试器按钮</c>


510
00:27:05,058 --> 00:27:07,561
<c.magenta>在调试菜单栏</c>


511
00:27:08,061 --> 00:27:10,030
<c.magenta>左边这里</c>


512
00:27:10,564 --> 00:27:15,569
<c.magenta>浏览器显示了我的应用中所有不同类型</c>


513
00:27:15,636 --> 00:27:17,004
<c.magenta>分配在应用中的</c>


514
00:27:17,237 --> 00:27:21,775
<c.magenta>它们按照模式被分解 然后按照类型</c>


515
00:27:21,842 --> 00:27:24,178
<c.magenta>每一个对象 都有一个实例</c>


516
00:27:25,212 --> 00:27:29,983
<c.magenta>在本例中 我对搜索堆感兴趣</c>


517
00:27:30,184 --> 00:27:31,251
<c.magenta>这很容易做到</c>


518
00:27:31,318 --> 00:27:34,655
<c.magenta>在过滤器里打字 搜索“操作”</c>


519
00:27:36,290 --> 00:27:38,725
<c.magenta>出现了</c>
<c.magenta>在SpriteKit里出现所有类型</c>


520
00:27:38,792 --> 00:27:42,829
<c.magenta>我们看到有很多操作——559个</c>


521
00:27:43,197 --> 00:27:45,532
<c.magenta>应该是操作太多了的问题</c>


522
00:27:45,599 --> 00:27:49,036
<c.magenta>而不是只有一个一直在运行的操作</c>


523
00:27:50,637 --> 00:27:52,406
<c.magenta>选择其中一个对象</c>


524
00:27:53,040 --> 00:27:57,444
<c.magenta>编辑器显示问题的答案</c>


525
00:27:57,511 --> 00:27:59,613
<c.magenta>即为什么这个对象还存在</c>


526
00:28:00,013 --> 00:28:02,149
<c.magenta>在这里 它显示了根操作图形</c>


527
00:28:02,216 --> 00:28:06,653
<c.magenta>可以追踪选中的对象</c>


528
00:28:06,720 --> 00:28:09,523
<c.magenta>回到左边 回到应用根目录</c>


529
00:28:09,890 --> 00:28:14,061
<c.magenta>可以看到它被一个SKC序列反复引用</c>


530
00:28:14,127 --> 00:28:15,696
<c.magenta>还带有一个数组</c>


531
00:28:15,796 --> 00:28:18,232
<c.magenta>我还可以发现更多问题</c>


532
00:28:18,932 --> 00:28:22,236
<c.magenta>这里有带一些操作的SKNode</c>


533
00:28:22,302 --> 00:28:25,172
<c.magenta>这是该SKNode的部分操作列表</c>


534
00:28:25,439 --> 00:28:28,642
<c.magenta>可以点击 然后快速查看</c>


535
00:28:29,209 --> 00:28:34,147
<c.magenta>如果想查看关于该操作更多的信息</c>


536
00:28:34,214 --> 00:28:37,117
<c.magenta>我可以选中它 拉出检查器</c>


537
00:28:38,719 --> 00:28:40,888
<c.magenta>检查器将显示一些内存细节</c>


538
00:28:40,954 --> 00:28:44,625
<c.magenta>比如类名 地址 层次结构</c>


539
00:28:44,691 --> 00:28:47,628
<c.magenta>如果是其它对象的子类</c>


540
00:28:48,228 --> 00:28:50,631
<c.magenta>我想知道该操作是在哪里新建的</c>


541
00:28:50,697 --> 00:28:51,798
<c.magenta>这样就可以找到该位置</c>


542
00:28:52,599 --> 00:28:57,905
<c.magenta>折叠该栈追踪 进入代码</c>


543
00:28:58,872 --> 00:29:02,109
<c.magenta>这里有一个函数</c>
<c.magenta>refreshHurtAction</c>


544
00:29:03,010 --> 00:29:06,180
<c.magenta>一个HurtAction在运行</c>


545
00:29:06,246 --> 00:29:11,552
<c.magenta>可以用快速帮助看到该操作已经添加到</c>


546
00:29:11,618 --> 00:29:14,087
<c.magenta>结点的操作列表当中</c>


547
00:29:15,556 --> 00:29:18,492
<c.magenta>但实际上我只想有一个单机操作</c>


548
00:29:18,559 --> 00:29:21,195
<c.magenta>并确保它取代之前的操作</c>


549
00:29:21,261 --> 00:29:22,529
<c.magenta>所以修复很简单</c>


550
00:29:22,596 --> 00:29:25,465
<c.magenta>我将使用withKey变量</c>


551
00:29:25,532 --> 00:29:28,035
<c.magenta>取代“playerAction”</c>


552
00:29:31,772 --> 00:29:35,042
<c.magenta>快速帮助将会显示</c>
<c.magenta>是的 这就是我想要的</c>


553
00:29:35,108 --> 00:29:37,177
<c.magenta>如果一个操作在使用正运行的统一键值</c>


554
00:29:37,244 --> 00:29:38,946
<c.magenta>它将会在该操作加进来之前被移除</c>


555
00:29:39,012 --> 00:29:40,013
<c.magenta>很好</c>


556
00:29:40,881 --> 00:29:46,420
<c.magenta>这是一种非常简单的方法</c>
<c.magenta>对某个特定类型进行调查</c>


557
00:29:46,753 --> 00:29:47,888
<c.magenta>但是我还注意到另外一点</c>


558
00:29:47,955 --> 00:29:50,791
<c.magenta>当我点击内存图像调试按钮时</c>


559
00:29:50,858 --> 00:29:55,062
<c.magenta>运行时问题浏览器提醒我有一些问题</c>


560
00:29:55,295 --> 00:29:56,363
<c.magenta>点击该提醒</c>


561
00:29:56,430 --> 00:30:00,367
<c.magenta>来到新的运行时问题浏览器</c>


562
00:30:00,868 --> 00:30:04,171
<c.magenta>显示在应用里有很多泄漏</c>


563
00:30:05,372 --> 00:30:09,276
<c.magenta>我先从模式里定义的一个类型开始</c>


564
00:30:09,343 --> 00:30:11,378
<c.magenta>比如这个LoadSceneOperation</c>


565
00:30:12,546 --> 00:30:16,116
<c.magenta>选中它 图形没有显示同样的风格</c>


566
00:30:16,183 --> 00:30:18,719
<c.magenta>它显示了一个引用周期</c>


567
00:30:19,219 --> 00:30:21,889
<c.magenta>它是一个泄漏的对象</c>


568
00:30:21,955 --> 00:30:24,892
<c.magenta>从应用里的位置无法访问它</c>


569
00:30:25,392 --> 00:30:28,061
<c.magenta>需要找出哪些</c>


570
00:30:28,128 --> 00:30:30,898
<c.magenta>泄漏的对象正在彼此引用</c>


571
00:30:31,765 --> 00:30:33,100
<c.magenta>快速来看这一点</c>


572
00:30:33,433 --> 00:30:36,803
<c.magenta>有一个带有内部状态的操作</c>


573
00:30:37,070 --> 00:30:39,106
<c.magenta>它在引用一个完成块</c>


574
00:30:39,606 --> 00:30:43,944
<c.magenta>作为该块的一部分 有一些捕捉</c>


575
00:30:44,011 --> 00:30:46,213
<c.magenta>正在强力引用LoadSceneOperation</c>


576
00:30:46,613 --> 00:30:47,481
<c.magenta>有意思</c>


577
00:30:48,315 --> 00:30:51,418
<c.magenta>如果点击该模块 我可以看到回溯轨迹</c>


578
00:30:51,485 --> 00:30:52,686
<c.magenta>马上去那里</c>


579
00:30:54,855 --> 00:30:56,323
<c.magenta>在这里</c>


580
00:30:56,623 --> 00:30:58,458
<c.magenta>我的LoadSceneOperation的完成块</c>


581
00:30:58,525 --> 00:31:01,461
<c.magenta>我甚至有一个“unowned self”捕捉列表</c>


582
00:31:02,029 --> 00:31:04,631
<c.magenta>但是图形显示该self没有问题</c>


583
00:31:04,698 --> 00:31:07,467
<c.magenta>问题是LoadSceneOperation</c>
<c.magenta>正在捕捉自己</c>


584
00:31:08,268 --> 00:31:09,770
<c.magenta>就在该模块中</c>


585
00:31:11,471 --> 00:31:13,407
<c.magenta>此处修复也非常简单</c>


586
00:31:13,674 --> 00:31:17,477
<c.magenta>只需要捕捉unowned</c>


587
00:31:18,245 --> 00:31:21,181
<c.magenta>就可以继续了 但是</c>


588
00:31:23,917 --> 00:31:26,653
<c.magenta>可惜的是 这不是真正的解决方案</c>


589
00:31:26,987 --> 00:31:31,091
<c.magenta>因为是整个模块 我的</c>
<c.magenta>LoadSceneOperation已要结束了</c>


590
00:31:31,558 --> 00:31:33,760
<c.magenta>如果它执行了该模块</c>


591
00:31:34,194 --> 00:31:36,830
<c.magenta>LoadSceneOperation将会结束其生命周期</c>


592
00:31:36,897 --> 00:31:38,599
<c.magenta>不会存在很长时间</c>


593
00:31:38,966 --> 00:31:41,401
<c.magenta>也就是说</c>
<c.magenta>如果用dispatch_async回到主队列</c>


594
00:31:42,536 --> 00:31:44,972
<c.magenta>该LoadSceneOperation</c>
<c.magenta>可能已经不可用</c>


595
00:31:45,038 --> 00:31:46,240
<c.magenta>系统将会崩溃</c>


596
00:31:46,807 --> 00:31:50,944
<c.magenta>只是想告诉大家</c>
<c.magenta>有时这些捕捉会有点复杂</c>


597
00:31:51,245 --> 00:31:54,214
<c.magenta>需要一点调查</c>


598
00:31:54,581 --> 00:31:56,450
<c.magenta>希望内存图形调试器</c>


599
00:31:56,517 --> 00:31:58,986
<c.magenta>也能够帮助你检查问题</c>


600
00:32:06,326 --> 00:32:10,397
<c.magenta>现在我们再来讲讲泄漏和废弃内存</c>


601
00:32:10,964 --> 00:32:14,535
<c.magenta>内存图形调试器是一个调试模式</c>


602
00:32:14,601 --> 00:32:17,471
<c.magenta>它会暂停 开始对目标应用进行检查</c>


603
00:32:17,738 --> 00:32:20,607
<c.magenta>这样应用就不会继续运行并改变状态</c>


604
00:32:20,674 --> 00:32:22,843
<c.magenta>可以有一个恒定的视图</c>


605
00:32:22,910 --> 00:32:25,879
<c.magenta>也可以让你做一些诸如快速查看的操作</c>
<c.magenta>或者PO不同的对象</c>


606
00:32:25,946 --> 00:32:27,681
<c.magenta>在你进行调查时</c>


607
00:32:27,748 --> 00:32:30,184
<c.magenta>而且在所有平台上都可用</c>


608
00:32:31,018 --> 00:32:33,987
<c.magenta>如我所演示的</c>
<c.magenta>共有两种不同的图形风格</c>


609
00:32:34,054 --> 00:32:37,491
<c.magenta>第一种是 根路径图形风格</c>


610
00:32:37,558 --> 00:32:39,426
<c.magenta>它将显示引用过的内存</c>


611
00:32:39,493 --> 00:32:40,594
<c.magenta>也许你废弃了它</c>


612
00:32:41,028 --> 00:32:45,299
<c.magenta>应用中不同的根 比如全局变量</c>


613
00:32:45,365 --> 00:32:47,968
<c.magenta>和正在运行的线程</c>
<c.magenta>是如何引用该内存的</c>


614
00:32:48,502 --> 00:32:50,103
<c.magenta>利用渐进展开模式</c>


615
00:32:50,170 --> 00:32:54,708
<c.magenta>它让你从对象开始回溯不同的中间对象</c>


616
00:32:54,775 --> 00:32:57,411
<c.magenta>找到那些不应该存在的引用</c>


617
00:32:58,679 --> 00:33:02,716
<c.magenta>对未引用或泄露的内存来说</c>
<c.magenta>第二种风格是周期视图</c>


618
00:33:02,783 --> 00:33:08,989
<c.magenta>其目标是帮助显示正强引用自身的对象</c>


619
00:33:09,056 --> 00:33:11,992
<c.magenta>会再一次找出引用问题</c>


620
00:33:14,127 --> 00:33:18,465
<c.magenta>在查看器里看到的栈记录集成</c>


621
00:33:20,467 --> 00:33:24,438
<c.magenta>它无法自由记录所有的分配和释放</c>


622
00:33:24,505 --> 00:33:27,007
<c.magenta>这是一种需要选择加入的诊断</c>


623
00:33:28,709 --> 00:33:31,879
<c.magenta>进入方案编辑器 选中“分配栈记录”</c>


624
00:33:31,945 --> 00:33:34,448
<c.magenta>在“诊断”标签</c>


625
00:33:34,815 --> 00:33:38,252
<c.magenta>它将记录所有的磁盘分配和释放</c>


626
00:33:38,318 --> 00:33:39,653
<c.magenta>方便之后的查询</c>


627
00:33:40,521 --> 00:33:42,189
<c.magenta>但是对于内存图形调试</c>


628
00:33:42,256 --> 00:33:44,591
<c.magenta>你不真正需要所有的分配和释放</c>


629
00:33:44,658 --> 00:33:49,329
<c.magenta>之前的分配模块通常也没什么用</c>


630
00:33:49,796 --> 00:33:56,236
<c.magenta>所以在最新的OS中有一个新特性</c>
<c.magenta>“实时只分配模式”</c>


631
00:33:56,303 --> 00:33:59,206
<c.magenta>这样做开销较低</c>


632
00:33:59,673 --> 00:34:02,910
<c.magenta>它还让你获得这些有用的信息</c>


633
00:34:02,976 --> 00:34:04,378
<c.magenta>在进行内存图形调试时</c>


634
00:34:04,645 --> 00:34:09,183
<c.magenta>它将把“分配栈记录”</c>
<c.magenta>标识为“lite”</c>


635
00:34:09,248 --> 00:34:10,884
<c.magenta>在目标环境下</c>


636
00:34:13,320 --> 00:34:18,492
<c.magenta>关于内存图形调试</c>
<c.magenta>你们还可能喜欢的一点</c>


637
00:34:18,559 --> 00:34:21,295
<c.magenta>我们引入.memgraph文件类型</c>


638
00:34:21,762 --> 00:34:23,830
<c.magenta>当在调试某个问题时</c>


639
00:34:23,897 --> 00:34:26,867
<c.magenta>你并没有时间去好好研究</c>


640
00:34:27,234 --> 00:34:28,768
<c.magenta>你想把它存下来</c>


641
00:34:28,835 --> 00:34:31,438
<c.magenta>或者让团队里的其他工程师也来看看</c>


642
00:34:32,105 --> 00:34:35,141
<c.magenta>在Xcode里</c>
<c.magenta>你可以点击“文件”菜单</c>


643
00:34:35,208 --> 00:34:37,277
<c.magenta>选择“导出内存图形”</c>


644
00:34:37,710 --> 00:34:39,246
<c.magenta>这将保存所有</c>


645
00:34:39,313 --> 00:34:41,815
<c.magenta>连接信息和堆信息</c>


646
00:34:41,882 --> 00:34:45,452
<c.magenta>以及一些VM数据 到一个文件</c>


647
00:34:45,853 --> 00:34:47,920
<c.magenta>之后某个时间 你可以双击它</c>


648
00:34:47,987 --> 00:34:52,259
<c.magenta>加载到Xcode 看一看内存图形</c>


649
00:34:52,960 --> 00:34:55,094
<c.magenta>但是用这种方法 调试器里没有进程</c>


650
00:34:55,161 --> 00:34:58,999
<c.magenta>所以你无法回溯 也无法快速查看对象</c>
<c.magenta>无法PO对象</c>


651
00:34:59,333 --> 00:35:03,504
<c.magenta>但这仍然是出错后分析应用的</c>
<c.magenta>一项非常强大技术</c>


652
00:35:04,638 --> 00:35:08,642
<c.magenta>如果你想持续集成</c>


653
00:35:09,576 --> 00:35:11,645
<c.magenta>在命令行中有一些选项</c>


654
00:35:12,279 --> 00:35:16,316
<c.magenta>只要运行leaks-outputGraph</c>
<c.magenta>选择一个路径</c>


655
00:35:16,383 --> 00:35:18,819
<c.magenta>保存到一个.memgraph文件</c>
<c.magenta>以便之后使用</c>


656
00:35:20,020 --> 00:35:24,391
<c.magenta>leaks vmmap heap</c>
<c.magenta>都可以读这个文件</c>


657
00:35:31,398 --> 00:35:33,133
<c.magenta>好了 到了有趣的部分</c>


658
00:35:33,200 --> 00:35:34,801
<c.magenta>我们来讲讲有用的小技巧</c>


659
00:35:34,868 --> 00:35:37,704
<c.magenta>这一切都建立在泄漏结构上</c>


660
00:35:38,338 --> 00:35:40,507
<c.magenta>说明图形是保守的</c>


661
00:35:41,108 --> 00:35:46,213
<c.magenta>我们非常非常小心</c>
<c.magenta>避免在对象没有泄漏时报告其泄漏</c>


662
00:35:46,280 --> 00:35:50,350
<c.magenta>避免误报</c>


663
00:35:50,918 --> 00:35:53,387
<c.magenta>在图形里可能会看到多余的引用</c>


664
00:35:54,354 --> 00:35:59,026
<c.magenta>这些引用将被显示为灰色 表示未知</c>


665
00:35:59,092 --> 00:36:01,061
<c.magenta>可能是有效引用 可能不是</c>


666
00:36:01,361 --> 00:36:04,364
<c.magenta>可能不止提供元数据给工具</c>


667
00:36:04,731 --> 00:36:10,170
<c.magenta>当你查看这些图形时 要多多注意</c>


668
00:36:10,671 --> 00:36:13,173
<c.magenta>提高准确度的一个方法是</c>


669
00:36:13,240 --> 00:36:14,441
<c.magenta>就是开启“内存涂鸦”</c>


670
00:36:14,508 --> 00:36:16,944
<c.magenta>该方案下的另一个诊断工具</c>


671
00:36:17,311 --> 00:36:20,347
<c.magenta>它的作用是当分配自由</c>


672
00:36:20,714 --> 00:36:23,851
<c.magenta>它将把内存写入 你就不用了</c>


673
00:36:23,917 --> 00:36:27,721
<c.magenta>未初始化的内存写入新的模块</c>


674
00:36:29,590 --> 00:36:31,325
<c.magenta>对于那些已知的强引用来说</c>


675
00:36:31,391 --> 00:36:33,427
<c.magenta>在图形里会粗体显示</c>


676
00:36:33,493 --> 00:36:39,233
<c.magenta>Swift 3实际上有</c>
<c.magenta>很多可用反射元数据</c>


677
00:36:39,600 --> 00:36:43,804
<c.magenta>我推荐大家使用</c>


678
00:36:44,571 --> 00:36:46,940
<c.magenta>因为它绝对更为准确</c>


679
00:36:47,007 --> 00:36:49,476
<c.magenta>在理解捕捉和引用方面</c>


680
00:36:50,511 --> 00:36:53,113
<c.magenta>最后 我应该关掉内存图形调试器</c>


681
00:36:53,180 --> 00:36:55,716
<c.magenta>暂时关闭所有检查工具</c>


682
00:36:55,782 --> 00:36:58,785
<c.magenta>比如地址检查工具</c>
<c.magenta>或"Thread Sanitizer线程检查工具"</c>


683
00:37:00,087 --> 00:37:01,588
<c.magenta>有很多的信息</c>


684
00:37:02,222 --> 00:37:04,591
<c.magenta>这是不是一个开始编写应用的好地方？</c>


685
00:37:05,092 --> 00:37:07,294
<c.magenta>验证你的期待吧</c>


686
00:37:07,794 --> 00:37:10,564
<c.magenta>还有别的某种类型的对象要期待吗？</c>


687
00:37:11,164 --> 00:37:13,934
<c.magenta>对象是不是在你想要时被释放？</c>


688
00:37:14,601 --> 00:37:17,938
<c.magenta>你的类型还有没有泄漏？</c>


689
00:37:18,672 --> 00:37:21,375
<c.magenta>如果你对某一个对象很感兴趣</c>


690
00:37:21,909 --> 00:37:24,378
<c.magenta>目标就是找到一条不应该</c>


691
00:37:24,444 --> 00:37:25,646
<c.magenta>连到对象上的路径</c>


692
00:37:26,079 --> 00:37:29,950
<c.magenta>还有两种常见模式</c>


693
00:37:30,017 --> 00:37:32,619
<c.magenta>来自块和闭包的强捕捉</c>


694
00:37:33,287 --> 00:37:39,026
<c.magenta>或图形中潜在的向上引用</c>


695
00:37:39,359 --> 00:37:41,361
<c.magenta>这些需要被标示为</c>
<c.magenta>“weak”或“unowned”</c>


696
00:37:42,629 --> 00:37:45,532
<c.magenta>讲了很多信息</c>


697
00:37:46,066 --> 00:37:50,704
<c.magenta>我非常感谢你们的倾听</c>


698
00:37:50,771 --> 00:37:54,641
<c.magenta>Xcode 8中</c>
<c.magenta>全新改进的可视化工具</c>


699
00:37:54,842 --> 00:37:56,176
<c.magenta>我们对此非常激动</c>


700
00:37:56,243 --> 00:38:00,047
<c.magenta>如更好的可视化调试 用视图调试器</c>


701
00:38:00,314 --> 00:38:03,750
<c.magenta>用FPS测量以及内存图形调试器</c>


702
00:38:03,984 --> 00:38:08,455
<c.magenta>今天就在应用中放手一试</c>
<c.magenta>多多解决问题吧</c>

