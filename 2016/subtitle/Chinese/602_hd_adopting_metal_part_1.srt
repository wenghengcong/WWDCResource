1
00:00:20,153 --> 00:00:23,023
<c.magenta>采用METAL 第一部分</c>


2
00:00:26,393 --> 00:00:29,296
<c.magenta>下午好 欢迎来到</c>
<c.magenta>“采用Metal 第一部分”</c>


3
00:00:29,696 --> 00:00:32,165
<c.magenta>我是GPU软件团队的</c>
<c.magenta>Warren Moore</c>


4
00:00:32,499 --> 00:00:36,203
<c.magenta>我和同事Matt Collins</c>
<c.magenta>一起 他主要负责做展示</c>


5
00:00:36,904 --> 00:00:38,338
<c.magenta>我想问一个</c>


6
00:00:38,405 --> 00:00:41,542
<c.magenta>看似简单的问题 什么是Metal</c>


7
00:00:42,209 --> 00:00:45,345
<c.magenta>你可能已听说过Metal是</c>
<c.magenta>Apple的偏底层的API</c>


8
00:00:45,412 --> 00:00:48,882
<c.magenta>面向GPU的</c>
<c.magenta>它是一个统一的图形计算语言</c>


9
00:00:49,216 --> 00:00:51,652
<c.magenta>并且面向多线程做了优化</c>


10
00:00:51,952 --> 00:00:53,720
<c.magenta>专门为我们的平台所设计</c>


11
00:00:53,954 --> 00:00:55,255
<c.magenta>这些都是正确的</c>


12
00:00:55,589 --> 00:00:58,825
<c.magenta>但是Metal不仅有</c>
<c.magenta>Metal.framework</c>


13
00:00:59,193 --> 00:01:04,864
<c.magenta>Metal同时也被</c>
<c.magenta>其他的框架和工具支持</c>


14
00:01:05,699 --> 00:01:08,869
<c.magenta>它们提供了比metal框架</c>
<c.magenta>API多很多的东西</c>


15
00:01:09,269 --> 00:01:11,939
<c.magenta>尤其是去年我们引入MetalKit</c>


16
00:01:12,339 --> 00:01:14,775
<c.magenta>它包括了用来一些处理常见任务的工具</c>


17
00:01:14,842 --> 00:01:18,478
<c.magenta>像与UIKit和AppKit交互</c>
<c.magenta>加载纹理</c>


18
00:01:20,113 --> 00:01:21,748
<c.magenta>还有Metal性能着色器</c>


19
00:01:21,949 --> 00:01:25,419
<c.magenta>能帮你做图片处理</c>


20
00:01:25,485 --> 00:01:28,789
<c.magenta>可以手动调优 高度优化的着色器</c>


21
00:01:29,189 --> 00:01:32,159
<c.magenta>可以直接放到你的应用里</c>
<c.magenta>来处理这些任务</c>


22
00:01:33,227 --> 00:01:36,263
<c.magenta>Metal同时还紧密</c>
<c.magenta>与我们的开发工具结合</c>


23
00:01:36,496 --> 00:01:37,998
<c.magenta>像Xcode与</c>
<c.magenta>Instruments</c>


24
00:01:40,167 --> 00:01:41,902
<c.magenta>当你的应用里面有着色器</c>


25
00:01:42,336 --> 00:01:44,471
<c.magenta>它们会同你的应用一起编译</c>


26
00:01:44,571 --> 00:01:48,809
<c.magenta>通过Xcode集成到你的应用包里</c>


27
00:01:49,376 --> 00:01:52,279
<c.magenta>还有GPU框架调试器</c>
<c.magenta>可以做一个快照</c>


28
00:01:52,579 --> 00:01:55,916
<c.magenta>在程序运行的任何一个点</c>
<c.magenta>来看看程序现在是什么情况</c>


29
00:01:56,717 --> 00:01:59,086
<c.magenta>Instruments中</c>
<c.magenta>Metal系统跟踪</c>


30
00:01:59,553 --> 00:02:01,955
<c.magenta>可以让你在运行是查看应用的性能</c>


31
00:02:02,022 --> 00:02:03,857
<c.magenta>和行为</c>


32
00:02:05,359 --> 00:02:07,794
<c.magenta>两年前我们把Metal引入了iOS</c>


33
00:02:08,027 --> 00:02:13,100
<c.magenta>然后我们又把它带到了</c>
<c.magenta>Mac OS和tvOS</c>


34
00:02:13,800 --> 00:02:16,436
<c.magenta>所以现在在我们平台上</c>
<c.magenta>受到了广泛的支持</c>


35
00:02:17,004 --> 00:02:19,540
<c.magenta>同时我们的大部分硬件也支持它</c>


36
00:02:19,907 --> 00:02:24,044
<c.magenta>包括桌面架构和移动架构</c>


37
00:02:24,111 --> 00:02:27,114
<c.magenta>像Apple AMD Intel</c>
<c.magenta>和NVIDIA</c>


38
00:02:27,447 --> 00:02:30,884
<c.magenta>所有的2012年后的Mac</c>


39
00:02:31,185 --> 00:02:34,655
<c.magenta>2013年以后的所有iOS设备</c>
<c.magenta>还有新的Apple TV</c>


40
00:02:35,389 --> 00:02:38,725
<c.magenta>Metal可以让应用程序充分利用</c>
<c.magenta>GPU的性能</c>


41
00:02:38,792 --> 00:02:42,162
<c.magenta>在我们的海量的产品上</c>


42
00:02:44,898 --> 00:02:47,701
<c.magenta>在这些平台上Metal属于基础技术</c>


43
00:02:48,235 --> 00:02:52,406
<c.magenta>它支持核心图像 核心动画</c>


44
00:02:52,773 --> 00:02:56,710
<c.magenta>游戏和图形库比如SpriteKit</c>
<c.magenta>SceneKit和Model I/O</c>


45
00:02:57,211 --> 00:02:58,912
<c.magenta>也是我们关键系统软件的重要部分</c>


46
00:02:58,979 --> 00:03:02,716
<c.magenta>像Preview和Safari</c>


47
00:03:04,384 --> 00:03:06,587
<c.magenta>各种各样开发者们</c>
<c.magenta>已广泛使用了Metal</c>


48
00:03:06,653 --> 00:03:10,591
<c.magenta>从AAA工作室 游戏引擎提供商</c>


49
00:03:11,024 --> 00:03:14,294
<c.magenta>到独立开发者和专业工具开发者</c>


50
00:03:14,428 --> 00:03:17,831
<c.magenta>他们开发了非常好的应用和游戏</c>


51
00:03:18,398 --> 00:03:21,502
<c.magenta>这只是一部分</c>
<c.magenta>我想着重说几个</c>


52
00:03:22,469 --> 00:03:26,073
<c.magenta>比如 Fancy Guo用</c>
<c.magenta>Metal显著的提升了性能</c>


53
00:03:26,273 --> 00:03:27,741
<c.magenta>带来了惊人的视觉效果</c>


54
00:03:27,808 --> 00:03:31,512
<c.magenta>在他们广受欢迎的MORPG游戏</c>
<c.magenta>Furious Wings</c>


55
00:03:33,180 --> 00:03:36,817
<c.magenta>Metal也被用在</c>
<c.magenta>专业的内容创造工具</c>


56
00:03:36,884 --> 00:03:39,419
<c.magenta>像iPad上即将发布的</c>
<c.magenta>Affinity Photos</c>


57
00:03:40,487 --> 00:03:44,691
<c.magenta>我带大家快速预览下都有什么</c>


58
00:03:46,026 --> 00:03:48,595
<c.magenta>这个是Serif Labs的</c>
<c.magenta>Affinity Photos</c>


59
00:03:49,196 --> 00:03:51,198
<c.magenta>这是个全功能的图片编辑应用</c>


60
00:03:51,265 --> 00:03:54,501
<c.magenta>在iPad pro上</c>
<c.magenta>Metal可让其获得令人惊叹的效果</c>


61
00:03:57,938 --> 00:04:00,874
<c.magenta>今年的 WWDC</c>
<c.magenta>我们会给你一些工具</c>


62
00:04:01,241 --> 00:04:02,743
<c.magenta>让你们开始使用Metal</c>


63
00:04:02,809 --> 00:04:05,812
<c.magenta>来制作体验非常棒的应用</c>


64
00:04:06,780 --> 00:04:10,551
<c.magenta>今年的 WWDC 有很多很棒的内容</c>


65
00:04:10,751 --> 00:04:12,619
<c.magenta>有五场讲座专门介绍Metal</c>


66
00:04:13,253 --> 00:04:16,390
<c.magenta>当然这是第一场会话</c>
<c.magenta>采用Metal 第一部分</c>


67
00:04:16,990 --> 00:04:19,159
<c.magenta>在这节中我们会讨论</c>


68
00:04:19,226 --> 00:04:23,263
<c.magenta>Metal里的一些基本概念</c>


69
00:04:23,864 --> 00:04:26,600
<c.magenta>接着会介绍2D绘图添加光照</c>


70
00:04:26,667 --> 00:04:29,903
<c.magenta>纹理和动画 我们还会介绍3D</c>


71
00:04:30,637 --> 00:04:34,074
<c.magenta>这节课的第二部分</c>
<c.magenta>也是在这个教室 紧接着这节课</c>


72
00:04:34,474 --> 00:04:36,176
<c.magenta>我们会介绍动态数据管理</c>


73
00:04:36,243 --> 00:04:38,445
<c.magenta>接着会介绍一些高级的</c>


74
00:04:38,545 --> 00:04:40,414
<c.magenta>关于GPU和CPU的同步</c>


75
00:04:40,614 --> 00:04:43,016
<c.magenta>会让你性能达到新高度</c>


76
00:04:43,116 --> 00:04:44,885
<c.magenta>通过使用多线程编码</c>


77
00:04:47,421 --> 00:04:49,723
<c.magenta>我们会介绍下</c>
<c.magenta>Metal里有什么新东西</c>


78
00:04:49,790 --> 00:04:52,893
<c.magenta>确实有很多新特性</c>


79
00:04:52,960 --> 00:04:56,063
<c.magenta>在昨天的统一介绍中</c>
<c.magenta>相信你们也看到了一些</c>


80
00:04:57,831 --> 00:04:59,266
<c.magenta>我不会详细介绍全部的东西</c>


81
00:04:59,333 --> 00:05:01,768
<c.magenta>如果你想在你的应用中使用</c>


82
00:05:01,835 --> 00:05:03,837
<c.magenta>你应该看一下那个最新课程</c>


83
00:05:05,572 --> 00:05:08,709
<c.magenta>最后 我们会有个很棒的</c>
<c.magenta>高级着色器优化的课程</c>


84
00:05:09,176 --> 00:05:12,312
<c.magenta>对于那些想要</c>


85
00:05:12,379 --> 00:05:14,781
<c.magenta>更好的使用着色器的人来说</c>
<c.magenta>这些绝对是干货</c>


86
00:05:14,848 --> 00:05:17,284
<c.magenta>我们会详细的讨论硬件如何工作</c>


87
00:05:17,351 --> 00:05:20,587
<c.magenta>你该怎样使用Metal来更好的</c>
<c.magenta>发挥它的性能</c>


88
00:05:21,622 --> 00:05:23,056
<c.magenta>还有调优你的着色器代码</c>


89
00:05:24,157 --> 00:05:26,827
<c.magenta>在这些课程中 我们会创建样例工程</c>


90
00:05:26,894 --> 00:05:30,030
<c.magenta>由简单的</c>
<c.magenta>Hello Triangle开始</c>


91
00:05:30,097 --> 00:05:31,798
<c.magenta>图形编程领域的</c>
<c.magenta>Hello world</c>


92
00:05:32,232 --> 00:05:35,402
<c.magenta>然后 我们会研究动画和纹理贴图</c>


93
00:05:35,702 --> 00:05:38,305
<c.magenta>第二部分 我们会进入到下一层级</c>


94
00:05:38,906 --> 00:05:41,341
<c.magenta>讨论下实时更新对象数据</c>


95
00:05:41,675 --> 00:05:44,578
<c.magenta>同时还有 通过多线程</c>
<c.magenta>来优化绘制调用</c>


96
00:05:45,913 --> 00:05:48,515
<c.magenta>现在我们假设</c>


97
00:05:49,283 --> 00:05:50,651
<c.magenta>你们已经熟悉</c>


98
00:05:50,717 --> 00:05:53,086
<c.magenta>基本的图形编程 最好是</c>


99
00:05:54,288 --> 00:05:58,525
<c.magenta>知道可编程管线</c>
<c.magenta>熟悉着色器等</c>


100
00:05:58,592 --> 00:06:01,895
<c.magenta>同时你想知道怎么能用Metal来</c>


101
00:06:01,962 --> 00:06:03,964
<c.magenta>让你的程序和游戏变得更棒</c>


102
00:06:04,164 --> 00:06:07,000
<c.magenta>我假设大家都是这样</c>


103
00:06:07,067 --> 00:06:08,468
<c.magenta>这也是你们为啥在此 对吧</c>


104
00:06:09,970 --> 00:06:11,705
<c.magenta>我先过一遍议题</c>


105
00:06:12,039 --> 00:06:14,241
<c.magenta>我们会先大体介绍下</c>


106
00:06:14,308 --> 00:06:16,476
<c.magenta>Metal的理念</c>


107
00:06:16,543 --> 00:06:18,312
<c.magenta>和为何Metal会是现在的样子</c>


108
00:06:18,378 --> 00:06:20,147
<c.magenta>接着我们会详细的</c>


109
00:06:20,214 --> 00:06:22,049
<c.magenta>介绍创建一个Metal实例</c>


110
00:06:22,482 --> 00:06:24,218
<c.magenta>接下来会介绍加载数据</c>


111
00:06:24,551 --> 00:06:26,687
<c.magenta>到内存来供GPU使用</c>


112
00:06:26,753 --> 00:06:29,389
<c.magenta>我们会简要介绍下Metal着色语言</c>


113
00:06:29,456 --> 00:06:32,326
<c.magenta>我们会介绍创建预验证管线状态</c>


114
00:06:33,026 --> 00:06:36,096
<c.magenta>和GPU调用 包括绘制调用</c>


115
00:06:36,830 --> 00:06:39,132
<c.magenta>我们会用一个讨论结束</c>


116
00:06:39,199 --> 00:06:42,970
<c.magenta>如何在Metal中处理</c>
<c.magenta>动画和纹理贴图</c>


117
00:06:43,737 --> 00:06:45,672
<c.magenta>第二部分我们会介绍的更深一些</c>


118
00:06:45,739 --> 00:06:47,508
<c.magenta>刚才我已经提到了</c>


119
00:06:47,574 --> 00:06:49,009
<c.magenta>现在我们开始</c>


120
00:06:49,543 --> 00:06:51,345
<c.magenta>从理念概览开始</c>


121
00:06:51,411 --> 00:06:53,981
<c.magenta>只有几点需要强调</c>


122
00:06:55,415 --> 00:06:57,851
<c.magenta>使用和硬件驱动相匹配的API</c>


123
00:06:58,652 --> 00:07:00,654
<c.magenta>尽量明确一些</c>


124
00:07:01,021 --> 00:07:03,790
<c.magenta>尽量不做耗时操作</c>


125
00:07:04,658 --> 00:07:07,160
<c.magenta>先说说使用和硬件驱动相匹配的API</c>


126
00:07:08,295 --> 00:07:10,230
<c.magenta>Metal是一个完全现代化的API</c>


127
00:07:10,430 --> 00:07:13,967
<c.magenta>也可以说它使用了最新的硬件特性</c>


128
00:07:15,269 --> 00:07:18,338
<c.magenta>和硬件的工作流程息息相关</c>


129
00:07:18,805 --> 00:07:22,476
<c.magenta>作为一个全新的API</c>
<c.magenta>它非常轻量级</c>


130
00:07:22,543 --> 00:07:25,679
<c.magenta>并且没有历史包袱</c>


131
00:07:26,446 --> 00:07:29,616
<c.magenta>对的开销的操作没有花哨的技巧</c>


132
00:07:29,816 --> 00:07:33,120
<c.magenta>它和Metal契合</c>


133
00:07:33,187 --> 00:07:34,755
<c.magenta>并且都是在最基础的层级操作</c>


134
00:07:34,821 --> 00:07:37,191
<c.magenta>幸运的是 它是统一的</c>


135
00:07:37,591 --> 00:07:39,226
<c.magenta>在我们的所有平台上</c>


136
00:07:41,328 --> 00:07:42,930
<c.magenta>当我们说我们更倾向明确的操作</c>


137
00:07:42,996 --> 00:07:45,866
<c.magenta>意思是我们想让你</c>


138
00:07:45,933 --> 00:07:49,770
<c.magenta>负责操作GPU</c>


139
00:07:49,837 --> 00:07:51,805
<c.magenta>而不是让其默认的操作</c>


140
00:07:52,105 --> 00:07:54,508
<c.magenta>同时还包括数据的管理和同步</c>


141
00:07:55,342 --> 00:07:57,578
<c.magenta>这让你有更多的责任</c>


142
00:07:57,644 --> 00:08:00,480
<c.magenta>同时能有更好的性能</c>


143
00:08:02,082 --> 00:08:04,284
<c.magenta>再来解释下</c>


144
00:08:04,351 --> 00:08:06,453
<c.magenta>不要经常做耗费大的工作</c>


145
00:08:07,754 --> 00:08:12,626
<c.magenta>有三个地方</c>


146
00:08:12,759 --> 00:08:14,194
<c.magenta>程序创建时</c>


147
00:08:14,695 --> 00:08:16,496
<c.magenta>程序加载时</c>


148
00:08:16,630 --> 00:08:18,165
<c.magenta>加载资源的时候</c>


149
00:08:18,465 --> 00:08:21,869
<c.magenta>然后就是绘制时 每秒会调用60次</c>


150
00:08:23,537 --> 00:08:25,672
<c.magenta>如果是历史API 如OpenGL</c>


151
00:08:25,973 --> 00:08:27,074
<c.magenta>你大部分时间会花在</c>


152
00:08:27,140 --> 00:08:29,810
<c.magenta>状态检查上</c>
<c.magenta>每次调用绘制的时候</c>


153
00:08:30,143 --> 00:08:33,246
<c.magenta>最坏的时候你需要在运行时重新编译</c>


154
00:08:33,746 --> 00:08:36,683
<c.magenta>这些都会给GPU的必要工作上</c>


155
00:08:37,484 --> 00:08:40,254
<c.magenta>添加负担 在调用绘制函数的时候</c>


156
00:08:41,688 --> 00:08:44,525
<c.magenta>在Metal中我们把这些工作提前</c>


157
00:08:44,958 --> 00:08:46,693
<c.magenta>像我开始说的</c>


158
00:08:47,094 --> 00:08:48,896
<c.magenta>着色器的编译可以在</c>


159
00:08:48,962 --> 00:08:50,931
<c.magenta>程序编译的时候同时进行</c>


160
00:08:52,366 --> 00:08:54,701
<c.magenta>同时 我们也允许你验证状态</c>


161
00:08:54,768 --> 00:08:57,538
<c.magenta>在调用绘制的时候提前验证</c>


162
00:08:57,838 --> 00:09:01,208
<c.magenta>这样就不用在每次</c>
<c.magenta>调用绘制的时候验证了</c>


163
00:09:01,642 --> 00:09:04,545
<c.magenta>这样你需要做的唯一工作</c>


164
00:09:04,611 --> 00:09:07,581
<c.magenta>就是只有绘制调用了</c>


165
00:09:10,083 --> 00:09:11,485
<c.magenta>通过这些理念介绍</c>


166
00:09:11,552 --> 00:09:13,487
<c.magenta>我们看看实际情况中的</c>


167
00:09:13,554 --> 00:09:14,888
<c.magenta>Metal设备</c>


168
00:09:16,123 --> 00:09:17,724
<c.magenta>这里有个类MTL设备</c>


169
00:09:18,425 --> 00:09:21,061
<c.magenta>它表示抽象的GPU</c>


170
00:09:21,528 --> 00:09:24,865
<c.magenta>它是你Metal应用中的最基本对象</c>


171
00:09:25,265 --> 00:09:27,301
<c.magenta>你将会用它来创建</c>


172
00:09:27,367 --> 00:09:30,904
<c.magenta>像指令队列 资源和管线状态对象</c>


173
00:09:30,971 --> 00:09:33,006
<c.magenta>和其他你需要用的对象</c>


174
00:09:35,709 --> 00:09:37,845
<c.magenta>创建Metal设备很简单</c>


175
00:09:37,911 --> 00:09:41,114
<c.magenta>只需调用</c>
<c.magenta>MTLCreateSystemDefaultDevice</c>


176
00:09:41,715 --> 00:09:43,951
<c.magenta>现在设备代表对象</c>


177
00:09:44,017 --> 00:09:46,553
<c.magenta>你需要在程序开始时创建一个</c>


178
00:09:46,720 --> 00:09:50,557
<c.magenta>并保持引用</c>
<c.magenta>因为会在整个程序的生命周期使用</c>


179
00:09:51,391 --> 00:09:52,759
<c.magenta>就这么简单</c>


180
00:09:53,927 --> 00:09:56,129
<c.magenta>现在说说怎么把数据</c>


181
00:09:56,430 --> 00:09:58,265
<c.magenta>放到GPU可以读取的位置</c>


182
00:09:58,565 --> 00:10:00,267
<c.magenta>然后你可以触发绘制调用</c>


183
00:10:00,968 --> 00:10:04,037
<c.magenta>在Metal中</c>
<c.magenta>我们把数据存到缓冲中</c>


184
00:10:04,338 --> 00:10:07,808
<c.magenta>缓冲就是一块内存用来存数据</c>


185
00:10:07,875 --> 00:10:09,309
<c.magenta>你可以用任何格式</c>


186
00:10:10,043 --> 00:10:14,348
<c.magenta>可能是顶点数据 索引数据 常量</c>


187
00:10:15,449 --> 00:10:17,084
<c.magenta>你把数据写到缓存中</c>


188
00:10:17,150 --> 00:10:18,752
<c.magenta>随后在</c>


189
00:10:19,052 --> 00:10:20,988
<c.magenta>顶点和片段函数中访问</c>


190
00:10:22,222 --> 00:10:23,957
<c.magenta>我们看看大体是个什么样子</c>


191
00:10:24,024 --> 00:10:26,059
<c.magenta>这里有个包含几个缓存的例子</c>


192
00:10:26,360 --> 00:10:28,795
<c.magenta>你加载数据的时候可能会创建</c>


193
00:10:28,862 --> 00:10:31,565
<c.magenta>我们有个vertexBuffer</c>
<c.magenta>包含一些顶点数据</c>


194
00:10:31,665 --> 00:10:34,434
<c.magenta>一个indexBuffer</c>
<c.magenta>包含一些连续的索引</c>


195
00:10:35,702 --> 00:10:37,171
<c.magenta>更具体写来说</c>


196
00:10:37,671 --> 00:10:42,042
<c.magenta>每个顶点类型的实例</c>
<c.magenta>可能是一个Swift结构</c>


197
00:10:42,376 --> 00:10:44,845
<c.magenta>用向量表示顶点的位置</c>


198
00:10:45,579 --> 00:10:47,548
<c.magenta>同样还有点的颜色</c>


199
00:10:47,848 --> 00:10:50,050
<c.magenta>你可以让它们在内存你连续保存</c>


200
00:10:51,285 --> 00:10:53,387
<c.magenta>说下如何创建缓存</c>


201
00:10:55,088 --> 00:10:58,292
<c.magenta>这个API在你已经创建的设备里</c>


202
00:10:58,692 --> 00:11:00,894
<c.magenta>简单调用newBufferWithLength</c>


203
00:11:00,961 --> 00:11:02,729
<c.magenta>来获得一个指定大小的缓存</c>


204
00:11:02,996 --> 00:11:04,998
<c.magenta>里面默认没有数据</c>


205
00:11:05,432 --> 00:11:07,734
<c.magenta>或调用newBufferWithBytes</c>


206
00:11:07,801 --> 00:11:10,237
<c.magenta>传一个已经在内存中有数据的指针</c>


207
00:11:10,637 --> 00:11:12,339
<c.magenta>Metal会把数据拷贝</c>


208
00:11:12,573 --> 00:11:14,308
<c.magenta>到新创建的缓存</c>


209
00:11:14,441 --> 00:11:16,109
<c.magenta>你可以马上使用</c>


210
00:11:17,244 --> 00:11:20,781
<c.magenta>你也可以用memcpy</c>
<c.magenta>把内容指针拷贝到缓存里</c>


211
00:11:23,717 --> 00:11:26,587
<c.magenta>既然我们要展示一个2D的三角</c>


212
00:11:26,720 --> 00:11:27,988
<c.magenta>作为我们第一部分的展示</c>


213
00:11:28,589 --> 00:11:31,825
<c.magenta>我们先说下三角的几何坐标</c>


214
00:11:33,126 --> 00:11:35,162
<c.magenta>既然我们想让顶点着色器</c>


215
00:11:35,229 --> 00:11:37,164
<c.magenta>和片段着色器尽可能的简单</c>


216
00:11:37,731 --> 00:11:40,901
<c.magenta>我们在裁减的空间里提供坐标</c>


217
00:11:41,668 --> 00:11:44,705
<c.magenta>Metal的裁剪空间很有趣</c>


218
00:11:44,771 --> 00:11:47,674
<c.magenta>它和其他类似的API有些不同</c>


219
00:11:47,741 --> 00:11:49,343
<c.magenta>有点像DirectX裁剪空间</c>


220
00:11:49,776 --> 00:11:53,013
<c.magenta>X从负1到1 Y轴从负1到1</c>


221
00:11:53,080 --> 00:11:55,883
<c.magenta>Z轴从0到1</c>


222
00:11:56,617 --> 00:11:59,753
<c.magenta>这个是我们要用的坐标空间</c>


223
00:11:59,953 --> 00:12:01,855
<c.magenta>代码中是这样的</c>


224
00:12:02,723 --> 00:12:04,992
<c.magenta>我们创建了个Swift的顶点数组</c>


225
00:12:05,292 --> 00:12:07,127
<c.magenta>我们依次添加顶点</c>


226
00:12:07,194 --> 00:12:09,196
<c.magenta>同时包括位置和颜色值</c>


227
00:12:12,766 --> 00:12:15,302
<c.magenta>现在 我们不用严格的使用索引绘制</c>


228
00:12:15,402 --> 00:12:18,438
<c.magenta>在这个简单的用例中</c>


229
00:12:18,672 --> 00:12:22,609
<c.magenta>接着创建一个indexBuffer</c>
<c.magenta>并向其中添加0 1 2</c>


230
00:12:22,876 --> 00:12:24,978
<c.magenta>代表三角形的第一个 第二个</c>


231
00:12:25,045 --> 00:12:27,047
<c.magenta>和第三个点</c>


232
00:12:27,114 --> 00:12:29,449
<c.magenta>然后用我们的设备创建接个缓存</c>


233
00:12:29,550 --> 00:12:32,019
<c.magenta>我们会用newBuffer(withBytes</c>
<c.magenta>创建vertexBuffer</c>


234
00:12:32,085 --> 00:12:34,721
<c.magenta>把顶点数据加载到Metal缓存中</c>


235
00:12:35,122 --> 00:12:37,024
<c.magenta>我们再调用一次newBuffer(withBytes</c>


236
00:12:37,090 --> 00:12:40,360
<c.magenta>把索引数据穿进去</c>
<c.magenta>得到indexBuffer</c>


237
00:12:42,229 --> 00:12:44,398
<c.magenta>现在我们有了数据和内存</c>


238
00:12:44,531 --> 00:12:47,634
<c.magenta>下面说说统一着色语言</c>


239
00:12:48,202 --> 00:12:51,972
<c.magenta>Metal的着色语言是</c>
<c.magenta>C++ 14的扩展子集</c>


240
00:12:52,339 --> 00:12:54,908
<c.magenta>他是图形和计算的统一语言</c>


241
00:12:55,275 --> 00:12:56,810
<c.magenta>代表你还可以做很多事</c>


242
00:12:56,877 --> 00:12:58,645
<c.magenta>不仅是3D图形</c>


243
00:12:58,979 --> 00:13:01,481
<c.magenta>它可以让你写程序给GPU</c>


244
00:13:02,816 --> 00:13:06,153
<c.magenta>这里有个管线各个阶段的图表</c>


245
00:13:06,253 --> 00:13:08,689
<c.magenta>现在我们是在顶点</c>


246
00:13:08,755 --> 00:13:10,524
<c.magenta>和片段处理阶段</c>


247
00:13:10,591 --> 00:13:13,393
<c.magenta>每个阶段都有相应的函数要写</c>


248
00:13:13,627 --> 00:13:16,930
<c.magenta>要么是处理顶点要么是片段</c>


249
00:13:16,997 --> 00:13:18,632
<c.magenta>将会刷到屏幕上</c>


250
00:13:19,266 --> 00:13:21,335
<c.magenta>语法上 它看起来像这样</c>


251
00:13:21,902 --> 00:13:25,672
<c.magenta>我们不会详细介绍</c>


252
00:13:25,739 --> 00:13:30,244
<c.magenta>希望你们注意这些函数修饰符：</c>
<c.magenta>顶点和片段</c>


253
00:13:30,544 --> 00:13:33,280
<c.magenta>你会注意到右面函数的前面</c>


254
00:13:33,347 --> 00:13:36,083
<c.magenta>不像普通的C++程序</c>


255
00:13:36,183 --> 00:13:38,418
<c.magenta>我们相用这些修饰符来表示</c>


256
00:13:38,552 --> 00:13:40,854
<c.magenta>这些函数和哪个阶段相关</c>


257
00:13:41,321 --> 00:13:42,856
<c.magenta>我们有一个顶点函数在上面</c>


258
00:13:42,923 --> 00:13:44,591
<c.magenta>和一个片段函数在下面</c>


259
00:13:46,026 --> 00:13:48,795
<c.magenta>我将简单展示怎么实际把这些</c>


260
00:13:49,429 --> 00:13:51,865
<c.magenta>和你的管线结合在绘制的时候</c>


261
00:13:52,266 --> 00:13:55,035
<c.magenta>我们还会看看这些函数的内部实现</c>


262
00:13:55,269 --> 00:13:58,105
<c.magenta>在以后的2D和3D展示中</c>


263
00:13:59,006 --> 00:14:01,074
<c.magenta>我提过好几次Metal可以</c>


264
00:14:01,141 --> 00:14:03,644
<c.magenta>直接把着色器编译到程序包里</c>


265
00:14:03,710 --> 00:14:07,915
<c.magenta>方法是即使你有一个.Metal文件</c>


266
00:14:08,282 --> 00:14:11,318
<c.magenta>在你的工程中的编译源码层</c>


267
00:14:11,385 --> 00:14:13,720
<c.magenta>Metal会自动生成</c>


268
00:14:13,787 --> 00:14:16,390
<c.magenta>一个Metal库文件</c>
<c.magenta>default.Metallib</c>


269
00:14:16,657 --> 00:14:17,958
<c.magenta>同时会拷贝到你的包中</c>


270
00:14:18,158 --> 00:14:19,860
<c.magenta>在你的程序编译的时候</c>


271
00:14:19,927 --> 00:14:21,562
<c.magenta>除此之外不会再编译</c>


272
00:14:22,763 --> 00:14:24,831
<c.magenta>所以它会在你程序包中</c>


273
00:14:25,732 --> 00:14:27,301
<c.magenta>这是</c>
<c.magenta>default.Metallib</c>


274
00:14:28,502 --> 00:14:29,436
<c.magenta>简单说</c>


275
00:14:31,438 --> 00:14:33,273
<c.magenta>你可在运行时编译Metal着色器</c>


276
00:14:33,540 --> 00:14:36,176
<c.magenta>如果你程序里有一个.Metal文件</c>


277
00:14:36,243 --> 00:14:37,845
<c.magenta>它会被Xcode用</c>
<c.magenta>Metal工具链编译</c>


278
00:14:38,111 --> 00:14:41,248
<c.magenta>生成一个default.Metallib</c>
<c.magenta>打到你的应用包中</c>


279
00:14:42,115 --> 00:14:44,051
<c.magenta>这里很自然会有个问题</c>


280
00:14:44,117 --> 00:14:47,955
<c.magenta>运行时怎么使用这些函数</c>


281
00:14:48,021 --> 00:14:49,389
<c.magenta>答案是你会用一个叫做</c>


282
00:14:49,456 --> 00:14:51,058
<c.magenta>Metal Library的类</c>


283
00:14:51,124 --> 00:14:52,693
<c.magenta>Metal Library</c>
<c.magenta>是一个集合</c>


284
00:14:52,759 --> 00:14:55,596
<c.magenta>编译器编译的函数对象</c>


285
00:14:55,996 --> 00:14:57,598
<c.magenta>有几种方法创建</c>


286
00:14:57,664 --> 00:14:59,466
<c.magenta>你可以通过我们讨论的流程</c>


287
00:14:59,800 --> 00:15:02,503
<c.magenta>创建一个</c>
<c.magenta>default.Metallib</c>


288
00:15:02,569 --> 00:15:04,872
<c.magenta>到你的应用包</c>
<c.magenta>然后在运行时加载</c>


289
00:15:04,938 --> 00:15:09,576
<c.magenta>你还可以用我们的命令行工具链</c>
<c.magenta>编译一个.metallibs</c>


290
00:15:10,344 --> 00:15:13,347
<c.magenta>运行时你还可以用代码串创建一个目录</c>


291
00:15:13,413 --> 00:15:16,750
<c.magenta>例如 通过字符串来编译一个渲染器</c>


292
00:15:18,085 --> 00:15:19,853
<c.magenta>在代码里看起来像这样</c>


293
00:15:20,020 --> 00:15:22,022
<c.magenta>为了加载</c>
<c.magenta>default.Metallib</c>


294
00:15:22,089 --> 00:15:24,491
<c.magenta>调用</c>
<c.magenta>newDefaultLibrary</c>


295
00:15:24,992 --> 00:15:26,627
<c.magenta>用你已经创建的Metal设备</c>


296
00:15:27,361 --> 00:15:30,297
<c.magenta>还有其他的API加载 例如</c>


297
00:15:30,364 --> 00:15:32,799
<c.magenta>从编译好的.Metallib</c>
<c.magenta>或者从源代码</c>


298
00:15:32,866 --> 00:15:35,002
<c.magenta>你可以详细查看文档</c>
<c.magenta>来了解这些API</c>


299
00:15:37,671 --> 00:15:40,107
<c.magenta>现你已有Metal Library</c>


300
00:15:40,207 --> 00:15:42,876
<c.magenta>能从中得到什么</c>
<c.magenta>可以得到Metal函数</c>


301
00:15:42,943 --> 00:15:46,380
<c.magenta>现在Metal函数是一个简单对象</c>
<c.magenta>代表一个函数</c>


302
00:15:46,880 --> 00:15:49,183
<c.magenta>它和一个特定的管线阶段关联</c>


303
00:15:49,249 --> 00:15:50,884
<c.magenta>记得我们刚才看过的图么</c>


304
00:15:50,951 --> 00:15:52,519
<c.magenta>顶点或片段阶段</c>


305
00:15:52,853 --> 00:15:55,856
<c.magenta>我们还有一个额外的</c>
<c.magenta>描述符叫“kernel”</c>


306
00:15:55,923 --> 00:15:58,825
<c.magenta>表示并行处理数据的函数</c>


307
00:16:01,795 --> 00:16:04,498
<c.magenta>这里有段代码 你可以看到</c>


308
00:16:04,565 --> 00:16:07,768
<c.magenta>函数名是</c>
<c.magenta>vertex transform</c>


309
00:16:08,001 --> 00:16:11,405
<c.magenta>fragmentFunction名是fragment lighting</c>


310
00:16:11,738 --> 00:16:14,641
<c.magenta>我重改下以便我能给你展示API</c>


311
00:16:14,708 --> 00:16:16,743
<c.magenta>如何在你的库中加载函数</c>


312
00:16:16,810 --> 00:16:17,945
<c.magenta>像这样</c>


313
00:16:18,011 --> 00:16:19,780
<c.magenta>我们先调用</c>
<c.magenta>NewFunctionWithName</c>


314
00:16:19,847 --> 00:16:22,249
<c.magenta>传一个代表函数名的字符串</c>


315
00:16:22,616 --> 00:16:26,520
<c.magenta>获得一个Metal函数 引用它</c>


316
00:16:27,588 --> 00:16:30,457
<c.magenta>稍后将展示实际中如何使用这些对象</c>


317
00:16:30,724 --> 00:16:33,794
<c.magenta>但也只是简要介绍Metal着色语言</c>


318
00:16:34,695 --> 00:16:38,232
<c.magenta>让我们介绍下创建预验证的管线状态</c>


319
00:16:40,701 --> 00:16:42,769
<c.magenta>但首先 我们先预热下</c>


320
00:16:42,970 --> 00:16:45,439
<c.magenta>像OpenGL中的API</c>


321
00:16:45,706 --> 00:16:48,008
<c.magenta>你经常需要设置许多状态</c>


322
00:16:48,375 --> 00:16:50,043
<c.magenta>然后触发绘制调用</c>


323
00:16:50,110 --> 00:16:53,280
<c.magenta>在这之间驱动负责验证</c>


324
00:16:53,347 --> 00:16:56,250
<c.magenta>你设置的状态是有效的</c>


325
00:16:56,650 --> 00:16:59,052
<c.magenta>然后 最坏的情况</c>


326
00:16:59,219 --> 00:17:01,255
<c.magenta>你还得付出运行时</c>
<c.magenta>重新编译着色器的代价</c>


327
00:17:01,922 --> 00:17:03,724
<c.magenta>我们想要避免这些</c>


328
00:17:04,590 --> 00:17:07,261
<c.magenta>在Metal中 它看起来像这样</c>


329
00:17:08,228 --> 00:17:10,564
<c.magenta>你设置一个预验证的管线状态对象</c>


330
00:17:10,631 --> 00:17:12,933
<c.magenta>可能还有其他少数辅助状态</c>


331
00:17:12,999 --> 00:17:14,468
<c.magenta>然后触发绘制调用</c>


332
00:17:14,867 --> 00:17:17,604
<c.magenta>我们这里想要减少绘制调用的负担</c>


333
00:17:17,671 --> 00:17:20,374
<c.magenta>把更多工作提前进行</c>


334
00:17:21,375 --> 00:17:27,146
<c.magenta>这里有几个你可以在管线状态对象中</c>
<c.magenta>设置的样例状态</c>


335
00:17:27,214 --> 00:17:30,384
<c.magenta>这些状态绘制时你可以在任何时间设置</c>


336
00:17:30,617 --> 00:17:32,085
<c.magenta>你看到左面这栏</c>


337
00:17:32,152 --> 00:17:33,987
<c.magenta>你可能设置的管线状态</c>


338
00:17:34,054 --> 00:17:37,157
<c.magenta>有顶点和片段函数用来绘制的</c>


339
00:17:37,391 --> 00:17:40,127
<c.magenta>还有透明渲染状态</c>


340
00:17:42,162 --> 00:17:44,364
<c.magenta>右面 我们看到的状态是</c>


341
00:17:44,431 --> 00:17:46,700
<c.magenta>你可以在触发绘制函数前设置</c>


342
00:17:46,767 --> 00:17:49,603
<c.magenta>包括front face winding</c>
<c.magenta>和cull mode</c>


343
00:17:50,971 --> 00:17:53,173
<c.magenta>来讲一下如何创建对象</c>


344
00:17:53,240 --> 00:17:55,242
<c.magenta>包括这些预验证的状态</c>


345
00:17:56,276 --> 00:17:59,179
<c.magenta>主要对象是</c>
<c.magenta>Metal RenderPipelineState</c>


346
00:17:59,880 --> 00:18:02,983
<c.magenta>它代表一类GPU的管线配置</c>


347
00:18:03,217 --> 00:18:06,820
<c.magenta>它包括你会在加载时创建的</c>
<c.magenta>一个预验证集合</c>


348
00:18:08,055 --> 00:18:09,423
<c.magenta>像设备</c>


349
00:18:09,489 --> 00:18:11,992
<c.magenta>RenderPipelineStates</c>
<c.magenta>是持久对象</c>


350
00:18:12,059 --> 00:18:16,063
<c.magenta>你想让它在你的整个程序</c>
<c.magenta>生命周期都存在</c>


351
00:18:16,597 --> 00:18:18,365
<c.magenta>如果你有很多不同的函数</c>


352
00:18:18,432 --> 00:18:20,033
<c.magenta>你可以异步创建管线状态对象</c>


353
00:18:20,100 --> 00:18:22,269
<c.magenta>在程序运行的时候</c>


354
00:18:23,270 --> 00:18:25,372
<c.magenta>实际上在创建</c>
<c.magenta>RenderPipelineState时</c>


355
00:18:25,439 --> 00:18:26,673
<c.magenta>我们不会直接创建</c>


356
00:18:26,740 --> 00:18:29,443
<c.magenta>反而 我们会用一个叫做</c>
<c.magenta>Descriptor的对象</c>


357
00:18:30,577 --> 00:18:34,014
<c.magenta>它打包了所有参数用来创建</c>
<c.magenta>RenderPipelineState</c>


358
00:18:34,515 --> 00:18:37,551
<c.magenta>通常在Metal中</c>
<c.magenta>我们创建Descriptor对象</c>


359
00:18:37,618 --> 00:18:40,354
<c.magenta>它会把所有不同的参数弄在一起</c>


360
00:18:40,420 --> 00:18:42,623
<c.magenta>我们在创建其他对象时也会使用</c>


361
00:18:42,689 --> 00:18:45,158
<c.magenta>对于RenderPipelineState对象</c>


362
00:18:45,225 --> 00:18:47,227
<c.magenta>它被叫做渲染管线描述符</c>


363
00:18:47,294 --> 00:18:50,230
<c.magenta>你会发现它包含指向顶点函数</c>


364
00:18:50,297 --> 00:18:52,232
<c.magenta>和片段函数的指针</c>
<c.magenta>我早先曾介绍过</c>


365
00:18:52,299 --> 00:18:55,202
<c.magenta>它还包含一个附件集合</c>


366
00:18:55,569 --> 00:18:59,506
<c.magenta>附件是一些纹理我们会在</c>


367
00:18:59,573 --> 00:19:01,341
<c.magenta>实际渲染中用到</c>


368
00:19:01,708 --> 00:19:04,344
<c.magenta>现在在Metal中</c>
<c.magenta>所有的渲染都会被渲染到纹理中</c>


369
00:19:04,678 --> 00:19:08,081
<c.magenta>但我们不需要提前指向</c>
<c.magenta>那些纹理的指针</c>


370
00:19:08,348 --> 00:19:11,552
<c.magenta>我们只需要提供你要渲染的像素格式</c>


371
00:19:11,618 --> 00:19:15,255
<c.magenta>这样我们对它们的管线状态优化</c>


372
00:19:15,689 --> 00:19:18,258
<c.magenta>若你使用了深度</c>
<c.magenta>或者Stencil Buffer</c>


373
00:19:18,325 --> 00:19:21,361
<c.magenta>你也可以指定它们的像素格式</c>


374
00:19:22,229 --> 00:19:24,831
<c.magenta>你一旦创建了一个管线描述符</c>


375
00:19:25,199 --> 00:19:27,201
<c.magenta>你可以传递给你的Metal设备</c>


376
00:19:27,267 --> 00:19:29,937
<c.magenta>然后得到一个</c>
<c.magenta>MTLRenderPipelineState对象</c>


377
00:19:30,504 --> 00:19:32,039
<c.magenta>让我们在代码中看一下</c>


378
00:19:32,673 --> 00:19:35,375
<c.magenta>这是一个RenderPipelineState</c>
<c.magenta>的最小化配置</c>


379
00:19:35,442 --> 00:19:37,611
<c.magenta>你会发现我们设置了顶点函数</c>


380
00:19:37,678 --> 00:19:39,780
<c.magenta>和片段函数属性给</c>


381
00:19:39,847 --> 00:19:43,116
<c.magenta>我们先前从我们库中创建的</c>
<c.magenta>顶点和片段对象</c>


382
00:19:44,284 --> 00:19:46,453
<c.magenta>同时我们也创建了</c>


383
00:19:46,520 --> 00:19:49,857
<c.magenta>主要颜色附件的像素格式</c>
<c.magenta>为.bgra8Unorm</c>


384
00:19:49,923 --> 00:19:53,560
<c.magenta>它是一个可显示和渲染的像素格式</c>


385
00:19:55,429 --> 00:19:57,331
<c.magenta>这代表我们最终要</c>


386
00:19:57,397 --> 00:19:59,666
<c.magenta>在绘制的时候绘制的纹理</c>


387
00:20:00,367 --> 00:20:03,270
<c.magenta>最后 一旦我们创建了管线描述符</c>


388
00:20:03,737 --> 00:20:06,540
<c.magenta>我们可以用设备新的</c>
<c.magenta>RenderPipelineState函数</c>


389
00:20:06,607 --> 00:20:10,077
<c.magenta>来获得实际的预验证对象</c>


390
00:20:11,945 --> 00:20:14,715
<c.magenta>我还行强调下PipelineStates</c>
<c.magenta>是持久的对象</c>


391
00:20:14,781 --> 00:20:16,450
<c.magenta>你应该在加载时创建</c>


392
00:20:16,517 --> 00:20:19,086
<c.magenta>在使用设备和资源的时候需要保持</c>


393
00:20:19,186 --> 00:20:20,921
<c.magenta>你可以在绘制时在它们之间切换</c>


394
00:20:20,988 --> 00:20:22,489
<c.magenta>来达到不同的效果</c>


395
00:20:22,789 --> 00:20:26,693
<c.magenta>通常会有一对顶点和片段函数</c>


396
00:20:28,862 --> 00:20:31,765
<c.magenta>现在我们已经讨论了</c>
<c.magenta>如何创建预验证的状态</c>


397
00:20:32,132 --> 00:20:34,535
<c.magenta>和如何加载资源到内存中</c>


398
00:20:34,601 --> 00:20:37,905
<c.magenta>接下来我们说下触发GPU指令</c>
<c.magenta>包括绘制调用</c>


399
00:20:39,640 --> 00:20:41,341
<c.magenta>我们通过几个阶段介绍</c>


400
00:20:41,408 --> 00:20:43,877
<c.magenta>我们还会讨论和</c>
<c.magenta>UIKit AppKit交互</c>


401
00:20:44,378 --> 00:20:47,314
<c.magenta>稍微讨论下Metal指令提交模型</c>


402
00:20:47,414 --> 00:20:49,950
<c.magenta>然后到渲染和绘制调用 最终</c>


403
00:20:50,017 --> 00:20:52,052
<c.magenta>如何展现你的内容到屏幕上</c>


404
00:20:53,153 --> 00:20:55,322
<c.magenta>就与UIKit和AppKit</c>
<c.magenta>交互而言</c>


405
00:20:55,389 --> 00:20:59,092
<c.magenta>我们用MetalKit里的</c>
<c.magenta>一个工具MTKView</c>


406
00:20:59,660 --> 00:21:02,729
<c.magenta>MTKView是一个跨平台的视图类</c>


407
00:21:02,796 --> 00:21:05,265
<c.magenta>继承自Mac OS的NSView</c>


408
00:21:05,799 --> 00:21:08,068
<c.magenta>iOS和tvOS中的UIView</c>


409
00:21:09,269 --> 00:21:11,405
<c.magenta>它可以减少你要写的代码</c>


410
00:21:11,471 --> 00:21:13,173
<c.magenta>为了让它在Metal中运行起来</c>


411
00:21:13,473 --> 00:21:17,010
<c.magenta>例如 它会创建和管理一个</c>
<c.magenta>CA Metal Layer</c>


412
00:21:17,077 --> 00:21:20,147
<c.magenta>是CALayer的一个特殊子类</c>


413
00:21:20,214 --> 00:21:23,784
<c.magenta>可以和窗口服务或者显示循环交互</c>


414
00:21:23,851 --> 00:21:25,352
<c.magenta>来让你的内容显示到屏幕上</c>


415
00:21:25,419 --> 00:21:29,256
<c.magenta>通过CV或CA显示链</c>


416
00:21:29,456 --> 00:21:31,892
<c.magenta>可管理绘制回调循环</c>


417
00:21:31,992 --> 00:21:33,627
<c.magenta>通过循环触发回调</c>


418
00:21:34,027 --> 00:21:35,729
<c.magenta>来完成你的绘制</c>


419
00:21:35,796 --> 00:21:38,765
<c.magenta>同时它还可以管理要渲染的纹理</c>


420
00:21:39,766 --> 00:21:41,835
<c.magenta>具体的方面我想强调</c>


421
00:21:42,135 --> 00:21:45,439
<c.magenta>它可以做什么和那些绘图资源</c>


422
00:21:46,306 --> 00:21:50,944
<c.magenta>在CA Metal Layer中</c>
<c.magenta>由MTKView管理</c>


423
00:21:51,011 --> 00:21:52,913
<c.magenta>有一个可绘制资源集合</c>


424
00:21:53,013 --> 00:21:54,848
<c.magenta>可绘制资源包含一个纹理</c>


425
00:21:54,915 --> 00:21:56,717
<c.magenta>将要显示到屏幕上</c>


426
00:21:57,084 --> 00:21:59,486
<c.magenta>这些在一个内部的队列中保存</c>
<c.magenta>会在帧间复用</c>


427
00:21:59,553 --> 00:22:02,155
<c.magenta>因为它们相对来说要耗费资源</c>


428
00:22:02,489 --> 00:22:05,058
<c.magenta>它们需要由系统管理</c>


429
00:22:05,125 --> 00:22:07,661
<c.magenta>因为它们和东西</c>


430
00:22:07,728 --> 00:22:09,663
<c.magenta>如何在屏幕上显示息息相关</c>


431
00:22:09,730 --> 00:22:12,966
<c.magenta>我们替你管理并给你</c>


432
00:22:13,033 --> 00:22:15,636
<c.magenta>包含纹理的可绘制对象</c>
<c.magenta>让你来绘制</c>


433
00:22:16,470 --> 00:22:18,272
<c.magenta>这里有几个属性</c>


434
00:22:18,338 --> 00:22:20,340
<c.magenta>你可以给MTKView设置</c>


435
00:22:20,407 --> 00:22:24,044
<c.magenta>来定义如何管理纹理并往里面绘制</c>


436
00:22:24,111 --> 00:22:26,914
<c.magenta>特别是 你还可以设置一个纯色</c>


437
00:22:26,980 --> 00:22:29,483
<c.magenta>让主色更清楚</c>


438
00:22:29,950 --> 00:22:32,753
<c.magenta>可以指定颜色像素格式</c>


439
00:22:33,120 --> 00:22:36,123
<c.magenta>需要匹配你指定的</c>


440
00:22:36,190 --> 00:22:37,791
<c.magenta>固定管线的状态对象的颜色格式</c>


441
00:22:37,858 --> 00:22:41,161
<c.magenta>同时制定深度或模板颜色格式</c>


442
00:22:41,562 --> 00:22:43,630
<c.magenta>最后一个属性可能是最重要的一个了</c>


443
00:22:43,697 --> 00:22:45,699
<c.magenta>我们在这里设置代理</c>


444
00:22:45,832 --> 00:22:49,603
<c.magenta>MTKView实际上不会做任何绘制</c>


445
00:22:49,670 --> 00:22:51,071
<c.magenta>你可以将它归为一个子类别</c>


446
00:22:51,205 --> 00:22:54,341
<c.magenta>或者你实现一个代理负责绘制</c>


447
00:22:54,708 --> 00:22:56,577
<c.magenta>我们通过接下来的例子来介绍</c>


448
00:22:56,844 --> 00:22:59,346
<c.magenta>我们看看你需要怎么做</c>


449
00:22:59,413 --> 00:23:02,382
<c.magenta>才能实现一个MTKView代理</c>


450
00:23:03,584 --> 00:23:06,119
<c.magenta>可归结需要实现两个方法</c>


451
00:23:06,353 --> 00:23:09,423
<c.magenta>绘制大小变化和绘制</c>


452
00:23:10,023 --> 00:23:13,126
<c.magenta>在绘制大小变化里你负责</c>


453
00:23:13,193 --> 00:23:18,031
<c.magenta>响应如窗口大小发生变化</c>
<c.magenta>或者设备旋转</c>


454
00:23:18,098 --> 00:23:20,667
<c.magenta>比如 如果你的投影矩阵依赖</c>


455
00:23:20,734 --> 00:23:23,604
<c.magenta>窗口大小 那么它可以让你</c>


456
00:23:23,670 --> 00:23:26,240
<c.magenta>响应来替代重建所有帧</c>


457
00:23:27,140 --> 00:23:30,511
<c.magenta>绘制方法会固定的被调用</c>


458
00:23:30,611 --> 00:23:33,514
<c.magenta>可以让你编码你想的执行指令</c>


459
00:23:33,580 --> 00:23:36,116
<c.magenta>包括绘制调用</c>


460
00:23:36,183 --> 00:23:39,920
<c.magenta>我们没有展示这个方法的</c>
<c.magenta>完整的内部内容</c>


461
00:23:41,255 --> 00:23:44,324
<c.magenta>但是这是对指令提交的简单介绍</c>


462
00:23:44,558 --> 00:23:48,529
<c.magenta>你要创建commandBuffer</c>
<c.magenta>做些事情 然后提交</c>


463
00:23:48,829 --> 00:23:50,964
<c.magenta>稍后我们会做更多介绍</c>


464
00:23:51,031 --> 00:23:55,068
<c.magenta>但是这是一种使用MTKView</c>
<c.magenta>的绘制功能的hook函数</c>


465
00:23:55,903 --> 00:23:58,238
<c.magenta>我们推荐使用MTKView</c>
<c.magenta>尤其是在开始时</c>


466
00:23:58,305 --> 00:24:00,507
<c.magenta>因为它已经为你做了不少其他的东西</c>


467
00:24:01,408 --> 00:24:03,810
<c.magenta>我们说下Metal的指令提交模型</c>


468
00:24:04,244 --> 00:24:06,079
<c.magenta>这里有张我们要做的图</c>


469
00:24:06,146 --> 00:24:07,714
<c.magenta>在接下来几张幻灯片中</c>


470
00:24:08,682 --> 00:24:12,052
<c.magenta>你不需要记住所有的东西</c>


471
00:24:12,119 --> 00:24:14,188
<c.magenta>我们将要把这个图绘出来</c>


472
00:24:14,288 --> 00:24:15,756
<c.magenta>这仅是个大体介绍</c>


473
00:24:15,822 --> 00:24:19,359
<c.magenta>我们会创建这个对象</c>


474
00:24:20,627 --> 00:24:24,464
<c.magenta>Metal的指令提交模型非常明确</c>


475
00:24:24,698 --> 00:24:26,934
<c.magenta>表示你需要自己构造</c>


476
00:24:27,000 --> 00:24:28,969
<c.magenta>和提交commandBuffers</c>


477
00:24:29,336 --> 00:24:32,005
<c.magenta>可把commandBuffer当作</c>


478
00:24:32,072 --> 00:24:34,007
<c.magenta>一个打包的工作交给GPU执行</c>


479
00:24:34,208 --> 00:24:37,744
<c.magenta>不同于我们存数据的Metal缓存</c>


480
00:24:38,078 --> 00:24:40,380
<c.magenta>指令缓冲存了GPU需要完成的工作</c>


481
00:24:40,848 --> 00:24:43,817
<c.magenta>同时commandBuffer的</c>
<c.magenta>提交完全由你控制</c>


482
00:24:43,884 --> 00:24:46,019
<c.magenta>就是当你构造了一个</c>
<c.magenta>commandBuffer</c>


483
00:24:46,086 --> 00:24:49,289
<c.magenta>你负责告诉GPU何时执行</c>


484
00:24:49,590 --> 00:24:51,258
<c.magenta>稍后会详细介绍</c>


485
00:24:51,491 --> 00:24:53,594
<c.magenta>我们先说说指令编码器</c>


486
00:24:53,660 --> 00:24:56,363
<c.magenta>把对象的API调用翻译成</c>


487
00:24:56,763 --> 00:24:58,432
<c.magenta>GPU需要做的工作</c>


488
00:24:58,498 --> 00:24:59,399
<c.magenta>你要明白这很重要</c>


489
00:24:59,466 --> 00:25:02,603
<c.magenta>这些指令编码器不会有状态验证延时</c>


490
00:25:02,669 --> 00:25:05,305
<c.magenta>所以所有预验证状态捆绑到</c>


491
00:25:05,372 --> 00:25:07,140
<c.magenta>管线的状态对象里了</c>


492
00:25:07,908 --> 00:25:10,878
<c.magenta>我们假设它是合法的</c>
<c.magenta>因为我们已经提前验证了</c>


493
00:25:11,144 --> 00:25:13,981
<c.magenta>所以这里没有额外的工作要做</c>


494
00:25:14,047 --> 00:25:17,117
<c.magenta>在你的编码器或驱动</c>
<c.magenta>调用渲染指令的时候</c>


495
00:25:19,920 --> 00:25:22,856
<c.magenta>还有 Metal的指令提交模型</c>
<c.magenta>是多线程的</c>


496
00:25:22,923 --> 00:25:26,326
<c.magenta>你可以并行的创建多个指令缓存</c>


497
00:25:26,493 --> 00:25:28,896
<c.magenta>让应用决定执行顺序</c>


498
00:25:29,162 --> 00:25:33,534
<c.magenta>这可以让你的每一帧的绘制</c>
<c.magenta>执行上万次调用</c>


499
00:25:33,934 --> 00:25:36,370
<c.magenta>使用Metal 第二部分会深入探讨</c>


500
00:25:36,470 --> 00:25:40,374
<c.magenta>但这里因为提到了所以说一下</c>


501
00:25:41,775 --> 00:25:44,211
<c.magenta>让我们深入了解下这些对象</c>


502
00:25:44,978 --> 00:25:47,548
<c.magenta>首先是指令队列</c>


503
00:25:48,081 --> 00:25:50,317
<c.magenta>指令队列这里是说</c>


504
00:25:50,384 --> 00:25:52,519
<c.magenta>一个叫做</c>
<c.magenta>MTLCommandQueue的类</c>


505
00:25:52,586 --> 00:25:55,822
<c.magenta>它把设备需要执行的指令</c>
<c.magenta>都放在队列里执行</c>


506
00:25:56,924 --> 00:25:59,493
<c.magenta>像设备和资源和管线状态</c>


507
00:25:59,826 --> 00:26:02,796
<c.magenta>队列是一直存在的对象</c>


508
00:26:02,963 --> 00:26:06,200
<c.magenta>在程序的整个生命周期会保持引用</c>


509
00:26:06,266 --> 00:26:07,935
<c.magenta>通常你只需要创建一个</c>


510
00:26:08,502 --> 00:26:12,072
<c.magenta>这样可以保证Metal API</c>
<c.magenta>是线程安全的</c>


511
00:26:12,239 --> 00:26:16,310
<c.magenta>你可以创建指令缓冲渲染</c>


512
00:26:16,376 --> 00:26:18,445
<c.magenta>并在多线程中使用它</c>


513
00:26:18,745 --> 00:26:22,349
<c.magenta>队列可以让你创建和提交它们</c>


514
00:26:22,583 --> 00:26:25,752
<c.magenta>并在自己不加锁的情况下</c>
<c.magenta>保证是线程安全的</c>


515
00:26:27,354 --> 00:26:29,323
<c.magenta>创建一个指令队列很简单</c>


516
00:26:29,790 --> 00:26:32,159
<c.magenta>用设备调用</c>
<c.magenta>newCommandQueue()</c>


517
00:26:32,459 --> 00:26:34,328
<c.magenta>你将会得到一个Metal指令队列</c>


518
00:26:36,463 --> 00:26:39,466
<c.magenta>当然只有你往里放入</c>
<c.magenta>指令的时候它才会工作</c>


519
00:26:39,666 --> 00:26:41,101
<c.magenta>我们说一下</c>


520
00:26:44,137 --> 00:26:45,405
<c.magenta>我已经提过指令缓冲了</c>


521
00:26:45,472 --> 00:26:48,809
<c.magenta>指令缓冲是GPU要执行的打包的工作</c>


522
00:26:48,876 --> 00:26:51,512
<c.magenta>在Metal中 它们用</c>


523
00:26:51,578 --> 00:26:53,680
<c.magenta>一个叫做MTLCommandBuffer的类表示</c>


524
00:26:54,014 --> 00:26:55,983
<c.magenta>MTLCommandBuffer</c>
<c.magenta>包含一系列指令</c>


525
00:26:56,049 --> 00:26:59,920
<c.magenta>由GPU来执行 它们被放进</c>


526
00:26:59,987 --> 00:27:02,322
<c.magenta>一个指令队列等待驱动来调度</c>


527
00:27:02,789 --> 00:27:04,858
<c.magenta>根据我们目前讲的这些</c>


528
00:27:04,925 --> 00:27:07,060
<c.magenta>它是临时对象</c>


529
00:27:07,127 --> 00:27:09,630
<c.magenta>就是说每一帧你都要</c>
<c.magenta>创建一个或多个</c>


530
00:27:10,230 --> 00:27:12,466
<c.magenta>然后往里给它编码指令</c>


531
00:27:12,533 --> 00:27:15,135
<c.magenta>然后让让它们脱离GPU</c>


532
00:27:15,202 --> 00:27:17,905
<c.magenta>你不会重用它们 不用引用它们</c>


533
00:27:18,272 --> 00:27:19,640
<c.magenta>它们会自己消失</c>


534
00:27:20,774 --> 00:27:22,376
<c.magenta>创建一个commandBuffer</c>


535
00:27:22,442 --> 00:27:25,078
<c.magenta>调用commandQueue.commandBuffer()</c>


536
00:27:28,182 --> 00:27:31,385
<c.magenta>我们已经说了缓冲和队列</c>


537
00:27:31,451 --> 00:27:33,187
<c.magenta>我们讨论下如何把数据和指令</c>


538
00:27:33,654 --> 00:27:36,089
<c.magenta>放到指令缓冲中</c>


539
00:27:36,156 --> 00:27:38,825
<c.magenta>通过一个叫做指令编码器的类</c>


540
00:27:39,026 --> 00:27:40,861
<c.magenta>这里有几种类型的指令编码器</c>


541
00:27:40,961 --> 00:27:43,163
<c.magenta>包括渲染 位传输和计算</c>


542
00:27:43,597 --> 00:27:45,766
<c.magenta>这些分别实现不同的功能</c>


543
00:27:45,832 --> 00:27:49,002
<c.magenta>它们都差不多 都可以把你的</c>


544
00:27:49,069 --> 00:27:51,638
<c.magenta>工作编码到指令缓存中</c>


545
00:27:51,905 --> 00:27:55,576
<c.magenta>比如 一个渲染指令编码器</c>


546
00:27:55,642 --> 00:27:57,644
<c.magenta>可以设置状态和执行绘制调用</c>


547
00:27:57,911 --> 00:28:00,514
<c.magenta>一个计算指令编码器可以</c>


548
00:28:00,848 --> 00:28:05,319
<c.magenta>把工作添加到队列中</c>
<c.magenta>并像数据一样并行计算 不像渲染工作</c>


549
00:28:05,385 --> 00:28:07,955
<c.magenta>它像GP GPU或者类似的东西</c>


550
00:28:08,655 --> 00:28:11,058
<c.magenta>位传输指令编码器用来</c>


551
00:28:11,124 --> 00:28:13,927
<c.magenta>在缓存和纹理之间相互拷贝数据</c>


552
00:28:16,330 --> 00:28:19,766
<c.magenta>这节课中我们会详细</c>
<c.magenta>看看渲染指令编码器</c>


553
00:28:20,467 --> 00:28:24,605
<c.magenta>我刚才提到 它负责编码指令</c>


554
00:28:24,671 --> 00:28:26,673
<c.magenta>每一个渲染指令编码器</c>


555
00:28:27,040 --> 00:28:30,210
<c.magenta>单独编码每个工作</c>


556
00:28:30,544 --> 00:28:32,579
<c.magenta>如果你触发状态变化</c>


557
00:28:32,946 --> 00:28:35,916
<c.magenta>然后触发绘制</c>


558
00:28:36,149 --> 00:28:39,887
<c.magenta>然后管理一个渲染附件集合 代表</c>


559
00:28:39,953 --> 00:28:42,923
<c.magenta>将要绘制的纹理</c>


560
00:28:43,924 --> 00:28:48,028
<c.magenta>概要来说 我们说的是最后这个阶段</c>


561
00:28:48,095 --> 00:28:50,364
<c.magenta>你能看到我们有这些附件</c>


562
00:28:50,430 --> 00:28:55,169
<c.magenta>被挂到管线的帧缓存合适的阶段</c>


563
00:28:55,802 --> 00:28:58,972
<c.magenta>如果我们做多通道渲染</c>


564
00:28:59,039 --> 00:29:02,643
<c.magenta>那么一个或多个渲染目标可能</c>
<c.magenta>会变为接下来的输入</c>


565
00:29:02,709 --> 00:29:05,846
<c.magenta>这里只有一个通道 比较简单</c>


566
00:29:06,780 --> 00:29:09,816
<c.magenta>附件表示纹理贴图</c>


567
00:29:09,883 --> 00:29:13,320
<c.magenta>我们将要这个阶段的最后绘制</c>


568
00:29:14,521 --> 00:29:17,157
<c.magenta>就是说 实际上创建一个</c>
<c.magenta>渲染指令编码器</c>


569
00:29:17,224 --> 00:29:20,561
<c.magenta>使用另一种类型描述对象</c>
<c.magenta>一个RenderPassDescriptor</c>


570
00:29:21,028 --> 00:29:24,031
<c.magenta>一个RenderPassDescriptor</c>
<c.magenta>包含一系列的附件</c>


571
00:29:24,331 --> 00:29:28,602
<c.magenta>每一个都有加载存储操作 纯色和值</c>


572
00:29:28,669 --> 00:29:31,205
<c.magenta>和将要被渲染的Metal纹理</c>


573
00:29:31,939 --> 00:29:35,442
<c.magenta>我们用几页讲一下加载和存储操作</c>


574
00:29:35,776 --> 00:29:37,945
<c.magenta>这里有很重要的一点需要明白</c>


575
00:29:38,145 --> 00:29:41,815
<c.magenta>你需要构造一个</c>
<c.magenta>RenderPassDescriptor</c>


576
00:29:42,115 --> 00:29:45,352
<c.magenta>在帧开始的时候并且把需要它</c>


577
00:29:45,419 --> 00:29:47,454
<c.magenta>和将要绘制的纹理相关联</c>


578
00:29:47,688 --> 00:29:53,527
<c.magenta>相比只需要知道像素格式</c>
<c.magenta>的renderPipelineState</c>


579
00:29:53,694 --> 00:29:55,295
<c.magenta>这是最重要的部分</c>


580
00:29:55,362 --> 00:29:58,799
<c.magenta>而你必须有我们将在</c>
<c.magenta>其中进行绘制的纹理</c>


581
00:30:01,235 --> 00:30:03,637
<c.magenta>RenderPassDescriptor包含</c>


582
00:30:03,704 --> 00:30:06,406
<c.magenta>渲染通道附件</c>
<c.magenta>每一个可能是一个颜色</c>


583
00:30:06,473 --> 00:30:07,774
<c.magenta>深度或者模型目标</c>


584
00:30:08,041 --> 00:30:09,943
<c.magenta>或者指向需要渲染的纹理</c>


585
00:30:10,577 --> 00:30:13,380
<c.magenta>指定这些东西叫做加载和存储操作</c>


586
00:30:13,680 --> 00:30:16,383
<c.magenta>我们更深入的说下是什么意思</c>


587
00:30:16,950 --> 00:30:19,987
<c.magenta>开始的通道中你有颜色缓存</c>


588
00:30:20,053 --> 00:30:23,590
<c.magenta>有深度缓存它们包含未知的内容</c>


589
00:30:24,258 --> 00:30:27,995
<c.magenta>为了做些真正的工作</c>
<c.magenta>我们先清空它</c>


590
00:30:28,295 --> 00:30:30,898
<c.magenta>我们通过设置和其相关的加载动作</c>


591
00:30:31,231 --> 00:30:33,033
<c.magenta>在RenderPassDescriptor中</c>


592
00:30:34,101 --> 00:30:37,638
<c.magenta>我们颜色和深度目标</c>
<c.magenta>设置一个清空加载动作</c>


593
00:30:38,105 --> 00:30:40,807
<c.magenta>那它会把相应的颜色设置为清空色</c>


594
00:30:40,874 --> 00:30:42,643
<c.magenta>或者值 根据实际情况</c>


595
00:30:43,410 --> 00:30:44,711
<c.magenta>然后我们开始绘制</c>


596
00:30:44,845 --> 00:30:46,113
<c.magenta>会把我们作用的结果</c>


597
00:30:46,180 --> 00:30:48,048
<c.magenta>绘制到纹理上</c>


598
00:30:48,582 --> 00:30:50,984
<c.magenta>然后存储操作会触发</c>


599
00:30:51,251 --> 00:30:53,820
<c.magenta>存储操作包含两部分</c>


600
00:30:54,188 --> 00:30:57,424
<c.magenta>存储操作的存储</c>


601
00:30:57,491 --> 00:30:59,193
<c.magenta>渲染的结果应该被写会</c>


602
00:30:59,259 --> 00:31:00,894
<c.magenta>内存并且存储</c>


603
00:31:00,961 --> 00:31:03,263
<c.magenta>对于颜色缓存</c>


604
00:31:03,330 --> 00:31:05,032
<c.magenta>我们尽可能的在屏幕上展现</c>


605
00:31:05,199 --> 00:31:07,968
<c.magenta>对于深度缓存 我们只在</c>


606
00:31:08,035 --> 00:31:11,438
<c.magenta>实际绘制和渲染时用到</c>


607
00:31:11,638 --> 00:31:15,209
<c.magenta>所以我们在最后的通道中</c>
<c.magenta>不关心它的结果</c>


608
00:31:15,409 --> 00:31:18,779
<c.magenta>我们可以设置一个存储动作为不关心</c>
<c.magenta>为了节省些带宽</c>


609
00:31:19,112 --> 00:31:21,014
<c.magenta>这也是你可以做的优化</c>


610
00:31:21,081 --> 00:31:23,450
<c.magenta>如果你并不需要</c>


611
00:31:23,517 --> 00:31:25,152
<c.magenta>渲染的结果写会渲染对象</c>


612
00:31:27,087 --> 00:31:29,556
<c.magenta>再深入说下加载和存储操作</c>


613
00:31:29,623 --> 00:31:31,391
<c.magenta>它决定了纹理内容如何被处理</c>


614
00:31:31,458 --> 00:31:32,960
<c.magenta>在开始和结束的时候</c>


615
00:31:33,293 --> 00:31:36,597
<c.magenta>另外对清空操作</c>


616
00:31:36,730 --> 00:31:39,366
<c.magenta>也有加载操作让你</c>


617
00:31:39,433 --> 00:31:43,136
<c.magenta>加载纹理的像素内容</c>


618
00:31:43,370 --> 00:31:44,972
<c.magenta>用之前的处理结果</c>


619
00:31:45,072 --> 00:31:46,373
<c.magenta>它也不用关心</c>


620
00:31:46,573 --> 00:31:49,843
<c.magenta>比如 你想从头到尾渲染一个目标</c>


621
00:31:49,910 --> 00:31:53,180
<c.magenta>所有的像素 那么你不用关心</c>


622
00:31:53,247 --> 00:31:56,583
<c.magenta>之前的纹理 你也不用清空它</c>


623
00:31:57,017 --> 00:31:58,619
<c.magenta>因为你知道你将会设置</c>


624
00:31:58,685 --> 00:32:00,954
<c.magenta>每一个像素为一些值</c>


625
00:32:01,255 --> 00:32:02,823
<c.magenta>还一种你可以做的优化</c>


626
00:32:02,890 --> 00:32:04,458
<c.magenta>如果你知道你会</c>


627
00:32:04,525 --> 00:32:07,261
<c.magenta>在这个阶段处理每个像素</c>


628
00:32:10,063 --> 00:32:13,534
<c.magenta>我会告诉你 如何创建</c>
<c.magenta>RenderPassDescriptor</c>


629
00:32:13,734 --> 00:32:16,370
<c.magenta>然后创建一个渲染器指令编码器</c>
<c.magenta>幸运的是</c>


630
00:32:16,603 --> 00:32:18,872
<c.magenta>MTKView使这些变得很简单</c>


631
00:32:19,273 --> 00:32:21,708
<c.magenta>之前我们配置MTKView</c>


632
00:32:21,942 --> 00:32:23,076
<c.magenta>用几个属性</c>


633
00:32:23,143 --> 00:32:25,612
<c.magenta>我希望你们熟悉它</c>
<c.magenta>像清空色</c>


634
00:32:25,679 --> 00:32:27,948
<c.magenta>还有渲染目标的纹理格式</c>


635
00:32:28,248 --> 00:32:30,317
<c.magenta>实际上你可以通过请求视图得到</c>


636
00:32:30,417 --> 00:32:32,319
<c.magenta>当前的RenderPassDescriptor</c>


637
00:32:32,386 --> 00:32:35,122
<c.magenta>你会获得一个设置的</c>
<c.magenta>RenderPassDescriptor</c>


638
00:32:35,422 --> 00:32:36,890
<c.magenta>接下来你就可以使用它</c>


639
00:32:36,957 --> 00:32:39,960
<c.magenta>创建渲染指令编码器了</c>


640
00:32:41,929 --> 00:32:44,364
<c.magenta>你该这么做 调用渲染指令编码器</c>


641
00:32:44,431 --> 00:32:46,033
<c.magenta>在你的指令缓存上</c>


642
00:32:46,099 --> 00:32:49,269
<c.magenta>你需要重点关注当前的</c>
<c.magenta>RenderPassDescriptor是</c>


643
00:32:49,336 --> 00:32:50,804
<c.magenta>一个潜在的块调用</c>


644
00:32:51,038 --> 00:32:53,540
<c.magenta>这样的原因是 实际上它会调用</c>


645
00:32:53,607 --> 00:32:57,144
<c.magenta>CA Metal Layers的</c>
<c.magenta>下一个可绘制函数</c>


646
00:32:57,444 --> 00:33:00,280
<c.magenta>我们不会详细介绍</c>
<c.magenta>但它是用来</c>


647
00:33:00,347 --> 00:33:02,516
<c.magenta>获取包含纹理的可绘制对象</c>


648
00:33:02,583 --> 00:33:04,184
<c.magenta>来展示到屏幕上</c>


649
00:33:04,318 --> 00:33:06,620
<c.magenta>因为那是个有限的资源</c>


650
00:33:06,854 --> 00:33:09,756
<c.magenta>如果当前没有可绘制的对象</c>


651
00:33:09,823 --> 00:33:12,993
<c.magenta>如果他们所有的在运行</c>
<c.magenta>然后这个调用会阻塞</c>


652
00:33:13,293 --> 00:33:14,995
<c.magenta>所以这里需要注意</c>


653
00:33:16,597 --> 00:33:18,866
<c.magenta>我们已经说了加载资源到内存</c>


654
00:33:18,932 --> 00:33:21,034
<c.magenta>我们说了创建预验证状态</c>


655
00:33:21,101 --> 00:33:24,137
<c.magenta>和创建渲染通道</c>


656
00:33:24,304 --> 00:33:25,739
<c.magenta>和渲染指令编码器</c>


657
00:33:25,806 --> 00:33:28,141
<c.magenta>如何把数据弄到着色器中</c>


658
00:33:29,376 --> 00:33:32,212
<c.magenta>第一我们需要说下参数表</c>


659
00:33:33,146 --> 00:33:36,617
<c.magenta>参数表是Metal资源到</c>


660
00:33:37,484 --> 00:33:38,819
<c.magenta>着色器参数的映射</c>


661
00:33:39,152 --> 00:33:41,755
<c.magenta>你用的每一种资源</c>


662
00:33:41,822 --> 00:33:43,323
<c.magenta>如缓存或者纹理</c>


663
00:33:43,390 --> 00:33:45,459
<c.magenta>都有他们自己的缓存参数表</c>


664
00:33:45,726 --> 00:33:46,994
<c.magenta>在右面你能看到</c>


665
00:33:47,060 --> 00:33:49,396
<c.magenta>我们有缓存参数表</c>


666
00:33:49,463 --> 00:33:52,466
<c.magenta>和纹理参数表</c>
<c.magenta>它们中每个都包含几个</c>


667
00:33:52,533 --> 00:33:56,837
<c.magenta>缓存对应着参数表中的索引</c>


668
00:33:57,671 --> 00:33:59,473
<c.magenta>给定参数表的插槽的可用数量</c>


669
00:33:59,540 --> 00:34:02,743
<c.magenta>根据设备决定</c>


670
00:34:02,843 --> 00:34:04,378
<c.magenta>你需要先查询</c>


671
00:34:05,579 --> 00:34:07,481
<c.magenta>我们具体说下</c>


672
00:34:07,548 --> 00:34:10,150
<c.magenta>在渲染指令编码器有个函数</c>


673
00:34:10,217 --> 00:34:11,918
<c.magenta>叫setVerTextBuffer</c>


674
00:34:12,252 --> 00:34:14,188
<c.magenta>它有三个参数</c>


675
00:34:14,254 --> 00:34:17,257
<c.magenta>一个buffer 一个offset</c>
<c.magenta>一个index</c>


676
00:34:17,491 --> 00:34:19,893
<c.magenta>最后一个是我们最关心的</c>


677
00:34:19,960 --> 00:34:23,297
<c.magenta>因为它是我们的参数表索引</c>


678
00:34:25,264 --> 00:34:29,735
<c.magenta>这是主机端设置资源</c>


679
00:34:29,803 --> 00:34:31,638
<c.magenta>在使用着色器的时候</c>


680
00:34:31,839 --> 00:34:34,608
<c.magenta>也有个对应的着色器端</c>


681
00:34:34,875 --> 00:34:36,243
<c.magenta>像这样</c>


682
00:34:36,443 --> 00:34:38,645
<c.magenta>在着色器语言中间</c>


683
00:34:38,745 --> 00:34:41,882
<c.magenta>在你的着色文件中 你指定</c>


684
00:34:42,248 --> 00:34:46,453
<c.magenta>每一个给定的参数</c>
<c.magenta>对应一个你要访问的资源</c>


685
00:34:46,520 --> 00:34:50,123
<c.magenta>有个属性像这样</c>


686
00:34:50,591 --> 00:34:52,993
<c.magenta>这是第一个缓存索引</c>


687
00:34:53,060 --> 00:34:54,995
<c.magenta>索引0在参数表中</c>


688
00:34:55,161 --> 00:34:59,533
<c.magenta>代表我们刚才在渲染指令编码器的缓存</c>


689
00:35:02,069 --> 00:35:04,538
<c.magenta>我们详细看下</c>


690
00:35:04,605 --> 00:35:06,974
<c.magenta>当在2D绘制中</c>


691
00:35:10,744 --> 00:35:12,212
<c.magenta>我们创建了renderPipelineState</c>


692
00:35:12,279 --> 00:35:14,815
<c.magenta>我们需要告诉渲染指令编码器</c>


693
00:35:14,882 --> 00:35:17,584
<c.magenta>在绘制前需要用哪个管线状态</c>


694
00:35:17,718 --> 00:35:18,986
<c.magenta>这个API就是干这个的</c>


695
00:35:19,419 --> 00:35:21,288
<c.magenta>我们调用setRenderPipelineState</c>


696
00:35:21,355 --> 00:35:23,790
<c.magenta>用刚才创建的</c>
<c.magenta>PipelineState对象</c>


697
00:35:23,957 --> 00:35:27,194
<c.magenta>用我们创建的着色器配置</c>


698
00:35:27,261 --> 00:35:30,364
<c.magenta>我们用先前创建的来绘制</c>


699
00:35:31,164 --> 00:35:32,666
<c.magenta>现在RenderPipelineState</c>


700
00:35:32,733 --> 00:35:36,170
<c.magenta>有相关的顶点和片段函数了</c>


701
00:35:36,403 --> 00:35:38,639
<c.magenta>我们看看顶点和片段函数</c>


702
00:35:38,705 --> 00:35:40,941
<c.magenta>我们在2D绘图中主要用这个</c>


703
00:35:41,975 --> 00:35:44,311
<c.magenta>回到Metal着色语言</c>
<c.magenta>看起来像这样</c>


704
00:35:44,645 --> 00:35:48,482
<c.magenta>大体上是一个直接的顶点函数</c>


705
00:35:48,549 --> 00:35:51,018
<c.magenta>没有复杂的数学操作</c>


706
00:35:51,084 --> 00:35:53,954
<c.magenta>它会复制所有的属性 直接连接</c>


707
00:35:54,555 --> 00:35:59,860
<c.magenta>函数的第一个参数是一个顶点列表</c>


708
00:35:59,927 --> 00:36:02,162
<c.magenta>我们刚才创建的缓存</c>


709
00:36:02,629 --> 00:36:05,165
<c.magenta>第二个参数是属于</c>


710
00:36:05,232 --> 00:36:08,202
<c.magenta>顶点ID的属性</c>


711
00:36:08,268 --> 00:36:11,638
<c.magenta>表示正Metal在处理的定点的</c>


712
00:36:11,705 --> 00:36:13,073
<c.magenta>索引</c>


713
00:36:13,473 --> 00:36:15,342
<c.magenta>它比较重要的原因</c>


714
00:36:15,409 --> 00:36:17,544
<c.magenta>vertexBuffer</c>
<c.magenta>包含所有的点</c>


715
00:36:17,611 --> 00:36:19,046
<c.magenta>我们可以随机获得</c>


716
00:36:19,479 --> 00:36:22,883
<c.magenta>实际上我们想在我们顶点函数</c>


717
00:36:22,950 --> 00:36:24,985
<c.magenta>一次对一个点操作</c>


718
00:36:25,052 --> 00:36:27,321
<c.magenta>这告诉我们正在操作哪一个</c>


719
00:36:27,554 --> 00:36:30,691
<c.magenta>我们创建一个</c>
<c.magenta>VertexOut结构的实例</c>


720
00:36:30,791 --> 00:36:34,294
<c.magenta>代表定顶点的各种属性</c>


721
00:36:34,728 --> 00:36:36,964
<c.magenta>然后我们传给给光栅</c>


722
00:36:37,097 --> 00:36:39,900
<c.magenta>我们创建一个实例 并设置位置</c>


723
00:36:40,000 --> 00:36:44,371
<c.magenta>为向量位置vertexId的顶点</c>


724
00:36:44,671 --> 00:36:46,039
<c.magenta>颜色也是类似</c>


725
00:36:46,106 --> 00:36:48,909
<c.magenta>这里进传递了</c>
<c.magenta>vertexBuffer数据</c>


726
00:36:49,243 --> 00:36:52,112
<c.magenta>给结构体供光栅来做插值</c>


727
00:36:52,579 --> 00:36:55,816
<c.magenta>然后我们返回这个结构</c>


728
00:36:57,384 --> 00:36:59,219
<c.magenta>让我们看看</c>
<c.magenta>fragmentFunction</c>


729
00:36:59,286 --> 00:37:00,954
<c.magenta>它更简单</c>


730
00:37:01,088 --> 00:37:05,759
<c.magenta>所以我们得到了插值结构</c>


731
00:37:05,826 --> 00:37:07,761
<c.magenta>它表示</c>


732
00:37:07,828 --> 00:37:10,464
<c.magenta>光栅化得来的数据</c>


733
00:37:10,998 --> 00:37:12,466
<c.magenta>我们刚抽取了颜色</c>


734
00:37:12,699 --> 00:37:15,702
<c.magenta>颜色来自结构</c>


735
00:37:16,036 --> 00:37:17,304
<c.magenta>然后再传回去</c>


736
00:37:17,604 --> 00:37:20,541
<c.magenta>这个过程中顶点发生了什么</c>


737
00:37:20,607 --> 00:37:23,277
<c.magenta>在这个例子里截取空间指定的</c>


738
00:37:23,710 --> 00:37:27,514
<c.magenta>被插值然后光栅化然后</c>


739
00:37:27,581 --> 00:37:29,283
<c.magenta>被每个片段处理</c>


740
00:37:29,349 --> 00:37:32,753
<c.magenta>我们返回由光栅创建的插值颜色</c>


741
00:37:34,988 --> 00:37:37,558
<c.magenta>一旦我们指定RenderPipelineState</c>


742
00:37:37,624 --> 00:37:39,693
<c.magenta>包含我们的顶点和片段函数</c>


743
00:37:39,760 --> 00:37:42,930
<c.magenta>我们可以设置额外状态</c>
<c.magenta>就像我之前介绍的</c>


744
00:37:42,996 --> 00:37:45,832
<c.magenta>包括front facing状态</c>


745
00:37:46,066 --> 00:37:49,203
<c.magenta>如果你想指定不同的</c>
<c.magenta>front facing顺序</c>


746
00:37:49,269 --> 00:37:52,005
<c.magenta>而不用Metal默认的</c>


747
00:37:52,139 --> 00:37:53,240
<c.magenta>你可以在这里实现</c>


748
00:37:54,808 --> 00:37:56,810
<c.magenta>这里有许多配置项</c>
<c.magenta>但我们只看</c>


749
00:37:56,877 --> 00:37:58,478
<c.magenta>一些绘制调用</c>


750
00:37:59,613 --> 00:38:00,547
<c.magenta>现在</c>


751
00:38:00,647 --> 00:38:02,049
<c.magenta>Metal有很多函数</c>


752
00:38:02,115 --> 00:38:05,152
<c.magenta>绘制几何图形包括indexed</c>
<c.magenta>instance和indirect</c>


753
00:38:05,219 --> 00:38:07,287
<c.magenta>我们只看基本的索引绘制</c>


754
00:38:07,654 --> 00:38:10,224
<c.magenta>这里我们想画一个三角形</c>


755
00:38:10,757 --> 00:38:13,393
<c.magenta>我们调用drawIndexedPrimitives</c>


756
00:38:13,760 --> 00:38:16,663
<c.magenta>我们指定原型为三角形</c>


757
00:38:16,830 --> 00:38:18,365
<c.magenta>因为我们想画三角形</c>


758
00:38:18,498 --> 00:38:21,201
<c.magenta>我们传递三个索引</c>


759
00:38:21,268 --> 00:38:22,603
<c.magenta>来画一个三角形</c>


760
00:38:23,203 --> 00:38:26,907
<c.magenta>我们同时需要制定索引的类型</c>


761
00:38:26,974 --> 00:38:31,044
<c.magenta>我们之前声明了一个Swift</c>
<c.magenta>的数组集合</c>


762
00:38:31,111 --> 00:38:32,746
<c.magenta>我们这里复制一下</c>


763
00:38:32,813 --> 00:38:36,550
<c.magenta>我们还要把</c>
<c.magenta>indexBuffer传递下去</c>


764
00:38:36,650 --> 00:38:38,285
<c.magenta>来表示哪些点应该绘制</c>


765
00:38:38,385 --> 00:38:40,220
<c.magenta>我们把位移设置为0</c>


766
00:38:40,621 --> 00:38:42,589
<c.magenta>这会画一个</c>


767
00:38:42,656 --> 00:38:45,058
<c.magenta>三角形在屏幕上</c>


768
00:38:46,693 --> 00:38:48,695
<c.magenta>我们可以添加些其他状态</c>


769
00:38:48,762 --> 00:38:50,731
<c.magenta>触发一些其他绘制调用</c>


770
00:38:50,797 --> 00:38:53,066
<c.magenta>但第一个演示我们就做这些</c>


771
00:38:53,600 --> 00:38:55,402
<c.magenta>为了完成一个渲染过程</c>


772
00:38:55,802 --> 00:38:59,606
<c.magenta>我们调用Render Command</c>
<c.magenta>Encoder的endEncoding</c>


773
00:39:00,641 --> 00:39:03,977
<c.magenta>回顾一下</c>
<c.magenta>你需要创建一个请求</c>


774
00:39:04,044 --> 00:39:06,680
<c.magenta>在开始时获得RenderPassDescriptor</c>


775
00:39:07,614 --> 00:39:10,918
<c.magenta>用这个描述符创建</c>
<c.magenta>一个Render Command Encoder</c>


776
00:39:11,752 --> 00:39:13,520
<c.magenta>设置RenderPipelineState</c>


777
00:39:14,054 --> 00:39:15,589
<c.magenta>设置其他必要的状态</c>


778
00:39:15,856 --> 00:39:18,559
<c.magenta>触发调用最后结束编码</c>


779
00:39:19,359 --> 00:39:21,862
<c.magenta>这是我们看到的代码的一个概括</c>


780
00:39:22,262 --> 00:39:23,263
<c.magenta>没有啥新东西</c>


781
00:39:23,330 --> 00:39:26,099
<c.magenta>和刚才我说的一样</c>


782
00:39:26,834 --> 00:39:31,738
<c.magenta>创建一个Render Command Encoder</c>
<c.magenta>设置状态 设置状态</c>


783
00:39:33,006 --> 00:39:34,575
<c.magenta>绑定缓存 然后绘制</c>


784
00:39:36,243 --> 00:39:38,212
<c.magenta>你已经渲染了这些内容</c>


785
00:39:38,412 --> 00:39:40,147
<c.magenta>怎么样让它显示在屏幕上</c>


786
00:39:40,214 --> 00:39:41,682
<c.magenta>非常简单</c>


787
00:39:41,949 --> 00:39:44,585
<c.magenta>首先 渲染路径的颜色附件</c>


788
00:39:44,651 --> 00:39:47,154
<c.magenta>通常是可绘制的纹理</c>


789
00:39:47,287 --> 00:39:50,824
<c.magenta>你可从CA Metal Layer</c>
<c.magenta>或者MKTView获得</c>


790
00:39:51,525 --> 00:39:54,862
<c.magenta>为了获得在实际上显示的纹理</c>


791
00:39:55,662 --> 00:39:57,197
<c.magenta>你可调用commandBuffer</c>
<c.magenta>的present</c>


792
00:39:57,264 --> 00:39:59,533
<c.magenta>并给它传递那个drawable</c>


793
00:39:59,600 --> 00:40:01,535
<c.magenta>它将会显示到屏幕</c>


794
00:40:01,602 --> 00:40:04,638
<c.magenta>一旦所有的处理路径完成</c>


795
00:40:06,740 --> 00:40:08,642
<c.magenta>要向实际完成这一帧</c>


796
00:40:08,709 --> 00:40:10,811
<c.magenta>由于我们把指令编码进</c>
<c.magenta>commandBuffer</c>


797
00:40:10,878 --> 00:40:11,979
<c.magenta>我们要表明下我们完成了</c>


798
00:40:12,045 --> 00:40:14,047
<c.magenta>通过调用commandBuffer.commit()</c>


799
00:40:14,448 --> 00:40:16,483
<c.magenta>提交告诉驱动</c>
<c.magenta>commandBuffer</c>


800
00:40:16,550 --> 00:40:18,085
<c.magenta>已经准备好给GPU运行了</c>


801
00:40:19,853 --> 00:40:21,421
<c.magenta>总结一下</c>


802
00:40:22,856 --> 00:40:24,391
<c.magenta>我们创建了一个指令队列开始</c>


803
00:40:24,458 --> 00:40:27,861
<c.magenta>它是一个持久对象</c>
<c.magenta>我们需要引用它</c>


804
00:40:28,462 --> 00:40:30,697
<c.magenta>每一帧我们创建一个</c>
<c.magenta>commandBuffer</c>


805
00:40:30,764 --> 00:40:33,834
<c.magenta>使用渲染指令编码器编码</c>
<c.magenta>一个或多个渲染路径</c>


806
00:40:34,935 --> 00:40:37,738
<c.magenta>通过提交commandBuffer</c>
<c.magenta>来在屏幕上显示</c>


807
00:40:39,273 --> 00:40:41,508
<c.magenta>现在交给我同事Matt</c>


808
00:40:41,575 --> 00:40:43,610
<c.magenta>带我们完成这个2D demo绘制</c>


809
00:40:43,944 --> 00:40:45,012
<c.magenta>谢谢 Warren</c>


810
00:40:53,120 --> 00:40:54,388
<c.magenta>这里是验证部分</c>


811
00:40:54,454 --> 00:40:57,524
<c.magenta>一个2D的三角形</c>
<c.magenta>这是Metal三角形演示</c>


812
00:40:57,591 --> 00:40:58,959
<c.magenta>从题目可以看出</c>


813
00:40:59,459 --> 00:41:01,562
<c.magenta>非常简单 就是一个三角形</c>
<c.magenta>三种颜色</c>


814
00:41:01,628 --> 00:41:03,931
<c.magenta>在边上被插值</c>


815
00:41:05,165 --> 00:41:06,667
<c.magenta>我们看下代码</c>


816
00:41:07,835 --> 00:41:11,171
<c.magenta>首先是MTKView的代理</c>


817
00:41:11,538 --> 00:41:13,507
<c.magenta>Warren说我们需要实现个函数</c>


818
00:41:13,607 --> 00:41:17,044
<c.magenta>这里是MTKView的drawable</c>
<c.magenta>和sizeable change</c>


819
00:41:17,344 --> 00:41:19,112
<c.magenta>它将会在window变化时</c>


820
00:41:19,179 --> 00:41:21,181
<c.magenta>响应</c>


821
00:41:21,949 --> 00:41:24,318
<c.magenta>例子很简单我们不会实现它</c>


822
00:41:24,384 --> 00:41:27,120
<c.magenta>你们在应用中自己实现</c>


823
00:41:28,121 --> 00:41:29,890
<c.magenta>另一个是绘制</c>


824
00:41:31,325 --> 00:41:33,327
<c.magenta>我们选择把它放到渲染函数</c>


825
00:41:33,493 --> 00:41:34,928
<c.magenta>当我们的绘制被调用</c>


826
00:41:35,929 --> 00:41:37,231
<c.magenta>我们进入渲染</c>


827
00:41:39,333 --> 00:41:41,702
<c.magenta>渲染也很简单</c>


828
00:41:43,270 --> 00:41:46,139
<c.magenta>当我们拿到MTKView的</c>
<c.magenta>当前RenderPassDescriptor</c>


829
00:41:46,673 --> 00:41:48,642
<c.magenta>你把它弄出来 如Warren所说</c>


830
00:41:48,876 --> 00:41:50,344
<c.magenta>然后你创建RenderPassDescriptor</c>


831
00:41:50,410 --> 00:41:51,678
<c.magenta>然后用它编码</c>


832
00:41:51,745 --> 00:41:53,380
<c.magenta>大家注意这里</c>


833
00:41:53,447 --> 00:41:54,715
<c.magenta>“pushDebugGroup.”</c>


834
00:41:55,015 --> 00:41:57,251
<c.magenta>这里你可以和Metal工具交互</c>


835
00:41:57,351 --> 00:42:00,287
<c.magenta>当你做帧捕获</c>


836
00:42:00,354 --> 00:42:02,623
<c.magenta>这里会列出调试组信息</c>


837
00:42:02,689 --> 00:42:04,892
<c.magenta>这里 我们有一个绘制和</c>
<c.magenta>一个绘制三角形</c>


838
00:42:06,760 --> 00:42:08,795
<c.magenta>绘制完我们会弹出调试组</c>


839
00:42:08,862 --> 00:42:11,398
<c.magenta>所以绘制显示标签为</c>
<c.magenta>Draw Triangle</c>


840
00:42:13,634 --> 00:42:15,169
<c.magenta>我们看下着色器</c>


841
00:42:17,504 --> 00:42:18,939
<c.magenta>正如Warren说的</c>


842
00:42:19,006 --> 00:42:21,041
<c.magenta>我们已经有了结构</c>
<c.magenta>有顶点结构</c>


843
00:42:21,108 --> 00:42:23,143
<c.magenta>这是我们放入着色器的数据格式</c>


844
00:42:23,210 --> 00:42:24,945
<c.magenta>只有位置和颜色</c>


845
00:42:25,345 --> 00:42:26,947
<c.magenta>有vertex out结构</c>


846
00:42:27,147 --> 00:42:29,249
<c.magenta>我们会传给光栅</c>


847
00:42:29,316 --> 00:42:31,185
<c.magenta>你看到位置被</c>


848
00:42:31,251 --> 00:42:32,786
<c.magenta>位置属性标记</c>


849
00:42:32,920 --> 00:42:35,088
<c.magenta>这里代表截取空间位置</c>


850
00:42:35,189 --> 00:42:37,758
<c.magenta>每个点着色器或点函数 抱歉</c>


851
00:42:37,824 --> 00:42:39,059
<c.magenta>都需要有一个</c>


852
00:42:40,327 --> 00:42:43,197
<c.magenta>看起来都很熟悉 都很简单</c>


853
00:42:43,530 --> 00:42:45,632
<c.magenta>顶点进来 我们有个路径</c>


854
00:42:46,266 --> 00:42:47,401
<c.magenta>同时你把它们写出去</c>


855
00:42:47,568 --> 00:42:50,938
<c.magenta>在片段函数里我们拿到顶点</c>


856
00:42:51,004 --> 00:42:54,474
<c.magenta>被光栅化后 我们读取颜色并且传下去</c>


857
00:42:55,275 --> 00:42:56,910
<c.magenta>这个三角形演示很简单</c>


858
00:42:56,977 --> 00:42:58,545
<c.magenta>下面由Warren继续</c>


859
00:42:58,712 --> 00:42:59,913
<c.magenta>谢谢 Matt</c>


860
00:43:03,817 --> 00:43:06,520
<c.magenta>我们已经展示了如何绘制2D内容</c>


861
00:43:07,321 --> 00:43:10,090
<c.magenta>2D非常酷</c>
<c.magenta>什么更酷呢</c>


862
00:43:12,025 --> 00:43:15,729
<c.magenta>3D 我么说说Metal中的</c>
<c.magenta>动画和纹理绘图</c>


863
00:43:18,398 --> 00:43:19,933
<c.magenta>进入3D前</c>


864
00:43:21,068 --> 00:43:22,936
<c.magenta>我们会经过几个阶段</c>


865
00:43:23,003 --> 00:43:24,371
<c.magenta>我们讨论如何真正实现3D</c>


866
00:43:24,905 --> 00:43:27,107
<c.magenta>我们用constant缓冲实现动画</c>


867
00:43:27,174 --> 00:43:29,910
<c.magenta>我们还会介绍纹理绘图样例</c>


868
00:43:30,611 --> 00:43:31,812
<c.magenta>为了进入3D</c>


869
00:43:32,446 --> 00:43:34,948
<c.magenta>我们已经指定了我们的顶点在截图空间</c>


870
00:43:35,015 --> 00:43:37,751
<c.magenta>我们现在需要在一个模型本地空间指定</c>


871
00:43:38,185 --> 00:43:42,923
<c.magenta>然后用一个合适的模型视图做投影矩阵</c>


872
00:43:43,190 --> 00:43:45,158
<c.magenta>为了回到截取空间</c>


873
00:43:45,926 --> 00:43:48,929
<c.magenta>同时我们将给普通顶点添加属性</c>


874
00:43:49,196 --> 00:43:51,665
<c.magenta>和纹理坐标 这样我们可以</c>


875
00:43:51,732 --> 00:43:54,601
<c.magenta>在我们的fragmentFunction中</c>
<c.magenta>设置光照</c>


876
00:43:54,735 --> 00:43:57,070
<c.magenta>和设置纹理映射</c>


877
00:43:58,272 --> 00:44:00,641
<c.magenta>这里是我们扩展过的顶点</c>


878
00:44:00,941 --> 00:44:05,012
<c.magenta>我们移去了颜色属性 添加进一个向量</c>


879
00:44:05,345 --> 00:44:07,381
<c.magenta>和一组纹理坐标</c>


880
00:44:08,549 --> 00:44:11,185
<c.magenta>和2D中的相似</c>


881
00:44:11,585 --> 00:44:16,857
<c.magenta>我们会添加一个新的缓冲</c>
<c.magenta>存储所有需要的常量</c>


882
00:44:17,224 --> 00:44:21,395
<c.magenta>引用我们的顶点和片段函数</c>


883
00:44:21,828 --> 00:44:25,165
<c.magenta>用来合适的转换那些顶点</c>


884
00:44:25,899 --> 00:44:27,167
<c.magenta>你会发现这个缓存的轮廓</c>


885
00:44:27,234 --> 00:44:30,704
<c.magenta>是虚线 这是有原因的</c>


886
00:44:31,805 --> 00:44:34,308
<c.magenta>因为我们不想创建另一个Metal缓存</c>


887
00:44:34,775 --> 00:44:37,277
<c.magenta>仅仅是出于要管理这一小部分数据</c>


888
00:44:37,344 --> 00:44:38,879
<c.magenta>只有几个矩阵</c>


889
00:44:38,946 --> 00:44:41,648
<c.magenta>实际上Metal也有很棒的API</c>


890
00:44:41,915 --> 00:44:45,452
<c.magenta>用来绑定和管理非常小缓存</c>


891
00:44:47,387 --> 00:44:49,523
<c.magenta>所以 对于小数据</c>


892
00:44:49,590 --> 00:44:51,258
<c.magenta>小于4K的</c>


893
00:44:51,725 --> 00:44:54,261
<c.magenta>你可以用这些API设置顶点字节</c>


894
00:44:54,628 --> 00:44:57,397
<c.magenta>直接把数据的指针传给他</c>


895
00:44:57,731 --> 00:44:59,399
<c.magenta>当然需要告诉我们大小</c>


896
00:44:59,900 --> 00:45:04,204
<c.magenta>Metal会创建和重用缓存</c>


897
00:45:04,271 --> 00:45:05,472
<c.magenta>包含那些数据</c>


898
00:45:06,039 --> 00:45:10,244
<c.magenta>你可以指定表的索引</c>


899
00:45:10,911 --> 00:45:12,012
<c.magenta>这里设置为1</c>


900
00:45:12,079 --> 00:45:14,781
<c.magenta>因为我们的顶点已经被</c>
<c.magenta>绑定在索引0</c>


901
00:45:15,249 --> 00:45:18,018
<c.magenta>所以我们绑定在1</c>
<c.magenta>这样我能从其中读取</c>


902
00:45:18,085 --> 00:45:20,087
<c.magenta>在我们的函数中</c>


903
00:45:20,721 --> 00:45:24,458
<c.magenta>我们看看函数如何响应</c>


904
00:45:25,158 --> 00:45:27,327
<c.magenta>开始之前 我们看一个例子</c>


905
00:45:27,394 --> 00:45:29,997
<c.magenta>如何在应用中调用</c>
<c.magenta>setForTextBytes</c>


906
00:45:30,664 --> 00:45:32,799
<c.magenta>我们创建了Constant结构</c>


907
00:45:32,866 --> 00:45:34,034
<c.magenta>同时创建</c>


908
00:45:34,101 --> 00:45:37,171
<c.magenta>包含两个矩阵相乘</c>


909
00:45:37,237 --> 00:45:40,641
<c.magenta>通过模型视图投影和普通矩阵</c>


910
00:45:40,707 --> 00:45:42,409
<c.magenta>这个矩阵会变换</c>


911
00:45:42,476 --> 00:45:45,078
<c.magenta>本地空间为iSpace</c>


912
00:45:45,546 --> 00:45:47,581
<c.magenta>我们用自己的矩阵工具构造</c>


913
00:45:47,648 --> 00:45:50,284
<c.magenta>然后把它们相乘</c>


914
00:45:50,450 --> 00:45:53,987
<c.magenta>最后用setVertexBytes</c>
<c.magenta>传递结构引用</c>


915
00:45:54,054 --> 00:45:57,124
<c.magenta>然后Metal会拷贝</c>


916
00:45:57,191 --> 00:46:00,194
<c.magenta>这个缓存用于绘制</c>


917
00:46:00,327 --> 00:46:01,995
<c.magenta>在接下的绘制调用</c>


918
00:46:03,830 --> 00:46:04,731
<c.magenta>现在</c>


919
00:46:05,832 --> 00:46:09,803
<c.magenta>在去年的 WWDC</c>
<c.magenta>我们介绍了Model I/O框架</c>


920
00:46:10,237 --> 00:46:13,574
<c.magenta>Model I/O包含许多工具</c>


921
00:46:13,974 --> 00:46:16,043
<c.magenta>最棒的是Model I/O包含</c>


922
00:46:16,109 --> 00:46:19,980
<c.magenta>可以让你生成常用图形的方法</c>


923
00:46:20,581 --> 00:46:22,449
<c.magenta>由于MetalKit</c>


924
00:46:22,516 --> 00:46:25,352
<c.magenta>和Metal集成非常紧密</c>


925
00:46:25,419 --> 00:46:29,990
<c.magenta>你可以创建顶点数据Metal</c>
<c.magenta>可以直接渲染</c>


926
00:46:30,991 --> 00:46:34,494
<c.magenta>我们可以不必手动指定所有顶点</c>


927
00:46:34,561 --> 00:46:37,731
<c.magenta>我们可以这样</c>
<c.magenta>在一些内容创建包</c>


928
00:46:38,065 --> 00:46:40,067
<c.magenta>里面绘制模型 导出</c>


929
00:46:40,133 --> 00:46:41,368
<c.magenta>然后用Model I/O加载</c>


930
00:46:41,435 --> 00:46:43,737
<c.magenta>或在这个例子中 用程序生成</c>


931
00:46:44,938 --> 00:46:46,640
<c.magenta>我们看看代码</c>


932
00:46:46,740 --> 00:46:49,843
<c.magenta>想生成些vertexBuffers</c>
<c.magenta>表示立方体</c>


933
00:46:50,477 --> 00:46:53,547
<c.magenta>为了在Metal中</c>
<c.magenta>使用Model I/O</c>


934
00:46:53,881 --> 00:46:56,450
<c.magenta>我会创建一个MeshBufferAllocator</c>


935
00:46:57,384 --> 00:47:02,055
<c.magenta>MeshBufferAllocator作为</c>
<c.magenta>Model I/O和Metal间的胶水程序</c>


936
00:47:02,923 --> 00:47:05,893
<c.magenta>传递一个设备给</c>
<c.magenta>MeshBufferAllocator</c>


937
00:47:06,193 --> 00:47:09,263
<c.magenta>然后我们可以让Model I/O</c>
<c.magenta>直接创建Metal缓存</c>


938
00:47:09,329 --> 00:47:10,898
<c.magenta>然后传回给我们</c>


939
00:47:12,999 --> 00:47:16,136
<c.magenta>所以我们用工具方法创建了</c>
<c.magenta>MDLMesh</c>


940
00:47:16,236 --> 00:47:20,174
<c.magenta>boxWithExtent等等</c>
<c.magenta>传进我们的分配器</c>


941
00:47:20,240 --> 00:47:23,143
<c.magenta>这将会创建一个MDLMesh</c>
<c.magenta>一个Model I/O网</c>


942
00:47:23,644 --> 00:47:26,346
<c.magenta>包含相关数据</c>


943
00:47:26,780 --> 00:47:30,450
<c.magenta>我们然后用MetalKit的工具类</c>
<c.magenta>提取出来</c>


944
00:47:31,051 --> 00:47:32,853
<c.magenta>就是为我们提供的</c>


945
00:47:32,953 --> 00:47:34,154
<c.magenta>这看起来像这样</c>


946
00:47:34,254 --> 00:47:36,523
<c.magenta>首先 我们生成了MTKMesh</c>


947
00:47:36,590 --> 00:47:39,760
<c.magenta>包含我们刚才创建的MDLMesh</c>
<c.magenta>同时包含设备</c>


948
00:47:42,162 --> 00:47:45,065
<c.magenta>为了得到vertexBuffer</c>


949
00:47:45,132 --> 00:47:46,733
<c.magenta>把它放进mesh然后抽出来</c>


950
00:47:47,267 --> 00:47:49,102
<c.magenta>对于indexBuffer</c>
<c.magenta>需要进行类似操作</c>


951
00:47:49,670 --> 00:47:51,071
<c.magenta>这里还有几个参数</c>


952
00:47:51,138 --> 00:47:52,139
<c.magenta>我们见过</c>


953
00:47:52,206 --> 00:47:53,574
<c.magenta>绘制调用的时候用的</c>


954
00:47:54,174 --> 00:47:56,910
<c.magenta>这里强调一下</c>


955
00:47:57,077 --> 00:47:59,847
<c.magenta>用Model I/O</c>
<c.magenta>生成进程几何图形很容易</c>


956
00:48:00,013 --> 00:48:03,717
<c.magenta>然后可以将缓冲提取出来</c>
<c.magenta>直接在Metal中应用</c>


957
00:48:05,352 --> 00:48:07,287
<c.magenta>下面说说纹理</c>


958
00:48:07,354 --> 00:48:08,455
<c.magenta>我们有了顶点数据</c>


959
00:48:08,522 --> 00:48:11,792
<c.magenta>我们想用纹理映射上去 并添加些细节</c>


960
00:48:11,992 --> 00:48:14,494
<c.magenta>像你知道的那样</c>
<c.magenta>纹理是一块内存</c>


961
00:48:14,595 --> 00:48:16,830
<c.magenta>用特定的像素格式预先指定</c>


962
00:48:16,997 --> 00:48:19,867
<c.magenta>主要用来存储图像数据</c>


963
00:48:20,968 --> 00:48:24,671
<c.magenta>在Metal中 创建一个纹理</c>


964
00:48:24,738 --> 00:48:25,973
<c.magenta>用描述符对象 很常见</c>


965
00:48:26,240 --> 00:48:28,509
<c.magenta>特别是Metal纹理描述符</c>


966
00:48:29,109 --> 00:48:31,245
<c.magenta>纹理描述符是参数对象</c>


967
00:48:31,311 --> 00:48:34,381
<c.magenta>它把纹理属性弄在一起 比如高和宽</c>


968
00:48:34,448 --> 00:48:37,918
<c.magenta>还有像素格式 设备会用</c>


969
00:48:37,985 --> 00:48:41,588
<c.magenta>它们生成纹理对象：Metal纹理</c>


970
00:48:42,155 --> 00:48:43,557
<c.magenta>我们看看</c>


971
00:48:44,525 --> 00:48:46,059
<c.magenta>我们有这些方便的函数</c>


972
00:48:46,126 --> 00:48:48,695
<c.magenta>在Metal Texture</c>
<c.magenta>Descriptor中</c>


973
00:48:48,762 --> 00:48:51,398
<c.magenta>可以让你得到一个2D的描述符</c>


974
00:48:51,932 --> 00:48:55,369
<c.magenta>仅提供必要的参数：高 宽</c>


975
00:48:55,769 --> 00:48:58,605
<c.magenta>像素格式或者你是否想</c>
<c.magenta>mipmapped</c>


976
00:49:00,641 --> 00:49:04,211
<c.magenta>你可调用设备的newTexture</c>
<c.magenta>创建一个新纹理</c>


977
00:49:04,811 --> 00:49:07,714
<c.magenta>这是一个不包含实际图像的纹理</c>


978
00:49:07,781 --> 00:49:11,218
<c.magenta>你需要使用替换区域或者相似的方法</c>


979
00:49:11,618 --> 00:49:14,321
<c.magenta>你可以查查文档怎么做</c>
<c.magenta>这里我们用</c>


980
00:49:14,388 --> 00:49:17,257
<c.magenta>另一个简单点的工具</c>


981
00:49:17,591 --> 00:49:19,293
<c.magenta>叫做TKTextureLoader</c>


982
00:49:19,359 --> 00:49:22,496
<c.magenta>这是MetalKit提供的工具</c>
<c.magenta>用来加载图像</c>


983
00:49:22,563 --> 00:49:24,898
<c.magenta>从资源包中 包括资源目录</c>


984
00:49:24,965 --> 00:49:27,768
<c.magenta>或者从一个文件URL 还有CG图像</c>


985
00:49:27,835 --> 00:49:29,336
<c.magenta>内存中已经有了</c>


986
00:49:29,403 --> 00:49:31,638
<c.magenta>以NSImage或UIImage</c>
<c.magenta>的形式</c>


987
00:49:32,105 --> 00:49:34,541
<c.magenta>它们生成填充Metal纹理</c>


988
00:49:34,608 --> 00:49:36,610
<c.magenta>用合适的大小和格式</c>


989
00:49:36,677 --> 00:49:38,612
<c.magenta>与你已经有的的图像数据有关</c>


990
00:49:39,513 --> 00:49:41,114
<c.magenta>我们看看代码</c>


991
00:49:41,181 --> 00:49:43,684
<c.magenta>你可以创建一个</c>
<c.magenta>MTKTextureLoader</c>


992
00:49:43,750 --> 00:49:45,252
<c.magenta>通过传入Metal设备</c>


993
00:49:45,686 --> 00:49:47,354
<c.magenta>你会得到一个</c>
<c.magenta>TextureLoader</c>


994
00:49:47,554 --> 00:49:50,958
<c.magenta>同时你可以接着或许一个数据集合</c>


995
00:49:51,024 --> 00:49:52,559
<c.magenta>或你的集合目录中的其他东西</c>


996
00:49:52,626 --> 00:49:54,127
<c.magenta>一旦你拿到了数据</c>


997
00:49:54,194 --> 00:49:57,197
<c.magenta>你可调用textureLoader.newTexture</c>


998
00:49:57,531 --> 00:50:00,434
<c.magenta>然后传递数据</c>
<c.magenta>那么将会返回一个Metal纹理</c>


999
00:50:03,971 --> 00:50:07,508
<c.magenta>你可能熟悉取样的概念</c>


1000
00:50:07,574 --> 00:50:10,143
<c.magenta>Samplers和Metal</c>
<c.magenta>从纹理来说不同</c>


1001
00:50:10,210 --> 00:50:12,112
<c.magenta>他们没有绑定在一起</c>


1002
00:50:13,313 --> 00:50:16,550
<c.magenta>Samplers只包含</c>
<c.magenta>纹理相关的取样状态</c>


1003
00:50:16,617 --> 00:50:20,454
<c.magenta>一些如过滤模式 地址模式</c>


1004
00:50:20,521 --> 00:50:22,322
<c.magenta>还有层级详细的参数</c>


1005
00:50:22,489 --> 00:50:24,791
<c.magenta>这里展示的我们都支持</c>


1006
00:50:26,126 --> 00:50:28,996
<c.magenta>为了获得我们竟来要绑定</c>
<c.magenta>的Sampler状态</c>


1007
00:50:29,062 --> 00:50:31,765
<c.magenta>在Render Command</c>
<c.magenta>encoder中做纹理绘制</c>


1008
00:50:32,266 --> 00:50:34,668
<c.magenta>我们会创建一个</c>
<c.magenta>Metal Sampler Descriptor</c>


1009
00:50:34,735 --> 00:50:36,036
<c.magenta>像这样</c>


1010
00:50:36,436 --> 00:50:39,072
<c.magenta>我们创建了个空的Metal Sampler Descriptor</c>


1011
00:50:39,139 --> 00:50:40,707
<c.magenta>拥有默认的属性</c>


1012
00:50:40,774 --> 00:50:42,643
<c.magenta>我们可以设置想要的属性</c>


1013
00:50:42,709 --> 00:50:45,412
<c.magenta>这里我们让纹理在各个轴</c>


1014
00:50:45,479 --> 00:50:46,747
<c.magenta>上重复</c>


1015
00:50:47,314 --> 00:50:50,050
<c.magenta>当缩小的时候使用</c>
<c.magenta>nearest filtering</c>


1016
00:50:50,117 --> 00:50:52,219
<c.magenta>当放大时用</c>
<c.magenta>linear filtering</c>


1017
00:50:52,853 --> 00:50:54,988
<c.magenta>一旦我们创建了描述符对象</c>


1018
00:50:55,355 --> 00:50:56,523
<c.magenta>我们调用</c>
<c.magenta>newSamplerState</c>


1019
00:50:56,590 --> 00:50:59,193
<c.magenta>得到</c>
<c.magenta>Metal Sampler State对象</c>


1020
00:50:59,493 --> 00:51:03,630
<c.magenta>我们可以用来在纹理中绑定采样</c>


1021
00:51:04,765 --> 00:51:07,367
<c.magenta>在Render Command Encoder中</c>
<c.magenta>API看起来像这样</c>


1022
00:51:07,434 --> 00:51:11,338
<c.magenta>我们创建一个纹理 把它放在</c>
<c.magenta>插槽0</c>


1023
00:51:11,839 --> 00:51:13,774
<c.magenta>在片段纹理参数表中</c>


1024
00:51:14,808 --> 00:51:18,745
<c.magenta>然后我们绑定Sampler</c>
<c.magenta>State在索引0</c>


1025
00:51:18,912 --> 00:51:21,849
<c.magenta>在Sampler State</c>
<c.magenta>参数表中</c>


1026
00:51:23,750 --> 00:51:25,886
<c.magenta>我们看看这些函数</c>


1027
00:51:26,720 --> 00:51:29,122
<c.magenta>顶点函数这次会和</c>


1028
00:51:29,189 --> 00:51:32,893
<c.magenta>MVP矩阵相乘</c>
<c.magenta>矩阵从constant buffer中获得</c>


1029
00:51:33,360 --> 00:51:35,229
<c.magenta>它会变换顶点的位置</c>


1030
00:51:35,295 --> 00:51:37,197
<c.magenta>从本地空间到截取空间</c>


1031
00:51:37,497 --> 00:51:40,701
<c.magenta>我们会从顶点函数返回</c>


1032
00:51:40,767 --> 00:51:42,736
<c.magenta>同时它还会变换那些顶点</c>


1033
00:51:42,803 --> 00:51:44,505
<c.magenta>从Models Local</c>
<c.magenta>Space到Eye Space</c>


1034
00:51:44,571 --> 00:51:46,240
<c.magenta>然后我们做光照渲染</c>


1035
00:51:46,406 --> 00:51:47,975
<c.magenta>代码里看起来是这样</c>


1036
00:51:48,108 --> 00:51:51,612
<c.magenta>我们添加了一个参数属性通过缓存1</c>


1037
00:51:51,678 --> 00:51:54,815
<c.magenta>像我之前说的通过</c>
<c.magenta>constants缓存获得</c>


1038
00:51:54,882 --> 00:51:56,283
<c.magenta>我们已创建了一个结构类型</c>


1039
00:51:56,850 --> 00:51:58,752
<c.magenta>在我们的Metal着色代码中</c>


1040
00:51:58,819 --> 00:52:01,455
<c.magenta>和SWF代码中创建</c>
<c.magenta>constant结构关联起来</c>


1041
00:52:01,622 --> 00:52:04,958
<c.magenta>这样我们可得到</c>
<c.magenta>MVP通过普通的矩阵</c>


1042
00:52:05,192 --> 00:52:08,028
<c.magenta>再一次 这个绑定在索引1的参数表</c>


1043
00:52:08,328 --> 00:52:11,031
<c.magenta>和你看到的属性关联起来</c>


1044
00:52:12,199 --> 00:52:16,103
<c.magenta>为了进入截取空间</c>


1045
00:52:16,170 --> 00:52:18,605
<c.magenta>获取vertexBuffer</c>
<c.magenta>位于VertexID的索引</c>


1046
00:52:18,872 --> 00:52:20,107
<c.magenta>得到一个位置向量</c>


1047
00:52:20,207 --> 00:52:23,343
<c.magenta>和MVP矩阵相乘然后赋值给结构</c>


1048
00:52:23,944 --> 00:52:25,445
<c.magenta>对普通的 进行相同的操作</c>


1049
00:52:27,281 --> 00:52:29,283
<c.magenta>我们还拷贝纹理坐标</c>


1050
00:52:29,349 --> 00:52:31,051
<c.magenta>给传出结构</c>


1051
00:52:31,118 --> 00:52:33,954
<c.magenta>这些都会被光栅插值</c>


1052
00:52:34,021 --> 00:52:35,889
<c.magenta>我们接着进行返回结构</c>


1053
00:52:36,256 --> 00:52:39,359
<c.magenta>fragmentFunction</c>
<c.magenta>比之前更参与</c>


1054
00:52:39,760 --> 00:52:42,095
<c.magenta>我们想要计算些光照</c>


1055
00:52:42,162 --> 00:52:44,865
<c.magenta>我们引用两种环境光和漫反射</c>


1056
00:52:45,399 --> 00:52:48,001
<c.magenta>同时从纹理中采样</c>


1057
00:52:48,435 --> 00:52:50,838
<c.magenta>应用到表面纹理中</c>


1058
00:52:51,405 --> 00:52:52,439
<c.magenta>像这样</c>


1059
00:52:52,506 --> 00:52:55,142
<c.magenta>我们不会详细介绍</c>


1060
00:52:55,742 --> 00:52:57,244
<c.magenta>需要注意的是</c>


1061
00:52:57,311 --> 00:52:59,413
<c.magenta>我们添加了一个参数</c>


1062
00:52:59,479 --> 00:53:00,981
<c.magenta>我们创建和绑定的</c>


1063
00:53:01,181 --> 00:53:03,617
<c.magenta>我们给它一个访问标识符</c>


1064
00:53:03,717 --> 00:53:05,185
<c.magenta>我们用来采样</c>


1065
00:53:05,586 --> 00:53:07,788
<c.magenta>在Argument Table Index的0位置</c>


1066
00:53:07,855 --> 00:53:09,556
<c.magenta>我们创建的</c>
<c.magenta>Sampler State在</c>


1067
00:53:09,623 --> 00:53:13,827
<c.magenta>samplers的Argument</c>
<c.magenta>Slot Zero</c>


1068
00:53:13,894 --> 00:53:18,098
<c.magenta>想获得实际的文本</c>


1069
00:53:18,565 --> 00:53:20,601
<c.magenta>调用纹理的Sample</c>


1070
00:53:20,667 --> 00:53:24,004
<c.magenta>Text2D.Sample</c>
<c.magenta>有个采样状态</c>


1071
00:53:24,872 --> 00:53:28,442
<c.magenta>和纹理坐标给到颜色向量</c>


1072
00:53:30,344 --> 00:53:33,580
<c.magenta>我们接着做光照</c>


1073
00:53:33,647 --> 00:53:35,382
<c.magenta>我不会详细介绍</c>


1074
00:53:35,449 --> 00:53:39,119
<c.magenta>它根据正常和光照方向的积来得到</c>


1075
00:53:39,186 --> 00:53:41,922
<c.magenta>我们设置了一些常量</c>


1076
00:53:42,022 --> 00:53:45,559
<c.magenta>在我们之前的着色文件</c>
<c.magenta>演示中可以看到</c>


1077
00:53:46,126 --> 00:53:47,494
<c.magenta>这相当多</c>


1078
00:53:47,561 --> 00:53:52,165
<c.magenta>我们构造特定片段的颜色</c>


1079
00:53:52,366 --> 00:53:54,835
<c.magenta>通过乘以从纹理中采样的值</c>


1080
00:53:54,935 --> 00:54:00,340
<c.magenta>通过光照反映到动画纹理的立方体上</c>


1081
00:54:00,707 --> 00:54:03,510
<c.magenta>现在让Matt给大家展示下</c>


1082
00:54:05,379 --> 00:54:07,481
<c.magenta>好的 我们看看演示</c>


1083
00:54:07,881 --> 00:54:09,583
<c.magenta>这里有个Metal纹理网</c>


1084
00:54:09,683 --> 00:54:11,718
<c.magenta>你可以看到</c>
<c.magenta>它是个很复杂的立方体</c>


1085
00:54:11,952 --> 00:54:13,854
<c.magenta>一些简单的光照和纹理贴图</c>


1086
00:54:13,921 --> 00:54:15,923
<c.magenta>在一个设置好颜色的背景上</c>


1087
00:54:18,458 --> 00:54:19,860
<c.magenta>欣赏下它</c>


1088
00:54:19,927 --> 00:54:22,563
<c.magenta>我们看看着色器</c>


1089
00:54:23,297 --> 00:54:26,233
<c.magenta>比起上一次 你能看到一些新的东西</c>


1090
00:54:26,300 --> 00:54:28,869
<c.magenta>首先是Constants结构体</c>


1091
00:54:29,136 --> 00:54:30,704
<c.magenta>是Swift写的</c>


1092
00:54:30,771 --> 00:54:33,173
<c.magenta>有4 X 4的模型投影矩阵</c>


1093
00:54:33,473 --> 00:54:37,010
<c.magenta>和3 X 3的普通矩阵</c>
<c.magenta>它们是用来做变换的</c>


1094
00:54:37,744 --> 00:54:40,714
<c.magenta>如Warren所说</c>
<c.magenta>我们有些光照数据</c>


1095
00:54:41,215 --> 00:54:43,350
<c.magenta>环境光强度 这里很弱</c>


1096
00:54:43,417 --> 00:54:45,452
<c.magenta>但漫射光 却很高</c>


1097
00:54:45,519 --> 00:54:47,321
<c.magenta>光的方向</c>


1098
00:54:47,387 --> 00:54:49,256
<c.magenta>我们用来计算点积</c>


1099
00:54:51,158 --> 00:54:52,893
<c.magenta>输入和输出结构有点不同</c>


1100
00:54:52,960 --> 00:54:55,762
<c.magenta>我们现在有更多的信息需要向下传递</c>


1101
00:54:55,829 --> 00:54:56,697
<c.magenta>我们有position</c>


1102
00:54:56,763 --> 00:54:58,298
<c.magenta>有normal 用来光照</c>


1103
00:54:58,365 --> 00:55:01,368
<c.magenta>和纹理坐标 用来纹理贴图</c>


1104
00:55:01,435 --> 00:55:04,137
<c.magenta>相似的 当从顶点函数输出时</c>


1105
00:55:05,472 --> 00:55:06,640
<c.magenta>我们需要相似的数据</c>


1106
00:55:06,773 --> 00:55:08,575
<c.magenta>我们看下顶点函数</c>


1107
00:55:08,642 --> 00:55:09,476
<c.magenta>如Warren所说</c>


1108
00:55:10,010 --> 00:55:12,679
<c.magenta>就是些简单的矩阵 乘法运算</c>


1109
00:55:12,746 --> 00:55:15,315
<c.magenta>然后传给纹理坐标</c>


1110
00:55:16,083 --> 00:55:18,151
<c.magenta>快速的看下片段函数</c>


1111
00:55:18,218 --> 00:55:20,287
<c.magenta>就是刚才给你展示的</c>


1112
00:55:22,256 --> 00:55:24,291
<c.magenta>我们看看渲染器</c>


1113
00:55:26,326 --> 00:55:27,828
<c.magenta>接着往前</c>


1114
00:55:28,962 --> 00:55:30,097
<c.magenta>我们有个小动画</c>


1115
00:55:30,163 --> 00:55:33,867
<c.magenta>所以我们需要每段时间更新</c>
<c.magenta>我们需要知道立方体需要旋转多少</c>


1116
00:55:34,568 --> 00:55:36,069
<c.magenta>这里有个帮助函数</c>


1117
00:55:36,136 --> 00:55:38,305
<c.magenta>来更是时间间隔</c>


1118
00:55:41,308 --> 00:55:43,043
<c.magenta>这将修改Constants</c>


1119
00:55:43,777 --> 00:55:45,946
<c.magenta>像Warren说的</c>
<c.magenta>我们不想让很多数据通过GPU传递</c>


1120
00:55:46,013 --> 00:55:48,448
<c.magenta>所以当你设置顶点字节</c>


1121
00:55:48,849 --> 00:55:51,885
<c.magenta>传一个小的结构 之前的两个矩阵</c>


1122
00:55:52,519 --> 00:55:57,090
<c.magenta>我们用来计算变动的位置</c>


1123
00:55:58,325 --> 00:56:00,827
<c.magenta>放入纹理和采样 触发绘制</c>


1124
00:56:01,195 --> 00:56:02,763
<c.magenta>我建议你们记住</c>


1125
00:56:02,829 --> 00:56:04,631
<c.magenta>用你的调试组 这样你可以知道</c>


1126
00:56:04,865 --> 00:56:07,935
<c.magenta>现在在什么位置</c>
<c.magenta>如果你想稍后捕获帧的话</c>


1127
00:56:08,001 --> 00:56:11,104
<c.magenta>展示绘制内容 提交 然后就可以了</c>


1128
00:56:14,741 --> 00:56:15,909
<c.magenta>很棒 谢谢 Matt</c>


1129
00:56:19,847 --> 00:56:21,782
<c.magenta>通过这些使用Metal的课程</c>


1130
00:56:22,349 --> 00:56:25,586
<c.magenta>我们想充分利用我们这几年的</c>


1131
00:56:25,652 --> 00:56:27,087
<c.magenta>成果 教授Metal</c>


1132
00:56:27,454 --> 00:56:29,323
<c.magenta>同时介绍非常棒的新工具</c>


1133
00:56:29,590 --> 00:56:31,225
<c.magenta>让Metal更容易使用</c>


1134
00:56:31,325 --> 00:56:32,793
<c.magenta>我们希望</c>


1135
00:56:33,126 --> 00:56:35,395
<c.magenta>这两部分课程对此有帮助</c>


1136
00:56:35,696 --> 00:56:38,799
<c.magenta>你看到Metal是强大的低负载的</c>


1137
00:56:38,866 --> 00:56:42,369
<c.magenta>GPU编程技术 幸运的</c>


1138
00:56:42,436 --> 00:56:45,172
<c.magenta>你现在已经熟悉它</c>


1139
00:56:45,239 --> 00:56:46,707
<c.magenta>其中的一些API</c>


1140
00:56:48,242 --> 00:56:50,143
<c.magenta>Metal非常接近</c>


1141
00:56:50,210 --> 00:56:52,980
<c.magenta>和符合GPU的实际运转情况</c>


1142
00:56:53,347 --> 00:56:57,584
<c.magenta>概念上也是这样 我们想把</c>


1143
00:56:57,651 --> 00:57:00,654
<c.magenta>耗费资源的操作尽可能提前</c>


1144
00:57:00,754 --> 00:57:02,389
<c.magenta>你已经看到了几种方式</c>


1145
00:57:02,456 --> 00:57:04,892
<c.magenta>怎么安排这些API</c>


1146
00:57:05,325 --> 00:57:09,429
<c.magenta>这个课程不是强调一些限制和细节</c>


1147
00:57:09,496 --> 00:57:10,564
<c.magenta>主要是</c>


1148
00:57:10,631 --> 00:57:12,132
<c.magenta>想给你灌输些能力</c>


1149
00:57:12,533 --> 00:57:14,401
<c.magenta>你已经看到如何明确的</c>
<c.magenta>进行内存管理</c>


1150
00:57:14,468 --> 00:57:17,337
<c.magenta>和指令提交 可以让你的工作更智能些</c>


1151
00:57:17,404 --> 00:57:19,740
<c.magenta>如果你知道你的应用是怎么回事</c>


1152
00:57:19,806 --> 00:57:22,209
<c.magenta>你知道它在做什么 然后你可以</c>


1153
00:57:22,409 --> 00:57:25,479
<c.magenta>直接控制GPU</c>


1154
00:57:26,713 --> 00:57:30,117
<c.magenta>当然接下来的几节关于Metal课程</c>


1155
00:57:30,517 --> 00:57:33,420
<c.magenta>在今年的 WWDC</c>
<c.magenta>我们会给你展示更多</c>


1156
00:57:33,487 --> 00:57:34,821
<c.magenta>的Metal的内容</c>


1157
00:57:35,055 --> 00:57:38,492
<c.magenta>当然 它会让你创建有更好体验的应用</c>


1158
00:57:38,825 --> 00:57:41,328
<c.magenta>想要了解更多的关于602会话的信息</c>


1159
00:57:41,395 --> 00:57:44,998
<c.magenta>你可以访问这个URL</c>
<c.magenta>同时可以参考其他相关课程</c>


1160
00:57:45,332 --> 00:57:48,936
<c.magenta>第二部分还会在这个教室</c>


1161
00:57:49,736 --> 00:57:53,307
<c.magenta>明天我们会有</c>
<c.magenta>Metal的新东西Parts I和II</c>


1162
00:57:54,007 --> 00:57:57,377
<c.magenta>和高级Metal着色优化课程</c>


1163
00:57:57,711 --> 00:57:59,947
<c.magenta>谢谢</c>
<c.magenta>祝你们在 WWDC 中大有收获</c>

